ﬁâŸ$/src/plugin/drainHttpServer/index.ts≈iimport type http from 'http';
import type { ApolloServerPlugin } from '../../externalTypes/index.js';
import { Stopper } from './stoppable.js';

/**
 * Options for ApolloServerPluginDrainHttpServer.
 */
export interface ApolloServerPluginDrainHttpServerOptions {
  /**
   * The http.Server (or https.Server, etc) to drain. Required.
   */
  httpServer: http.Server;
  /**
   * How long to wait before forcefully closing non-idle connections.
   * Defaults to 10_000 (ten seconds).
   */
  stopGracePeriodMillis?: number;
}

/**
 * This plugin is used with apollo-server-express and other framework
 * integrations to drain your HTTP server on shutdown.
 * See https://www.apollographql.com/docs/apollo-server/api/plugin/drain-http-server/
 * for details.
 */
export function ApolloServerPluginDrainHttpServer(
  options: ApolloServerPluginDrainHttpServerOptions,
): ApolloServerPlugin {
  const stopper = new Stopper(options.httpServer);
  return {
    async serverWillStart() {
      return {
        async drainServer() {
          await stopper.stop(options.stopGracePeriodMillis ?? 10_000);
        },
      };
    },
  };
}
Ÿ(/dist/esm/plugin/disabled/index.d.ts.map≈¿{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/plugin/disabled/index.ts"],"names":[],"mappings":"AAQA,OAAO,KAAK,EAAE,WAAW,EAAE,kBAAkB,EAAE,MAAM,gBAAgB,CAAC;AActE,wBAAgB,sCAAsC,IAAI,kBAAkB,CAAC,WAAW,CAAC,CAExF;AAED,wBAAgB,qCAAqC,IAAI,kBAAkB,CAAC,WAAW,CAAC,CAEvF;AAED,wBAAgB,qCAAqC,IAAI,kBAAkB,CAAC,WAAW,CAAC,CAEvF;AAED,wBAAgB,yCAAyC,IAAI,kBAAkB,CAAC,WAAW,CAAC,CAE3F;AAED,wBAAgB,wCAAwC,IAAI,kBAAkB,CAAC,WAAW,CAAC,CAE1F"}Ÿ./dist/cjs/plugin/usageReporting/options.js.mapƒâ{"version":3,"file":"options.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/options.ts"],"names":[],"mappings":""}Ÿ$/plugin/drainHttpServer/package.json≈{
  "name": "@apollo/server/plugin/drainHttpServer",
  "type": "module",
  "main": "../../dist/cjs/plugin/drainHttpServer/index.js",
  "module": "../../dist/esm/plugin/drainHttpServer/index.js",
  "types": "../../dist/esm/plugin/drainHttpServer/index.d.ts",
  "sideEffects": false
}
º/dist/cjs/preventCsrf.js.map≈ÿ{"version":3,"file":"preventCsrf.js","sourceRoot":"","sources":["../../src/preventCsrf.ts"],"names":[],"mappings":";;;;;;AAAA,sEAAuC;AACvC,uEAA4D;AAa/C,QAAA,uCAAuC,GAAG;IACrD,yBAAyB;IACzB,0BAA0B;CAC3B,CAAC;AAGF,MAAM,6BAA6B,GAAG;IACpC,mCAAmC;IACnC,qBAAqB;IACrB,YAAY;CACb,CAAC;AAqBF,SAAgB,WAAW,CACzB,OAAkB,EAClB,4BAAsC;IAEtC,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAOhD,IAAI,WAAW,KAAK,SAAS,EAAE;QAC7B,MAAM,iBAAiB,GAAG,yBAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QACtD,IAAI,iBAAiB,KAAK,IAAI,EAAE;YAQ9B,OAAO;SACR;QACD,IAAI,CAAC,6BAA6B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE;YAKtE,OAAO;SACR;KACF;IAMD,IACE,4BAA4B,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;QAC3C,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAClC,OAAO,KAAK,KAAK,SAAS,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;IACjD,CAAC,CAAC,EACF;QACA,OAAO;KACR;IAED,MAAM,IAAI,yCAAe,CACvB,4EAA4E;QAC1E,0EAA0E;QAC1E,iBAAiB,6BAA6B,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe;QACxE,uDAAuD,4BAA4B,CAAC,IAAI,CACtF,IAAI,CACL,IAAI,CACR,CAAC;AACJ,CAAC;AArDD,kCAqDC"}Ÿ /dist/cjs/utils/isDefined.js.mapƒÃ{"version":3,"file":"isDefined.js","sourceRoot":"","sources":["../../../src/utils/isDefined.ts"],"names":[],"mappings":";;;AAAA,SAAgB,SAAS,CAAI,CAA8B;IACzD,OAAO,CAAC,IAAI,IAAI,CAAC;AACnB,CAAC;AAFD,8BAEC"}Ÿ(/dist/esm/externalTypes/constructor.d.ts≈Aimport type { Logger } from '@apollo/utils.logger';
import type { IExecutableSchemaDefinition } from '@graphql-tools/schema';
import type { DocumentNode, GraphQLFieldResolver, GraphQLFormattedError, GraphQLSchema, ParseOptions, ValidationRule } from 'graphql';
import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { GatewayInterface } from '@apollo/server-gateway-interface';
import type { ApolloServerPlugin } from './plugins.js';
import type { BaseContext } from './index.js';
import type { GraphQLExperimentalIncrementalExecutionResults } from '../incrementalDeliveryPolyfill.js';
export declare type DocumentStore = KeyValueCache<DocumentNode>;
export interface ApolloConfigInput {
    key?: string;
    graphRef?: string;
    graphId?: string;
    graphVariant?: string;
}
export interface ApolloConfig {
    key?: string;
    keyHash?: string;
    graphRef?: string;
}
export interface PersistedQueryOptions {
    cache?: KeyValueCache<string>;
    ttl?: number | null;
}
export interface CSRFPreventionOptions {
    requestHeaders?: string[];
}
interface ApolloServerOptionsBase<TContext extends BaseContext> {
    formatError?: (formattedError: GraphQLFormattedError, error: unknown) => GraphQLFormattedError;
    rootValue?: ((parsedQuery: DocumentNode) => unknown) | unknown;
    validationRules?: Array<ValidationRule>;
    fieldResolver?: GraphQLFieldResolver<any, TContext>;
    cache?: KeyValueCache<string>;
    includeStacktraceInErrorResponses?: boolean;
    logger?: Logger;
    allowBatchedHttpRequests?: boolean;
    introspection?: boolean;
    plugins?: ApolloServerPlugin<TContext>[];
    persistedQueries?: PersistedQueryOptions | false;
    stopOnTerminationSignals?: boolean;
    apollo?: ApolloConfigInput;
    nodeEnv?: string;
    documentStore?: DocumentStore | null;
    csrfPrevention?: CSRFPreventionOptions | boolean;
    parseOptions?: ParseOptions;
    __testing_incrementalExecutionResults?: GraphQLExperimentalIncrementalExecutionResults;
}
interface ApolloServerOptionsWithGateway<TContext extends BaseContext> extends ApolloServerOptionsBase<TContext> {
    gateway: GatewayInterface;
    schema?: undefined;
    typeDefs?: undefined;
    resolvers?: undefined;
}
interface ApolloServerOptionsWithSchema<TContext extends BaseContext> extends ApolloServerOptionsBase<TContext> {
    schema: GraphQLSchema;
    gateway?: undefined;
    typeDefs?: undefined;
    resolvers?: undefined;
}
interface ApolloServerOptionsWithTypeDefs<TContext extends BaseContext> extends ApolloServerOptionsBase<TContext> {
    typeDefs: IExecutableSchemaDefinition<TContext>['typeDefs'];
    resolvers?: IExecutableSchemaDefinition<TContext>['resolvers'];
    gateway?: undefined;
    schema?: undefined;
}
export declare type ApolloServerOptionsWithStaticSchema<TContext extends BaseContext> = ApolloServerOptionsWithSchema<TContext> | ApolloServerOptionsWithTypeDefs<TContext>;
export declare type ApolloServerOptions<TContext extends BaseContext> = ApolloServerOptionsWithGateway<TContext> | ApolloServerOptionsWithStaticSchema<TContext>;
export {};
//# sourceMappingURL=constructor.d.ts.mapŸ$/dist/esm/plugin/traceTreeBuilder.js≈6import { GraphQLError } from 'graphql';
import { Trace, google } from '@apollo/usage-reporting-protobuf';
import { UnreachableCaseError } from '../utils/UnreachableCaseError.js';
function internalError(message) {
    return new Error(`[internal apollo-server error] ${message}`);
}
export class TraceTreeBuilder {
    constructor(options) {
        this.rootNode = new Trace.Node();
        this.trace = new Trace({
            root: this.rootNode,
            fieldExecutionWeight: 1,
        });
        this.stopped = false;
        this.nodes = new Map([
            [responsePathAsString(), this.rootNode],
        ]);
        const { logger, sendErrors, maskedBy } = options;
        if (!sendErrors || 'masked' in sendErrors) {
            this.transformError = () => new GraphQLError('<masked>', {
                extensions: { maskedBy },
            });
        }
        else if ('transform' in sendErrors) {
            this.transformError = sendErrors.transform;
        }
        else if ('unmodified' in sendErrors) {
            this.transformError = null;
        }
        else {
            throw new UnreachableCaseError(sendErrors);
        }
        this.logger = logger;
    }
    startTiming() {
        if (this.startHrTime) {
            throw internalError('startTiming called twice!');
        }
        if (this.stopped) {
            throw internalError('startTiming called after stopTiming!');
        }
        this.trace.startTime = dateToProtoTimestamp(new Date());
        this.startHrTime = process.hrtime();
    }
    stopTiming() {
        if (!this.startHrTime) {
            throw internalError('stopTiming called before startTiming!');
        }
        if (this.stopped) {
            throw internalError('stopTiming called twice!');
        }
        this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        this.trace.endTime = dateToProtoTimestamp(new Date());
        this.stopped = true;
    }
    willResolveField(info) {
        if (!this.startHrTime) {
            throw internalError('willResolveField called before startTiming!');
        }
        if (this.stopped) {
            throw internalError('willResolveField called after stopTiming!');
        }
        const path = info.path;
        const node = this.newNode(path);
        node.type = info.returnType.toString();
        node.parentType = info.parentType.toString();
        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        if (typeof path.key === 'string' && path.key !== info.fieldName) {
            node.originalFieldName = info.fieldName;
        }
        return () => {
            node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        };
    }
    didEncounterErrors(errors) {
        errors.forEach((err) => {
            if (err.extensions?.serviceName) {
                return;
            }
            const errorForReporting = this.transformAndNormalizeError(err);
            if (errorForReporting === null) {
                return;
            }
            this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));
        });
    }
    addProtobufError(path, error) {
        if (!this.startHrTime) {
            throw internalError('addProtobufError called before startTiming!');
        }
        if (this.stopped) {
            throw internalError('addProtobufError called after stopTiming!');
        }
        let node = this.rootNode;
        if (Array.isArray(path)) {
            const specificNode = this.nodes.get(path.join('.'));
            if (specificNode) {
                node = specificNode;
            }
            else {
                this.logger.warn(`Could not find node with path ${path.join('.')}; defaulting to put errors on root node.`);
            }
        }
        node.error.push(error);
    }
    newNode(path) {
        const node = new Trace.Node();
        const id = path.key;
        if (typeof id === 'number') {
            node.index = id;
        }
        else {
            node.responseName = id;
        }
        this.nodes.set(responsePathAsString(path), node);
        const parentNode = this.ensureParentNode(path);
        parentNode.child.push(node);
        return node;
    }
    ensureParentNode(path) {
        const parentPath = responsePathAsString(path.prev);
        const parentNode = this.nodes.get(parentPath);
        if (parentNode) {
            return parentNode;
        }
        return this.newNode(path.prev);
    }
    transformAndNormalizeError(err) {
        if (this.transformError) {
            const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);
            const rewrittenError = this.transformError(clonedError);
            if (rewrittenError === null) {
                return null;
            }
            if (!(rewrittenError instanceof GraphQLError)) {
                return err;
            }
            return new GraphQLError(rewrittenError.message, {
                nodes: err.nodes,
                source: err.source,
                positions: err.positions,
                path: err.path,
                originalError: err.originalError,
                extensions: rewrittenError.extensions || err.extensions,
            });
        }
        return err;
    }
}
function durationHrTimeToNanos(hrtime) {
    return hrtime[0] * 1e9 + hrtime[1];
}
function responsePathAsString(p) {
    if (p === undefined) {
        return '';
    }
    let res = String(p.key);
    while ((p = p.prev) !== undefined) {
        res = `${p.key}.${res}`;
    }
    return res;
}
function errorToProtobufError(error) {
    return new Trace.Error({
        message: error.message,
        location: (error.locations || []).map(({ line, column }) => new Trace.Location({ line, column })),
        json: JSON.stringify(error),
    });
}
export function dateToProtoTimestamp(date) {
    const totalMillis = +date;
    const millis = totalMillis % 1000;
    return new google.protobuf.Timestamp({
        seconds: (totalMillis - millis) / 1000,
        nanos: millis * 1e6,
    });
}
//# sourceMappingURL=traceTreeBuilder.js.mapŸ"/dist/esm/plugin/disabled/index.js≈–function disabledPlugin(id) {
    const plugin = {
        __internal_plugin_id__: id,
        __is_disabled_plugin__: true,
    };
    return plugin;
}
export function ApolloServerPluginCacheControlDisabled() {
    return disabledPlugin('CacheControl');
}
export function ApolloServerPluginInlineTraceDisabled() {
    return disabledPlugin('InlineTrace');
}
export function ApolloServerPluginLandingPageDisabled() {
    return disabledPlugin('LandingPageDisabled');
}
export function ApolloServerPluginSchemaReportingDisabled() {
    return disabledPlugin('SchemaReporting');
}
export function ApolloServerPluginUsageReportingDisabled() {
    return disabledPlugin('UsageReporting');
}
//# sourceMappingURL=index.js.mapŸ%/dist/esm/utils/urlForHttpServer.d.tsƒ∑/// <reference types="node" />
import type { Server } from 'http';
export declare function urlForHttpServer(httpServer: Server): string;
//# sourceMappingURL=urlForHttpServer.d.ts.mapŸ-/dist/esm/plugin/landingPage/default/types.jsƒ,export {};
//# sourceMappingURL=types.js.mapŸA/dist/esm/plugin/usageReporting/defaultSendOperationsAsTrace.d.tsƒ‰import type { Trace } from '@apollo/usage-reporting-protobuf';
export declare function defaultSendOperationsAsTrace(): (trace: Trace, statsReportKey: string) => boolean;
//# sourceMappingURL=defaultSendOperationsAsTrace.d.ts.map∂/dist/cjs/package.jsonƒ{"type":"commonjs"}™/README.md≈
# `@apollo/server`

> This `@apollo/server` package is new with Apollo Server 4. Previous major versions of Apollo Server used a set of package names starting with `apollo-server`, such as `apollo-server`, `apollo-server-express`, `apollo-server-core`, etc.

## A TypeScript/JavaScript GraphQL server

**Apollo Server is an [open-source](https://github.com/apollographql/apollo-server), spec-compliant GraphQL server** that's compatible with any GraphQL client, including [Apollo Client](https://www.apollographql.com/docs/react). It's the best way to build a production-ready, self-documenting GraphQL API that can use data from any source.


You can use Apollo Server as:

* A stand-alone GraphQL server
* The GraphQL server for a [subgraph](https://www.apollographql.com/docs/federation/subgraphs/) in a federated supergraph
* The gateway for a [federated supergraph](https://www.apollographql.com/docs/federation/)

Apollo Server provides a simple API for integrating with any Node.js web framework or serverless environment. The `@apollo/server` package itself ships with a minimally-configurable, standalone web server which handles CORS and body parsing out of the box. Integrations with other environments are community-maintained.

Apollo Server provides:

*  **Straightforward setup**, so your client developers can start fetching data quickly
*  **Incremental adoption**, enabling you to add features as they're needed
*  **Universal compatibility** with any data source, any build tool, and any GraphQL client
*  **Production readiness**, enabling you to confidently run your graph in production

## Documentation

Full documentation for Apollo Server is available on [our documentation site](https://www.apollographql.com/docs/apollo-server/). This README shows the basics of getting a server running (both standalone and with Express), but most features are only documented on our docs site.


## Getting started: standalone server

> You can also check out the [getting started](https://www.apollographql.com/docs/apollo-server/getting-started) guide in the Apollo Server docs for more details, including examples in both TypeScript and JavaScript.

Apollo Server's standalone server lets you get a GraphQL server up and running quickly without needing to set up an HTTP server yourself. It allows all the same configuration of GraphQL logic as the Express integration, but does not provide the ability to make fine-grained tweaks to the HTTP-specific behavior of your server.

First, install Apollo Server and the JavaScript implementation of the core GraphQL algorithms:

```
npm install @apollo/server graphql
```

Then, write the following to `server.mjs`. (By using the `.mjs` extension, Node lets you use the `await` keyword at the top level.)

```js
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';

// The GraphQL schema
const typeDefs = `#graphql
  type Query {
    hello: String
  }
`;

// A map of functions which return data for the schema.
const resolvers = {
  Query: {
    hello: () => 'world',
  },
};

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

const { url } = await startStandaloneServer(server);
console.log(`üöÄ Server ready at ${url}`);
```

Now run your server with:

```
node server.mjs
```

Open the URL it prints in a web browser. It will show [Apollo Sandbox](https://www.apollographql.com/docs/studio/explorer/sandbox/), a web-based tool for running GraphQL operations. Try running the operation `query { hello }`!


## Getting started: Express middleware

Apollo Server's built-in Express middleware lets you run your GraphQL server as part of an app built with [Express](https://expressjs.com/), the most popular web framework for Node.

First, install Apollo Server, the JavaScript implementation of the core GraphQL algorithms, Express, and two common Express middleware packages:

```
npm install @apollo/server graphql express cors body-parser
```

Then, write the following to `server.mjs`. (By using the `.mjs` extension, Node lets you use the `await` keyword at the top level.)

```js
import { ApolloServer } from '@apollo/server';
import { expressMiddleware } from '@apollo/server/express4';
import { ApolloServerPluginDrainHttpServer } from '@apollo/server/plugin/drainHttpServer'
import express from 'express';
import http from 'http';
import cors from 'cors';
import bodyParser from 'body-parser';

// The GraphQL schema
const typeDefs = `#graphql
  type Query {
    hello: String
  }
`;

// A map of functions which return data for the schema.
const resolvers = {
  Query: {
    hello: () => 'world',
  },
};

const app = express();
const httpServer = http.createServer(app);

// Set up Apollo Server
const server = new ApolloServer({
  typeDefs,
  resolvers,
  plugins: [ApolloServerPluginDrainHttpServer({ httpServer })],
});
await server.start();

app.use(
  cors(),
  bodyParser.json(),
  expressMiddleware(server),
);

await new Promise((resolve) => httpServer.listen({ port: 4000 }, resolve));
console.log(`üöÄ Server ready at http://localhost:4000`);
```

Now run your server with:

```
node server.mjs
```

Open the URL it prints in a web browser. It will show [Apollo Sandbox](https://www.apollographql.com/docs/studio/explorer/sandbox/), a web-based tool for running GraphQL operations. Try running the operation `query { hello }`!
Ÿ)/dist/cjs/plugin/drainHttpServer/index.js≈ç"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApolloServerPluginDrainHttpServer = void 0;
const stoppable_js_1 = require("./stoppable.js");
function ApolloServerPluginDrainHttpServer(options) {
    const stopper = new stoppable_js_1.Stopper(options.httpServer);
    return {
        async serverWillStart() {
            return {
                async drainServer() {
                    await stopper.stop(options.stopGracePeriodMillis ?? 10000);
                },
            };
        },
    };
}
exports.ApolloServerPluginDrainHttpServer = ApolloServerPluginDrainHttpServer;
//# sourceMappingURL=index.js.mapŸ"/dist/cjs/determineApolloConfig.js≈≥"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineApolloConfig = void 0;
const utils_createhash_1 = require("@apollo/utils.createhash");
function determineApolloConfig(input) {
    const apolloConfig = {};
    const { APOLLO_KEY, APOLLO_GRAPH_REF, APOLLO_GRAPH_ID, APOLLO_GRAPH_VARIANT, } = process.env;
    if (input?.key) {
        apolloConfig.key = input.key;
    }
    else if (APOLLO_KEY) {
        apolloConfig.key = APOLLO_KEY;
    }
    if (apolloConfig.key) {
        apolloConfig.keyHash = (0, utils_createhash_1.createHash)('sha512')
            .update(apolloConfig.key)
            .digest('hex');
    }
    if (input?.graphRef) {
        apolloConfig.graphRef = input.graphRef;
    }
    else if (APOLLO_GRAPH_REF) {
        apolloConfig.graphRef = APOLLO_GRAPH_REF;
    }
    const graphId = input?.graphId ?? APOLLO_GRAPH_ID;
    const graphVariant = input?.graphVariant ?? APOLLO_GRAPH_VARIANT;
    if (apolloConfig.graphRef) {
        if (graphId) {
            throw new Error('Cannot specify both graph ref and graph ID. Please use ' +
                '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.');
        }
        if (graphVariant) {
            throw new Error('Cannot specify both graph ref and graph variant. Please use ' +
                '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.');
        }
    }
    else if (graphId) {
        apolloConfig.graphRef = graphVariant
            ? `${graphId}@${graphVariant}`
            : graphId;
    }
    return apolloConfig;
}
exports.determineApolloConfig = determineApolloConfig;
//# sourceMappingURL=determineApolloConfig.js.mapŸ&/dist/esm/plugin/cacheControl/index.js≈'˜import { getNamedType, isCompositeType, isInterfaceType, isObjectType, responsePathAsArray, } from 'graphql';
import { newCachePolicy } from '../../cachePolicy.js';
import { internalPlugin } from '../../internalPlugin.js';
import LRUCache from 'lru-cache';
export function ApolloServerPluginCacheControl(options = Object.create(null)) {
    let typeAnnotationCache;
    let fieldAnnotationCache;
    return internalPlugin({
        __internal_plugin_id__: 'CacheControl',
        __is_disabled_plugin__: false,
        async serverWillStart({ schema }) {
            typeAnnotationCache = new LRUCache({
                max: Object.values(schema.getTypeMap()).filter(isCompositeType)
                    .length,
            });
            fieldAnnotationCache = new LRUCache({
                max: Object.values(schema.getTypeMap())
                    .filter(isObjectType)
                    .flatMap((t) => Object.values(t.getFields())).length +
                    Object.values(schema.getTypeMap())
                        .filter(isInterfaceType)
                        .flatMap((t) => Object.values(t.getFields())).length,
            });
            return undefined;
        },
        async requestDidStart(requestContext) {
            function memoizedCacheAnnotationFromType(t) {
                const existing = typeAnnotationCache.get(t);
                if (existing) {
                    return existing;
                }
                const annotation = cacheAnnotationFromType(t);
                typeAnnotationCache.set(t, annotation);
                return annotation;
            }
            function memoizedCacheAnnotationFromField(field) {
                const existing = fieldAnnotationCache.get(field);
                if (existing) {
                    return existing;
                }
                const annotation = cacheAnnotationFromField(field);
                fieldAnnotationCache.set(field, annotation);
                return annotation;
            }
            const defaultMaxAge = options.defaultMaxAge ?? 0;
            const calculateHttpHeaders = options.calculateHttpHeaders ?? true;
            const { __testing__cacheHints } = options;
            return {
                async executionDidStart() {
                    if (isRestricted(requestContext.overallCachePolicy)) {
                        const fakeFieldPolicy = newCachePolicy();
                        return {
                            willResolveField({ info }) {
                                info.cacheControl = {
                                    setCacheHint: (dynamicHint) => {
                                        fakeFieldPolicy.replace(dynamicHint);
                                    },
                                    cacheHint: fakeFieldPolicy,
                                    cacheHintFromType: memoizedCacheAnnotationFromType,
                                };
                            },
                        };
                    }
                    return {
                        willResolveField({ info }) {
                            const fieldPolicy = newCachePolicy();
                            let inheritMaxAge = false;
                            const targetType = getNamedType(info.returnType);
                            if (isCompositeType(targetType)) {
                                const typeAnnotation = memoizedCacheAnnotationFromType(targetType);
                                fieldPolicy.replace(typeAnnotation);
                                inheritMaxAge = !!typeAnnotation.inheritMaxAge;
                            }
                            const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);
                            if (fieldAnnotation.inheritMaxAge &&
                                fieldPolicy.maxAge === undefined) {
                                inheritMaxAge = true;
                                if (fieldAnnotation.scope) {
                                    fieldPolicy.replace({ scope: fieldAnnotation.scope });
                                }
                            }
                            else {
                                fieldPolicy.replace(fieldAnnotation);
                            }
                            info.cacheControl = {
                                setCacheHint: (dynamicHint) => {
                                    fieldPolicy.replace(dynamicHint);
                                },
                                cacheHint: fieldPolicy,
                                cacheHintFromType: memoizedCacheAnnotationFromType,
                            };
                            return () => {
                                if (fieldPolicy.maxAge === undefined &&
                                    ((isCompositeType(targetType) && !inheritMaxAge) ||
                                        !info.path.prev)) {
                                    fieldPolicy.restrict({ maxAge: defaultMaxAge });
                                }
                                if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                                    const path = responsePathAsArray(info.path).join('.');
                                    if (__testing__cacheHints.has(path)) {
                                        throw Error("shouldn't happen: addHint should only be called once per path");
                                    }
                                    __testing__cacheHints.set(path, {
                                        maxAge: fieldPolicy.maxAge,
                                        scope: fieldPolicy.scope,
                                    });
                                }
                                requestContext.overallCachePolicy.restrict(fieldPolicy);
                            };
                        },
                    };
                },
                async willSendResponse(requestContext) {
                    if (!calculateHttpHeaders) {
                        return;
                    }
                    const { response, overallCachePolicy } = requestContext;
                    const existingCacheControlHeader = parseExistingCacheControlHeader(response.http.headers.get('cache-control'));
                    if (existingCacheControlHeader.kind === 'unparsable') {
                        return;
                    }
                    const cachePolicy = newCachePolicy();
                    cachePolicy.replace(overallCachePolicy);
                    if (existingCacheControlHeader.kind === 'parsable-and-cacheable') {
                        cachePolicy.restrict(existingCacheControlHeader.hint);
                    }
                    const policyIfCacheable = cachePolicy.policyIfCacheable();
                    if (policyIfCacheable &&
                        existingCacheControlHeader.kind !== 'uncacheable' &&
                        response.body.kind === 'single' &&
                        !response.body.singleResult.errors) {
                        response.http.headers.set('cache-control', `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);
                    }
                    else if (calculateHttpHeaders !== 'if-cacheable') {
                        response.http.headers.set('cache-control', CACHE_CONTROL_HEADER_UNCACHEABLE);
                    }
                },
            };
        },
    });
}
const CACHE_CONTROL_HEADER_CACHEABLE_REGEXP = /^max-age=(\d+), (public|private)$/;
const CACHE_CONTROL_HEADER_UNCACHEABLE = 'no-store';
function parseExistingCacheControlHeader(header) {
    if (!header) {
        return { kind: 'no-header' };
    }
    if (header === CACHE_CONTROL_HEADER_UNCACHEABLE) {
        return { kind: 'uncacheable' };
    }
    const match = CACHE_CONTROL_HEADER_CACHEABLE_REGEXP.exec(header);
    if (!match) {
        return { kind: 'unparsable' };
    }
    return {
        kind: 'parsable-and-cacheable',
        hint: {
            maxAge: +match[1],
            scope: match[2] === 'public' ? 'PUBLIC' : 'PRIVATE',
        },
    };
}
function cacheAnnotationFromDirectives(directives) {
    if (!directives)
        return undefined;
    const cacheControlDirective = directives.find((directive) => directive.name.value === 'cacheControl');
    if (!cacheControlDirective)
        return undefined;
    if (!cacheControlDirective.arguments)
        return undefined;
    const maxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'maxAge');
    const scopeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'scope');
    const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'inheritMaxAge');
    const scopeString = scopeArgument?.value?.kind === 'EnumValue'
        ? scopeArgument.value.value
        : undefined;
    const scope = scopeString === 'PUBLIC' || scopeString === 'PRIVATE'
        ? scopeString
        : undefined;
    if (inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&
        inheritMaxAgeArgument.value.value) {
        return { inheritMaxAge: true, scope };
    }
    return {
        maxAge: maxAgeArgument?.value?.kind === 'IntValue'
            ? parseInt(maxAgeArgument.value.value)
            : undefined,
        scope,
    };
}
function cacheAnnotationFromType(t) {
    if (t.astNode) {
        const hint = cacheAnnotationFromDirectives(t.astNode.directives);
        if (hint) {
            return hint;
        }
    }
    if (t.extensionASTNodes) {
        for (const node of t.extensionASTNodes) {
            const hint = cacheAnnotationFromDirectives(node.directives);
            if (hint) {
                return hint;
            }
        }
    }
    return {};
}
function cacheAnnotationFromField(field) {
    if (field.astNode) {
        const hint = cacheAnnotationFromDirectives(field.astNode.directives);
        if (hint) {
            return hint;
        }
    }
    return {};
}
function isRestricted(hint) {
    return hint.maxAge !== undefined || hint.scope !== undefined;
}
//# sourceMappingURL=index.js.map∂/src/internalPlugin.ts≈import type { BaseContext, ApolloServerPlugin } from './externalTypes/index.js';

// This file's exports should not be exported from the overall
// @apollo/server module.

// The internal plugins implement this interface which
// ApolloServer.ensurePluginInstantiation uses to figure out if the plugins have
// already been installed (or explicitly disabled via the matching Disable
// plugins).
export interface InternalApolloServerPlugin<TContext extends BaseContext>
  extends ApolloServerPlugin<TContext> {
  // Used to identify a few specific plugins that are instantiated
  // by default if not explicitly used or disabled.
  __internal_plugin_id__: InternalPluginId;
  __is_disabled_plugin__: boolean;
}

// Helper function for writing internal plugins which lets you write an object
// that is type-checked as InternalApolloServerPlugin but is still only of type
// ApolloServerPlugin (as appropriate for externally-exported plugin-returning
// functions).
export function internalPlugin<TContext extends BaseContext>(
  p: InternalApolloServerPlugin<TContext>,
): ApolloServerPlugin<TContext> {
  return p;
}

export type InternalPluginId =
  | 'CacheControl'
  | 'LandingPageDisabled'
  | 'SchemaReporting'
  | 'InlineTrace'
  | 'UsageReporting';

export function pluginIsInternal<TContext extends BaseContext>(
  plugin: ApolloServerPlugin<TContext>,
): plugin is InternalApolloServerPlugin<TContext> {
  // We could call the function and compare it to the list above, but this seems
  // good enough.
  return '__internal_plugin_id__' in plugin;
}
ª/dist/esm/internalPlugin.jsƒ∫export function internalPlugin(p) {
    return p;
}
export function pluginIsInternal(plugin) {
    return '__internal_plugin_id__' in plugin;
}
//# sourceMappingURL=internalPlugin.js.mapŸ%/dist/esm/internalErrorClasses.js.map≈	Ö{"version":3,"file":"internalErrorClasses.js","sourceRoot":"","sources":["../../src/internalErrorClasses.ts"],"names":[],"mappings":"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"}Ÿ+/dist/esm/plugin/schemaReporting/index.d.ts≈import type { ApolloServerPlugin } from '../../externalTypes/index.js';
import type { Fetcher } from '@apollo/utils.fetcher';
export interface ApolloServerPluginSchemaReportingOptions {
    initialDelayMaxMs?: number;
    overrideReportedSchema?: string;
    endpointUrl?: string;
    fetcher?: Fetcher;
}
export declare function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher, }?: ApolloServerPluginSchemaReportingOptions): ApolloServerPlugin;
//# sourceMappingURL=index.d.ts.mapª/dist/cjs/internalPlugin.js≈ã"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginIsInternal = exports.internalPlugin = void 0;
function internalPlugin(p) {
    return p;
}
exports.internalPlugin = internalPlugin;
function pluginIsInternal(plugin) {
    return '__internal_plugin_id__' in plugin;
}
exports.pluginIsInternal = pluginIsInternal;
//# sourceMappingURL=internalPlugin.js.mapŸ+/dist/esm/plugin/usageReporting/plugin.d.ts≈áimport { Trace } from '@apollo/usage-reporting-protobuf';
import type { ApolloServerPlugin, BaseContext } from '../../externalTypes/index.js';
import type { ApolloServerPluginUsageReportingOptions, SendValuesBaseOptions } from './options.js';
import type { HeaderMap } from '../../utils/HeaderMap.js';
export declare function ApolloServerPluginUsageReporting<TContext extends BaseContext>(options?: ApolloServerPluginUsageReportingOptions<TContext>): ApolloServerPlugin<TContext>;
export declare function makeHTTPRequestHeaders(http: Trace.IHTTP, headers: HeaderMap, sendHeaders?: SendValuesBaseOptions): void;
//# sourceMappingURL=plugin.d.ts.mapŸ</dist/cjs/plugin/usageReporting/operationDerivedDataCache.js≈ó"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.operationDerivedDataCacheKey = exports.createOperationDerivedDataCache = void 0;
const lru_cache_1 = __importDefault(require("lru-cache"));
function createOperationDerivedDataCache({ logger, }) {
    let lastWarn;
    let lastDisposals = 0;
    return new lru_cache_1.default({
        sizeCalculation(obj) {
            return Buffer.byteLength(JSON.stringify(obj), 'utf8');
        },
        maxSize: Math.pow(2, 20) * 10,
        dispose() {
            lastDisposals++;
            if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {
                lastWarn = new Date();
                logger.warn([
                    'This server is processing a high number of unique operations.  ',
                    `A total of ${lastDisposals} records have been `,
                    'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',
                    'interval.  If you see this warning frequently, please open an ',
                    'issue on the Apollo Server repository.',
                ].join(''));
                lastDisposals = 0;
            }
        },
    });
}
exports.createOperationDerivedDataCache = createOperationDerivedDataCache;
function operationDerivedDataCacheKey(queryHash, operationName) {
    return `${queryHash}${operationName && ':' + operationName}`;
}
exports.operationDerivedDataCacheKey = operationDerivedDataCacheKey;
//# sourceMappingURL=operationDerivedDataCache.js.mapŸ!/dist/esm/express4/index.d.ts.map≈,{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/express4/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,4BAA4B,CAAC;AAC/D,OAAO,KAAK,OAAO,MAAM,SAAS,CAAC;AACnC,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,aAAa,CAAC;AAChD,OAAO,KAAK,EACV,WAAW,EACX,eAAe,EAEhB,MAAM,2BAA2B,CAAC;AAGnC,MAAM,WAAW,8BAA8B;IAC7C,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC;IACrB,GAAG,EAAE,OAAO,CAAC,QAAQ,CAAC;CACvB;AAED,MAAM,WAAW,wBAAwB,CAAC,QAAQ,SAAS,WAAW;IACpE,OAAO,CAAC,EAAE,eAAe,CAAC,CAAC,8BAA8B,CAAC,EAAE,QAAQ,CAAC,CAAC;CACvE;AAED,wBAAgB,iBAAiB,CAC/B,MAAM,EAAE,YAAY,CAAC,WAAW,CAAC,EACjC,OAAO,CAAC,EAAE,wBAAwB,CAAC,WAAW,CAAC,GAC9C,OAAO,CAAC,cAAc,CAAC;AAC1B,wBAAgB,iBAAiB,CAAC,QAAQ,SAAS,WAAW,EAC5D,MAAM,EAAE,YAAY,CAAC,QAAQ,CAAC,EAC9B,OAAO,EAAE,YAAY,CAAC,wBAAwB,CAAC,QAAQ,CAAC,EAAE,SAAS,CAAC,GACnE,OAAO,CAAC,cAAc,CAAC"}Ÿ&/dist/esm/plugin/disabled/index.js.map≈e{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/disabled/index.ts"],"names":[],"mappings":"AAcA,SAAS,cAAc,CAAC,EAAoB;IAC1C,MAAM,MAAM,GAA4C;QACtD,sBAAsB,EAAE,EAAE;QAC1B,sBAAsB,EAAE,IAAI;KAC7B,CAAC;IACF,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,MAAM,UAAU,sCAAsC;IACpD,OAAO,cAAc,CAAC,cAAc,CAAC,CAAC;AACxC,CAAC;AAED,MAAM,UAAU,qCAAqC;IACnD,OAAO,cAAc,CAAC,aAAa,CAAC,CAAC;AACvC,CAAC;AAED,MAAM,UAAU,qCAAqC;IACnD,OAAO,cAAc,CAAC,qBAAqB,CAAC,CAAC;AAC/C,CAAC;AAED,MAAM,UAAU,yCAAyC;IACvD,OAAO,cAAc,CAAC,iBAAiB,CAAC,CAAC;AAC3C,CAAC;AAED,MAAM,UAAU,wCAAwC;IACtD,OAAO,cAAc,CAAC,gBAAgB,CAAC,CAAC;AAC1C,CAAC"}Ÿ./dist/cjs/externalTypes/requestPipeline.js.mapƒé{"version":3,"file":"requestPipeline.js","sourceRoot":"","sources":["../../../src/externalTypes/requestPipeline.ts"],"names":[],"mappings":""}Ÿ /dist/cjs/utils/HeaderMap.js.map≈-{"version":3,"file":"HeaderMap.js","sourceRoot":"","sources":["../../../src/utils/HeaderMap.ts"],"names":[],"mappings":";;;AAAA,MAAa,SAAU,SAAQ,GAAmB;IACvC,GAAG,CAAC,GAAW,EAAE,KAAa;QACrC,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,CAAC;IAC7C,CAAC;IAEQ,GAAG,CAAC,GAAW;QACtB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;IAEQ,MAAM,CAAC,GAAW;QACzB,OAAO,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACzC,CAAC;IAEQ,GAAG,CAAC,GAAW;QACtB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;CACF;AAhBD,8BAgBC"}Ÿ&/dist/esm/externalTypes/graphql.js.mapƒ~{"version":3,"file":"graphql.js","sourceRoot":"","sources":["../../../src/externalTypes/graphql.ts"],"names":[],"mappings":""}¥/src/runHttpQuery.ts≈0µimport type {
  BaseContext,
  GraphQLExperimentalFormattedIncrementalResult,
  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,
  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,
  GraphQLRequest,
  HTTPGraphQLHead,
  HTTPGraphQLRequest,
  HTTPGraphQLResponse,
} from './externalTypes/index.js';
import {
  ApolloServer,
  ApolloServerInternals,
  chooseContentTypeForSingleResultResponse,
  internalExecuteOperation,
  MEDIA_TYPES,
  SchemaDerivedData,
} from './ApolloServer.js';
import { FormattedExecutionResult, Kind } from 'graphql';
import { BadRequestError } from './internalErrorClasses.js';
import { URLSearchParams } from 'url';
import Negotiator from 'negotiator';
import { HeaderMap } from './utils/HeaderMap.js';

function fieldIfString(
  o: Record<string, unknown>,
  fieldName: string,
): string | undefined {
  const value = o[fieldName];
  if (typeof value === 'string') {
    return value;
  }
  return undefined;
}

function searchParamIfSpecifiedOnce(
  searchParams: URLSearchParams,
  paramName: string,
) {
  const values = searchParams.getAll(paramName);
  switch (values.length) {
    case 0:
      return undefined;
    case 1:
      return values[0];
    default:
      throw new BadRequestError(
        `The '${paramName}' search parameter may only be specified once.`,
      );
  }
}

function jsonParsedSearchParamIfSpecifiedOnce(
  searchParams: URLSearchParams,
  fieldName: string,
): Record<string, unknown> | undefined {
  const value = searchParamIfSpecifiedOnce(searchParams, fieldName);
  if (value === undefined) {
    return undefined;
  }
  let hopefullyRecord;
  try {
    hopefullyRecord = JSON.parse(value);
  } catch {
    throw new BadRequestError(
      `The ${fieldName} search parameter contains invalid JSON.`,
    );
  }
  if (!isStringRecord(hopefullyRecord)) {
    throw new BadRequestError(
      `The ${fieldName} search parameter should contain a JSON-encoded object.`,
    );
  }
  return hopefullyRecord;
}

function fieldIfRecord(
  o: Record<string, unknown>,
  fieldName: string,
): Record<string, unknown> | undefined {
  const value = o[fieldName];
  if (isStringRecord(value)) {
    return value;
  }
  return undefined;
}

function isStringRecord(o: unknown): o is Record<string, unknown> {
  return (
    !!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o)
  );
}

function isNonEmptyStringRecord(o: unknown): o is Record<string, unknown> {
  return isStringRecord(o) && Object.keys(o).length > 0;
}

function ensureQueryIsStringOrMissing(query: unknown) {
  if (!query || typeof query === 'string') {
    return;
  }
  // Check for a common error first.
  if ((query as any).kind === Kind.DOCUMENT) {
    throw new BadRequestError(
      "GraphQL queries must be strings. It looks like you're sending the " +
        'internal graphql-js representation of a parsed query in your ' +
        'request instead of a request in the GraphQL query language. You ' +
        'can convert an AST to a string using the `print` function from ' +
        '`graphql`, or use a client like `apollo-client` which converts ' +
        'the internal representation to a string for you.',
    );
  } else {
    throw new BadRequestError('GraphQL queries must be strings.');
  }
}

export async function runHttpQuery<TContext extends BaseContext>({
  server,
  httpRequest,
  contextValue,
  schemaDerivedData,
  internals,
  sharedResponseHTTPGraphQLHead,
}: {
  server: ApolloServer<TContext>;
  httpRequest: HTTPGraphQLRequest;
  contextValue: TContext;
  schemaDerivedData: SchemaDerivedData;
  internals: ApolloServerInternals<TContext>;
  sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;
}): Promise<HTTPGraphQLResponse> {
  let graphQLRequest: GraphQLRequest;

  switch (httpRequest.method) {
    case 'POST': {
      if (!isNonEmptyStringRecord(httpRequest.body)) {
        throw new BadRequestError(
          'POST body missing, invalid Content-Type, or JSON object has no keys.',
        );
      }

      ensureQueryIsStringOrMissing(httpRequest.body.query);

      if (typeof httpRequest.body.variables === 'string') {
        throw new BadRequestError(
          '`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.',
        );
      }

      if (typeof httpRequest.body.extensions === 'string') {
        throw new BadRequestError(
          '`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.',
        );
      }

      graphQLRequest = {
        query: fieldIfString(httpRequest.body, 'query'),
        operationName: fieldIfString(httpRequest.body, 'operationName'),
        variables: fieldIfRecord(httpRequest.body, 'variables'),
        extensions: fieldIfRecord(httpRequest.body, 'extensions'),
        http: httpRequest,
      };

      break;
    }

    case 'GET': {
      const searchParams = new URLSearchParams(httpRequest.search);

      graphQLRequest = {
        query: searchParamIfSpecifiedOnce(searchParams, 'query'),
        operationName: searchParamIfSpecifiedOnce(
          searchParams,
          'operationName',
        ),
        variables: jsonParsedSearchParamIfSpecifiedOnce(
          searchParams,
          'variables',
        ),
        extensions: jsonParsedSearchParamIfSpecifiedOnce(
          searchParams,
          'extensions',
        ),
        http: httpRequest,
      };

      break;
    }
    default:
      throw new BadRequestError(
        'Apollo Server supports only GET/POST requests.',
        {
          extensions: {
            http: {
              status: 405,
              headers: new HeaderMap([['allow', 'GET, POST']]),
            },
          },
        },
      );
  }

  const graphQLResponse = await internalExecuteOperation(
    {
      server,
      graphQLRequest,
      internals,
      schemaDerivedData,
      sharedResponseHTTPGraphQLHead,
    },
    { contextValue },
  );

  if (graphQLResponse.body.kind === 'single') {
    if (!graphQLResponse.http.headers.get('content-type')) {
      // If we haven't already set the content-type (via a plugin or something),
      // decide which content-type to use based on the accept header.
      const contentType = chooseContentTypeForSingleResultResponse(httpRequest);
      if (contentType === null) {
        throw new BadRequestError(
          `An 'accept' header was provided for this request which does not accept ` +
            `${MEDIA_TYPES.APPLICATION_JSON} or ${MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON}`,
          // Use 406 Not Accepted
          { extensions: { http: { status: 406 } } },
        );
      }
      graphQLResponse.http.headers.set('content-type', contentType);
    }

    return {
      ...graphQLResponse.http,
      body: {
        kind: 'complete',
        string: prettyJSONStringify(
          orderExecutionResultFields(graphQLResponse.body.singleResult),
        ),
      },
    };
  }

  // Note that incremental delivery is not yet part of the official GraphQL
  // spec. We are implementing a proposed version of the spec, and require
  // clients to explicitly state `deferSpec=20220824`. Once incremental delivery
  // has been added to the GraphQL spec, we will support `accept` headers
  // without `deferSpec` as well (perhaps with slightly different behavior if
  // anything has changed).
  const acceptHeader = httpRequest.headers.get('accept');
  if (
    !(
      acceptHeader &&
      new Negotiator({
        headers: { accept: httpRequest.headers.get('accept') },
      }).mediaType([
        // mediaType() will return the first one that matches, so if the client
        // doesn't include the deferSpec parameter it will match this one here,
        // which isn't good enough.
        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,
        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,
      ]) === MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL
    )
  ) {
    // The client ran an operation that would yield multiple parts, but didn't
    // specify `accept: multipart/mixed`. We return an error.
    throw new BadRequestError(
      'Apollo server received an operation that uses incremental delivery ' +
        '(@defer or @stream), but the client does not accept multipart/mixed ' +
        'HTTP responses. To enable incremental delivery support, add the HTTP ' +
        "header 'Accept: multipart/mixed; deferSpec=20220824'.",
      // Use 406 Not Accepted
      { extensions: { http: { status: 406 } } },
    );
  }

  graphQLResponse.http.headers.set(
    'content-type',
    'multipart/mixed; boundary="-"; deferSpec=20220824',
  );
  return {
    ...graphQLResponse.http,
    body: {
      kind: 'chunked',
      asyncIterator: writeMultipartBody(
        graphQLResponse.body.initialResult,
        graphQLResponse.body.subsequentResults,
      ),
    },
  };
}

async function* writeMultipartBody(
  initialResult: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,
  subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>,
): AsyncGenerator<string> {
  // Note: we assume in this function that every result other than the last has
  // hasNext=true and the last has hasNext=false. That is, we choose which kind
  // of delimiter to place at the end of each block based on the contents of the
  // message, not the structure of the async iterator. This makes sense because
  // we want to write the delimiter as soon as each block is done (so the client
  // can parse it immediately) but we may not know whether a general async
  // iterator is finished until we do async work.

  yield `\r\n---\r\ncontent-type: application/json; charset=utf-8\r\n\r\n${JSON.stringify(
    orderInitialIncrementalExecutionResultFields(initialResult),
  )}\r\n---${initialResult.hasNext ? '' : '--'}\r\n`;

  for await (const result of subsequentResults) {
    yield `content-type: application/json; charset=utf-8\r\n\r\n${JSON.stringify(
      orderSubsequentIncrementalExecutionResultFields(result),
    )}\r\n---${result.hasNext ? '' : '--'}\r\n`;
  }
}

// See https://github.com/facebook/graphql/pull/384 for why
// errors comes first.
function orderExecutionResultFields(
  result: FormattedExecutionResult,
): FormattedExecutionResult {
  return {
    errors: result.errors,
    data: result.data,
    extensions: result.extensions,
  };
}
function orderInitialIncrementalExecutionResultFields(
  result: GraphQLExperimentalFormattedInitialIncrementalExecutionResult,
): GraphQLExperimentalFormattedInitialIncrementalExecutionResult {
  return {
    hasNext: result.hasNext,
    errors: result.errors,
    data: result.data,
    incremental: orderIncrementalResultFields(result.incremental),
    extensions: result.extensions,
  };
}
function orderSubsequentIncrementalExecutionResultFields(
  result: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,
): GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult {
  return {
    hasNext: result.hasNext,
    incremental: orderIncrementalResultFields(result.incremental),
    extensions: result.extensions,
  };
}

function orderIncrementalResultFields(
  incremental?: readonly GraphQLExperimentalFormattedIncrementalResult[],
): undefined | GraphQLExperimentalFormattedIncrementalResult[] {
  return incremental?.map((i: any) => ({
    hasNext: i.hasNext,
    errors: i.errors,
    path: i.path,
    label: i.label,
    data: i.data,
    items: i.items,
    extensions: i.extensions,
  }));
}

// The result of a curl does not appear well in the terminal, so we add an extra new line
export function prettyJSONStringify(value: FormattedExecutionResult) {
  return JSON.stringify(value) + '\n';
}

export function newHTTPGraphQLHead(status?: number): HTTPGraphQLHead {
  return {
    status,
    headers: new HeaderMap(),
  };
}

// Updates `target` with status code and headers from `source`. For now let's
// consider it undefined what happens if both have a status code set or both set
// the same header.
export function mergeHTTPGraphQLHead(
  target: HTTPGraphQLHead,
  source: HTTPGraphQLHead,
) {
  if (source.status) {
    target.status = source.status;
  }
  if (source.headers) {
    for (const [name, value] of source.headers) {
      // If source.headers contains non-lowercase header names, this will
      // catch that case as long as target.headers is a HeaderMap.
      target.headers.set(name, value);
    }
  }
}
Ÿ)/dist/esm/plugin/inlineTrace/index.js.map≈Ã{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/inlineTrace/index.ts"],"names":[],"mappings":"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"}Ÿ7/dist/cjs/utils/makeGatewayGraphQLRequestContext.js.map≈ñ{"version":3,"file":"makeGatewayGraphQLRequestContext.js","sourceRoot":"","sources":["../../../src/utils/makeGatewayGraphQLRequestContext.ts"],"names":[],"mappings":"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"}Ÿ"/dist/esm/externalTypes/context.jsƒ.export {};
//# sourceMappingURL=context.js.mapŸ//dist/esm/plugin/drainHttpServer/stoppable.d.ts≈|/// <reference types="node" />
/// <reference types="node" />
import type http from 'http';
import https from 'https';
export declare class Stopper {
    private server;
    private requestCountPerSocket;
    private stopped;
    constructor(server: http.Server | https.Server);
    stop(stopGracePeriodMillis?: number): Promise<boolean>;
}
//# sourceMappingURL=stoppable.d.ts.mapŸ6/dist/esm/plugin/usageReporting/durationHistogram.d.ts≈mexport interface DurationHistogramOptions {
    initSize?: number;
    buckets?: number[];
}
export declare class DurationHistogram {
    private readonly buckets;
    static readonly BUCKET_COUNT = 384;
    static readonly EXPONENT_LOG: number;
    toArray(): number[];
    static durationToBucket(durationNs: number): number;
    incrementDuration(durationNs: number, value?: number): DurationHistogram;
    incrementBucket(bucket: number, value?: number): void;
    combine(otherHistogram: DurationHistogram): void;
    constructor(options?: DurationHistogramOptions);
}
//# sourceMappingURL=durationHistogram.d.ts.mapŸ&/dist/esm/utils/schemaManager.d.ts.map≈i{"version":3,"file":"schemaManager.d.ts","sourceRoot":"","sources":["../../../src/utils/schemaManager.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,KAAK,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AAC7C,OAAO,KAAK,EACV,eAAe,EACf,gBAAgB,EAChB,mBAAmB,EACpB,MAAM,kCAAkC,CAAC;AAC1C,OAAO,KAAK,EAAE,iBAAiB,EAAE,MAAM,oBAAoB,CAAC;AAC5D,OAAO,KAAK,EACV,YAAY,EACZ,oBAAoB,EACrB,MAAM,2BAA2B,CAAC;AAEnC,aAAK,yBAAyB,GAAG,CAC/B,SAAS,EAAE,aAAa,KACrB,iBAAiB,CAAC;AAevB,qBAAa,aAAa;IACxB,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAS;IAChC,OAAO,CAAC,QAAQ,CAAC,yBAAyB,CAA4B;IACtE,OAAO,CAAC,QAAQ,CAAC,6BAA6B,CAE1C;IACJ,OAAO,CAAC,SAAS,CAAS;IAC1B,OAAO,CAAC,iBAAiB,CAAC,CAAoB;IAC9C,OAAO,CAAC,aAAa,CAAC,CAAuB;IAG7C,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAW5B;gBAGJ,OAAO,EAAE,CACL;QAAE,OAAO,EAAE,gBAAgB,CAAC;QAAC,YAAY,EAAE,YAAY,CAAA;KAAE,GACzD;QAAE,SAAS,EAAE,aAAa,CAAA;KAAE,CAC/B,GAAG;QACF,MAAM,EAAE,MAAM,CAAC;QACf,yBAAyB,EAAE,yBAAyB,CAAC;KACtD;IA8BU,KAAK,IAAI,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC;IA8C9C,oBAAoB,CACzB,QAAQ,EAAE,CAAC,aAAa,EAAE,oBAAoB,KAAK,IAAI,GACtD,mBAAmB;IA6Bf,oBAAoB,IAAI,iBAAiB;IAcnC,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC;IAQlC,OAAO,CAAC,8BAA8B;CAqBvC"}Ÿ7/src/plugin/usageReporting/operationDerivedDataCache.ts≈	Wimport type { Logger } from '@apollo/utils.logger';
import type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';
import LRUCache from 'lru-cache';

export interface OperationDerivedData {
  signature: string;
  referencedFieldsByType: ReferencedFieldsByType;
}

export function createOperationDerivedDataCache({
  logger,
}: {
  logger: Logger;
}): LRUCache<string, OperationDerivedData> {
  let lastWarn: Date;
  let lastDisposals = 0;
  return new LRUCache<string, OperationDerivedData>({
    // Calculate the length of cache objects by the JSON.stringify byteLength.
    sizeCalculation(obj) {
      return Buffer.byteLength(JSON.stringify(obj), 'utf8');
    },
    // 10MiB limit, very much approximately since we can't be sure how V8 might
    // be storing this data internally. Though this should be enough to store a
    // fair amount of operation data, depending on their overall complexity. A
    // future version of this might expose some configuration option to grow the
    // cache, but ideally, we could do that dynamically based on the resources
    // available to the server, and not add more configuration surface area.
    // Hopefully the warning message will allow us to evaluate the need with
    // more validated input from those that receive it.
    maxSize: Math.pow(2, 20) * 10,
    dispose() {
      // Count the number of disposals between warning messages.
      lastDisposals++;

      // Only show a message warning about the high turnover every 60 seconds.
      if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {
        // Log the time that we last displayed the message.
        lastWarn = new Date();
        logger.warn(
          [
            'This server is processing a high number of unique operations.  ',
            `A total of ${lastDisposals} records have been `,
            'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',
            'interval.  If you see this warning frequently, please open an ',
            'issue on the Apollo Server repository.',
          ].join(''),
        );

        // Reset the disposal counter for the next message interval.
        lastDisposals = 0;
      }
    },
  });
}

export function operationDerivedDataCacheKey(
  queryHash: string,
  operationName: string,
) {
  return `${queryHash}${operationName && ':' + operationName}`;
}
Ÿ./dist/esm/utils/computeCoreSchemaHash.d.ts.mapƒ {"version":3,"file":"computeCoreSchemaHash.d.ts","sourceRoot":"","sources":["../../../src/utils/computeCoreSchemaHash.ts"],"names":[],"mappings":"AAMA,wBAAgB,qBAAqB,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM,CAE5D"}ª/src/utils/schemaManager.ts≈œimport type { Logger } from '@apollo/utils.logger';
import type { GraphQLSchema } from 'graphql';
import type {
  GatewayExecutor,
  GatewayInterface,
  GatewayUnsubscriber,
} from '@apollo/server-gateway-interface';
import type { SchemaDerivedData } from '../ApolloServer.js';
import type {
  ApolloConfig,
  GraphQLSchemaContext,
} from '../externalTypes/index.js';

type SchemaDerivedDataProvider = (
  apiSchema: GraphQLSchema,
) => SchemaDerivedData;

/**
 * An async-safe class for tracking changes in schemas and schema-derived data.
 *
 * Specifically, as long as start() is called (and completes) before stop() is
 * called, any set of executions of public methods is linearizable.
 *
 * Note that linearizability in Javascript is trivial if all public methods are
 * non-async, but increasingly difficult to guarantee if public methods become
 * async. Accordingly, if you believe a public method should be async, think
 * carefully on whether it's worth the mental overhead. (E.g. if you wished that
 * a callback was async, consider instead resolving a Promise in a non-async
 * callback and having your async code wait on the Promise in setTimeout().)
 */
export class SchemaManager {
  private readonly logger: Logger;
  private readonly schemaDerivedDataProvider: SchemaDerivedDataProvider;
  private readonly onSchemaLoadOrUpdateListeners = new Set<
    (schemaContext: GraphQLSchemaContext) => void
  >();
  private isStopped = false;
  private schemaDerivedData?: SchemaDerivedData;
  private schemaContext?: GraphQLSchemaContext;

  // For state that's specific to the mode of operation.
  private readonly modeSpecificState:
    | {
        readonly mode: 'gateway';
        readonly gateway: GatewayInterface;
        readonly apolloConfig: ApolloConfig;
        unsubscribeFromGateway?: GatewayUnsubscriber;
      }
    | {
        readonly mode: 'schema';
        readonly apiSchema: GraphQLSchema;
        readonly schemaDerivedData: SchemaDerivedData;
      };

  constructor(
    options: (
      | { gateway: GatewayInterface; apolloConfig: ApolloConfig }
      | { apiSchema: GraphQLSchema }
    ) & {
      logger: Logger;
      schemaDerivedDataProvider: SchemaDerivedDataProvider;
    },
  ) {
    this.logger = options.logger;
    this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
    if ('gateway' in options) {
      this.modeSpecificState = {
        mode: 'gateway',
        gateway: options.gateway,
        apolloConfig: options.apolloConfig,
      };
    } else {
      this.modeSpecificState = {
        mode: 'schema',
        apiSchema: options.apiSchema,
        // The caller of the constructor expects us to fail early if the schema
        // given is invalid/has errors, so we call the provider here. We also
        // pass the result to start(), as the provider can be expensive to call.
        schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema),
      };
    }
  }

  /**
   * Calling start() will:
   * - Start gateway schema fetching (if a gateway was provided).
   * - Initialize schema-derived data.
   * - Synchronously notify onSchemaLoadOrUpdate() listeners of schema load, and
   *   asynchronously notify them of schema updates.
   * - If we started a gateway, returns the gateway's executor; otherwise null.
   */
  public async start(): Promise<GatewayExecutor | null> {
    if (this.modeSpecificState.mode === 'gateway') {
      const gateway = this.modeSpecificState.gateway;
      if (gateway.onSchemaLoadOrUpdate) {
        // Use onSchemaLoadOrUpdate, as it reports the core supergraph SDL and
        // always reports the initial schema load.
        this.modeSpecificState.unsubscribeFromGateway =
          gateway.onSchemaLoadOrUpdate((schemaContext) => {
            this.processSchemaLoadOrUpdateEvent(schemaContext);
          });
      } else {
        throw new Error(
          "Unexpectedly couldn't find onSchemaLoadOrUpdate on gateway",
        );
      }

      const config = await this.modeSpecificState.gateway.load({
        apollo: this.modeSpecificState.apolloConfig,
      });

      return config.executor;
    } else {
      this.processSchemaLoadOrUpdateEvent(
        {
          apiSchema: this.modeSpecificState.apiSchema,
        },
        this.modeSpecificState.schemaDerivedData,
      );
      return null;
    }
  }

  /**
   * Registers a listener for schema load/update events. Note that the latest
   * event is buffered, i.e.
   * - If registered before start(), this method will throw. (We have no need
   *   for registration before start(), but this is easy enough to change.)
   * - If registered after start() but before stop(), the callback will be first
   *   called in this method (for whatever the current schema is), and then
   *   later for updates.
   * - If registered after stop(), the callback will never be called.
   *
   * For gateways, a core supergraph SDL will be provided to the callback.
   *
   * @param callback The listener to execute on schema load/updates.
   */
  public onSchemaLoadOrUpdate(
    callback: (schemaContext: GraphQLSchemaContext) => void,
  ): GatewayUnsubscriber {
    if (!this.schemaContext) {
      throw new Error('You must call start() before onSchemaLoadOrUpdate()');
    }
    if (!this.isStopped) {
      try {
        callback(this.schemaContext);
      } catch (e) {
        // Note that onSchemaLoadOrUpdate() is currently only called from
        // ApolloServer._start(), so we throw here to alert the user early
        // that their callback is failing.
        throw new Error(
          `An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${
            (e as Error).message
          }`,
        );
      }
    }
    this.onSchemaLoadOrUpdateListeners.add(callback);

    return () => {
      this.onSchemaLoadOrUpdateListeners.delete(callback);
    };
  }

  /**
   * Get the schema-derived state for the current schema. This throws if called
   * before start() is called.
   */
  public getSchemaDerivedData(): SchemaDerivedData {
    if (!this.schemaDerivedData) {
      throw new Error('You must call start() before getSchemaDerivedData()');
    }
    return this.schemaDerivedData;
  }

  /**
   * Calling stop() will:
   * - Stop gateway schema fetching (if a gateway was provided).
   *   - Note that this specific step may not succeed if gateway is old.
   * - Stop updating schema-derived data.
   * - Stop notifying onSchemaLoadOrUpdate() listeners.
   */
  public async stop(): Promise<void> {
    this.isStopped = true;
    if (this.modeSpecificState.mode === 'gateway') {
      this.modeSpecificState.unsubscribeFromGateway?.();
      await this.modeSpecificState.gateway.stop?.();
    }
  }

  private processSchemaLoadOrUpdateEvent(
    schemaContext: GraphQLSchemaContext,
    schemaDerivedData?: SchemaDerivedData,
  ): void {
    if (!this.isStopped) {
      this.schemaDerivedData =
        schemaDerivedData ??
        this.schemaDerivedDataProvider(schemaContext.apiSchema);
      this.schemaContext = schemaContext;
      this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
        try {
          listener(schemaContext);
        } catch (e) {
          this.logger.error(
            "An error was thrown from an 'onSchemaLoadOrUpdate' listener",
          );
          this.logger.error(e);
        }
      });
    }
  }
}
Ÿ"/dist/cjs/externalTypes/graphql.jsƒp"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=graphql.js.mapŸ-/dist/esm/plugin/drainHttpServer/stoppable.js≈–import https from 'https';
export class Stopper {
    constructor(server) {
        this.server = server;
        this.requestCountPerSocket = new Map();
        this.stopped = false;
        server.on(server instanceof https.Server ? 'secureConnection' : 'connection', (socket) => {
            this.requestCountPerSocket.set(socket, 0);
            socket.once('close', () => this.requestCountPerSocket.delete(socket));
        });
        server.on('request', (req, res) => {
            this.requestCountPerSocket.set(req.socket, (this.requestCountPerSocket.get(req.socket) ?? 0) + 1);
            res.once('finish', () => {
                const pending = (this.requestCountPerSocket.get(req.socket) ?? 0) - 1;
                this.requestCountPerSocket.set(req.socket, pending);
                if (this.stopped && pending === 0) {
                    req.socket.end();
                }
            });
        });
    }
    async stop(stopGracePeriodMillis = Infinity) {
        let gracefully = true;
        await new Promise((resolve) => setImmediate(resolve));
        this.stopped = true;
        let timeout = null;
        if (stopGracePeriodMillis < Infinity) {
            timeout = setTimeout(() => {
                gracefully = false;
                this.requestCountPerSocket.forEach((_, socket) => socket.end());
                setImmediate(() => {
                    this.requestCountPerSocket.forEach((_, socket) => socket.destroy());
                });
            }, stopGracePeriodMillis);
        }
        const closePromise = new Promise((resolve) => this.server.close(() => {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            resolve();
        }));
        this.requestCountPerSocket.forEach((requests, socket) => {
            if (requests === 0)
                socket.end();
        });
        await closePromise;
        return gracefully;
    }
}
//# sourceMappingURL=stoppable.js.mapŸ /dist/esm/utils/HeaderMap.js.map≈"{"version":3,"file":"HeaderMap.js","sourceRoot":"","sources":["../../../src/utils/HeaderMap.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,SAAU,SAAQ,GAAmB;IACvC,GAAG,CAAC,GAAW,EAAE,KAAa;QACrC,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,CAAC;IAC7C,CAAC;IAEQ,GAAG,CAAC,GAAW;QACtB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;IAEQ,MAAM,CAAC,GAAW;QACzB,OAAO,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACzC,CAAC;IAEQ,GAAG,CAAC,GAAW;QACtB,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtC,CAAC;CACF"}Ÿ"/dist/esm/externalTypes/graphql.jsƒ.export {};
//# sourceMappingURL=graphql.js.mapŸ(/dist/esm/externalTypes/plugins.d.ts.map≈ã{"version":3,"file":"plugins.d.ts","sourceRoot":"","sources":["../../../src/externalTypes/plugins.ts"],"names":[],"mappings":"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"}Ÿ(/src/plugin/landingPage/default/types.ts≈export interface ApolloServerPluginLandingPageDefaultBaseOptions {
  /**
   * By default, the landing page plugin uses the latest version of the landing
   * page published to Apollo's CDN. If you'd like to pin the current version,
   * pass the SHA served at
   * https://apollo-server-landing-page.cdn.apollographql.com/_latest/version.txt
   * here.
   */
  version?: string;
  /**
   * Set to false to suppress the footer which explains how to configure the
   * landing page.
   */
  footer?: boolean;
  /**
   * Users can configure their landing page to link to Studio Explorer with a
   * document loaded in the UI.
   */
  document?: string;
  /**
   * Users can configure their landing page to link to Studio Explorer with
   * variables loaded in the UI.
   */
  variables?: Record<string, any>;
  /**
   * Users can configure their landing page to link to Studio Explorer with
   * headers loaded in the UI.
   */
  headers?: Record<string, string>;

  includeCookies?: boolean;
  // For Apollo use only.
  __internal_apolloStudioEnv__?: 'staging' | 'prod';
}

export interface ApolloServerPluginNonEmbeddedLandingPageLocalDefaultOptions
  extends ApolloServerPluginLandingPageDefaultBaseOptions {
  /**
   * Users can configure their landing page to render an embedded Explorer if
   * given a graphRef, or an embedded Sandbox if there is not graphRef provided.
   */
  embed: false;
}

export interface ApolloServerPluginNonEmbeddedLandingPageProductionDefaultOptions
  extends ApolloServerPluginLandingPageDefaultBaseOptions {
  /**
   * If specified, provide a link (with opt-in auto-redirect) to the Studio page
   * for the given graphRef. (You need to explicitly pass this here rather than
   * relying on the server's ApolloConfig, because if your server is publicly
   * accessible you may not want to display the graph ref publicly.)
   */
  graphRef?: string;
  /**
   * Users can configure their landing page to render an embedded Explorer if
   * given a graphRef, or an embedded Sandbox if there is not graphRef provided.
   */
  embed?: false;
}

export interface ApolloServerPluginEmbeddedLandingPageLocalDefaultOptions
  extends ApolloServerPluginLandingPageDefaultBaseOptions {
  /**
   * Users can configure their landing page to render an embedded Explorer if
   * given a graphRef, or an embedded Sandbox if there is not graphRef provided.
   */
  embed?: true;
}

export interface ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions
  extends ApolloServerPluginLandingPageDefaultBaseOptions {
  /**
   * Use this registered's graphs schema to populate the embedded Explorer.
   * Required if passing `embed: true`
   */
  graphRef: string;
  /**
   * Users can configure their landing page to render an embedded Explorer.
   */
  embed: true | EmbeddableExplorerOptions;
}

type EmbeddableExplorerOptions = {
  /**
   * Display options can be configured for the embedded Explorer.
   */
  displayOptions?: {
    /**
     * If true, the embedded Explorer includes the panels for setting
     * request headers and environment variables.
     * If false, those panels are not present.
     *
     * The default value is true.
     */
    showHeadersAndEnvVars: boolean;
    /**
     * If open, the Explorer's Documentation panel (the left column) is
     * initially expanded. If closed, the panel is initially collapsed.
     *
     * The default value is open.
     */
    docsPanelState: 'open' | 'closed';
    /**
     * If dark, the Explorer's dark theme is used. If light, the light theme is used.
     *
     * The default value is dark.
     */
    theme: 'light' | 'dark';
  };
  /**
   * If true, the embedded Explorer uses localStorage to persist its state
   * (including operations, tabs, variables, and headers) between user sessions.
   * This state is automatically populated in the Explorer on page load.
   *
   * If false, the embedded Explorer loads with an example query
   * based on your schema (unless you provide document).
   *
   * The default value is false.
   */
  persistExplorerState: boolean;
};

export type ApolloServerPluginLandingPageLocalDefaultOptions =
  | ApolloServerPluginEmbeddedLandingPageLocalDefaultOptions
  | ApolloServerPluginNonEmbeddedLandingPageLocalDefaultOptions;

export type ApolloServerPluginLandingPageProductionDefaultOptions =
  | ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions
  | ApolloServerPluginNonEmbeddedLandingPageProductionDefaultOptions;

export type LandingPageConfig =
  | ApolloServerPluginLandingPageLocalDefaultOptions
  | ApolloServerPluginLandingPageProductionDefaultOptions;
Ÿ1/dist/esm/plugin/landingPage/default/types.js.mapƒç{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/types.ts"],"names":[],"mappings":""}Ÿ$/plugin/schemaReporting/package.json≈{
  "name": "@apollo/server/plugin/schemaReporting",
  "type": "module",
  "main": "../../dist/cjs/plugin/schemaReporting/index.js",
  "module": "../../dist/esm/plugin/schemaReporting/index.js",
  "types": "../../dist/esm/plugin/schemaReporting/index.d.ts",
  "sideEffects": false
}
ø/dist/cjs/express4/index.js.map≈){"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/express4/index.ts"],"names":[],"mappings":";;;AAQA,6BAAwC;AAmBxC,SAAgB,iBAAiB,CAC/B,MAA8B,EAC9B,OAA4C;IAE5C,MAAM,CAAC,aAAa,CAAC,qBAAqB,CAAC,CAAC;IAK5C,MAAM,cAAc,GAGhB,KAAK,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAErB,MAAM,OAAO,GACX,OAAO,EAAE,OAAO,IAAI,cAAc,CAAC;IAErC,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;QACxB,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;YAKb,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAChB,GAAG,CAAC,IAAI,CACN,sEAAsE;gBACpE,+DAA+D,CAClE,CAAC;YACF,OAAO;SACR;QAED,MAAM,OAAO,GAAG,IAAI,GAAG,EAAkB,CAAC;QAC1C,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YACtD,IAAI,KAAK,KAAK,SAAS,EAAE;gBAOvB,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;aACnE;SACF;QAED,MAAM,kBAAkB,GAAuB;YAC7C,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,WAAW,EAAE;YAChC,OAAO;YACP,MAAM,EAAE,IAAA,WAAQ,EAAC,GAAG,CAAC,GAAG,CAAC,CAAC,MAAM,IAAI,EAAE;YACtC,IAAI,EAAE,GAAG,CAAC,IAAI;SACf,CAAC;QAEF,MAAM;aACH,yBAAyB,CAAC;YACzB,kBAAkB;YAClB,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;SACrC,CAAC;aACD,IAAI,CAAC,KAAK,EAAE,mBAAmB,EAAE,EAAE;YAClC,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,mBAAmB,CAAC,OAAO,EAAE;gBACtD,GAAG,CAAC,SAAS,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;aAC3B;YACD,GAAG,CAAC,UAAU,GAAG,mBAAmB,CAAC,MAAM,IAAI,GAAG,CAAC;YAEnD,IAAI,mBAAmB,CAAC,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;gBAChD,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC1C,OAAO;aACR;YAED,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,mBAAmB,CAAC,IAAI,CAAC,aAAa,EAAE;gBAChE,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBAMjB,IAAI,OAAQ,GAAW,CAAC,KAAK,KAAK,UAAU,EAAE;oBAC3C,GAAW,CAAC,KAAK,EAAE,CAAC;iBACtB;aACF;YACD,GAAG,CAAC,GAAG,EAAE,CAAC;QACZ,CAAC,CAAC;aACD,KAAK,CAAC,IAAI,CAAC,CAAC;IACjB,CAAC,CAAC;AACJ,CAAC;AAlFD,8CAkFC"}Ÿ//dist/esm/plugin/schemaReporting/index.d.ts.map≈Ú{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/plugin/schemaReporting/index.ts"],"names":[],"mappings":"AAOA,OAAO,KAAK,EAAE,kBAAkB,EAAE,MAAM,8BAA8B,CAAC;AACvE,OAAO,KAAK,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAIrD,MAAM,WAAW,wCAAwC;IAavD,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAuB3B,sBAAsB,CAAC,EAAE,MAAM,CAAC;IAKhC,WAAW,CAAC,EAAE,MAAM,CAAC;IAIrB,OAAO,CAAC,EAAE,OAAO,CAAC;CACnB;AAED,wBAAgB,iCAAiC,CAC/C,EACE,iBAAiB,EACjB,sBAAsB,EACtB,WAAW,EACX,OAAO,GACR,GAAE,wCAA8D,GAChE,kBAAkB,CAkIpB"}Ÿ*/dist/esm/plugin/traceTreeBuilder.d.ts.map≈¬{"version":3,"file":"traceTreeBuilder.d.ts","sourceRoot":"","sources":["../../../src/plugin/traceTreeBuilder.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,YAAY,EAAE,kBAAkB,EAAgB,MAAM,SAAS,CAAC;AACzE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,kCAAkC,CAAC;AACjE,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,KAAK,EAAE,iBAAiB,EAAE,MAAM,kBAAkB,CAAC;AAO1D,qBAAa,gBAAgB;IAC3B,OAAO,CAAC,QAAQ,CAAoB;IACpC,OAAO,CAAC,MAAM,CAAS;IAChB,KAAK,QAUT;IACI,WAAW,CAAC,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACtC,OAAO,CAAC,OAAO,CAAS;IACxB,OAAO,CAAC,KAAK,CAEV;IACH,OAAO,CAAC,QAAQ,CAAC,cAAc,CAEtB;gBAEU,OAAO,EAAE;QAC1B,QAAQ,EAAE,MAAM,CAAC;QACjB,MAAM,EAAE,MAAM,CAAC;QACf,UAAU,CAAC,EAAE,iBAAiB,CAAC;KAChC;IAiBM,WAAW;IAWX,UAAU;IAeV,gBAAgB,CAAC,IAAI,EAAE,kBAAkB,GAAG,MAAM,IAAI;IAuBtD,kBAAkB,CAAC,MAAM,EAAE,SAAS,YAAY,EAAE;IA6BzD,OAAO,CAAC,gBAAgB;IA+BxB,OAAO,CAAC,OAAO;IAcf,OAAO,CAAC,gBAAgB;IAWxB,OAAO,CAAC,0BAA0B;CAkDnC;AAiDD,wBAAgB,oBAAoB,CAAC,IAAI,EAAE,IAAI,GAAG,MAAM,CAAC,QAAQ,CAAC,SAAS,CAO1E"}Ÿ"/src/utils/UnreachableCaseError.ts≈c/**
 * Throw this in places that should be unreachable (because all other cases have
 * been handled, reducing the type of the argument to `never`). TypeScript will
 * complain if in fact there is a valid type for the argument.
 */
export class UnreachableCaseError extends Error {
  constructor(val: never) {
    super(`Unreachable case: ${val}`);
  }
}
ŸC/dist/cjs/plugin/usageReporting/defaultSendOperationsAsTrace.js.map≈ï{"version":3,"file":"defaultSendOperationsAsTrace.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/defaultSendOperationsAsTrace.ts"],"names":[],"mappings":";;;;;;AAAA,0DAAiC;AAEjC,+DAAyD;AACzD,iEAA2D;AAE3D,SAAgB,4BAA4B;IAU1C,MAAM,KAAK,GAAG,IAAI,mBAAQ,CAAe;QAWvC,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;QACxB,eAAe,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;YAC7B,OAAO,CAAC,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,KAAY,EAAE,cAAsB,EAAW,EAAE;QACvD,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC;QAC9C,IAAI,cAAc,IAAI,IAAI,EAAE;YAC1B,MAAM,KAAK,CAAC,6CAA6C,CAAC,CAAC;SAC5D;QAED,MAAM,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QACxC,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;YAC9B,cAAc;YACd,wCAAiB,CAAC,gBAAgB,CAAC,KAAK,CAAC,UAAU,CAAC;YAEpD,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,EAAE,CAAC;YAG/B,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;SAChD,CAAC,CAAC;QAGH,IAAI,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;YACvB,OAAO,KAAK,CAAC;SACd;QAED,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC1B,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;AACJ,CAAC;AApDD,oEAoDC;AAID,SAAS,cAAc,CAAC,KAAY;IAClC,IAAI,SAAS,GAAG,KAAK,CAAC;IAEtB,SAAS,cAAc,CAAC,IAAiB;QACvC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE;YACjC,SAAS,GAAG,IAAI,CAAC;SAClB;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,IAAA,sCAAgB,EAAC,KAAK,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;IAC/C,OAAO,SAAS,CAAC;AACnB,CAAC"}ª/src/externalTypes/index.ts≈Q/**
 * This file represents the external type definitions needed by end users,
 * integration implementors, and plugin implementors. Everything from this file
 * is re-exported by the root (via * export), so add exports to this file with
 * intention (it's public API).
 */
export type { BaseContext, ContextFunction, ContextThunk } from './context.js';
export type { GraphQLRequest, GraphQLResponse } from './graphql.js';
export type {
  HTTPGraphQLRequest,
  HTTPGraphQLResponse,
  HTTPGraphQLHead,
} from './http.js';
export type {
  ApolloServerPlugin,
  GraphQLFieldResolverParams,
  GraphQLRequestExecutionListener,
  GraphQLRequestListener,
  GraphQLRequestListenerDidResolveField,
  GraphQLRequestListenerExecutionDidEnd,
  GraphQLRequestListenerParsingDidEnd,
  GraphQLRequestListenerValidationDidEnd,
  GraphQLSchemaContext,
  GraphQLServerListener,
  GraphQLServerContext,
  LandingPage,
} from './plugins.js';
export type {
  GraphQLRequestContext,
  GraphQLRequestMetrics,
  GraphQLRequestContextDidEncounterErrors,
  GraphQLRequestContextDidResolveOperation,
  GraphQLRequestContextDidResolveSource,
  GraphQLRequestContextExecutionDidStart,
  GraphQLRequestContextParsingDidStart,
  GraphQLRequestContextResponseForOperation,
  GraphQLRequestContextValidationDidStart,
  GraphQLRequestContextWillSendResponse,
} from './requestPipeline.js';
export type {
  DocumentStore,
  ApolloConfigInput,
  ApolloConfig,
  PersistedQueryOptions,
  CSRFPreventionOptions,
  ApolloServerOptions,
} from './constructor.js';

export type {
  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,
  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,
  GraphQLExperimentalFormattedIncrementalResult,
  GraphQLExperimentalFormattedIncrementalDeferResult,
  GraphQLExperimentalFormattedIncrementalStreamResult,
} from './incrementalDeliveryPolyfill.js';
∑/src/utils/HeaderMap.ts≈àexport class HeaderMap extends Map<string, string> {
  override set(key: string, value: string): this {
    return super.set(key.toLowerCase(), value);
  }

  override get(key: string) {
    return super.get(key.toLowerCase());
  }

  override delete(key: string) {
    return super.delete(key.toLowerCase());
  }

  override has(key: string) {
    return super.has(key.toLowerCase());
  }
}
Ÿ-/dist/cjs/plugin/landingPage/default/types.jsƒn"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map¥/errors/package.jsonƒ“{
  "name": "@apollo/server/errors",
  "type": "module",
  "main": "../dist/cjs/errors/index.js",
  "module": "../dist/esm/errors/index.js",
  "types": "../dist/esm/errors/index.d.ts",
  "sideEffects": false
}
Ÿ./dist/esm/incrementalDeliveryPolyfill.d.ts.map≈{"version":3,"file":"incrementalDeliveryPolyfill.d.ts","sourceRoot":"","sources":["../../src/incrementalDeliveryPolyfill.ts"],"names":[],"mappings":"AAAA,OAAO,EAAW,aAAa,EAAE,eAAe,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAOhF,UAAU,MAAM,CAAC,CAAC;IAChB,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,CAAC;CAClB;AACD,MAAM,WAAW,oDAAoD,CACnE,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,CAC7B,SAAQ,eAAe,CAAC,KAAK,EAAE,WAAW,CAAC;IAC3C,OAAO,EAAE,OAAO,CAAC;IACjB,WAAW,CAAC,EAAE,aAAa,CACzB,oCAAoC,CAAC,KAAK,EAAE,WAAW,CAAC,CACzD,CAAC;IACF,UAAU,CAAC,EAAE,WAAW,CAAC;CAC1B;AAED,MAAM,WAAW,uDAAuD,CACtE,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC;IAE7B,OAAO,EAAE,OAAO,CAAC;IACjB,WAAW,CAAC,EAAE,aAAa,CACzB,oCAAoC,CAAC,KAAK,EAAE,WAAW,CAAC,CACzD,CAAC;IACF,UAAU,CAAC,EAAE,WAAW,CAAC;CAC1B;AAED,aAAK,oCAAoC,CACvC,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,IAE3B,yCAAyC,CAAC,KAAK,EAAE,WAAW,CAAC,GAC7D,0CAA0C,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;AAEnE,UAAU,yCAAyC,CACjD,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,CAC7B,SAAQ,eAAe,CAAC,KAAK,EAAE,WAAW,CAAC;IAC3C,IAAI,CAAC,EAAE,aAAa,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACtC,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB;AAED,UAAU,0CAA0C,CAClD,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,EACtB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC;IAE7B,MAAM,CAAC,EAAE,aAAa,CAAC,YAAY,CAAC,CAAC;IACrC,KAAK,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;IACrB,IAAI,CAAC,EAAE,aAAa,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACtC,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,UAAU,CAAC,EAAE,WAAW,CAAC;CAC1B;AAED,MAAM,WAAW,8CAA8C,CAC7D,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC;IAE7B,aAAa,EAAE,oDAAoD,CACjE,KAAK,EACL,WAAW,CACZ,CAAC;IACF,iBAAiB,EAAE,cAAc,CAC/B,uDAAuD,CAAC,KAAK,EAAE,WAAW,CAAC,EAC3E,IAAI,EACJ,IAAI,CACL,CAAC;CACH;AA8BD,wBAAsB,oBAAoB,CACxC,IAAI,EAAE,aAAa,GAClB,OAAO,CAAC,eAAe,GAAG,8CAA8C,CAAC,CAM3E"}Ÿ2/dist/esm/plugin/schemaReporting/schemaReporter.js≈¶import fetch from 'node-fetch';
import { packageVersion } from '../../generated/packageVersion.js';
export const schemaReportGql = `mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
  reportSchema(report: $report, coreSchema: $coreSchema) {
    __typename
    ... on ReportSchemaError {
      message
      code
    }
    ... on ReportSchemaResponse {
      inSeconds
      withCoreSchema
    }
  }
}
`;
export class SchemaReporter {
    constructor(options) {
        this.headers = {
            'Content-Type': 'application/json',
            'x-api-key': options.apiKey,
            'apollographql-client-name': 'ApolloServerPluginSchemaReporting',
            'apollographql-client-version': packageVersion,
        };
        this.endpointUrl =
            options.endpointUrl ||
                'https://schema-reporting.api.apollographql.com/api/graphql';
        this.schemaReport = options.schemaReport;
        this.coreSchema = options.coreSchema;
        this.isStopped = false;
        this.logger = options.logger;
        this.initialReportingDelayInMs = options.initialReportingDelayInMs;
        this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
        this.fetcher = options.fetcher ?? fetch;
    }
    stopped() {
        return this.isStopped;
    }
    start() {
        this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.initialReportingDelayInMs);
    }
    stop() {
        this.isStopped = true;
        if (this.pollTimer) {
            clearTimeout(this.pollTimer);
            this.pollTimer = undefined;
        }
    }
    async sendOneReportAndScheduleNext(sendNextWithCoreSchema) {
        this.pollTimer = undefined;
        if (this.stopped())
            return;
        try {
            const result = await this.reportSchema(sendNextWithCoreSchema);
            if (!result) {
                return;
            }
            if (!this.stopped()) {
                this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(result.withCoreSchema), result.inSeconds * 1000);
            }
            return;
        }
        catch (error) {
            this.logger.error(`Error reporting server info to Apollo during schema reporting: ${error}`);
            if (!this.stopped()) {
                this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.fallbackReportingDelayInMs);
            }
        }
    }
    async reportSchema(withCoreSchema) {
        const { data, errors } = await this.apolloQuery({
            report: this.schemaReport,
            coreSchema: withCoreSchema ? this.coreSchema : null,
        });
        if (errors) {
            throw new Error(errors.map((x) => x.message).join('\n'));
        }
        function msgForUnexpectedResponse(data) {
            return [
                'Unexpected response shape from Apollo when',
                'reporting schema. If this continues, please reach',
                'out to support@apollographql.com.',
                'Received response:',
                JSON.stringify(data),
            ].join(' ');
        }
        if (!data || !data.reportSchema) {
            throw new Error(msgForUnexpectedResponse(data));
        }
        if (data.reportSchema.__typename === 'ReportSchemaResponse') {
            return data.reportSchema;
        }
        else if (data.reportSchema.__typename === 'ReportSchemaError') {
            this.logger.error([
                'Received input validation error from Apollo:',
                data.reportSchema.message,
                'Stopping reporting. Please fix the input errors.',
            ].join(' '));
            this.stop();
            return null;
        }
        throw new Error(msgForUnexpectedResponse(data));
    }
    async apolloQuery(variables) {
        const request = {
            query: schemaReportGql,
            variables,
        };
        const httpResponse = await this.fetcher(this.endpointUrl, {
            method: 'POST',
            headers: this.headers,
            body: JSON.stringify(request),
        });
        if (!httpResponse.ok) {
            throw new Error([
                `An unexpected HTTP status code (${httpResponse.status}) was`,
                'encountered during schema reporting.',
            ].join(' '));
        }
        try {
            return await httpResponse.json();
        }
        catch (error) {
            throw new Error([
                "Couldn't report schema to Apollo.",
                'Parsing response as JSON failed.',
                'If this continues please reach out to support@apollographql.com',
                error,
            ].join(' '));
        }
    }
}
//# sourceMappingURL=schemaReporter.js.mapŸ,/dist/cjs/plugin/usageReporting/index.js.mapƒ´{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/index.ts"],"names":[],"mappings":";;;AAAA,yCAA+D;AAAtD,6HAAA,gCAAgC,OAAA"}Ÿ#/dist/esm/standalone/index.d.ts.map≈È{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/standalone/index.ts"],"names":[],"mappings":";;AAAA,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,4BAA4B,CAAC;AAI/D,OAAa,EAAE,eAAe,EAAE,cAAc,EAAE,MAAM,MAAM,CAAC;AAC7D,OAAO,KAAK,EAAE,aAAa,EAAE,MAAM,KAAK,CAAC;AACzC,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,oBAAoB,CAAC;AAEvD,OAAO,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE,MAAM,2BAA2B,CAAC;AAY9E,MAAM,WAAW,uCAAuC;IACtD,GAAG,EAAE,eAAe,CAAC;IACrB,GAAG,EAAE,cAAc,CAAC;CACrB;AAED,MAAM,WAAW,4BAA4B,CAAC,QAAQ,SAAS,WAAW;IACxE,OAAO,CAAC,EAAE,eAAe,CACvB;QAAC,uCAAuC;KAAC,EACzC,QAAQ,CACT,CAAC;CACH;AAED,wBAAsB,qBAAqB,CACzC,MAAM,EAAE,YAAY,CAAC,WAAW,CAAC,EACjC,OAAO,CAAC,EAAE,4BAA4B,CAAC,WAAW,CAAC,GAAG;IACpD,MAAM,CAAC,EAAE,aAAa,CAAC;CACxB,GACA,OAAO,CAAC;IAAE,GAAG,EAAE,MAAM,CAAA;CAAE,CAAC,CAAC;AAC5B,wBAAsB,qBAAqB,CAAC,QAAQ,SAAS,WAAW,EACtE,MAAM,EAAE,YAAY,CAAC,QAAQ,CAAC,EAC9B,OAAO,EAAE,YAAY,CAAC,4BAA4B,CAAC,QAAQ,CAAC,EAAE,SAAS,CAAC,GAAG;IACzE,MAAM,CAAC,EAAE,aAAa,CAAC;CACxB,GACA,OAAO,CAAC;IAAE,GAAG,EAAE,MAAM,CAAA;CAAE,CAAC,CAAC"}Ÿ*/dist/esm/externalTypes/constructor.js.mapƒÜ{"version":3,"file":"constructor.js","sourceRoot":"","sources":["../../../src/externalTypes/constructor.ts"],"names":[],"mappings":""}Ω/dist/cjs/standalone/index.js≈©"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startStandaloneServer = void 0;
const body_parser_1 = __importDefault(require("body-parser"));
const cors_1 = __importDefault(require("cors"));
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const index_js_1 = require("../express4/index.js");
const index_js_2 = require("../plugin/drainHttpServer/index.js");
const urlForHttpServer_js_1 = require("../utils/urlForHttpServer.js");
async function startStandaloneServer(server, options) {
    const app = (0, express_1.default)();
    const httpServer = http_1.default.createServer(app);
    server.addPlugin((0, index_js_2.ApolloServerPluginDrainHttpServer)({ httpServer: httpServer }));
    await server.start();
    const context = options?.context ?? (async () => ({}));
    app.use((0, cors_1.default)(), body_parser_1.default.json(), (0, index_js_1.expressMiddleware)(server, { context }));
    const listenOptions = options?.listen ?? { port: 4000 };
    await new Promise((resolve) => {
        httpServer.listen(listenOptions, resolve);
    });
    return { url: (0, urlForHttpServer_js_1.urlForHttpServer)(httpServer) };
}
exports.startStandaloneServer = startStandaloneServer;
//# sourceMappingURL=index.js.mapŸ(/dist/cjs/utils/computeCoreSchemaHash.js≈û"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeCoreSchemaHash = void 0;
const utils_createhash_1 = require("@apollo/utils.createhash");
function computeCoreSchemaHash(schema) {
    return (0, utils_createhash_1.createHash)('sha256').update(schema).digest('hex');
}
exports.computeCoreSchemaHash = computeCoreSchemaHash;
//# sourceMappingURL=computeCoreSchemaHash.js.mapŸ-/dist/cjs/plugin/schemaReporting/index.js.map≈
«{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/schemaReporting/index.ts"],"names":[],"mappings":"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"}Ÿ6/dist/cjs/externalTypes/incrementalDeliveryPolyfill.jsƒÑ"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=incrementalDeliveryPolyfill.js.mapŸ"/dist/esm/utils/invokeHooks.js.map≈m{"version":3,"file":"invokeHooks.js","sourceRoot":"","sources":["../../../src/utils/invokeHooks.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAK3C,MAAM,CAAC,KAAK,UAAU,kBAAkB,CACtC,OAAY,EACZ,IAAyE;IAEzE,MAAM,WAAW,GAAG,CAClB,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CACzD,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IAEpB,WAAW,CAAC,OAAO,EAAE,CAAC;IAEtB,OAAO,KAAK,EAAE,GAAG,IAAkB,EAAE,EAAE;QACrC,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;SACrB;IACH,CAAC,CAAC;AACJ,CAAC;AAID,MAAM,UAAU,sBAAsB,CACpC,OAAY,EACZ,IAA+D;IAE/D,MAAM,WAAW,GAAmC,OAAO;SACxD,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAC7B,MAAM,CAAC,SAAS,CAAC,CAAC;IAErB,WAAW,CAAC,OAAO,EAAE,CAAC;IAEtB,OAAO,CAAC,GAAG,IAAkB,EAAE,EAAE;QAC/B,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;SACrB;IACH,CAAC,CAAC;AACJ,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,iCAAiC,CACrD,OAAY,EACZ,IAAgD;IAEhD,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;QAC5B,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC;QACjC,IAAI,KAAK,IAAI,IAAI,EAAE;YACjB,OAAO,KAAK,CAAC;SACd;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC"}Ω/dist/esm/errorNormalize.d.ts≈∑import { GraphQLError, GraphQLFormattedError } from 'graphql';
import type { HTTPGraphQLHead } from './externalTypes/http.js';
export declare function normalizeAndFormatErrors(errors: ReadonlyArray<unknown>, options?: {
    formatError?: (formattedError: GraphQLFormattedError, error: unknown) => GraphQLFormattedError;
    includeStacktraceInErrorResponses?: boolean;
}): {
    formattedErrors: Array<GraphQLFormattedError>;
    httpFromErrors: HTTPGraphQLHead;
};
export declare function ensureError(maybeError: unknown): Error;
export declare function ensureGraphQLError(maybeError: unknown, messagePrefixIfNotGraphQLError?: string): GraphQLError;
//# sourceMappingURL=errorNormalize.d.ts.mapø/dist/esm/runHttpQuery.d.ts.map≈X{"version":3,"file":"runHttpQuery.d.ts","sourceRoot":"","sources":["../../src/runHttpQuery.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,WAAW,EAKX,eAAe,EACf,kBAAkB,EAClB,mBAAmB,EACpB,MAAM,0BAA0B,CAAC;AAClC,OAAO,EACL,YAAY,EACZ,qBAAqB,EAIrB,iBAAiB,EAClB,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EAAE,wBAAwB,EAAQ,MAAM,SAAS,CAAC;AAkGzD,wBAAsB,YAAY,CAAC,QAAQ,SAAS,WAAW,EAAE,EAC/D,MAAM,EACN,WAAW,EACX,YAAY,EACZ,iBAAiB,EACjB,SAAS,EACT,6BAA6B,GAC9B,EAAE;IACD,MAAM,EAAE,YAAY,CAAC,QAAQ,CAAC,CAAC;IAC/B,WAAW,EAAE,kBAAkB,CAAC;IAChC,YAAY,EAAE,QAAQ,CAAC;IACvB,iBAAiB,EAAE,iBAAiB,CAAC;IACrC,SAAS,EAAE,qBAAqB,CAAC,QAAQ,CAAC,CAAC;IAC3C,6BAA6B,EAAE,eAAe,GAAG,IAAI,CAAC;CACvD,GAAG,OAAO,CAAC,mBAAmB,CAAC,CA6J/B;AAwED,wBAAgB,mBAAmB,CAAC,KAAK,EAAE,wBAAwB,UAElE;AAED,wBAAgB,kBAAkB,CAAC,MAAM,CAAC,EAAE,MAAM,GAAG,eAAe,CAKnE;AAKD,wBAAgB,oBAAoB,CAClC,MAAM,EAAE,eAAe,EACvB,MAAM,EAAE,eAAe,QAYxB"}Ÿ"/dist/cjs/externalTypes/plugins.jsƒp"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=plugins.js.mapŸ3/dist/esm/plugin/drainHttpServer/stoppable.d.ts.map≈†{"version":3,"file":"stoppable.d.ts","sourceRoot":"","sources":["../../../../src/plugin/drainHttpServer/stoppable.ts"],"names":[],"mappings":";;AA4BA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,MAAM,OAAO,CAAC;AAG1B,qBAAa,OAAO;IAIN,OAAO,CAAC,MAAM;IAH1B,OAAO,CAAC,qBAAqB,CAA6B;IAC1D,OAAO,CAAC,OAAO,CAAS;gBAEJ,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM;IA+BhD,IAAI,CAAC,qBAAqB,SAAW,GAAG,OAAO,CAAC,OAAO,CAAC;CA8C/D"}Ÿ-/dist/cjs/plugin/usageReporting/plugin.js.map≈;!{"version":3,"file":"plugin.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/plugin.ts"],"names":[],"mappings":"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"}ø/dist/esm/express4/index.js.map≈>{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/express4/index.ts"],"names":[],"mappings":"AAQA,OAAO,EAAE,KAAK,IAAI,QAAQ,EAAE,MAAM,KAAK,CAAC;AAmBxC,MAAM,UAAU,iBAAiB,CAC/B,MAA8B,EAC9B,OAA4C;IAE5C,MAAM,CAAC,aAAa,CAAC,qBAAqB,CAAC,CAAC;IAK5C,MAAM,cAAc,GAGhB,KAAK,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IAErB,MAAM,OAAO,GACX,OAAO,EAAE,OAAO,IAAI,cAAc,CAAC;IAErC,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;QACxB,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;YAKb,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAChB,GAAG,CAAC,IAAI,CACN,sEAAsE;gBACpE,+DAA+D,CAClE,CAAC;YACF,OAAO;SACR;QAED,MAAM,OAAO,GAAG,IAAI,GAAG,EAAkB,CAAC;QAC1C,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YACtD,IAAI,KAAK,KAAK,SAAS,EAAE;gBAOvB,OAAO,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;aACnE;SACF;QAED,MAAM,kBAAkB,GAAuB;YAC7C,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,WAAW,EAAE;YAChC,OAAO;YACP,MAAM,EAAE,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,MAAM,IAAI,EAAE;YACtC,IAAI,EAAE,GAAG,CAAC,IAAI;SACf,CAAC;QAEF,MAAM;aACH,yBAAyB,CAAC;YACzB,kBAAkB;YAClB,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;SACrC,CAAC;aACD,IAAI,CAAC,KAAK,EAAE,mBAAmB,EAAE,EAAE;YAClC,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,mBAAmB,CAAC,OAAO,EAAE;gBACtD,GAAG,CAAC,SAAS,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;aAC3B;YACD,GAAG,CAAC,UAAU,GAAG,mBAAmB,CAAC,MAAM,IAAI,GAAG,CAAC;YAEnD,IAAI,mBAAmB,CAAC,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;gBAChD,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC1C,OAAO;aACR;YAED,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,mBAAmB,CAAC,IAAI,CAAC,aAAa,EAAE;gBAChE,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBAMjB,IAAI,OAAQ,GAAW,CAAC,KAAK,KAAK,UAAU,EAAE;oBAC3C,GAAW,CAAC,KAAK,EAAE,CAAC;iBACtB;aACF;YACD,GAAG,CAAC,GAAG,EAAE,CAAC;QACZ,CAAC,CAAC;aACD,KAAK,CAAC,IAAI,CAAC,CAAC;IACjB,CAAC,CAAC;AACJ,CAAC"}∏/dist/cjs/preventCsrf.js≈˜"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.preventCsrf = exports.recommendedCsrfPreventionRequestHeaders = void 0;
const whatwg_mimetype_1 = __importDefault(require("whatwg-mimetype"));
const internalErrorClasses_js_1 = require("./internalErrorClasses.js");
exports.recommendedCsrfPreventionRequestHeaders = [
    'x-apollo-operation-name',
    'apollo-require-preflight',
];
const NON_PREFLIGHTED_CONTENT_TYPES = [
    'application/x-www-form-urlencoded',
    'multipart/form-data',
    'text/plain',
];
function preventCsrf(headers, csrfPreventionRequestHeaders) {
    const contentType = headers.get('content-type');
    if (contentType !== undefined) {
        const contentTypeParsed = whatwg_mimetype_1.default.parse(contentType);
        if (contentTypeParsed === null) {
            return;
        }
        if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
            return;
        }
    }
    if (csrfPreventionRequestHeaders.some((header) => {
        const value = headers.get(header);
        return value !== undefined && value.length > 0;
    })) {
        return;
    }
    throw new internalErrorClasses_js_1.BadRequestError(`This operation has been blocked as a potential Cross-Site Request Forgery ` +
        `(CSRF). Please either specify a 'content-type' header (with a type that ` +
        `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +
        `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(', ')}\n`);
}
exports.preventCsrf = preventCsrf;
//# sourceMappingURL=preventCsrf.js.mapŸ-/dist/cjs/plugin/landingPage/default/index.js≈$"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApolloServerPluginLandingPageProductionDefault = exports.ApolloServerPluginLandingPageLocalDefault = void 0;
const getEmbeddedHTML_js_1 = require("./getEmbeddedHTML.js");
function ApolloServerPluginLandingPageLocalDefault(options = {}) {
    const { version, __internal_apolloStudioEnv__, ...rest } = {
        embed: true,
        ...options,
    };
    return ApolloServerPluginLandingPageDefault(version, {
        isProd: false,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest,
    });
}
exports.ApolloServerPluginLandingPageLocalDefault = ApolloServerPluginLandingPageLocalDefault;
function ApolloServerPluginLandingPageProductionDefault(options = {}) {
    const { version, __internal_apolloStudioEnv__, ...rest } = options;
    return ApolloServerPluginLandingPageDefault(version, {
        isProd: true,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest,
    });
}
exports.ApolloServerPluginLandingPageProductionDefault = ApolloServerPluginLandingPageProductionDefault;
function encodeConfig(config) {
    return JSON.stringify(encodeURIComponent(JSON.stringify(config)));
}
const getNonEmbeddedLandingPageHTML = (version, config) => {
    const encodedConfig = encodeConfig(config);
    return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script>window.landingPage = ${encodedConfig};</script>
<script src="https://apollo-server-landing-page.cdn.apollographql.com/${version}/static/js/main.js"></script>`;
};
function ApolloServerPluginLandingPageDefault(maybeVersion, config) {
    const version = maybeVersion ?? '_latest';
    return {
        __internal_installed_implicitly__: false,
        async serverWillStart() {
            return {
                async renderLandingPage() {
                    const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body style="margin: 0; overflow-x: hidden; overflow-y: hidden">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style>
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${config.embed
                        ? 'graphRef' in config && config.graphRef
                            ? (0, getEmbeddedHTML_js_1.getEmbeddedExplorerHTML)(version, config)
                            : (0, getEmbeddedHTML_js_1.getEmbeddedSandboxHTML)(version, config)
                        : getNonEmbeddedLandingPageHTML(version, config)}
    </div>
  </body>
</html>
          `;
                    return { html };
                },
            };
        },
    };
}
//# sourceMappingURL=index.js.mapŸ(/dist/cjs/plugin/usageReporting/stats.js≈*Ä"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = void 0;
const usage_reporting_protobuf_1 = require("@apollo/usage-reporting-protobuf");
const durationHistogram_js_1 = require("./durationHistogram.js");
const iterateOverTrace_js_1 = require("./iterateOverTrace.js");
class SizeEstimator {
    constructor() {
        this.bytes = 0;
    }
}
exports.SizeEstimator = SizeEstimator;
class OurReport {
    constructor(header) {
        this.header = header;
        this.tracesPerQuery = Object.create(null);
        this.endTime = null;
        this.operationCount = 0;
        this.sizeEstimator = new SizeEstimator();
    }
    ensureCountsAreIntegers() {
        for (const tracesAndStats of Object.values(this.tracesPerQuery)) {
            tracesAndStats.ensureCountsAreIntegers();
        }
    }
    addTrace({ statsReportKey, trace, asTrace, referencedFieldsByType, maxTraceBytes = 10 * 1024 * 1024, }) {
        const tracesAndStats = this.getTracesAndStats({
            statsReportKey,
            referencedFieldsByType,
        });
        if (asTrace) {
            const encodedTrace = usage_reporting_protobuf_1.Trace.encode(trace).finish();
            if (!isNaN(maxTraceBytes) && encodedTrace.length > maxTraceBytes) {
                tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
            }
            else {
                tracesAndStats.trace.push(encodedTrace);
                this.sizeEstimator.bytes += 2 + encodedTrace.length;
            }
        }
        else {
            tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
        }
    }
    getTracesAndStats({ statsReportKey, referencedFieldsByType, }) {
        const existing = this.tracesPerQuery[statsReportKey];
        if (existing) {
            return existing;
        }
        this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);
        for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {
            this.sizeEstimator.bytes += 2 + 2;
            if (referencedFieldsForType.isInterface) {
                this.sizeEstimator.bytes += 2;
            }
            this.sizeEstimator.bytes += estimatedBytesForString(typeName);
            for (const fieldName of referencedFieldsForType.fieldNames) {
                this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
            }
        }
        return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType));
    }
}
exports.OurReport = OurReport;
class OurTracesAndStats {
    constructor(referencedFieldsByType) {
        this.referencedFieldsByType = referencedFieldsByType;
        this.trace = [];
        this.statsWithContext = new StatsByContext();
        this.internalTracesContributingToStats = [];
    }
    ensureCountsAreIntegers() {
        this.statsWithContext.ensureCountsAreIntegers();
    }
}
class StatsByContext {
    constructor() {
        this.map = Object.create(null);
    }
    toArray() {
        return Object.values(this.map);
    }
    ensureCountsAreIntegers() {
        for (const contextualizedStats of Object.values(this.map)) {
            contextualizedStats.ensureCountsAreIntegers();
        }
    }
    addTrace(trace, sizeEstimator) {
        this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);
    }
    getContextualizedStats(trace, sizeEstimator) {
        const statsContext = {
            clientName: trace.clientName,
            clientVersion: trace.clientVersion,
        };
        const statsContextKey = JSON.stringify(statsContext);
        const existing = this.map[statsContextKey];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes +=
            20 +
                estimatedBytesForString(trace.clientName) +
                estimatedBytesForString(trace.clientVersion);
        const contextualizedStats = new OurContextualizedStats(statsContext);
        this.map[statsContextKey] = contextualizedStats;
        return contextualizedStats;
    }
}
class OurContextualizedStats {
    constructor(context) {
        this.context = context;
        this.queryLatencyStats = new OurQueryLatencyStats();
        this.perTypeStat = Object.create(null);
    }
    ensureCountsAreIntegers() {
        for (const typeStat of Object.values(this.perTypeStat)) {
            typeStat.ensureCountsAreIntegers();
        }
    }
    addTrace(trace, sizeEstimator) {
        const { fieldExecutionWeight } = trace;
        if (!fieldExecutionWeight) {
            this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
        }
        this.queryLatencyStats.requestCount++;
        if (trace.fullQueryCacheHit) {
            this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);
            this.queryLatencyStats.cacheHits++;
        }
        else {
            this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);
        }
        if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {
            switch (trace.cachePolicy.scope) {
                case usage_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:
                    this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
                    break;
                case usage_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:
                    this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
                    break;
            }
        }
        if (trace.persistedQueryHit) {
            this.queryLatencyStats.persistedQueryHits++;
        }
        if (trace.persistedQueryRegister) {
            this.queryLatencyStats.persistedQueryMisses++;
        }
        if (trace.forbiddenOperation) {
            this.queryLatencyStats.forbiddenOperationCount++;
        }
        if (trace.registeredOperation) {
            this.queryLatencyStats.registeredOperationCount++;
        }
        let hasError = false;
        const traceNodeStats = (node, path) => {
            if (node.error?.length) {
                hasError = true;
                let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
                path.toArray().forEach((subPath) => {
                    currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
                });
                currPathErrorStats.requestsWithErrorsCount += 1;
                currPathErrorStats.errorsCount += node.error.length;
            }
            if (fieldExecutionWeight) {
                const fieldName = node.originalFieldName || node.responseName;
                if (node.parentType &&
                    fieldName &&
                    node.type &&
                    node.endTime != null &&
                    node.startTime != null &&
                    node.endTime >= node.startTime) {
                    const typeStat = this.getTypeStat(node.parentType, sizeEstimator);
                    const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);
                    fieldStat.errorsCount += node.error?.length ?? 0;
                    fieldStat.observedExecutionCount++;
                    fieldStat.estimatedExecutionCount += fieldExecutionWeight;
                    fieldStat.requestsWithErrorsCount +=
                        (node.error?.length ?? 0) > 0 ? 1 : 0;
                    fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);
                }
            }
            return false;
        };
        (0, iterateOverTrace_js_1.iterateOverTrace)(trace, traceNodeStats, true);
        if (hasError) {
            this.queryLatencyStats.requestsWithErrorsCount++;
        }
    }
    getTypeStat(parentType, sizeEstimator) {
        const existing = this.perTypeStat[parentType];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(parentType);
        const typeStat = new OurTypeStat();
        this.perTypeStat[parentType] = typeStat;
        return typeStat;
    }
}
exports.OurContextualizedStats = OurContextualizedStats;
class OurQueryLatencyStats {
    constructor() {
        this.latencyCount = new durationHistogram_js_1.DurationHistogram();
        this.requestCount = 0;
        this.requestsWithoutFieldInstrumentation = 0;
        this.cacheHits = 0;
        this.persistedQueryHits = 0;
        this.persistedQueryMisses = 0;
        this.cacheLatencyCount = new durationHistogram_js_1.DurationHistogram();
        this.rootErrorStats = new OurPathErrorStats();
        this.requestsWithErrorsCount = 0;
        this.publicCacheTtlCount = new durationHistogram_js_1.DurationHistogram();
        this.privateCacheTtlCount = new durationHistogram_js_1.DurationHistogram();
        this.registeredOperationCount = 0;
        this.forbiddenOperationCount = 0;
    }
}
class OurPathErrorStats {
    constructor() {
        this.children = Object.create(null);
        this.errorsCount = 0;
        this.requestsWithErrorsCount = 0;
    }
    getChild(subPath, sizeEstimator) {
        const existing = this.children[subPath];
        if (existing) {
            return existing;
        }
        const child = new OurPathErrorStats();
        this.children[subPath] = child;
        sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
        return child;
    }
}
class OurTypeStat {
    constructor() {
        this.perFieldStat = Object.create(null);
    }
    getFieldStat(fieldName, returnType, sizeEstimator) {
        const existing = this.perFieldStat[fieldName];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes +=
            estimatedBytesForString(fieldName) +
                estimatedBytesForString(returnType) +
                10;
        const fieldStat = new OurFieldStat(returnType);
        this.perFieldStat[fieldName] = fieldStat;
        return fieldStat;
    }
    ensureCountsAreIntegers() {
        for (const fieldStat of Object.values(this.perFieldStat)) {
            fieldStat.ensureCountsAreIntegers();
        }
    }
}
class OurFieldStat {
    constructor(returnType) {
        this.returnType = returnType;
        this.errorsCount = 0;
        this.observedExecutionCount = 0;
        this.estimatedExecutionCount = 0;
        this.requestsWithErrorsCount = 0;
        this.latencyCount = new durationHistogram_js_1.DurationHistogram();
    }
    ensureCountsAreIntegers() {
        this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
    }
}
function estimatedBytesForString(s) {
    return 2 + Buffer.byteLength(s);
}
//# sourceMappingURL=stats.js.mapπ/dist/esm/errors/index.js≈ import { GraphQLError } from 'graphql';
export var ApolloServerErrorCode;
(function (ApolloServerErrorCode) {
    ApolloServerErrorCode["INTERNAL_SERVER_ERROR"] = "INTERNAL_SERVER_ERROR";
    ApolloServerErrorCode["GRAPHQL_PARSE_FAILED"] = "GRAPHQL_PARSE_FAILED";
    ApolloServerErrorCode["GRAPHQL_VALIDATION_FAILED"] = "GRAPHQL_VALIDATION_FAILED";
    ApolloServerErrorCode["PERSISTED_QUERY_NOT_FOUND"] = "PERSISTED_QUERY_NOT_FOUND";
    ApolloServerErrorCode["PERSISTED_QUERY_NOT_SUPPORTED"] = "PERSISTED_QUERY_NOT_SUPPORTED";
    ApolloServerErrorCode["BAD_USER_INPUT"] = "BAD_USER_INPUT";
    ApolloServerErrorCode["OPERATION_RESOLUTION_FAILURE"] = "OPERATION_RESOLUTION_FAILURE";
    ApolloServerErrorCode["BAD_REQUEST"] = "BAD_REQUEST";
})(ApolloServerErrorCode || (ApolloServerErrorCode = {}));
export var ApolloServerValidationErrorCode;
(function (ApolloServerValidationErrorCode) {
    ApolloServerValidationErrorCode["INTROSPECTION_DISABLED"] = "INTROSPECTION_DISABLED";
})(ApolloServerValidationErrorCode || (ApolloServerValidationErrorCode = {}));
export function unwrapResolverError(error) {
    if (error instanceof GraphQLError && error.path && error.originalError) {
        return error.originalError;
    }
    return error;
}
//# sourceMappingURL=index.js.mapŸ&/dist/esm/externalTypes/context.js.mapƒ~{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../src/externalTypes/context.ts"],"names":[],"mappings":""}º/dist/esm/utils/HeaderMap.js≈hexport class HeaderMap extends Map {
    set(key, value) {
        return super.set(key.toLowerCase(), value);
    }
    get(key) {
        return super.get(key.toLowerCase());
    }
    delete(key) {
        return super.delete(key.toLowerCase());
    }
    has(key) {
        return super.has(key.toLowerCase());
    }
}
//# sourceMappingURL=HeaderMap.js.mapŸ$/dist/esm/determineApolloConfig.d.tsƒÁimport type { ApolloConfig, ApolloConfigInput } from './externalTypes/index.js';
export declare function determineApolloConfig(input: ApolloConfigInput | undefined): ApolloConfig;
//# sourceMappingURL=determineApolloConfig.d.ts.mapŸ%/src/externalTypes/requestPipeline.ts≈V// This file defines the GraphQLRequestContext type which is an argument to most
// plugin hooks, as well as a variety of variants on it which assert that
// particular sub-fields are set by a particular point in the request pipeline.

import type { WithRequired } from '@apollo/utils.withrequired';
import type { Trace } from '@apollo/usage-reporting-protobuf';
import type { BaseContext } from './context.js';
import type {
  GraphQLInProgressResponse,
  GraphQLRequest,
  GraphQLResponse,
} from './graphql.js';
import type { Logger } from '@apollo/utils.logger';
import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type {
  DocumentNode,
  GraphQLError,
  GraphQLSchema,
  OperationDefinitionNode,
} from 'graphql';
import type { CachePolicy } from '@apollo/cache-control-types';

export interface GraphQLRequestMetrics {
  // It would be more accurate to call this fieldLevelInstrumentation (it is
  // true if the hook of that name returns truthy) but for backwards
  // compatibility we keep this name (this field is read by `@apollo/gateway` to
  // decide whether or not to send the apollo-federation-include-trace header).
  captureTraces?: boolean;
  persistedQueryHit?: boolean;
  persistedQueryRegister?: boolean;
  responseCacheHit?: boolean;
  forbiddenOperation?: boolean;
  registeredOperation?: boolean;
  startHrTime?: [number, number];
  queryPlanTrace?: Trace.QueryPlanNode;
}

export interface GraphQLRequestContext<TContext extends BaseContext> {
  readonly logger: Logger;
  readonly cache: KeyValueCache<string>;

  readonly request: GraphQLRequest;
  readonly response: GraphQLInProgressResponse;

  readonly schema: GraphQLSchema;

  readonly contextValue: TContext;

  readonly queryHash?: string;

  readonly document?: DocumentNode;
  readonly source?: string;

  // `operationName` is set based on the operation AST, so it is defined even if
  // no `request.operationName` was passed in.  It will be set to `null` for an
  // anonymous operation, or if `requestName.operationName` was passed in but
  // doesn't resolve to an operation in the document.
  readonly operationName?: string | null;
  readonly operation?: OperationDefinitionNode;

  /**
   * Unformatted errors which have occurred during the request. Note that these
   * are present earlier in the request pipeline and differ from **formatted**
   * errors which are the result of running the user-configurable `formatError`
   * transformation function over specific errors; these can eventually be found
   * in `response.result.errors`.
   */
  readonly errors?: ReadonlyArray<GraphQLError>;

  readonly metrics: GraphQLRequestMetrics;

  readonly overallCachePolicy: CachePolicy;

  /**
   * True if this request is part of a potentially multi-operation batch. Note
   * that if this is true, `response.http` will be shared with the other
   * operations in the batch.
   */
  readonly requestIsBatched: boolean;
}

export type GraphQLRequestContextDidResolveSource<
  TContext extends BaseContext,
> = WithRequired<GraphQLRequestContext<TContext>, 'source' | 'queryHash'>;
export type GraphQLRequestContextParsingDidStart<TContext extends BaseContext> =
  GraphQLRequestContextDidResolveSource<TContext>;
export type GraphQLRequestContextValidationDidStart<
  TContext extends BaseContext,
> = GraphQLRequestContextParsingDidStart<TContext> &
  WithRequired<GraphQLRequestContext<TContext>, 'document'>;
export type GraphQLRequestContextDidResolveOperation<
  TContext extends BaseContext,
> = GraphQLRequestContextValidationDidStart<TContext> &
  WithRequired<GraphQLRequestContext<TContext>, 'operationName'>;
export type GraphQLRequestContextDidEncounterErrors<
  TContext extends BaseContext,
> = WithRequired<GraphQLRequestContext<TContext>, 'errors'>;
export type GraphQLRequestContextResponseForOperation<
  TContext extends BaseContext,
> = WithRequired<
  GraphQLRequestContext<TContext>,
  'source' | 'document' | 'operation' | 'operationName'
>;
export type GraphQLRequestContextExecutionDidStart<
  TContext extends BaseContext,
> = GraphQLRequestContextParsingDidStart<TContext> &
  WithRequired<
    GraphQLRequestContext<TContext>,
    'document' | 'operation' | 'operationName'
  >;
export type GraphQLRequestContextWillSendResponse<
  TContext extends BaseContext,
> = GraphQLRequestContextDidResolveSource<TContext> & {
  readonly response: GraphQLResponse;
};
export type GraphQLRequestContextDidEncounterSubsequentErrors<
  TContext extends BaseContext,
> = GraphQLRequestContextWillSendResponse<TContext>;
export type GraphQLRequestContextWillSendSubsequentPayload<
  TContext extends BaseContext,
> = GraphQLRequestContextWillSendResponse<TContext>;
Ÿ//dist/esm/plugin/landingPage/default/index.d.ts≈£import type { ApolloServerPlugin } from '../../../externalTypes/index.js';
import type { ApolloServerPluginLandingPageLocalDefaultOptions, ApolloServerPluginLandingPageProductionDefaultOptions } from './types.js';
export type { ApolloServerPluginLandingPageLocalDefaultOptions, ApolloServerPluginLandingPageProductionDefaultOptions, };
export declare function ApolloServerPluginLandingPageLocalDefault(options?: ApolloServerPluginLandingPageLocalDefaultOptions): ApolloServerPlugin;
export declare function ApolloServerPluginLandingPageProductionDefault(options?: ApolloServerPluginLandingPageProductionDefaultOptions): ApolloServerPlugin;
//# sourceMappingURL=index.d.ts.mapŸ,/dist/esm/plugin/usageReporting/options.d.ts≈	ãimport type { GraphQLError, DocumentNode } from 'graphql';
import type { GraphQLRequestContextDidResolveOperation, GraphQLRequestContext, GraphQLRequestContextWillSendResponse, BaseContext } from '../../externalTypes/index.js';
import type { Logger } from '@apollo/utils.logger';
import type { Trace } from '@apollo/usage-reporting-protobuf';
import type { Fetcher } from '@apollo/utils.fetcher';
export interface ApolloServerPluginUsageReportingOptions<TContext extends BaseContext> {
    sendTraces?: boolean;
    sendVariableValues?: VariableValueOptions;
    sendHeaders?: SendValuesBaseOptions;
    sendErrors?: SendErrorsOptions;
    fieldLevelInstrumentation?: number | ((request: GraphQLRequestContextDidResolveOperation<TContext>) => Promise<number | boolean>);
    includeRequest?: (request: GraphQLRequestContextDidResolveOperation<TContext> | GraphQLRequestContextWillSendResponse<TContext>) => Promise<boolean>;
    generateClientInfo?: GenerateClientInfo<TContext>;
    overrideReportedSchema?: string;
    sendUnexecutableOperationDocuments?: boolean;
    experimental_sendOperationAsTrace?: (trace: Trace, statsReportKey: string) => boolean;
    sendReportsImmediately?: boolean;
    fetcher?: Fetcher;
    reportIntervalMs?: number;
    maxUncompressedReportSize?: number;
    maxAttempts?: number;
    minimumRetryDelayMs?: number;
    requestTimeoutMs?: number;
    logger?: Logger;
    reportErrorFunction?: (err: Error) => void;
    endpointUrl?: string;
    debugPrintReports?: boolean;
    calculateSignature?: (ast: DocumentNode, operationName: string) => string;
}
export declare type SendValuesBaseOptions = {
    onlyNames: Array<string>;
} | {
    exceptNames: Array<string>;
} | {
    all: true;
} | {
    none: true;
};
declare type VariableValueTransformOptions = {
    variables: Record<string, any>;
    operationString?: string;
};
export declare type VariableValueOptions = {
    transform: (options: VariableValueTransformOptions) => Record<string, any>;
} | SendValuesBaseOptions;
export declare type SendErrorsOptions = {
    unmodified: true;
} | {
    masked: true;
} | {
    transform: (err: GraphQLError) => GraphQLError | null;
};
export interface ClientInfo {
    clientName?: string;
    clientVersion?: string;
}
export declare type GenerateClientInfo<TContext extends BaseContext> = (requestContext: GraphQLRequestContext<TContext>) => ClientInfo;
export {};
//# sourceMappingURL=options.d.ts.mapŸ%/src/plugin/usageReporting/options.ts≈K import type { GraphQLError, DocumentNode } from 'graphql';
import type {
  GraphQLRequestContextDidResolveOperation,
  GraphQLRequestContext,
  GraphQLRequestContextWillSendResponse,
  BaseContext,
} from '../../externalTypes/index.js';
import type { Logger } from '@apollo/utils.logger';
import type { Trace } from '@apollo/usage-reporting-protobuf';
import type { Fetcher } from '@apollo/utils.fetcher';

export interface ApolloServerPluginUsageReportingOptions<
  TContext extends BaseContext,
> {
  //#region Configure exactly which data should be sent to Apollo.
  /**
   * Apollo Server's usage reports describe each individual request in one of
   * two ways: as a "trace" (a detailed description of the specific request,
   * including a query plan and resolver tree with timings and errors, as well
   * as optional details like variable values and HTTP headers), or as part of
   * aggregated "stats" (where invocations of the same operation from the same
   * client program are aggregated together rather than described individually).
   * Apollo Server uses an heuristic to decide which operations to describe as
   * traces and which to aggregate as stats.
   *
   * By setting the `sendTraces` option to `false`, Apollo Server will describe
   * *all* operations as stats; individual requests will never be broken out
   * into separate traces. If you set `sendTraces: false`, then Apollo Studio's
   * Traces view won't show any traces (other Studio functionality will be
   * unaffected).
   *
   * Note that the values of `sendVariableValues`, `sendHeaders`, and
   *  `sendUnexecutableOperationDocuments` are irrelevant if you set
   *  `sendTraces: false`, because those options control data that is contained
   *  only in traces (not in stats).
   *
   * Setting `sendTraces: false` does *NOT* imply `fieldLevelInstrumentation:
   * 0`. Apollo Server can still take advantage of field-level instrumentation
   * (either directly for monolith servers, or via federated tracing for
   * Gateways) in order to accurately report field execution usage in "stats".
   * This option only controls whether data is sent to Apollo's servers as
   * traces, not whether traces are internally used to learn about usage.
   */
  sendTraces?: boolean;

  /**
   * By default, Apollo Server does not send the values of any GraphQL variables
   * to Apollo's servers, because variable values often contain the private data
   * of your app's users. If you'd like variable values to be included in
   * traces, set this option. This option can take several forms:
   * - { none: true }: don't send any variable values (DEFAULT)
   * - { all: true}: send all variable values
   * - { transform: ... }: a custom function for modifying variable values. The
   *    function receives `variables` and `operationString` and should return a
   *    record of `variables` with the same keys as the `variables` it receives
   *    (added variables will be ignored and removed variables will be reported
   *    with an empty value). For security reasons, if an error occurs within
   *    this function, all variable values will be replaced with
   *    `[PREDICATE_FUNCTION_ERROR]`.
   * - { exceptNames: ... }: a case-sensitive list of names of variables whose
   *   values should not be sent to Apollo servers
   * - { onlyNames: ... }: A case-sensitive list of names of variables whose
   *   values will be sent to Apollo servers
   *
   * Defaults to not sending any variable values if both this parameter and the
   * deprecated `privateVariables` are not set. The report will indicate each
   * private variable key whose value was redacted by { none: true } or {
   * exceptNames: [...] }.
   *
   * The value of this option is not relevant if you set `sendTraces: false`,
   * because variable values only appear in traces.
   */
  sendVariableValues?: VariableValueOptions;
  /**
   * By default, Apollo Server does not send the HTTP request headers and values
   * to Apollo's servers, as these headers may contain your users' private data.
   * If you'd like this information included in traces, set this option. This
   * option can take several forms:
   *
   * - { none: true } to drop all HTTP request headers (DEFAULT)
   * - { all: true } to send the values of all HTTP request headers
   * - { exceptNames: Array<String> } A case-insensitive list of names of HTTP
   *     headers whose values should not be sent to Apollo servers
   * - { onlyNames: Array<String> }: A case-insensitive list of names of HTTP
   *   headers whose values will be sent to Apollo servers
   *
   * Unlike with sendVariableValues, names of dropped headers are not reported.
   * The headers 'authorization', 'cookie', and 'set-cookie' are never reported.
   *
   * The value of this option is not relevant if you set `sendTraces: false`,
   * because request headers only appear in traces.
   */
  sendHeaders?: SendValuesBaseOptions;
  /**
   * By default, if a trace contains errors, the errors are reported to Apollo
   * servers with the message `<masked>`. The errors are associated with
   * specific paths in the operation, but do not include the original error
   * message or any extensions such as the error `code`, as those details may
   * contain your users' private data. The extension `maskedBy:
   * 'ApolloServerPluginUsageReporting'` is added.
   *
   * If you'd like details about the error included in traces, set this option.
   * This option can take several forms:
   *
   * - { masked: true }: mask error messages and omit extensions (DEFAULT)
   * - { unmodified: true }: send all error messages and extensions to Apollo
   *   servers
   * - { transform: ... }: a custom function for transforming errors. This
   *   function receives a `GraphQLError` and may return a `GraphQLError`
   *   (either a new error, or its potentially-modified argument) or `null`.
   *   This error is used in the report to Apollo servers; if `null`, the error
   *   is not included in traces or error statistics.
   *
   * If you set `sendTraces: false`, then the only relevant aspect of this
   * option is whether you return `null` from a `transform` function or not
   * (which affects aggregated error statistics).
   */
  sendErrors?: SendErrorsOptions;

  /**
   * This option allows you to choose if Apollo Server should calculate detailed
   * per-field statistics for a particular request. It is only called for
   * executable operations: operations which parse and validate properly and
   * which do not have an unknown operation name. It is not called if an
   * `includeRequest` hook is provided and returns false.
   *
   * You can either pass an async function or a number. The function receives a
   * `GraphQLRequestContext`. (The effect of passing a number is described
   * later.) Your function can return a boolean or a number; returning false is
   * equivalent to returning 0 and returning true is equivalent to returning 1.
   *
   * Returning false (or 0) means that Apollo Server will only pay attention to
   * overall properties of the operation, like what GraphQL operation is
   * executing and how long the entire operation takes to execute, and not
   * anything about field-by-field execution.
   *
   * If you return false (or 0), this operation *will* still contribute to most
   * features of Studio, such as schema checks, the Operations page, and the
   * "referencing operations" statistic on the Fields page, etc.
   *
   * If you return false (or 0), this operation will *not* contribute to the
   * "field executions" statistic on the Fields page or to the execution timing
   * hints optionally displayed in Studio Explorer or in vscode-graphql.
   * Additionally, this operation will not produce a trace that can be viewed on
   * the Traces section of the Operations page.
   *
   * Returning false (or 0) for some or all operations can improve your server's
   * performance, as the overhead of calculating complete traces is not always
   * negligible. This is especially the case if this server is an Apollo
   * Gateway, as captured traces are transmitted from the subgraph to the
   * Gateway in-band inside the actual GraphQL response.
   *
   * Returning a positive number means that Apollo Server will track each field
   * execution and send Apollo Studio statistics on how many times each field
   * was executed and what the per-field performance was. Apollo Server sends
   * both a precise observed execution count and an estimated execution count.
   * The former is calculated by counting each field execution as 1, and the
   * latter is calculated by counting each field execution as the number
   * returned from this hook, which can be thought of as a weight.
   *
   * Passing a number `x` (which should be between 0 and 1 inclusive) for
   * `fieldLevelInstrumentation` is equivalent to passing the function `async ()
   * => Math.random() < x ? 1/x : 0`.  For example, if you pass 0.01, then 99%
   * of the time this function will return 0, and 1% of the time this function
   * will return 100. So 99% of the time Apollo Server will not track field
   * executions, and 1% of the time Apollo Server will track field executions
   * and send them to Apollo Studio both as an exact observed count and as an
   * "estimated" count which is 100 times higher.  Generally, the weights you
   * return should be roughly the reciprocal of the probability that the
   * function returns non-zero; however, you're welcome to craft a more
   * sophisticated function, such as one that uses a higher probability for
   * rarer operations and a lower probability for more common operations.
   *
   * (Note that returning true here does *not* mean that the data derived from
   * field-level instrumentation must be transmitted to Apollo Studio's servers
   * in the form of a trace; it may still be aggregated locally to statistics.
   * Similarly, setting `sendTraces: false` does not affect
   * `fieldLevelInstrumentation`. But either way this operation will contribute
   * to the "field executions" statistic and timing hints.)
   *
   * The default `fieldLevelInstrumentation` is a function that always returns
   * true.
   */
  fieldLevelInstrumentation?:
    | number
    | ((
        request: GraphQLRequestContextDidResolveOperation<TContext>,
      ) => Promise<number | boolean>);

  /**
   * This option allows you to choose if a particular request should be
   * represented in the usage reporting sent to Apollo servers. By default, all
   * requests are included. If this async predicate function is specified, its
   * return value will determine whether a given request is included.
   *
   * Note that returning false here means that the operation will be completely
   * ignored by all Apollo Studio features. If you merely want to improve
   * performance by skipping the field-level execution trace, set the
   * `fieldLevelInstrumentation` option instead of this one.
   *
   * The predicate function receives the request context. If validation and
   * parsing of the request succeeds, the function will receive the request
   * context in the
   * [`GraphQLRequestContextDidResolveOperation`](https://www.apollographql.com/docs/apollo-server/integrations/plugins/#didresolveoperation)
   * phase, which permits tracing based on dynamic properties, e.g., HTTP
   * headers or the `operationName` (when available). Otherwise it will receive
   * the request context in the
   * [`GraphQLRequestContextWillSendResponse`](https://www.apollographql.com/docs/apollo-server/integrations/plugins/#willsendresponse)
   * phase:
   *
   * (If you don't want any usage reporting at all, don't use this option:
   * instead, either avoid specifying an Apollo API key, or use
   * ApolloServerPluginUsageReportingDisabled to prevent this plugin from being
   * created by default.)
   *
   * **Example:**
   *
   * ```js
   * includeRequest(requestContext) {
   *   // Always include `query HomeQuery { ... }`.
   *   if (requestContext.operationName === "HomeQuery") return true;
   *
   *   // Omit if the "report-to-apollo" header is set to "false".
   *   if (requestContext.request.http?.headers?.get("report-to-apollo") === "false") {
   *     return false;
   *   }
   *
   *   // Otherwise include.
   *   return true;
   * },
   * ```
   *
   */
  includeRequest?: (
    request:
      | GraphQLRequestContextDidResolveOperation<TContext>
      | GraphQLRequestContextWillSendResponse<TContext>,
  ) => Promise<boolean>;
  /**
   * By default, this plugin associates client information such as name
   * and version with user requests based on HTTP headers starting with
   * `apollographql-client-`. If you have another way of communicating
   * client information to your server, tell the plugin how it works
   * with this option.
   */
  generateClientInfo?: GenerateClientInfo<TContext>;
  /**
   * If you are using the `overrideReportedSchema` option to the schema
   * reporting plugin (`ApolloServerPluginSchemaReporting`), you should
   * pass the same value here as well, so that the schema ID associated
   * with requests in this plugin's usage reports matches the schema
   * ID that the other plugin reports.
   */
  overrideReportedSchema?: string;
  /**
   * Whether to include the entire document in the trace if the operation
   * was a GraphQL parse or validation error (i.e. failed the GraphQL parse or
   * validation phases). This will be included as a separate field on the trace
   * and the operation name and signature will always be reported with a constant
   * identifier. Whether the operation was a parse failure or a validation
   * failure will be embedded within the stats report key itself.
   *
   * The value of this option is not relevant if you set `sendTraces: false`,
   * because unexecutable operation documents only appear in traces.
   */
  sendUnexecutableOperationDocuments?: boolean;

  /**
   * This plugin sends information about operations to Apollo's servers in two
   * forms: as detailed operation traces of single operations and as summarized
   * statistics of many operations. Each individual operation is described in
   * exactly one of those ways. This hook lets you select which operations are
   * sent as traces and which are sent as statistics. The default is a heuristic
   * that tries to send one trace for each rough duration bucket for each
   * operation each minute, plus more if the operations have errors. (Note that
   * Apollo's servers perform their own sampling on received traces; not all
   * traces sent to Apollo's servers can be later retrieved via the trace UI.)
   *
   * If you just want to send all operations as stats, set `sendTraces: false`
   * instead of using this experimental hook.
   *
   * This option is highly experimental and may change or be removed in future
   * versions.
   */
  experimental_sendOperationAsTrace?: (
    trace: Trace,
    statsReportKey: string,
  ) => boolean;
  //#endregion

  //#region Configure the mechanics of communicating with Apollo's servers.
  /**
   * Sends a usage report after every request. This options is useful for
   * stateless environments like Amazon Lambda where processes handle only a
   * small number of requests before terminating. It defaults to true when the
   * ApolloServer was started in the background with
   * `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests`
   * (generally used with serverless frameworks), or false otherwise. (Note that
   * "immediately" does not mean synchronously with completing the response, but
   * "very soon", such as after a setImmediate call.)
   */
  sendReportsImmediately?: boolean;
  /**
   * Specifies which Fetch API implementation to use when sending usage reports.
   */
  fetcher?: Fetcher;
  /**
   * How often to send reports to Apollo. We'll also send reports when the
   * report gets big; see maxUncompressedReportSize.
   */
  reportIntervalMs?: number;
  /**
   * We send a report when the report size will become bigger than this size in
   * bytes (default: 4MB).  (This is a rough limit --- we ignore the size of the
   * report header and some other top level bytes. We just add up the lengths of
   * the serialized traces and signatures.)
   */
  maxUncompressedReportSize?: number;
  /**
   * Reporting is retried with exponential backoff up to this many times
   * (including the original request). Defaults to 5.
   */
  maxAttempts?: number;
  /**
   * Minimum back-off for retries. Defaults to 100ms.
   */
  minimumRetryDelayMs?: number;
  /**
   * Timeout for each individual attempt to send a report to Apollo. (This is
   * for each HTTP POST, not for all potential retries.) Defaults to 30 seconds
   * (30000ms).
   */
  requestTimeoutMs?: number;
  /**
   * A logger interface to be used for output and errors.  When not provided
   * it will default to the server's own `logger` implementation and use
   * `console` when that is not available.
   */
  logger?: Logger;
  /**
   * By default, if an error occurs when sending trace reports to Apollo
   * servers, its message will be sent to the `error` method on the logger
   * specified with the `logger` option to this plugin or to ApolloServer (or to
   * `console.error` by default). Specify this function to process errors in a
   * different way. (The difference between using this option and using a logger
   * is that this option receives the actual Error object whereas `logger.error`
   * only receives its message.)
   */
  reportErrorFunction?: (err: Error) => void;
  //#endregion

  //#region Internal and non-recommended options
  /**
   * The URL base that we send reports to (not including the path). This option
   * only needs to be set for testing and Apollo-internal uses.
   */
  endpointUrl?: string;
  /**
   * If set, prints all reports as JSON when they are sent. (Note that for
   * technical reasons, traces embedded in a report are printed separately when
   * they are added to a report.) Reports are sent through `logger.info`.
   */
  debugPrintReports?: boolean;
  /**
   * Specify the function for creating a signature for a query. See signature.ts
   * for details. This option is not recommended, as Apollo's servers make assumptions
   * about how the signature relates to the operation you executed.
   */
  calculateSignature?: (ast: DocumentNode, operationName: string) => string;
  //#endregion
}

export type SendValuesBaseOptions =
  | { onlyNames: Array<string> }
  | { exceptNames: Array<string> }
  | { all: true }
  | { none: true };

type VariableValueTransformOptions = {
  variables: Record<string, any>;
  operationString?: string;
};

export type VariableValueOptions =
  | {
      transform: (
        options: VariableValueTransformOptions,
      ) => Record<string, any>;
    }
  | SendValuesBaseOptions;

export type SendErrorsOptions =
  | { unmodified: true }
  | { masked: true }
  | { transform: (err: GraphQLError) => GraphQLError | null };

export interface ClientInfo {
  clientName?: string;
  clientVersion?: string;
}
export type GenerateClientInfo<TContext extends BaseContext> = (
  requestContext: GraphQLRequestContext<TContext>,
) => ClientInfo;
π/dist/esm/runHttpQuery.js≈#import { chooseContentTypeForSingleResultResponse, internalExecuteOperation, MEDIA_TYPES, } from './ApolloServer.js';
import { Kind } from 'graphql';
import { BadRequestError } from './internalErrorClasses.js';
import { URLSearchParams } from 'url';
import Negotiator from 'negotiator';
import { HeaderMap } from './utils/HeaderMap.js';
function fieldIfString(o, fieldName) {
    const value = o[fieldName];
    if (typeof value === 'string') {
        return value;
    }
    return undefined;
}
function searchParamIfSpecifiedOnce(searchParams, paramName) {
    const values = searchParams.getAll(paramName);
    switch (values.length) {
        case 0:
            return undefined;
        case 1:
            return values[0];
        default:
            throw new BadRequestError(`The '${paramName}' search parameter may only be specified once.`);
    }
}
function jsonParsedSearchParamIfSpecifiedOnce(searchParams, fieldName) {
    const value = searchParamIfSpecifiedOnce(searchParams, fieldName);
    if (value === undefined) {
        return undefined;
    }
    let hopefullyRecord;
    try {
        hopefullyRecord = JSON.parse(value);
    }
    catch {
        throw new BadRequestError(`The ${fieldName} search parameter contains invalid JSON.`);
    }
    if (!isStringRecord(hopefullyRecord)) {
        throw new BadRequestError(`The ${fieldName} search parameter should contain a JSON-encoded object.`);
    }
    return hopefullyRecord;
}
function fieldIfRecord(o, fieldName) {
    const value = o[fieldName];
    if (isStringRecord(value)) {
        return value;
    }
    return undefined;
}
function isStringRecord(o) {
    return (!!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o));
}
function isNonEmptyStringRecord(o) {
    return isStringRecord(o) && Object.keys(o).length > 0;
}
function ensureQueryIsStringOrMissing(query) {
    if (!query || typeof query === 'string') {
        return;
    }
    if (query.kind === Kind.DOCUMENT) {
        throw new BadRequestError("GraphQL queries must be strings. It looks like you're sending the " +
            'internal graphql-js representation of a parsed query in your ' +
            'request instead of a request in the GraphQL query language. You ' +
            'can convert an AST to a string using the `print` function from ' +
            '`graphql`, or use a client like `apollo-client` which converts ' +
            'the internal representation to a string for you.');
    }
    else {
        throw new BadRequestError('GraphQL queries must be strings.');
    }
}
export async function runHttpQuery({ server, httpRequest, contextValue, schemaDerivedData, internals, sharedResponseHTTPGraphQLHead, }) {
    let graphQLRequest;
    switch (httpRequest.method) {
        case 'POST': {
            if (!isNonEmptyStringRecord(httpRequest.body)) {
                throw new BadRequestError('POST body missing, invalid Content-Type, or JSON object has no keys.');
            }
            ensureQueryIsStringOrMissing(httpRequest.body.query);
            if (typeof httpRequest.body.variables === 'string') {
                throw new BadRequestError('`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.');
            }
            if (typeof httpRequest.body.extensions === 'string') {
                throw new BadRequestError('`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.');
            }
            graphQLRequest = {
                query: fieldIfString(httpRequest.body, 'query'),
                operationName: fieldIfString(httpRequest.body, 'operationName'),
                variables: fieldIfRecord(httpRequest.body, 'variables'),
                extensions: fieldIfRecord(httpRequest.body, 'extensions'),
                http: httpRequest,
            };
            break;
        }
        case 'GET': {
            const searchParams = new URLSearchParams(httpRequest.search);
            graphQLRequest = {
                query: searchParamIfSpecifiedOnce(searchParams, 'query'),
                operationName: searchParamIfSpecifiedOnce(searchParams, 'operationName'),
                variables: jsonParsedSearchParamIfSpecifiedOnce(searchParams, 'variables'),
                extensions: jsonParsedSearchParamIfSpecifiedOnce(searchParams, 'extensions'),
                http: httpRequest,
            };
            break;
        }
        default:
            throw new BadRequestError('Apollo Server supports only GET/POST requests.', {
                extensions: {
                    http: {
                        status: 405,
                        headers: new HeaderMap([['allow', 'GET, POST']]),
                    },
                },
            });
    }
    const graphQLResponse = await internalExecuteOperation({
        server,
        graphQLRequest,
        internals,
        schemaDerivedData,
        sharedResponseHTTPGraphQLHead,
    }, { contextValue });
    if (graphQLResponse.body.kind === 'single') {
        if (!graphQLResponse.http.headers.get('content-type')) {
            const contentType = chooseContentTypeForSingleResultResponse(httpRequest);
            if (contentType === null) {
                throw new BadRequestError(`An 'accept' header was provided for this request which does not accept ` +
                    `${MEDIA_TYPES.APPLICATION_JSON} or ${MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON}`, { extensions: { http: { status: 406 } } });
            }
            graphQLResponse.http.headers.set('content-type', contentType);
        }
        return {
            ...graphQLResponse.http,
            body: {
                kind: 'complete',
                string: prettyJSONStringify(orderExecutionResultFields(graphQLResponse.body.singleResult)),
            },
        };
    }
    const acceptHeader = httpRequest.headers.get('accept');
    if (!(acceptHeader &&
        new Negotiator({
            headers: { accept: httpRequest.headers.get('accept') },
        }).mediaType([
            MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,
            MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,
        ]) === MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL)) {
        throw new BadRequestError('Apollo server received an operation that uses incremental delivery ' +
            '(@defer or @stream), but the client does not accept multipart/mixed ' +
            'HTTP responses. To enable incremental delivery support, add the HTTP ' +
            "header 'Accept: multipart/mixed; deferSpec=20220824'.", { extensions: { http: { status: 406 } } });
    }
    graphQLResponse.http.headers.set('content-type', 'multipart/mixed; boundary="-"; deferSpec=20220824');
    return {
        ...graphQLResponse.http,
        body: {
            kind: 'chunked',
            asyncIterator: writeMultipartBody(graphQLResponse.body.initialResult, graphQLResponse.body.subsequentResults),
        },
    };
}
async function* writeMultipartBody(initialResult, subsequentResults) {
    yield `\r\n---\r\ncontent-type: application/json; charset=utf-8\r\n\r\n${JSON.stringify(orderInitialIncrementalExecutionResultFields(initialResult))}\r\n---${initialResult.hasNext ? '' : '--'}\r\n`;
    for await (const result of subsequentResults) {
        yield `content-type: application/json; charset=utf-8\r\n\r\n${JSON.stringify(orderSubsequentIncrementalExecutionResultFields(result))}\r\n---${result.hasNext ? '' : '--'}\r\n`;
    }
}
function orderExecutionResultFields(result) {
    return {
        errors: result.errors,
        data: result.data,
        extensions: result.extensions,
    };
}
function orderInitialIncrementalExecutionResultFields(result) {
    return {
        hasNext: result.hasNext,
        errors: result.errors,
        data: result.data,
        incremental: orderIncrementalResultFields(result.incremental),
        extensions: result.extensions,
    };
}
function orderSubsequentIncrementalExecutionResultFields(result) {
    return {
        hasNext: result.hasNext,
        incremental: orderIncrementalResultFields(result.incremental),
        extensions: result.extensions,
    };
}
function orderIncrementalResultFields(incremental) {
    return incremental?.map((i) => ({
        hasNext: i.hasNext,
        errors: i.errors,
        path: i.path,
        label: i.label,
        data: i.data,
        items: i.items,
        extensions: i.extensions,
    }));
}
export function prettyJSONStringify(value) {
    return JSON.stringify(value) + '\n';
}
export function newHTTPGraphQLHead(status) {
    return {
        status,
        headers: new HeaderMap(),
    };
}
export function mergeHTTPGraphQLHead(target, source) {
    if (source.status) {
        target.status = source.status;
    }
    if (source.headers) {
        for (const [name, value] of source.headers) {
            target.headers.set(name, value);
        }
    }
}
//# sourceMappingURL=runHttpQuery.js.mapπ/dist/cjs/runHttpQuery.js≈&»"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeHTTPGraphQLHead = exports.newHTTPGraphQLHead = exports.prettyJSONStringify = exports.runHttpQuery = void 0;
const ApolloServer_js_1 = require("./ApolloServer.js");
const graphql_1 = require("graphql");
const internalErrorClasses_js_1 = require("./internalErrorClasses.js");
const url_1 = require("url");
const negotiator_1 = __importDefault(require("negotiator"));
const HeaderMap_js_1 = require("./utils/HeaderMap.js");
function fieldIfString(o, fieldName) {
    const value = o[fieldName];
    if (typeof value === 'string') {
        return value;
    }
    return undefined;
}
function searchParamIfSpecifiedOnce(searchParams, paramName) {
    const values = searchParams.getAll(paramName);
    switch (values.length) {
        case 0:
            return undefined;
        case 1:
            return values[0];
        default:
            throw new internalErrorClasses_js_1.BadRequestError(`The '${paramName}' search parameter may only be specified once.`);
    }
}
function jsonParsedSearchParamIfSpecifiedOnce(searchParams, fieldName) {
    const value = searchParamIfSpecifiedOnce(searchParams, fieldName);
    if (value === undefined) {
        return undefined;
    }
    let hopefullyRecord;
    try {
        hopefullyRecord = JSON.parse(value);
    }
    catch {
        throw new internalErrorClasses_js_1.BadRequestError(`The ${fieldName} search parameter contains invalid JSON.`);
    }
    if (!isStringRecord(hopefullyRecord)) {
        throw new internalErrorClasses_js_1.BadRequestError(`The ${fieldName} search parameter should contain a JSON-encoded object.`);
    }
    return hopefullyRecord;
}
function fieldIfRecord(o, fieldName) {
    const value = o[fieldName];
    if (isStringRecord(value)) {
        return value;
    }
    return undefined;
}
function isStringRecord(o) {
    return (!!o && typeof o === 'object' && !Buffer.isBuffer(o) && !Array.isArray(o));
}
function isNonEmptyStringRecord(o) {
    return isStringRecord(o) && Object.keys(o).length > 0;
}
function ensureQueryIsStringOrMissing(query) {
    if (!query || typeof query === 'string') {
        return;
    }
    if (query.kind === graphql_1.Kind.DOCUMENT) {
        throw new internalErrorClasses_js_1.BadRequestError("GraphQL queries must be strings. It looks like you're sending the " +
            'internal graphql-js representation of a parsed query in your ' +
            'request instead of a request in the GraphQL query language. You ' +
            'can convert an AST to a string using the `print` function from ' +
            '`graphql`, or use a client like `apollo-client` which converts ' +
            'the internal representation to a string for you.');
    }
    else {
        throw new internalErrorClasses_js_1.BadRequestError('GraphQL queries must be strings.');
    }
}
async function runHttpQuery({ server, httpRequest, contextValue, schemaDerivedData, internals, sharedResponseHTTPGraphQLHead, }) {
    let graphQLRequest;
    switch (httpRequest.method) {
        case 'POST': {
            if (!isNonEmptyStringRecord(httpRequest.body)) {
                throw new internalErrorClasses_js_1.BadRequestError('POST body missing, invalid Content-Type, or JSON object has no keys.');
            }
            ensureQueryIsStringOrMissing(httpRequest.body.query);
            if (typeof httpRequest.body.variables === 'string') {
                throw new internalErrorClasses_js_1.BadRequestError('`variables` in a POST body should be provided as an object, not a recursively JSON-encoded string.');
            }
            if (typeof httpRequest.body.extensions === 'string') {
                throw new internalErrorClasses_js_1.BadRequestError('`extensions` in a POST body should be provided as an object, not a recursively JSON-encoded string.');
            }
            graphQLRequest = {
                query: fieldIfString(httpRequest.body, 'query'),
                operationName: fieldIfString(httpRequest.body, 'operationName'),
                variables: fieldIfRecord(httpRequest.body, 'variables'),
                extensions: fieldIfRecord(httpRequest.body, 'extensions'),
                http: httpRequest,
            };
            break;
        }
        case 'GET': {
            const searchParams = new url_1.URLSearchParams(httpRequest.search);
            graphQLRequest = {
                query: searchParamIfSpecifiedOnce(searchParams, 'query'),
                operationName: searchParamIfSpecifiedOnce(searchParams, 'operationName'),
                variables: jsonParsedSearchParamIfSpecifiedOnce(searchParams, 'variables'),
                extensions: jsonParsedSearchParamIfSpecifiedOnce(searchParams, 'extensions'),
                http: httpRequest,
            };
            break;
        }
        default:
            throw new internalErrorClasses_js_1.BadRequestError('Apollo Server supports only GET/POST requests.', {
                extensions: {
                    http: {
                        status: 405,
                        headers: new HeaderMap_js_1.HeaderMap([['allow', 'GET, POST']]),
                    },
                },
            });
    }
    const graphQLResponse = await (0, ApolloServer_js_1.internalExecuteOperation)({
        server,
        graphQLRequest,
        internals,
        schemaDerivedData,
        sharedResponseHTTPGraphQLHead,
    }, { contextValue });
    if (graphQLResponse.body.kind === 'single') {
        if (!graphQLResponse.http.headers.get('content-type')) {
            const contentType = (0, ApolloServer_js_1.chooseContentTypeForSingleResultResponse)(httpRequest);
            if (contentType === null) {
                throw new internalErrorClasses_js_1.BadRequestError(`An 'accept' header was provided for this request which does not accept ` +
                    `${ApolloServer_js_1.MEDIA_TYPES.APPLICATION_JSON} or ${ApolloServer_js_1.MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON}`, { extensions: { http: { status: 406 } } });
            }
            graphQLResponse.http.headers.set('content-type', contentType);
        }
        return {
            ...graphQLResponse.http,
            body: {
                kind: 'complete',
                string: prettyJSONStringify(orderExecutionResultFields(graphQLResponse.body.singleResult)),
            },
        };
    }
    const acceptHeader = httpRequest.headers.get('accept');
    if (!(acceptHeader &&
        new negotiator_1.default({
            headers: { accept: httpRequest.headers.get('accept') },
        }).mediaType([
            ApolloServer_js_1.MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,
            ApolloServer_js_1.MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,
        ]) === ApolloServer_js_1.MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL)) {
        throw new internalErrorClasses_js_1.BadRequestError('Apollo server received an operation that uses incremental delivery ' +
            '(@defer or @stream), but the client does not accept multipart/mixed ' +
            'HTTP responses. To enable incremental delivery support, add the HTTP ' +
            "header 'Accept: multipart/mixed; deferSpec=20220824'.", { extensions: { http: { status: 406 } } });
    }
    graphQLResponse.http.headers.set('content-type', 'multipart/mixed; boundary="-"; deferSpec=20220824');
    return {
        ...graphQLResponse.http,
        body: {
            kind: 'chunked',
            asyncIterator: writeMultipartBody(graphQLResponse.body.initialResult, graphQLResponse.body.subsequentResults),
        },
    };
}
exports.runHttpQuery = runHttpQuery;
async function* writeMultipartBody(initialResult, subsequentResults) {
    yield `\r\n---\r\ncontent-type: application/json; charset=utf-8\r\n\r\n${JSON.stringify(orderInitialIncrementalExecutionResultFields(initialResult))}\r\n---${initialResult.hasNext ? '' : '--'}\r\n`;
    for await (const result of subsequentResults) {
        yield `content-type: application/json; charset=utf-8\r\n\r\n${JSON.stringify(orderSubsequentIncrementalExecutionResultFields(result))}\r\n---${result.hasNext ? '' : '--'}\r\n`;
    }
}
function orderExecutionResultFields(result) {
    return {
        errors: result.errors,
        data: result.data,
        extensions: result.extensions,
    };
}
function orderInitialIncrementalExecutionResultFields(result) {
    return {
        hasNext: result.hasNext,
        errors: result.errors,
        data: result.data,
        incremental: orderIncrementalResultFields(result.incremental),
        extensions: result.extensions,
    };
}
function orderSubsequentIncrementalExecutionResultFields(result) {
    return {
        hasNext: result.hasNext,
        incremental: orderIncrementalResultFields(result.incremental),
        extensions: result.extensions,
    };
}
function orderIncrementalResultFields(incremental) {
    return incremental?.map((i) => ({
        hasNext: i.hasNext,
        errors: i.errors,
        path: i.path,
        label: i.label,
        data: i.data,
        items: i.items,
        extensions: i.extensions,
    }));
}
function prettyJSONStringify(value) {
    return JSON.stringify(value) + '\n';
}
exports.prettyJSONStringify = prettyJSONStringify;
function newHTTPGraphQLHead(status) {
    return {
        status,
        headers: new HeaderMap_js_1.HeaderMap(),
    };
}
exports.newHTTPGraphQLHead = newHTTPGraphQLHead;
function mergeHTTPGraphQLHead(target, source) {
    if (source.status) {
        target.status = source.status;
    }
    if (source.headers) {
        for (const [name, value] of source.headers) {
            target.headers.set(name, value);
        }
    }
}
exports.mergeHTTPGraphQLHead = mergeHTTPGraphQLHead;
//# sourceMappingURL=runHttpQuery.js.mapŸ1/dist/cjs/plugin/landingPage/default/types.js.mapƒç{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/types.ts"],"names":[],"mappings":""}Ÿ#/dist/esm/utils/urlForHttpServer.js≈mimport { format } from 'url';
export function urlForHttpServer(httpServer) {
    const { address, port } = httpServer.address();
    const hostname = address === '' || address === '::' ? 'localhost' : address;
    return format({
        protocol: 'http',
        hostname,
        port,
        pathname: '/',
    });
}
//# sourceMappingURL=urlForHttpServer.js.mapŸ,/dist/esm/plugin/usageReporting/index.js.mapƒÆ{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gCAAgC,EAAE,MAAM,aAAa,CAAC"}Ÿ6/dist/cjs/plugin/schemaReporting/schemaReporter.js.map≈ﬂ{"version":3,"file":"schemaReporter.js","sourceRoot":"","sources":["../../../../src/plugin/schemaReporting/schemaReporter.ts"],"names":[],"mappings":"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"}Ÿ /plugin/inlineTrace/package.json≈{
  "name": "@apollo/server/plugin/inlineTrace",
  "type": "module",
  "main": "../../dist/cjs/plugin/inlineTrace/index.js",
  "module": "../../dist/esm/plugin/inlineTrace/index.js",
  "types": "../../dist/esm/plugin/inlineTrace/index.d.ts",
  "sideEffects": false
}
Ÿ=/dist/esm/plugin/landingPage/default/getEmbeddedHTML.d.ts.map≈S{"version":3,"file":"getEmbeddedHTML.d.ts","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/getEmbeddedHTML.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,6DAA6D,EAC7D,iBAAiB,EAClB,MAAM,SAAS,CAAC;AAmBjB,eAAO,MAAM,uBAAuB,YACzB,MAAM,UACP,6DAA6D,WAmEtE,CAAC;AAEF,eAAO,MAAM,sBAAsB,YACxB,MAAM,UACP,iBAAiB,WA+B1B,CAAC"}Ÿ&/dist/esm/externalTypes/plugins.js.mapƒ~{"version":3,"file":"plugins.js","sourceRoot":"","sources":["../../../src/externalTypes/plugins.ts"],"names":[],"mappings":""}Ÿ!/plugin/cacheControl/package.json≈{
  "name": "@apollo/server/plugin/cacheControl",
  "type": "module",
  "main": "../../dist/cjs/plugin/cacheControl/index.js",
  "module": "../../dist/esm/plugin/cacheControl/index.js",
  "types": "../../dist/esm/plugin/cacheControl/index.d.ts",
  "sideEffects": false
}
Ÿ'/dist/esm/plugin/schemaIsFederated.d.tsƒ£import { GraphQLSchema } from 'graphql';
export declare function schemaIsFederated(schema: GraphQLSchema): boolean;
//# sourceMappingURL=schemaIsFederated.d.ts.map∏/standalone/package.jsonƒ·{
  "name": "@apollo/server/standalone",
  "type": "module",
  "main": "../dist/cjs/standalone/index.js",
  "module": "../dist/esm/standalone/index.js",
  "types": "../dist/esm/standalone/index.d.ts",
  "sideEffects": false
}ø/dist/cjs/errorNormalize.js.map≈Û{"version":3,"file":"errorNormalize.js","sourceRoot":"","sources":["../../src/errorNormalize.ts"],"names":[],"mappings":";;;AAEA,qCAIiB;AACjB,gDAA0D;AAE1D,uDAA6E;AAC7E,uDAAiD;AAUjD,SAAgB,wBAAwB,CACtC,MAA8B,EAC9B,UAMI,EAAE;IAKN,MAAM,WAAW,GAAG,OAAO,CAAC,WAAW,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC;IAC9D,MAAM,cAAc,GAAG,IAAA,oCAAkB,GAAE,CAAC;IAE5C,OAAO;QACL,cAAc;QACd,eAAe,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;YACpC,IAAI;gBACF,OAAO,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,CAAC;aAC/C;YAAC,OAAO,eAAe,EAAE;gBACxB,IAAI,OAAO,CAAC,iCAAiC,EAAE;oBAG7C,OAAO,WAAW,CAAC,eAAe,CAAC,CAAC;iBACrC;qBAAM;oBAEL,OAAO;wBACL,OAAO,EAAE,uBAAuB;wBAChC,UAAU,EAAE,EAAE,IAAI,EAAE,gCAAqB,CAAC,qBAAqB,EAAE;qBAClE,CAAC;iBACH;aACF;QACH,CAAC,CAAC;KACH,CAAC;IAEF,SAAS,WAAW,CAAC,UAAmB;QACtC,MAAM,YAAY,GAAG,kBAAkB,CAAC,UAAU,CAAC,CAAC;QAEpD,MAAM,UAAU,GAA2B;YACzC,GAAG,YAAY,CAAC,UAAU;YAC1B,IAAI,EACF,YAAY,CAAC,UAAU,CAAC,IAAI;gBAC5B,gCAAqB,CAAC,qBAAqB;SAC9C,CAAC;QAEF,IAAI,wBAAwB,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;YAC7C,IAAA,sCAAoB,EAAC,cAAc,EAAE;gBACnC,OAAO,EAAE,IAAI,wBAAS,EAAE;gBACxB,GAAG,UAAU,CAAC,IAAI;aACnB,CAAC,CAAC;YACH,OAAO,UAAU,CAAC,IAAI,CAAC;SACxB;QAED,IAAI,OAAO,CAAC,iCAAiC,EAAE;YAK7C,UAAU,CAAC,UAAU,GAAG,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;SACzD;QAED,OAAO,EAAE,GAAG,YAAY,CAAC,MAAM,EAAE,EAAE,UAAU,EAAE,CAAC;IAClD,CAAC;AACH,CAAC;AAjED,4DAiEC;AAED,SAAgB,WAAW,CAAC,UAAmB;IAC7C,OAAO,UAAU,YAAY,KAAK;QAChC,CAAC,CAAC,UAAU;QACZ,CAAC,CAAC,IAAI,sBAAY,CAAC,0BAA0B,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;AACxE,CAAC;AAJD,kCAIC;AAED,SAAgB,kBAAkB,CAChC,UAAmB,EACnB,iCAAyC,EAAE;IAE3C,MAAM,KAAK,GAAU,WAAW,CAAC,UAAU,CAAC,CAAC;IAE7C,OAAO,KAAK,YAAY,sBAAY;QAClC,CAAC,CAAC,KAAK;QACP,CAAC,CAAC,IAAI,sBAAY,CAAC,8BAA8B,GAAG,KAAK,CAAC,OAAO,EAAE;YAC/D,aAAa,EAAE,KAAK;SACrB,CAAC,CAAC;AACT,CAAC;AAXD,gDAWC;AAED,SAAS,wBAAwB,CAAC,CAAU;IAC1C,OAAO,CACL,CAAC,CAAC,CAAC;QACH,OAAO,CAAC,KAAK,QAAQ;QACrB,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,CAAC,IAAI,OAAQ,CAAS,CAAC,MAAM,KAAK,QAAQ,CAAC;QAC3D,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,IAAK,CAAS,CAAC,OAAO,YAAY,GAAG,CAAC,CACzD,CAAC;AACJ,CAAC"}Ÿ#/src/plugin/usageReporting/index.tsƒ˙export { ApolloServerPluginUsageReporting } from './plugin.js';
export type {
  ApolloServerPluginUsageReportingOptions,
  SendValuesBaseOptions,
  VariableValueOptions,
  SendErrorsOptions,
  ClientInfo,
  GenerateClientInfo,
} from './options.js';
Ÿ,/dist/cjs/incrementalDeliveryPolyfill.js.map≈é{"version":3,"file":"incrementalDeliveryPolyfill.js","sourceRoot":"","sources":["../../src/incrementalDeliveryPolyfill.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qCAAgF;AA+EhF,IAAI,uCAAuC,GAO3B,SAAS,CAAC;AAE1B,KAAK,UAAU,kBAAkB;IAC/B,IAAI,uCAAuC,KAAK,SAAS,EAAE;QACzD,OAAO;KACR;IACD,MAAM,OAAO,GAAG,wDAAa,SAAS,GAAC,CAAC;IACxC,IAAI,kCAAkC,IAAI,OAAO,EAAE;QACjD,uCAAuC,GAAI,OAAe;aACvD,gCAAgC,CAAC;KACrC;SAAM;QACL,uCAAuC,GAAG,IAAI,CAAC;KAChD;AACH,CAAC;AAEM,KAAK,UAAU,oBAAoB,CACxC,IAAmB;IAEnB,MAAM,kBAAkB,EAAE,CAAC;IAC3B,IAAI,uCAAuC,EAAE;QAC3C,OAAO,uCAAuC,CAAC,IAAI,CAAC,CAAC;KACtD;IACD,OAAO,IAAA,iBAAO,EAAC,IAAI,CAAC,CAAC;AACvB,CAAC;AARD,oDAQC"}Ÿ&/dist/esm/determineApolloConfig.js.map≈–{"version":3,"file":"determineApolloConfig.js","sourceRoot":"","sources":["../../src/determineApolloConfig.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;AAKtD,MAAM,UAAU,qBAAqB,CACnC,KAAoC;IAEpC,MAAM,YAAY,GAAiB,EAAE,CAAC;IAEtC,MAAM,EACJ,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf,oBAAoB,GACrB,GAAG,OAAO,CAAC,GAAG,CAAC;IAGhB,IAAI,KAAK,EAAE,GAAG,EAAE;QACd,YAAY,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC;KAC9B;SAAM,IAAI,UAAU,EAAE;QACrB,YAAY,CAAC,GAAG,GAAG,UAAU,CAAC;KAC/B;IAGD,IAAI,YAAY,CAAC,GAAG,EAAE;QACpB,YAAY,CAAC,OAAO,GAAG,UAAU,CAAC,QAAQ,CAAC;aACxC,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC;aACxB,MAAM,CAAC,KAAK,CAAC,CAAC;KAClB;IAGD,IAAI,KAAK,EAAE,QAAQ,EAAE;QACnB,YAAY,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;KACxC;SAAM,IAAI,gBAAgB,EAAE;QAC3B,YAAY,CAAC,QAAQ,GAAG,gBAAgB,CAAC;KAC1C;IAGD,MAAM,OAAO,GAAG,KAAK,EAAE,OAAO,IAAI,eAAe,CAAC;IAClD,MAAM,YAAY,GAAG,KAAK,EAAE,YAAY,IAAI,oBAAoB,CAAC;IAEjE,IAAI,YAAY,CAAC,QAAQ,EAAE;QACzB,IAAI,OAAO,EAAE;YACX,MAAM,IAAI,KAAK,CACb,yDAAyD;gBACvD,4EAA4E,CAC/E,CAAC;SACH;QACD,IAAI,YAAY,EAAE;YAChB,MAAM,IAAI,KAAK,CACb,8DAA8D;gBAC5D,iFAAiF,CACpF,CAAC;SACH;KACF;SAAM,IAAI,OAAO,EAAE;QAKlB,YAAY,CAAC,QAAQ,GAAG,YAAY;YAClC,CAAC,CAAC,GAAG,OAAO,IAAI,YAAY,EAAE;YAC9B,CAAC,CAAC,OAAO,CAAC;KACb;IAED,OAAO,YAAY,CAAC;AACtB,CAAC"}º/dist/esm/cachePolicy.js.map≈≈{"version":3,"file":"cachePolicy.js","sourceRoot":"","sources":["../../src/cachePolicy.ts"],"names":[],"mappings":"AAEA,MAAM,UAAU,cAAc;IAC5B,OAAO;QACL,MAAM,EAAE,SAAS;QACjB,KAAK,EAAE,SAAS;QAChB,QAAQ,CAAC,IAAe;YACtB,IACE,IAAI,CAAC,MAAM,KAAK,SAAS;gBACzB,CAAC,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,EACxD;gBACA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;aAC3B;YACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;gBACxD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;aACzB;QACH,CAAC;QACD,OAAO,CAAC,IAAe;YACrB,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE;gBAC7B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;aAC3B;YACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;gBAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;aACzB;QACH,CAAC;QACD,iBAAiB;YACf,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBAClD,OAAO,IAAI,CAAC;aACb;YACD,OAAO,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,QAAQ,EAAE,CAAC;QAChE,CAAC;KACF,CAAC;AACJ,CAAC"}Ÿ#/src/incrementalDeliveryPolyfill.ts≈Íimport { execute, ExecutionArgs, ExecutionResult, GraphQLError } from 'graphql';

// This file "polyfills" graphql@17's experimentalExecuteIncrementally (by
// returning a function that does not understand incremental directives if
// you're using graphql@16). The types defined in this file are largely copied
// from graphql-js.

interface ObjMap<T> {
  [key: string]: T;
}
export interface GraphQLExperimentalInitialIncrementalExecutionResult<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> extends ExecutionResult<TData, TExtensions> {
  hasNext: boolean;
  incremental?: ReadonlyArray<
    GraphQLExperimentalIncrementalResult<TData, TExtensions>
  >;
  extensions?: TExtensions;
}

export interface GraphQLExperimentalSubsequentIncrementalExecutionResult<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> {
  hasNext: boolean;
  incremental?: ReadonlyArray<
    GraphQLExperimentalIncrementalResult<TData, TExtensions>
  >;
  extensions?: TExtensions;
}

type GraphQLExperimentalIncrementalResult<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> =
  | GraphQLExperimentalIncrementalDeferResult<TData, TExtensions>
  | GraphQLExperimentalIncrementalStreamResult<TData, TExtensions>;

interface GraphQLExperimentalIncrementalDeferResult<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> extends ExecutionResult<TData, TExtensions> {
  path?: ReadonlyArray<string | number>;
  label?: string;
}

interface GraphQLExperimentalIncrementalStreamResult<
  TData = Array<unknown>,
  TExtensions = ObjMap<unknown>,
> {
  errors?: ReadonlyArray<GraphQLError>;
  items?: TData | null;
  path?: ReadonlyArray<string | number>;
  label?: string;
  extensions?: TExtensions;
}

export interface GraphQLExperimentalIncrementalExecutionResults<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> {
  initialResult: GraphQLExperimentalInitialIncrementalExecutionResult<
    TData,
    TExtensions
  >;
  subsequentResults: AsyncGenerator<
    GraphQLExperimentalSubsequentIncrementalExecutionResult<TData, TExtensions>,
    void,
    void
  >;
}

type PromiseOrValue<T> = Promise<T> | T;

// This starts as undefined and is set to a function or null by running
// tryToLoadGraphQL17(). If graphql-js 17 is installed, it is set to the
// experimentalExecuteIncrementally function from that package; otherwise it is
// set to null.
let graphqlExperimentalExecuteIncrementally:
  | ((
      args: ExecutionArgs,
    ) => PromiseOrValue<
      ExecutionResult | GraphQLExperimentalIncrementalExecutionResults
    >)
  | null
  | undefined = undefined;

async function tryToLoadGraphQL17() {
  if (graphqlExperimentalExecuteIncrementally !== undefined) {
    return;
  }
  const graphql = await import('graphql');
  if ('experimentalExecuteIncrementally' in graphql) {
    graphqlExperimentalExecuteIncrementally = (graphql as any)
      .experimentalExecuteIncrementally;
  } else {
    graphqlExperimentalExecuteIncrementally = null;
  }
}

export async function executeIncrementally(
  args: ExecutionArgs,
): Promise<ExecutionResult | GraphQLExperimentalIncrementalExecutionResults> {
  await tryToLoadGraphQL17();
  if (graphqlExperimentalExecuteIncrementally) {
    return graphqlExperimentalExecuteIncrementally(args);
  }
  return execute(args);
}
π/dist/cjs/httpBatching.js≈	0"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runPotentiallyBatchedHttpQuery = void 0;
const runHttpQuery_js_1 = require("./runHttpQuery.js");
const internalErrorClasses_js_1 = require("./internalErrorClasses.js");
async function runBatchedHttpQuery({ server, batchRequest, body, contextValue, schemaDerivedData, internals, }) {
    if (body.length === 0) {
        throw new internalErrorClasses_js_1.BadRequestError('No operations found in request.');
    }
    const sharedResponseHTTPGraphQLHead = (0, runHttpQuery_js_1.newHTTPGraphQLHead)();
    const responseBodies = await Promise.all(body.map(async (bodyPiece) => {
        const singleRequest = {
            ...batchRequest,
            body: bodyPiece,
        };
        const response = await (0, runHttpQuery_js_1.runHttpQuery)({
            server,
            httpRequest: singleRequest,
            contextValue,
            schemaDerivedData,
            internals,
            sharedResponseHTTPGraphQLHead,
        });
        if (response.body.kind === 'chunked') {
            throw Error('Incremental delivery is not implemented for batch requests');
        }
        return response.body.string;
    }));
    return {
        ...sharedResponseHTTPGraphQLHead,
        body: { kind: 'complete', string: `[${responseBodies.join(',')}]` },
    };
}
async function runPotentiallyBatchedHttpQuery(server, httpGraphQLRequest, contextValue, schemaDerivedData, internals) {
    if (!(httpGraphQLRequest.method === 'POST' &&
        Array.isArray(httpGraphQLRequest.body))) {
        return await (0, runHttpQuery_js_1.runHttpQuery)({
            server,
            httpRequest: httpGraphQLRequest,
            contextValue,
            schemaDerivedData,
            internals,
            sharedResponseHTTPGraphQLHead: null,
        });
    }
    if (internals.allowBatchedHttpRequests) {
        return await runBatchedHttpQuery({
            server,
            batchRequest: httpGraphQLRequest,
            body: httpGraphQLRequest.body,
            contextValue,
            schemaDerivedData,
            internals,
        });
    }
    throw new internalErrorClasses_js_1.BadRequestError('Operation batching disabled.');
}
exports.runPotentiallyBatchedHttpQuery = runPotentiallyBatchedHttpQuery;
//# sourceMappingURL=httpBatching.js.mapæ/dist/esm/preventCsrf.d.ts.map≈{"version":3,"file":"preventCsrf.d.ts","sourceRoot":"","sources":["../../src/preventCsrf.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAC;AAYtD,eAAO,MAAM,uCAAuC,UAGnD,CAAC;AA4BF,wBAAgB,WAAW,CACzB,OAAO,EAAE,SAAS,EAClB,4BAA4B,EAAE,MAAM,EAAE,QAmDvC"}Ÿ./dist/esm/utils/schemaInstrumentation.d.ts.map≈µ{"version":3,"file":"schemaInstrumentation.d.ts","sourceRoot":"","sources":["../../../src/utils/schemaInstrumentation.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,aAAa,EAMd,MAAM,SAAS,CAAC;AACjB,OAAO,KAAK,EACV,WAAW,EAEZ,MAAM,2BAA2B,CAAC;AAEnC,eAAO,MAAM,yCAAyC,eAErD,CAAC;AACF,eAAO,MAAM,uBAAuB,eAA0C,CAAC;AAC/E,QAAA,MAAM,oBAAoB,eAAuC,CAAC;AAElE,wBAAgB,+BAA+B,CAAC,QAAQ,SAAS,WAAW,EAC1E,MAAM,EAAE,aAAa,GAAG;IAAE,CAAC,oBAAoB,CAAC,CAAC,EAAE,OAAO,CAAA;CAAE;;EAuB7D;AAED,wBAAgB,gCAAgC,CAC9C,MAAM,EAAE,aAAa,GAAG;IAAE,CAAC,oBAAoB,CAAC,CAAC,EAAE,OAAO,CAAA;CAAE,GAC3D,OAAO,CAET;AA4DD,wBAAgB,oBAAoB,CAClC,MAAM,EAAE,GAAG,EACX,QAAQ,EAAE,CAAC,GAAG,EAAE,KAAK,GAAG,IAAI,EAAE,MAAM,CAAC,EAAE,GAAG,KAAK,IAAI,QAmBpD"}Ÿ;/dist/cjs/plugin/landingPage/default/getEmbeddedHTML.js.map≈˛{"version":3,"file":"getEmbeddedHTML.js","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/getEmbeddedHTML.ts"],"names":[],"mappings":";;;AAcA,SAAS,sBAAsB,CAAC,MAAyB;IACvD,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;SAC1B,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC;SACvB,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC;SACvB,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC;SACvB,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;AAC7B,CAAC;AAEM,MAAM,uBAAuB,GAAG,CACrC,OAAe,EACf,MAAqE,EACrE,EAAE;IAqBF,MAAM,oCAAoC,GAAG;QAC3C,cAAc,EAAE,EAAE;QAClB,oBAAoB,EAAE,KAAK;QAC3B,GAAG,CAAC,OAAO,MAAM,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;KAC3D,CAAC;IACF,MAAM,sBAAsB,GAC1B;QACE,GAAG,MAAM;QACT,MAAM,EAAE,qBAAqB;QAC7B,YAAY,EAAE;YACZ,GAAG,MAAM;YACT,cAAc,EAAE;gBACd,GAAG,oCAAoC,CAAC,cAAc;aACvD;SACF;QACD,oBAAoB,EAClB,oCAAoC,CAAC,oBAAoB;KAC5D,CAAC;IAEJ,OAAO;;;;;;;;;;;;;;iEAcwD,OAAO;;;iCAGvC,sBAAsB,CACnD,sBAAsB,CACvB;;;;;;CAMF,CAAC;AACF,CAAC,CAAC;AArEW,QAAA,uBAAuB,2BAqElC;AAEK,MAAM,sBAAsB,GAAG,CACpC,OAAe,EACf,MAAyB,EACzB,EAAE;IACF,OAAO;;;;;;;;;;;;;;gEAcuD,OAAO;;;;;;sBAMjD,MAAM,CAAC,cAAc,IAAI,OAAO;oBAClC,sBAAsB,CAAC;QACrC,QAAQ,EAAE,MAAM,CAAC,QAAQ,IAAI,SAAS;QACtC,SAAS,EAAE,MAAM,CAAC,SAAS,IAAI,SAAS;QACxC,OAAO,EAAE,MAAM,CAAC,OAAO,IAAI,SAAS;KACrC,CAAC;;;CAGL,CAAC;AACF,CAAC,CAAC;AAjCW,QAAA,sBAAsB,0BAiCjC"}Ÿ,/dist/esm/utils/computeCoreSchemaHash.js.map≈={"version":3,"file":"computeCoreSchemaHash.js","sourceRoot":"","sources":["../../../src/utils/computeCoreSchemaHash.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,0BAA0B,CAAC;AAMtD,MAAM,UAAU,qBAAqB,CAAC,MAAc;IAClD,OAAO,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC3D,CAAC"}¥/src/ApolloServer.ts≈∆Áimport { isNodeLike } from '@apollo/utils.isnodelike';
import type { Logger } from '@apollo/utils.logger';
import { makeExecutableSchema } from '@graphql-tools/schema';
import resolvable, { Resolvable } from '@josephg/resolvable';
import {
  assertValidSchema,
  DocumentNode,
  GraphQLError,
  GraphQLFieldResolver,
  GraphQLFormattedError,
  GraphQLSchema,
  ParseOptions,
  print,
  TypedQueryDocumentNode,
  ValidationContext,
  ValidationRule,
} from 'graphql';
import {
  type KeyValueCache,
  InMemoryLRUCache,
  PrefixingKeyValueCache,
} from '@apollo/utils.keyvaluecache';
import loglevel from 'loglevel';
import Negotiator from 'negotiator';
import * as uuid from 'uuid';
import { newCachePolicy } from './cachePolicy.js';
import { determineApolloConfig } from './determineApolloConfig.js';
import {
  ensureError,
  ensureGraphQLError,
  normalizeAndFormatErrors,
} from './errorNormalize.js';
import {
  ApolloServerErrorCode,
  ApolloServerValidationErrorCode,
} from './errors/index.js';
import type {
  ApolloServerPlugin,
  BaseContext,
  GraphQLRequest,
  GraphQLResponse,
  GraphQLServerListener,
  GraphQLServerContext,
  HTTPGraphQLRequest,
  HTTPGraphQLResponse,
  LandingPage,
  ApolloConfig,
  ApolloServerOptions,
  DocumentStore,
  PersistedQueryOptions,
  ContextThunk,
  GraphQLRequestContext,
  HTTPGraphQLHead,
} from './externalTypes/index.js';
import { runPotentiallyBatchedHttpQuery } from './httpBatching.js';
import { InternalPluginId, pluginIsInternal } from './internalPlugin.js';
import {
  preventCsrf,
  recommendedCsrfPreventionRequestHeaders,
} from './preventCsrf.js';
import { APQ_CACHE_PREFIX, processGraphQLRequest } from './requestPipeline.js';
import { newHTTPGraphQLHead, prettyJSONStringify } from './runHttpQuery.js';
import { SchemaManager } from './utils/schemaManager.js';
import { isDefined } from './utils/isDefined.js';
import { UnreachableCaseError } from './utils/UnreachableCaseError.js';
import type { WithRequired } from '@apollo/utils.withrequired';
import type { ApolloServerOptionsWithStaticSchema } from './externalTypes/constructor.js';
import type { GatewayExecutor } from '@apollo/server-gateway-interface';
import type { GraphQLExperimentalIncrementalExecutionResults } from './incrementalDeliveryPolyfill.js';
import { HeaderMap } from './utils/HeaderMap.js';
import type {
  ExecuteOperationOptions,
  VariableValues,
} from './externalTypes/graphql.js';

const NoIntrospection: ValidationRule = (context: ValidationContext) => ({
  Field(node) {
    if (node.name.value === '__schema' || node.name.value === '__type') {
      context.reportError(
        new GraphQLError(
          'GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production',
          {
            nodes: [node],
            extensions: {
              validationErrorCode:
                ApolloServerValidationErrorCode.INTROSPECTION_DISABLED,
            },
          },
        ),
      );
    }
  },
});

export type SchemaDerivedData = {
  schema: GraphQLSchema;
  // A store that, when enabled (default), will store the parsed and validated
  // versions of operations in-memory, allowing subsequent parses/validates
  // on the same operation to be executed immediately.
  documentStore: DocumentStore | null;
};

type RunningServerState = {
  schemaManager: SchemaManager;
  landingPage: LandingPage | null;
};

type ServerState =
  | {
      phase: 'initialized';
      schemaManager: SchemaManager;
    }
  | {
      phase: 'starting';
      barrier: Resolvable<void>;
      schemaManager: SchemaManager;
      // This is set to true if you called
      // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests
      // instead of start. The main purpose is that assertStarted allows you to
      // still be in the starting phase if this is set. (This is the serverless
      // use case.)
      startedInBackground: boolean;
    }
  | {
      phase: 'failed to start';
      error: Error;
    }
  | ({
      phase: 'started';
      drainServers: (() => Promise<void>) | null;
      toDispose: (() => Promise<void>)[];
      toDisposeLast: (() => Promise<void>)[];
    } & RunningServerState)
  | ({
      phase: 'draining';
      barrier: Resolvable<void>;
    } & RunningServerState)
  | {
      phase: 'stopping';
      barrier: Resolvable<void>;
    }
  | {
      phase: 'stopped';
      stopError: Error | null;
    };

export interface ApolloServerInternals<TContext extends BaseContext> {
  state: ServerState;
  gatewayExecutor: GatewayExecutor | null;

  formatError?: (
    formattedError: GraphQLFormattedError,
    error: unknown,
  ) => GraphQLFormattedError;
  includeStacktraceInErrorResponses: boolean;
  persistedQueries?: WithRequired<PersistedQueryOptions, 'cache'>;
  nodeEnv: string;
  allowBatchedHttpRequests: boolean;
  apolloConfig: ApolloConfig;
  plugins: ApolloServerPlugin<TContext>[];
  parseOptions: ParseOptions;
  // `undefined` means we figure out what to do during _start (because
  // the default depends on whether or not we used the background version
  // of start).
  stopOnTerminationSignals: boolean | undefined;
  csrfPreventionRequestHeaders: string[] | null;

  rootValue?: ((parsedQuery: DocumentNode) => unknown) | unknown;
  validationRules: Array<ValidationRule>;
  fieldResolver?: GraphQLFieldResolver<any, TContext>;

  __testing_incrementalExecutionResults?: GraphQLExperimentalIncrementalExecutionResults;
}

function defaultLogger(): Logger {
  const loglevelLogger = loglevel.getLogger('apollo-server');
  loglevelLogger.setLevel(loglevel.levels.INFO);
  return loglevelLogger;
}

// We really want to prevent this from being legal:
//
//     const s: ApolloServer<{}> =
//       new ApolloServer<{importantContextField: boolean}>({ ... });
//     s.executeOperation({query}, {contextValue: {}});
//
// ie, if you declare an ApolloServer whose context values must be of a certain
// type, you can't assign it to a variable whose context values are less
// constrained and then pass in a context value missing important fields.
//
// We also want this to be illegal:
//
//     const sBase = new ApolloServer<{}>({ ... });
//     const s: ApolloServer<{importantContextField: boolean}> = sBase;
//     s.addPlugin({async requestDidStart({contextValue: {importantContextField}}) { ... }})
//     sBase.executeOperation({query}, {contextValue: {}});
//
// so you shouldn't be able to assign an ApolloServer to a variable whose
// context values are more constrained, either. So we want to declare that
// ApolloServer is *invariant* in TContext, which we do with `in out` (a
// TypeScript 4.7 feature).
export class ApolloServer<in out TContext extends BaseContext = BaseContext> {
  private internals: ApolloServerInternals<TContext>;

  public readonly cache: KeyValueCache<string>;
  public readonly logger: Logger;

  constructor(config: ApolloServerOptions<TContext>) {
    const nodeEnv = config.nodeEnv ?? process.env.NODE_ENV ?? '';

    this.logger = config.logger ?? defaultLogger();

    const apolloConfig = determineApolloConfig(config.apollo);

    const isDev = nodeEnv !== 'production';

    const state: ServerState = config.gateway
      ? // ApolloServer has been initialized but we have not yet tried to load the
        // schema from the gateway. That will wait until `start()` or
        // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`
        // is called. (These may be called by other helpers; for example,
        // `standaloneServer` calls `start` for you inside its `listen` method,
        // and a serverless framework integration would call
        // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests
        // for you.)
        {
          phase: 'initialized',
          schemaManager: new SchemaManager({
            gateway: config.gateway,
            apolloConfig,
            schemaDerivedDataProvider: (schema) =>
              ApolloServer.generateSchemaDerivedData(
                schema,
                config.documentStore,
              ),
            logger: this.logger,
          }),
        }
      : // We construct the schema synchronously so that we can fail fast if the
        // schema can't be constructed. (This used to be more important because we
        // used to have a 'schema' field that was publicly accessible immediately
        // after construction, though that field never actually worked with
        // gateways.)
        {
          phase: 'initialized',
          schemaManager: new SchemaManager({
            apiSchema: ApolloServer.constructSchema(config),
            schemaDerivedDataProvider: (schema) =>
              ApolloServer.generateSchemaDerivedData(
                schema,
                config.documentStore,
              ),
            logger: this.logger,
          }),
        };

    const introspectionEnabled = config.introspection ?? isDev;

    this.cache = config.cache ?? new InMemoryLRUCache();

    // Note that we avoid calling methods on `this` before `this.internals` is assigned
    // (thus a bunch of things being static methods above).
    this.internals = {
      formatError: config.formatError,
      rootValue: config.rootValue,
      validationRules: [
        ...(config.validationRules ?? []),
        ...(introspectionEnabled ? [] : [NoIntrospection]),
      ],
      fieldResolver: config.fieldResolver,
      includeStacktraceInErrorResponses:
        config.includeStacktraceInErrorResponses ??
        (nodeEnv !== 'production' && nodeEnv !== 'test'),
      persistedQueries:
        config.persistedQueries === false
          ? undefined
          : {
              ...config.persistedQueries,
              cache: new PrefixingKeyValueCache(
                config.persistedQueries?.cache ?? this.cache,
                APQ_CACHE_PREFIX,
              ),
            },
      nodeEnv,
      allowBatchedHttpRequests: config.allowBatchedHttpRequests ?? false,
      apolloConfig,
      // Note that more plugins can be added before `start()` with `addPlugin()`
      // (eg, plugins that want to take this ApolloServer as an argument), and
      // `start()` will call `addDefaultPlugins` to add default plugins.
      plugins: config.plugins ?? [],
      parseOptions: config.parseOptions ?? {},
      state,
      stopOnTerminationSignals: config.stopOnTerminationSignals,

      gatewayExecutor: null, // set by _start

      csrfPreventionRequestHeaders:
        config.csrfPrevention === true || config.csrfPrevention === undefined
          ? recommendedCsrfPreventionRequestHeaders
          : config.csrfPrevention === false
          ? null
          : config.csrfPrevention.requestHeaders ??
            recommendedCsrfPreventionRequestHeaders,
      __testing_incrementalExecutionResults:
        config.__testing_incrementalExecutionResults,
    };
  }

  // Awaiting a call to `start` ensures that a schema has been loaded and that
  // all plugin `serverWillStart` hooks have been called. If either of these
  // processes throw, `start` will (async) throw as well.
  //
  // If you're using `standaloneServer`, you don't need to call `start` yourself
  // (in fact, it will throw if you do so); its `listen` method takes care of
  // that for you.
  //
  // If instead you're using an integration package for a non-serverless
  // framework (like Express), you must await a call to `start` immediately
  // after creating your `ApolloServer`, before attaching it to your web
  // framework and starting to accept requests. `start` should only be called
  // once; if it throws and you'd like to retry, just create another
  // `ApolloServer`. (Calling `start` was optional in Apollo Server 2, but in
  // Apollo Server 3+ the functions like `expressMiddleware` use `assertStarted`
  // to throw if `start` hasn't successfully completed.)
  //
  // Serverless integrations like Lambda do not support calling `start()`,
  // because their lifecycle doesn't allow you to wait before assigning a
  // handler or allowing the handler to be called. So they call
  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()`
  // instead, and don't really differentiate between startup failures and
  // request failures. This is hopefully appropriate for a "serverless"
  // framework. Serverless startup failures result in returning a redacted error
  // to the end user and logging the more detailed error.
  public async start(): Promise<void> {
    return await this._start(false);
  }

  public startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests(): void {
    this._start(true).catch((e) => this.logStartupError(e));
  }

  private async _start(startedInBackground: boolean): Promise<void> {
    if (this.internals.state.phase !== 'initialized') {
      // If we wanted we could make this error detectable and change
      // `standaloneServer` to change the message to say not to call start() at
      // all.
      throw new Error(
        `You should only call 'start()' or ` +
          `'startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()' ` +
          `once on your ApolloServer.`,
      );
    }
    const schemaManager = this.internals.state.schemaManager;
    const barrier = resolvable();
    this.internals.state = {
      phase: 'starting',
      barrier,
      schemaManager,
      startedInBackground,
    };
    try {
      // Now that you can't call addPlugin any more, add default plugins like
      // usage reporting if they're not already added.
      await this.addDefaultPlugins();

      const toDispose: (() => Promise<void>)[] = [];
      const executor = await schemaManager.start();
      if (executor) {
        this.internals.gatewayExecutor = executor;
      }
      toDispose.push(async () => {
        await schemaManager.stop();
      });

      const schemaDerivedData = schemaManager.getSchemaDerivedData();
      const service: GraphQLServerContext = {
        logger: this.logger,
        cache: this.cache,
        schema: schemaDerivedData.schema,
        apollo: this.internals.apolloConfig,
        startedInBackground,
      };

      const taggedServerListeners = (
        await Promise.all(
          this.internals.plugins.map(async (plugin) => ({
            serverListener:
              plugin.serverWillStart && (await plugin.serverWillStart(service)),
            installedImplicitly:
              isImplicitlyInstallablePlugin(plugin) &&
              plugin.__internal_installed_implicitly__,
          })),
        )
      ).filter(
        (
          maybeTaggedServerListener,
        ): maybeTaggedServerListener is {
          serverListener: GraphQLServerListener;
          installedImplicitly: boolean;
        } => typeof maybeTaggedServerListener.serverListener === 'object',
      );

      taggedServerListeners.forEach(
        ({ serverListener: { schemaDidLoadOrUpdate } }) => {
          if (schemaDidLoadOrUpdate) {
            schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
          }
        },
      );

      const serverWillStops = taggedServerListeners
        .map((l) => l.serverListener.serverWillStop)
        .filter(isDefined);
      if (serverWillStops.length) {
        toDispose.push(async () => {
          await Promise.all(
            serverWillStops.map((serverWillStop) => serverWillStop()),
          );
        });
      }

      const drainServerCallbacks = taggedServerListeners
        .map((l) => l.serverListener.drainServer)
        .filter(isDefined);
      const drainServers = drainServerCallbacks.length
        ? async () => {
            await Promise.all(
              drainServerCallbacks.map((drainServer) => drainServer()),
            );
          }
        : null;

      // Find the renderLandingPage callback, if one is provided. If the user
      // installed ApolloServerPluginLandingPageDisabled then there may be none
      // found. On the other hand, if the user installed a landingPage plugin,
      // then both the implicit installation of
      // ApolloServerPluginLandingPage*Default and the other plugin will be
      // found; we skip the implicit plugin.
      let taggedServerListenersWithRenderLandingPage =
        taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
      if (taggedServerListenersWithRenderLandingPage.length > 1) {
        taggedServerListenersWithRenderLandingPage =
          taggedServerListenersWithRenderLandingPage.filter(
            (l) => !l.installedImplicitly,
          );
      }
      let landingPage: LandingPage | null = null;
      if (taggedServerListenersWithRenderLandingPage.length > 1) {
        throw Error('Only one plugin can implement renderLandingPage.');
      } else if (taggedServerListenersWithRenderLandingPage.length) {
        landingPage = await taggedServerListenersWithRenderLandingPage[0]
          .serverListener.renderLandingPage!();
      }

      const toDisposeLast = this.maybeRegisterTerminationSignalHandlers(
        ['SIGINT', 'SIGTERM'],
        startedInBackground,
      );

      this.internals.state = {
        phase: 'started',
        schemaManager,
        drainServers,
        landingPage,
        toDispose,
        toDisposeLast,
      };
    } catch (maybeError: unknown) {
      const error = ensureError(maybeError);

      try {
        await Promise.all(
          this.internals.plugins.map(async (plugin) =>
            plugin.startupDidFail?.({ error }),
          ),
        );
      } catch (pluginError) {
        this.logger.error(`startupDidFail hook threw: ${pluginError}`);
      }

      this.internals.state = {
        phase: 'failed to start',
        error,
      };
      throw error;
    } finally {
      barrier.resolve();
    }
  }

  private maybeRegisterTerminationSignalHandlers(
    signals: NodeJS.Signals[],
    startedInBackground: boolean,
  ): (() => Promise<void>)[] {
    const toDisposeLast: (() => Promise<void>)[] = [];

    // We handle signals if it was explicitly requested
    // (stopOnTerminationSignals === true), or if we're in Node, not in a test,
    // not in a serverless framework (which we guess based on whether they
    // called
    // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests),
    // and it wasn't explicitly turned off. (We only actually register the
    // signal handlers once we've successfully started up, because there's
    // nothing to stop otherwise.)
    if (
      this.internals.stopOnTerminationSignals === false ||
      (this.internals.stopOnTerminationSignals === undefined &&
        !(
          isNodeLike &&
          this.internals.nodeEnv !== 'test' &&
          !startedInBackground
        ))
    ) {
      return toDisposeLast;
    }

    let receivedSignal = false;
    const signalHandler: NodeJS.SignalsListener = async (signal) => {
      if (receivedSignal) {
        // If we receive another SIGINT or SIGTERM while we're waiting
        // for the server to stop, just ignore it.
        return;
      }
      receivedSignal = true;
      try {
        await this.stop();
      } catch (e) {
        this.logger.error(`stop() threw during ${signal} shutdown`);
        this.logger.error(e);
        // Can't rely on the signal handlers being removed.
        process.exit(1);
      }
      // Note: this.stop will call the toDisposeLast handlers below, so at
      // this point this handler will have been removed and we can re-kill
      // ourself to die with the appropriate signal exit status. this.stop
      // takes care to call toDisposeLast last, so the signal handler isn't
      // removed until after the rest of shutdown happens.
      process.kill(process.pid, signal);
    };

    signals.forEach((signal) => {
      process.on(signal, signalHandler);
      toDisposeLast.push(async () => {
        process.removeListener(signal, signalHandler);
      });
    });
    return toDisposeLast;
  }

  // This method is called at the beginning of each GraphQL request by
  // `executeHTTPGraphQLRequest` and `executeOperation`. Most of its logic is
  // only helpful if you started the server in the background (ie, for
  // serverless frameworks): unless you're in a serverless framework, you should
  // have called `await server.start()` before the server got to the point of
  // running GraphQL requests (`assertStarted` calls in the framework
  // integrations verify that) and so the only cases for non-serverless
  // frameworks that this should hit are 'started', 'stopping', and 'stopped'.
  // But if you started the server in the background (with
  // startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests), this
  // lets the server wait until fully started before serving operations.
  private async _ensureStarted(): Promise<RunningServerState> {
    while (true) {
      switch (this.internals.state.phase) {
        case 'initialized':
          // This error probably won't happen: serverless framework integrations
          // should call
          // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests`
          // for you, and other frameworks call `assertStarted` before setting
          // things up enough to make calling this function possible.
          throw new Error(
            'You need to call `server.start()` before using your Apollo Server.',
          );
        case 'starting':
          await this.internals.state.barrier;
          // continue the while loop
          break;
        case 'failed to start':
          // First we log the error that prevented startup (which means it will
          // get logged once for every GraphQL operation).
          this.logStartupError(this.internals.state.error);
          // Now make the operation itself fail.
          // We intentionally do not re-throw actual startup error as it may contain
          // implementation details and this error will propagate to the client.
          throw new Error(
            'This data graph is missing a valid configuration. More details may be available in the server logs.',
          );
        case 'started':
        case 'draining': // We continue to run operations while draining.
          return this.internals.state;
        case 'stopping':
        case 'stopped':
          this.logger.warn(
            'A GraphQL operation was received during server shutdown. The ' +
              'operation will fail. Consider draining the HTTP server on shutdown; ' +
              'see https://go.apollo.dev/s/drain for details.',
          );
          throw new Error(
            `Cannot execute GraphQL operations ${
              this.internals.state.phase === 'stopping'
                ? 'while the server is stopping'
                : 'after the server has stopped'
            }.'`,
          );
        default:
          throw new UnreachableCaseError(this.internals.state);
      }
    }
  }

  // Framework integrations should call this to ensure that you've properly
  // started your server before you get anywhere close to actually listening for
  // incoming requests.
  //
  // There's a special case that if you called
  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` and
  // it hasn't finished starting up yet, this works too. This is intended for
  // cases like a serverless integration (say, Google Cloud Functions) that
  // calls
  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` for
  // you and then immediately sets up an integration based on another middleware
  // like `expressMiddleware` which calls this function. We'd like this to be
  // OK, but we still want normal Express users to start their ApolloServer
  // before setting up their HTTP server unless they know what they are doing
  // well enough to call the function with the long name themselves.
  public assertStarted(expressionForError: string) {
    if (
      this.internals.state.phase !== 'started' &&
      this.internals.state.phase !== 'draining' &&
      !(
        this.internals.state.phase === 'starting' &&
        this.internals.state.startedInBackground
      )
    ) {
      throw new Error(
        'You must `await server.start()` before calling `' +
          expressionForError +
          '`',
      );
    }
  }

  // Given an error that occurred during Apollo Server startup, log it with a
  // helpful message. This should happen when you call
  // `startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests` (ie,
  // in serverless frameworks); with other frameworks, you must `await
  // server.start()` which will throw the startup error directly instead of
  // logging. This gets called both immediately when the startup error happens,
  // and on all subsequent requests.
  private logStartupError(err: Error) {
    this.logger.error(
      'An error occurred during Apollo Server startup. All GraphQL requests ' +
        'will now fail. The startup error was: ' +
        (err?.message || err),
    );
  }

  private static constructSchema<TContext extends BaseContext>(
    config: ApolloServerOptionsWithStaticSchema<TContext>,
  ): GraphQLSchema {
    if (config.schema) {
      return config.schema;
    }

    const { typeDefs, resolvers } = config;
    const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];

    // For convenience, we allow you to pass a few options that we pass through
    // to a particular version of `@graphql-tools/schema`'s
    // `makeExecutableSchema`. If you want to use more of this function's
    // features or have more control over the version of the packages used, just
    // call it yourself like `new ApolloServer({schema:
    // makeExecutableSchema(...)})`.
    return makeExecutableSchema({
      typeDefs: augmentedTypeDefs,
      resolvers,
    });
  }

  private static generateSchemaDerivedData(
    schema: GraphQLSchema,
    // null means don't use a documentStore at all.
    // missing/undefined means use the default (creating a new one each
    // time).
    // defined means wrap this one in a random prefix for each new schema.
    providedUnprefixedDocumentStore: DocumentStore | null | undefined,
  ): SchemaDerivedData {
    // Instead of waiting for the first operation execution against the schema
    // to find out if it's a valid schema or not, check right now. In the
    // non-gateway case, if this throws then the `new ApolloServer` call will
    // throw. In the gateway case if this throws then it will log a message and
    // just not update the schema (although oddly the message will claim that
    // the schema is updating).
    assertValidSchema(schema);

    return {
      schema,
      // The DocumentStore is schema-derived because we put documents in it
      // after checking that they pass GraphQL validation against the schema and
      // use this to skip validation as well as parsing. So we can't reuse the
      // same DocumentStore for different schemas because that might make us
      // treat invalid operations as valid. If we're using the default
      // DocumentStore, then we just create it from scratch each time we get a
      // new schema. If we're using a user-provided DocumentStore, then we use a
      // random prefix each time we get a new schema.
      documentStore:
        providedUnprefixedDocumentStore === undefined
          ? new InMemoryLRUCache<DocumentNode>()
          : providedUnprefixedDocumentStore === null
          ? null
          : new PrefixingKeyValueCache(
              providedUnprefixedDocumentStore,
              `${uuid.v4()}:`,
            ),
    };
  }

  public async stop() {
    switch (this.internals.state.phase) {
      case 'initialized':
      case 'starting':
      case 'failed to start':
        throw Error(
          'apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded',
        );

      // Calling stop more than once should have the same result as the first time.
      case 'stopped':
        if (this.internals.state.stopError) {
          throw this.internals.state.stopError;
        }
        return;

      // Two parallel calls to stop; just wait for the other one to finish and
      // do whatever it did.
      case 'stopping':
      case 'draining': {
        await this.internals.state.barrier;
        // The cast here is because TS doesn't understand that this.state can
        // change during the await
        // (https://github.com/microsoft/TypeScript/issues/9998).
        const state = this.internals.state as ServerState;
        if (state.phase !== 'stopped') {
          throw Error(`Surprising post-stopping state ${state.phase}`);
        }
        if (state.stopError) {
          throw state.stopError;
        }
        return;
      }

      case 'started':
        // This is handled by the rest of the function.
        break;

      default:
        throw new UnreachableCaseError(this.internals.state);
    }

    const barrier = resolvable();

    const {
      schemaManager,
      drainServers,
      landingPage,
      toDispose,
      toDisposeLast,
    } = this.internals.state;

    // Commit to stopping and start draining servers.
    this.internals.state = {
      phase: 'draining',
      barrier,
      schemaManager,
      landingPage,
    };

    try {
      await drainServers?.();

      // Servers are drained. Prevent further operations from starting and call
      // stop handlers.
      this.internals.state = { phase: 'stopping', barrier };

      // We run shutdown handlers in two phases because we don't want to turn
      // off our signal listeners (ie, allow signals to kill the process) until
      // we've done the important parts of shutdown like running serverWillStop
      // handlers. (We can make this more generic later if it's helpful.)
      await Promise.all([...toDispose].map((dispose) => dispose()));
      await Promise.all([...toDisposeLast].map((dispose) => dispose()));
    } catch (stopError) {
      this.internals.state = {
        phase: 'stopped',
        stopError: stopError as Error,
      };
      barrier.resolve();
      throw stopError;
    }
    this.internals.state = { phase: 'stopped', stopError: null };
  }

  private async addDefaultPlugins() {
    const { plugins, apolloConfig, nodeEnv } = this.internals;
    const isDev = nodeEnv !== 'production';

    const alreadyHavePluginWithInternalId = (id: InternalPluginId) =>
      plugins.some(
        (p) => pluginIsInternal(p) && p.__internal_plugin_id__ === id,
      );

    // Make sure we're not trying to explicitly enable and disable the same
    // feature. (Be careful: we are not trying to stop people from installing
    // the same plugin twice if they have a use case for it, like two usage
    // reporting plugins for different variants.)
    //
    // Note that this check doesn't work for the landing page plugin, because
    // users can write their own landing page plugins and we don't know if a
    // given plugin is a landing page plugin until the server has started.
    const pluginsByInternalID = new Map<
      InternalPluginId,
      { sawDisabled: boolean; sawNonDisabled: boolean }
    >();
    for (const p of plugins) {
      if (pluginIsInternal(p)) {
        const id = p.__internal_plugin_id__;
        if (!pluginsByInternalID.has(id)) {
          pluginsByInternalID.set(id, {
            sawDisabled: false,
            sawNonDisabled: false,
          });
        }
        const seen = pluginsByInternalID.get(id)!;
        if (p.__is_disabled_plugin__) {
          seen.sawDisabled = true;
        } else {
          seen.sawNonDisabled = true;
        }

        if (seen.sawDisabled && seen.sawNonDisabled) {
          throw new Error(
            `You have tried to install both ApolloServerPlugin${id} and ` +
              `ApolloServerPlugin${id}Disabled in your server. Please choose ` +
              `whether or not you want to disable the feature and install the ` +
              `appropriate plugin for your use case.`,
          );
        }
      }
    }

    // Special case: cache control is on unless you explicitly disable it.
    {
      if (!alreadyHavePluginWithInternalId('CacheControl')) {
        const { ApolloServerPluginCacheControl } = await import(
          './plugin/cacheControl/index.js'
        );
        plugins.push(ApolloServerPluginCacheControl());
      }
    }

    // Special case: usage reporting is on by default (and first!) if you
    // configure an API key.
    {
      const alreadyHavePlugin =
        alreadyHavePluginWithInternalId('UsageReporting');
      if (!alreadyHavePlugin && apolloConfig.key) {
        if (apolloConfig.graphRef) {
          // Keep this plugin first so it wraps everything. (Unfortunately despite
          // the fact that the person who wrote this line also was the original
          // author of the comment above in #1105, they don't quite understand why this was important.)
          const { ApolloServerPluginUsageReporting } = await import(
            './plugin/usageReporting/index.js'
          );
          plugins.unshift(ApolloServerPluginUsageReporting());
        } else {
          this.logger.warn(
            'You have specified an Apollo key but have not specified a graph ref; usage ' +
              'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +
              'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +
              'warning, install `ApolloServerPluginUsageReportingDisabled`.',
          );
        }
      }
    }

    // Special case: schema reporting can be turned on via environment variable.
    {
      const alreadyHavePlugin =
        alreadyHavePluginWithInternalId('SchemaReporting');
      const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';
      if (!alreadyHavePlugin && enabledViaEnvVar) {
        if (apolloConfig.key) {
          const { ApolloServerPluginSchemaReporting } = await import(
            './plugin/schemaReporting/index.js'
          );
          plugins.push(ApolloServerPluginSchemaReporting());
        } else {
          throw new Error(
            "You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING " +
              'environment variable to true, but you also need to provide your ' +
              'Apollo API key, via the APOLLO_KEY environment ' +
              'variable or via `new ApolloServer({apollo: {key})',
          );
        }
      }
    }

    // Special case: inline tracing is on by default for federated schemas.
    {
      const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');
      if (!alreadyHavePlugin) {
        // If we haven't explicitly disabled inline tracing via
        // ApolloServerPluginInlineTraceDisabled or explicitly installed our own
        // ApolloServerPluginInlineTrace, we set up inline tracing in "only if
        // federated" mode.  (This is slightly different than the
        // pre-ApolloServerPluginInlineTrace where we would also avoid doing
        // this if an API key was configured and log a warning.)
        const { ApolloServerPluginInlineTrace } = await import(
          './plugin/inlineTrace/index.js'
        );
        plugins.push(
          ApolloServerPluginInlineTrace({ __onlyIfSchemaIsFederated: true }),
        );
      }
    }

    // Special case: If we're not in production, show our default landing page.
    //
    // This works a bit differently from the other implicitly installed plugins,
    // which rely entirely on the __internal_plugin_id__ to decide whether the
    // plugin takes effect. That's because we want third-party plugins to be
    // able to provide a landing page that overrides the default landing page,
    // without them having to know about __internal_plugin_id__. So unless we
    // actively disable the default landing page with
    // ApolloServerPluginLandingPageDisabled, we install the default landing
    // page, but with a special flag that _start() uses to ignore it if some
    // other plugin defines a renderLandingPage callback. (We can't just look
    // now to see if the plugin defines renderLandingPage because we haven't run
    // serverWillStart yet.)
    const alreadyHavePlugin = alreadyHavePluginWithInternalId(
      'LandingPageDisabled',
    );
    if (!alreadyHavePlugin) {
      const {
        ApolloServerPluginLandingPageLocalDefault,
        ApolloServerPluginLandingPageProductionDefault,
      } = await import('./plugin/landingPage/default/index.js');
      const plugin: ApolloServerPlugin<TContext> = isDev
        ? ApolloServerPluginLandingPageLocalDefault()
        : ApolloServerPluginLandingPageProductionDefault();
      if (!isImplicitlyInstallablePlugin(plugin)) {
        throw Error(
          'default landing page plugin should be implicitly installable?',
        );
      }
      plugin.__internal_installed_implicitly__ = true;
      plugins.push(plugin);
    }
  }

  public addPlugin(plugin: ApolloServerPlugin<TContext>) {
    if (this.internals.state.phase !== 'initialized') {
      throw new Error("Can't add plugins after the server has started");
    }
    this.internals.plugins.push(plugin);
  }

  public async executeHTTPGraphQLRequest({
    httpGraphQLRequest,
    context,
  }: {
    httpGraphQLRequest: HTTPGraphQLRequest;
    context: ContextThunk<TContext>;
  }): Promise<HTTPGraphQLResponse> {
    try {
      let runningServerState;
      try {
        runningServerState = await this._ensureStarted();
      } catch (error: unknown) {
        // This is typically either the masked error from when background startup
        // failed, or related to invoking this function before startup or
        // during/after shutdown (due to lack of draining).
        return this.errorResponse(error, httpGraphQLRequest);
      }

      if (
        runningServerState.landingPage &&
        this.prefersHTML(httpGraphQLRequest)
      ) {
        return {
          headers: new HeaderMap([['content-type', 'text/html']]),
          body: {
            kind: 'complete',
            string: runningServerState.landingPage.html,
          },
        };
      }

      // If enabled, check to ensure that this request was preflighted before doing
      // anything real (such as running the context function).
      if (this.internals.csrfPreventionRequestHeaders) {
        preventCsrf(
          httpGraphQLRequest.headers,
          this.internals.csrfPreventionRequestHeaders,
        );
      }

      let contextValue: TContext;
      try {
        contextValue = await context();
      } catch (maybeError: unknown) {
        const error = ensureError(maybeError);
        try {
          await Promise.all(
            this.internals.plugins.map(async (plugin) =>
              plugin.contextCreationDidFail?.({
                error,
              }),
            ),
          );
        } catch (pluginError) {
          this.logger.error(
            `contextCreationDidFail hook threw: ${pluginError}`,
          );
        }

        // If some random function threw, add a helpful prefix when converting
        // to GraphQLError. If it was already a GraphQLError, trust that the
        // message was chosen thoughtfully and leave off the prefix.
        return this.errorResponse(
          ensureGraphQLError(error, 'Context creation failed: '),
          httpGraphQLRequest,
        );
      }

      return await runPotentiallyBatchedHttpQuery(
        this,
        httpGraphQLRequest,
        contextValue,
        runningServerState.schemaManager.getSchemaDerivedData(),
        this.internals,
      );
    } catch (maybeError_: unknown) {
      const maybeError = maybeError_; // fixes inference because catch vars are not const
      if (
        maybeError instanceof GraphQLError &&
        maybeError.extensions.code === ApolloServerErrorCode.BAD_REQUEST
      ) {
        try {
          await Promise.all(
            this.internals.plugins.map(async (plugin) =>
              plugin.invalidRequestWasReceived?.({ error: maybeError }),
            ),
          );
        } catch (pluginError) {
          this.logger.error(
            `invalidRequestWasReceived hook threw: ${pluginError}`,
          );
        }
      }
      return this.errorResponse(maybeError, httpGraphQLRequest);
    }
  }

  private errorResponse(
    error: unknown,
    requestHead: HTTPGraphQLHead,
  ): HTTPGraphQLResponse {
    const { formattedErrors, httpFromErrors } = normalizeAndFormatErrors(
      [error],
      {
        includeStacktraceInErrorResponses:
          this.internals.includeStacktraceInErrorResponses,
        formatError: this.internals.formatError,
      },
    );

    return {
      status: httpFromErrors.status ?? 500,
      headers: new HeaderMap([
        ...httpFromErrors.headers,
        [
          'content-type',
          // Note that we may change the default to
          // 'application/graphql-response+json' by 2025 as encouraged by the
          // graphql-over-http spec. It's maybe a bit bad for us to provide
          // an application/json response if they send `accept: foo/bar`,
          // but we're already providing some sort of bad request error, and
          // it's probably more useful for them to fix the other error before
          // they deal with the `accept` header.
          chooseContentTypeForSingleResultResponse(requestHead) ??
            MEDIA_TYPES.APPLICATION_JSON,
        ],
      ]),
      body: {
        kind: 'complete',
        string: prettyJSONStringify({
          errors: formattedErrors,
        }),
      },
    };
  }

  private prefersHTML(request: HTTPGraphQLRequest): boolean {
    const acceptHeader = request.headers.get('accept');
    return (
      request.method === 'GET' &&
      !!acceptHeader &&
      new Negotiator({
        headers: { accept: acceptHeader },
      }).mediaType([
        // We need it to actively prefer text/html over less browser-y types;
        // eg, `accept: */*' should still go for JSON. Negotiator does tiebreak
        // by the order in the list we provide, so we put text/html last.
        MEDIA_TYPES.APPLICATION_JSON,
        MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,
        MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,
        MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,
        MEDIA_TYPES.TEXT_HTML,
      ]) === MEDIA_TYPES.TEXT_HTML
    );
  }

  /**
   * This method is primarily meant for testing: it allows you to execute a
   * GraphQL operation via the request pipeline without going through the HTTP
   * layer. Note that this means that any handling you do in your server at the
   * HTTP level will not affect this call!
   *
   * For convenience, you can provide `request.query` either as a string or a
   * DocumentNode, in case you choose to use the gql tag in your tests. This is
   * just a convenience, not an optimization (we convert provided ASTs back into
   * string).
   *
   * The second object is an optional options object which includes the optional
   * `contextValue` object available in resolvers.
   *
   * You may specify the TData and TVariables generic types when calling this
   * method; Apollo Server does not validate that the returned data actually
   * matches the structure of TData. (Typically these types are created by a
   * code generation tool.) Note that this does not enforce that `variables` is
   * provided at all, just that it has the right type if provided.
   */
  public async executeOperation<
    TData = Record<string, unknown>,
    TVariables extends VariableValues = VariableValues,
  >(
    this: ApolloServer<BaseContext>,
    request: Omit<GraphQLRequest<TVariables>, 'query'> & {
      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;
    },
  ): Promise<GraphQLResponse<TData>>;
  public async executeOperation<
    TData = Record<string, unknown>,
    TVariables extends VariableValues = VariableValues,
  >(
    request: Omit<GraphQLRequest<TVariables>, 'query'> & {
      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;
    },
    options?: ExecuteOperationOptions<TContext>,
  ): Promise<GraphQLResponse<TData>>;

  async executeOperation<
    TData = Record<string, unknown>,
    TVariables extends VariableValues = VariableValues,
  >(
    request: Omit<GraphQLRequest<TVariables>, 'query'> & {
      // We should consider supporting TypedDocumentNode from
      // `@graphql-typed-document-node/core` as well, as it is more popular than
      // the newer built-in type.
      query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;
    },
    options: ExecuteOperationOptions<TContext> = {},
  ): Promise<GraphQLResponse<TData>> {
    // Since this function is mostly for testing, you don't need to explicitly
    // start your server before calling it. (That also means you can use it with
    // `apollo-server` which doesn't support `start()`.)
    if (this.internals.state.phase === 'initialized') {
      await this.start();
    }

    const schemaDerivedData = (
      await this._ensureStarted()
    ).schemaManager.getSchemaDerivedData();

    // For convenience, this function lets you pass either a string or an AST,
    // but we normalize to string.
    const graphQLRequest: GraphQLRequest = {
      ...request,
      query:
        request.query && typeof request.query !== 'string'
          ? print(request.query)
          : request.query,
    };

    const response: GraphQLResponse = await internalExecuteOperation(
      {
        server: this,
        graphQLRequest,
        internals: this.internals,
        schemaDerivedData,
        sharedResponseHTTPGraphQLHead: null,
      },
      options,
    );

    // It's your job to set an appropriate TData (perhaps using codegen); we
    // don't validate it.
    return response as GraphQLResponse<TData>;
  }
}

// Shared code between runHttpQuery (ie executeHTTPGraphQLRequest) and
// executeOperation to set up a request context and invoke the request pipeline.
export async function internalExecuteOperation<TContext extends BaseContext>(
  {
    server,
    graphQLRequest,
    internals,
    schemaDerivedData,
    sharedResponseHTTPGraphQLHead,
  }: {
    server: ApolloServer<TContext>;
    graphQLRequest: GraphQLRequest;
    internals: ApolloServerInternals<TContext>;
    schemaDerivedData: SchemaDerivedData;
    sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;
  },
  options: ExecuteOperationOptions<TContext>,
): Promise<GraphQLResponse> {
  const requestContext: GraphQLRequestContext<TContext> = {
    logger: server.logger,
    cache: server.cache,
    schema: schemaDerivedData.schema,
    request: graphQLRequest,
    response: {
      http: sharedResponseHTTPGraphQLHead ?? newHTTPGraphQLHead(),
    },
    // We clone the context because there are some assumptions that every operation
    // execution has a brand new context object; specifically, in order to implement
    // willResolveField we put a Symbol on the context that is specific to a particular
    // request pipeline execution. We could avoid this if we had a better way of
    // instrumenting execution.
    //
    // We don't want to do a deep clone here, because one of the main advantages of
    // using batched HTTP requests is to share context across operations for a
    // single request.
    //
    // The typecast here is safe, because the only way `contextValue` can be
    // null-ish is if we used the `contextValue?: BaseContext` override, in
    // which case TContext is BaseContext and {} is ok. (This does depend on
    // the fact we've hackily forced the class to be contravariant in
    // TContext.)
    contextValue: cloneObject(options?.contextValue ?? ({} as TContext)),
    metrics: {},
    overallCachePolicy: newCachePolicy(),
    requestIsBatched: sharedResponseHTTPGraphQLHead !== null,
  };

  try {
    return await processGraphQLRequest(
      schemaDerivedData,
      server,
      internals,
      requestContext,
    );
  } catch (maybeError: unknown) {
    // processGraphQLRequest throwing usually means that either there's a bug in
    // Apollo Server or some plugin hook threw unexpectedly.
    const error = ensureError(maybeError);
    // If *these* hooks throw then we'll still get a 500 but won't mask its
    // error.
    await Promise.all(
      internals.plugins.map(async (plugin) =>
        plugin.unexpectedErrorProcessingRequest?.({
          requestContext,
          error,
        }),
      ),
    );
    // Mask unexpected error externally.
    server.logger.error(`Unexpected error processing request: ${error}`);
    throw new Error('Internal server error');
  }
}

// Unlike InternalPlugins (where we can decide whether to install the default
// plugin based on looking at which plugins are installed),
// ImplicitlyInstallablePlugins (ie the default landing page plugin) can't
// determine if they're needed until later in startup. Specifically, we can't
// know if we've defined our own landing page until after serverWillStart
// plugins have run.
export type ImplicitlyInstallablePlugin<TContext extends BaseContext> =
  ApolloServerPlugin<TContext> & {
    __internal_installed_implicitly__: boolean;
  };

export function isImplicitlyInstallablePlugin<TContext extends BaseContext>(
  p: ApolloServerPlugin<TContext>,
): p is ImplicitlyInstallablePlugin<TContext> {
  return '__internal_installed_implicitly__' in p;
}

export const MEDIA_TYPES = {
  APPLICATION_JSON: 'application/json; charset=utf-8',
  APPLICATION_GRAPHQL_RESPONSE_JSON:
    'application/graphql-response+json; charset=utf-8',
  // We do *not* currently support this content-type; we will once incremental
  // delivery is part of the official GraphQL spec.
  MULTIPART_MIXED_NO_DEFER_SPEC: 'multipart/mixed',
  MULTIPART_MIXED_EXPERIMENTAL: 'multipart/mixed; deferSpec=20220824',
  TEXT_HTML: 'text/html',
};

export function chooseContentTypeForSingleResultResponse(
  head: HTTPGraphQLHead,
): string | null {
  const acceptHeader = head.headers.get('accept');
  if (!acceptHeader) {
    // Note that we may change the default to
    // 'application/graphql-response+json' by 2025 as encouraged by the
    // graphql-over-http spec.
    return MEDIA_TYPES.APPLICATION_JSON;
  } else {
    const preferred = new Negotiator({
      headers: { accept: head.headers.get('accept') },
    }).mediaType([
      MEDIA_TYPES.APPLICATION_JSON,
      MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,
    ]);
    if (preferred) {
      return preferred;
    } else {
      return null;
    }
  }
}

function cloneObject<T extends Object>(object: T): T {
  return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
}
Ÿ*/dist/cjs/externalTypes/constructor.js.mapƒÜ{"version":3,"file":"constructor.js","sourceRoot":"","sources":["../../../src/externalTypes/constructor.ts"],"names":[],"mappings":""}Ÿ*/dist/esm/utils/schemaInstrumentation.d.ts≈Aimport { GraphQLSchema } from 'graphql';
import type { BaseContext } from '../externalTypes/index.js';
export declare const symbolExecutionDispatcherWillResolveField: unique symbol;
export declare const symbolUserFieldResolver: unique symbol;
declare const symbolPluginsEnabled: unique symbol;
export declare function enablePluginsForSchemaResolvers<TContext extends BaseContext>(schema: GraphQLSchema & {
    [symbolPluginsEnabled]?: boolean;
}): GraphQLSchema & {
    [symbolPluginsEnabled]?: boolean | undefined;
};
export declare function pluginsEnabledForSchemaResolvers(schema: GraphQLSchema & {
    [symbolPluginsEnabled]?: boolean;
}): boolean;
export declare function whenResultIsFinished(result: any, callback: (err: Error | null, result?: any) => void): void;
export {};
//# sourceMappingURL=schemaInstrumentation.d.ts.mapŸ /dist/esm/utils/isDefined.js.mapƒ¬{"version":3,"file":"isDefined.js","sourceRoot":"","sources":["../../../src/utils/isDefined.ts"],"names":[],"mappings":"AAAA,MAAM,UAAU,SAAS,CAAI,CAA8B;IACzD,OAAO,CAAC,IAAI,IAAI,CAAC;AACnB,CAAC"}Ÿ'/dist/cjs/utils/UnreachableCaseError.js≈N"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnreachableCaseError = void 0;
class UnreachableCaseError extends Error {
    constructor(val) {
        super(`Unreachable case: ${val}`);
    }
}
exports.UnreachableCaseError = UnreachableCaseError;
//# sourceMappingURL=UnreachableCaseError.js.mapŸ"/dist/esm/externalTypes/plugins.jsƒ.export {};
//# sourceMappingURL=plugins.js.mapŸ$/dist/esm/utils/schemaManager.js.map≈
e{"version":3,"file":"schemaManager.js","sourceRoot":"","sources":["../../../src/utils/schemaManager.ts"],"names":[],"mappings":"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"}ª/dist/cjs/errorNormalize.js≈]"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureGraphQLError = exports.ensureError = exports.normalizeAndFormatErrors = void 0;
const graphql_1 = require("graphql");
const index_js_1 = require("./errors/index.js");
const runHttpQuery_js_1 = require("./runHttpQuery.js");
const HeaderMap_js_1 = require("./utils/HeaderMap.js");
function normalizeAndFormatErrors(errors, options = {}) {
    const formatError = options.formatError ?? ((error) => error);
    const httpFromErrors = (0, runHttpQuery_js_1.newHTTPGraphQLHead)();
    return {
        httpFromErrors,
        formattedErrors: errors.map((error) => {
            try {
                return formatError(enrichError(error), error);
            }
            catch (formattingError) {
                if (options.includeStacktraceInErrorResponses) {
                    return enrichError(formattingError);
                }
                else {
                    return {
                        message: 'Internal server error',
                        extensions: { code: index_js_1.ApolloServerErrorCode.INTERNAL_SERVER_ERROR },
                    };
                }
            }
        }),
    };
    function enrichError(maybeError) {
        const graphqlError = ensureGraphQLError(maybeError);
        const extensions = {
            ...graphqlError.extensions,
            code: graphqlError.extensions.code ??
                index_js_1.ApolloServerErrorCode.INTERNAL_SERVER_ERROR,
        };
        if (isPartialHTTPGraphQLHead(extensions.http)) {
            (0, runHttpQuery_js_1.mergeHTTPGraphQLHead)(httpFromErrors, {
                headers: new HeaderMap_js_1.HeaderMap(),
                ...extensions.http,
            });
            delete extensions.http;
        }
        if (options.includeStacktraceInErrorResponses) {
            extensions.stacktrace = graphqlError.stack?.split('\n');
        }
        return { ...graphqlError.toJSON(), extensions };
    }
}
exports.normalizeAndFormatErrors = normalizeAndFormatErrors;
function ensureError(maybeError) {
    return maybeError instanceof Error
        ? maybeError
        : new graphql_1.GraphQLError('Unexpected error value: ' + String(maybeError));
}
exports.ensureError = ensureError;
function ensureGraphQLError(maybeError, messagePrefixIfNotGraphQLError = '') {
    const error = ensureError(maybeError);
    return error instanceof graphql_1.GraphQLError
        ? error
        : new graphql_1.GraphQLError(messagePrefixIfNotGraphQLError + error.message, {
            originalError: error,
        });
}
exports.ensureGraphQLError = ensureGraphQLError;
function isPartialHTTPGraphQLHead(x) {
    return (!!x &&
        typeof x === 'object' &&
        (!('status' in x) || typeof x.status === 'number') &&
        (!('headers' in x) || x.headers instanceof Map));
}
//# sourceMappingURL=errorNormalize.js.mapŸ3/dist/cjs/utils/makeGatewayGraphQLRequestContext.js≈õ"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeGatewayGraphQLRequestContext = void 0;
function makeGatewayGraphQLRequestContext(as4RequestContext, server, internals) {
    const request = {};
    if ('query' in as4RequestContext.request) {
        request.query = as4RequestContext.request.query;
    }
    if ('operationName' in as4RequestContext.request) {
        request.operationName = as4RequestContext.request.operationName;
    }
    if ('variables' in as4RequestContext.request) {
        request.variables = as4RequestContext.request.variables;
    }
    if ('extensions' in as4RequestContext.request) {
        request.extensions = as4RequestContext.request.extensions;
    }
    if (as4RequestContext.request.http) {
        const as4http = as4RequestContext.request.http;
        const needQuestion = as4http.search !== '' && !as4http.search.startsWith('?');
        request.http = {
            method: as4http.method,
            url: `https://unknown-url.invalid/${needQuestion ? '?' : ''}${as4http.search}`,
            headers: new FetcherHeadersForHeaderMap(as4http.headers),
        };
    }
    const response = {
        http: {
            headers: new FetcherHeadersForHeaderMap(as4RequestContext.response.http.headers),
            get status() {
                return as4RequestContext.response.http.status;
            },
            set status(newStatus) {
                as4RequestContext.response.http.status = newStatus;
            },
        },
    };
    return {
        request,
        response,
        logger: server.logger,
        schema: as4RequestContext.schema,
        schemaHash: 'schemaHash no longer exists in Apollo Server 4',
        context: as4RequestContext.contextValue,
        cache: server.cache,
        queryHash: as4RequestContext.queryHash,
        document: as4RequestContext.document,
        source: as4RequestContext.source,
        operationName: as4RequestContext.operationName,
        operation: as4RequestContext.operation,
        errors: as4RequestContext.errors,
        metrics: as4RequestContext.metrics,
        debug: internals.includeStacktraceInErrorResponses,
        overallCachePolicy: as4RequestContext.overallCachePolicy,
        requestIsBatched: as4RequestContext.requestIsBatched,
    };
}
exports.makeGatewayGraphQLRequestContext = makeGatewayGraphQLRequestContext;
class FetcherHeadersForHeaderMap {
    constructor(map) {
        this.map = map;
    }
    append(name, value) {
        if (this.map.has(name)) {
            this.map.set(name, this.map.get(name) + ', ' + value);
        }
        else {
            this.map.set(name, value);
        }
    }
    delete(name) {
        this.map.delete(name);
    }
    get(name) {
        return this.map.get(name) ?? null;
    }
    has(name) {
        return this.map.has(name);
    }
    set(name, value) {
        this.map.set(name, value);
    }
    entries() {
        return this.map.entries();
    }
    keys() {
        return this.map.keys();
    }
    values() {
        return this.map.values();
    }
    [Symbol.iterator]() {
        return this.map.entries();
    }
}
//# sourceMappingURL=makeGatewayGraphQLRequestContext.js.mapŸ#/src/plugin/usageReporting/stats.ts≈>∏import {
  type google,
  type IContextualizedStats,
  type IFieldStat,
  type IPathErrorStats,
  type IQueryLatencyStats,
  type IReport,
  type IStatsContext,
  type ITracesAndStats,
  type ITypeStat,
  type ReportHeader,
  Trace,
} from '@apollo/usage-reporting-protobuf';
import type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';
import { DurationHistogram } from './durationHistogram.js';
import { iterateOverTrace, ResponseNamePath } from './iterateOverTrace.js';

// protobuf.js exports both a class and an interface (starting with I) for each
// message type. The class is what it produces when it decodes the message; the
// interface is what is accepted as input. We build up our messages using custom
// types implementing the interfaces, so that we can take advantage of the
// js_use_toArray option we added to our protobuf.js fork which allows us to use
// classes like DurationHistogram to generate repeated fields. We end up
// re-creating most of the report structure as custom classes (starting with
// "Our"). TypeScript validates that we've properly listed all of the message
// fields with the appropriate types (we use `Required` to ensure we implement
// all message fields). Using our own classes has other advantages, like being
// able to specify that nested messages are instances of the same class rather
// than the interface type and thus that they have non-null fields (because the
// interface type allows all fields to be optional, even though the protobuf
// format doesn't differentiate between missing and falsey).

export class SizeEstimator {
  bytes = 0;
}
export class OurReport implements Required<IReport> {
  constructor(readonly header: ReportHeader) {}
  readonly tracesPerQuery: Record<string, OurTracesAndStats> =
    Object.create(null);
  endTime: google.protobuf.ITimestamp | null = null;
  operationCount = 0;
  // A rough estimate of the number of bytes currently in the report. We start
  // at zero and don't count `header` and `endTime`, which have the same size
  // for every report. This really is a rough estimate, so we don't stress too
  // much about counting bytes for the tags and string/message lengths, etc:
  // we mostly just count the lengths of strings plus some estimates for the
  // messages with a bunch of numbers in them.
  //
  // We store this in a class so we can pass it down as a reference to other
  // methods which increment it.
  readonly sizeEstimator = new SizeEstimator();

  ensureCountsAreIntegers() {
    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {
      tracesAndStats.ensureCountsAreIntegers();
    }
  }

  addTrace({
    statsReportKey,
    trace,
    asTrace,
    referencedFieldsByType,
    // The max size a trace can be before it is sent as stats. Note that the
    // Apollo reporting ingress server will never store any traces over 10mb
    // anyway. They will still be converted to stats as we would do here.
    maxTraceBytes = 10 * 1024 * 1024,
  }: {
    statsReportKey: string;
    trace: Trace;
    asTrace: boolean;
    referencedFieldsByType: ReferencedFieldsByType;
    maxTraceBytes?: number;
  }) {
    const tracesAndStats = this.getTracesAndStats({
      statsReportKey,
      referencedFieldsByType,
    });
    if (asTrace) {
      const encodedTrace = Trace.encode(trace).finish();

      if (!isNaN(maxTraceBytes) && encodedTrace.length > maxTraceBytes) {
        tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
      } else {
        tracesAndStats.trace.push(encodedTrace);
        this.sizeEstimator.bytes += 2 + encodedTrace.length;
      }
    } else {
      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
    }
  }

  private getTracesAndStats({
    statsReportKey,
    referencedFieldsByType,
  }: {
    statsReportKey: string;
    referencedFieldsByType: ReferencedFieldsByType;
  }) {
    const existing = this.tracesPerQuery[statsReportKey];
    if (existing) {
      return existing;
    }
    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);

    // Update the size estimator for the referenced field structure.
    for (const [typeName, referencedFieldsForType] of Object.entries(
      referencedFieldsByType,
    )) {
      // Two bytes each for the map entry and for the ReferencedFieldsForType,
      // and for the isInterface bool if it's set.
      this.sizeEstimator.bytes += 2 + 2;
      if (referencedFieldsForType.isInterface) {
        this.sizeEstimator.bytes += 2;
      }
      this.sizeEstimator.bytes += estimatedBytesForString(typeName);
      for (const fieldName of referencedFieldsForType.fieldNames) {
        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
      }
    }

    // Include the referenced fields map in the report. (In an ideal world we
    // could have a slightly more sophisticated protocol and ingestion pipeline
    // that allowed us to only have to send this data once for each
    // schema/operation pair.)
    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(
      referencedFieldsByType,
    ));
  }
}

class OurTracesAndStats implements Required<ITracesAndStats> {
  constructor(readonly referencedFieldsByType: ReferencedFieldsByType) {}
  readonly trace: Uint8Array[] = [];
  readonly statsWithContext = new StatsByContext();
  readonly internalTracesContributingToStats: Uint8Array[] = [];

  ensureCountsAreIntegers() {
    this.statsWithContext.ensureCountsAreIntegers();
  }
}

class StatsByContext {
  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);

  /**
   * This function is used by the protobuf generator to convert this map into
   * an array of contextualized stats to serialize
   */
  toArray(): IContextualizedStats[] {
    return Object.values(this.map);
  }

  ensureCountsAreIntegers() {
    for (const contextualizedStats of Object.values(this.map)) {
      contextualizedStats.ensureCountsAreIntegers();
    }
  }

  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {
    this.getContextualizedStats(trace, sizeEstimator).addTrace(
      trace,
      sizeEstimator,
    );
  }

  private getContextualizedStats(
    trace: Trace,
    sizeEstimator: SizeEstimator,
  ): OurContextualizedStats {
    const statsContext: IStatsContext = {
      clientName: trace.clientName,
      clientVersion: trace.clientVersion,
    };
    const statsContextKey = JSON.stringify(statsContext);

    const existing = this.map[statsContextKey];
    if (existing) {
      return existing;
    }
    // Adding a ContextualizedStats means adding a StatsContext plus a
    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;
    // it'll be more if more features are used (like cache, APQ, etc).
    sizeEstimator.bytes +=
      20 +
      estimatedBytesForString(trace.clientName) +
      estimatedBytesForString(trace.clientVersion);
    const contextualizedStats = new OurContextualizedStats(statsContext);
    this.map[statsContextKey] = contextualizedStats;
    return contextualizedStats;
  }
}

export class OurContextualizedStats implements Required<IContextualizedStats> {
  queryLatencyStats = new OurQueryLatencyStats();
  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);

  constructor(readonly context: IStatsContext) {}

  ensureCountsAreIntegers() {
    for (const typeStat of Object.values(this.perTypeStat)) {
      typeStat.ensureCountsAreIntegers();
    }
  }

  // Extract statistics from the trace, and increment the estimated report size.
  // We only add to the estimate when adding whole sub-messages. If it really
  // mattered, we could do a lot more careful things like incrementing it
  // whenever a numeric field on queryLatencyStats gets incremented over 0.
  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {
    const { fieldExecutionWeight } = trace;
    if (!fieldExecutionWeight) {
      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
    }

    this.queryLatencyStats.requestCount++;
    if (trace.fullQueryCacheHit) {
      this.queryLatencyStats.cacheLatencyCount.incrementDuration(
        trace.durationNs,
      );
      this.queryLatencyStats.cacheHits++;
    } else {
      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);
    }

    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly
    // calculated by the backend), not for cache hits. This matches the
    // behavior we've had for a while when converting traces into statistics
    // in Studio's servers.
    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {
      switch (trace.cachePolicy.scope) {
        case Trace.CachePolicy.Scope.PRIVATE:
          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(
            trace.cachePolicy.maxAgeNs,
          );
          break;
        case Trace.CachePolicy.Scope.PUBLIC:
          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(
            trace.cachePolicy.maxAgeNs,
          );
          break;
      }
    }

    if (trace.persistedQueryHit) {
      this.queryLatencyStats.persistedQueryHits++;
    }
    if (trace.persistedQueryRegister) {
      this.queryLatencyStats.persistedQueryMisses++;
    }

    if (trace.forbiddenOperation) {
      this.queryLatencyStats.forbiddenOperationCount++;
    }
    if (trace.registeredOperation) {
      this.queryLatencyStats.registeredOperationCount++;
    }

    let hasError = false;

    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {
      // Generate error stats and error path information
      if (node.error?.length) {
        hasError = true;

        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
        path.toArray().forEach((subPath) => {
          currPathErrorStats = currPathErrorStats.getChild(
            subPath,
            sizeEstimator,
          );
        });

        currPathErrorStats.requestsWithErrorsCount += 1;
        currPathErrorStats.errorsCount += node.error.length;
      }

      if (fieldExecutionWeight) {
        // The actual field name behind the node; originalFieldName is set
        // if an alias was used, otherwise responseName. (This is falsey for
        // nodes that are not fields (root, array index, etc).)
        const fieldName = node.originalFieldName || node.responseName;

        // Protobuf doesn't really differentiate between "unset" and "falsey" so
        // we're mostly actually checking that these things are non-empty string /
        // non-zero numbers. The time fields represent the number of nanoseconds
        // since the beginning of the entire trace, so let's pretend for the
        // moment that it's plausible for a node to start or even end exactly when
        // the trace started (ie, for the time values to be 0). This is unlikely
        // in practice (everything should take at least 1ns). In practice we only
        // write `type` and `parentType` on a Node when we write `startTime`, so
        // the main thing we're looking out for by checking the time values is
        // whether we somehow failed to write `endTime` at the end of the field;
        // in this case, the `endTime >= startTime` check won't match.
        if (
          node.parentType &&
          fieldName &&
          node.type &&
          node.endTime != null &&
          node.startTime != null &&
          node.endTime >= node.startTime
        ) {
          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);

          const fieldStat = typeStat.getFieldStat(
            fieldName,
            node.type,
            sizeEstimator,
          );

          fieldStat.errorsCount += node.error?.length ?? 0;
          fieldStat.observedExecutionCount++;
          fieldStat.estimatedExecutionCount += fieldExecutionWeight;
          // Note: this is actually counting the number of resolver calls for this
          // field that had at least one error, not the number of overall GraphQL
          // queries that had at least one error for this field. That doesn't seem
          // to match the name, but it does match the other implementations of this
          // logic.
          fieldStat.requestsWithErrorsCount +=
            (node.error?.length ?? 0) > 0 ? 1 : 0;
          fieldStat.latencyCount.incrementDuration(
            node.endTime - node.startTime,
            // The latency histogram is always "estimated"; we don't track
            // "observed" and "estimated" separately.
            fieldExecutionWeight,
          );
        }
      }

      return false;
    };

    iterateOverTrace(trace, traceNodeStats, true);
    if (hasError) {
      this.queryLatencyStats.requestsWithErrorsCount++;
    }
  }

  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {
    const existing = this.perTypeStat[parentType];
    if (existing) {
      return existing;
    }
    sizeEstimator.bytes += estimatedBytesForString(parentType);
    const typeStat = new OurTypeStat();
    this.perTypeStat[parentType] = typeStat;
    return typeStat;
  }
}

class OurQueryLatencyStats implements Required<IQueryLatencyStats> {
  latencyCount: DurationHistogram = new DurationHistogram();
  requestCount = 0;
  requestsWithoutFieldInstrumentation = 0;
  cacheHits = 0;
  persistedQueryHits = 0;
  persistedQueryMisses = 0;
  cacheLatencyCount: DurationHistogram = new DurationHistogram();
  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();
  requestsWithErrorsCount = 0;
  publicCacheTtlCount: DurationHistogram = new DurationHistogram();
  privateCacheTtlCount: DurationHistogram = new DurationHistogram();
  registeredOperationCount = 0;
  forbiddenOperationCount = 0;
}

class OurPathErrorStats implements Required<IPathErrorStats> {
  children: { [k: string]: OurPathErrorStats } = Object.create(null);
  errorsCount = 0;
  requestsWithErrorsCount = 0;

  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {
    const existing = this.children[subPath];
    if (existing) {
      return existing;
    }
    const child = new OurPathErrorStats();
    this.children[subPath] = child;
    // Include a few bytes in the estimate for the numbers etc.
    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
    return child;
  }
}

class OurTypeStat implements Required<ITypeStat> {
  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);

  getFieldStat(
    fieldName: string,
    returnType: string,
    sizeEstimator: SizeEstimator,
  ): OurFieldStat {
    const existing = this.perFieldStat[fieldName];
    if (existing) {
      return existing;
    }
    // Rough estimate of 10 bytes for the numbers in the FieldStat.
    sizeEstimator.bytes +=
      estimatedBytesForString(fieldName) +
      estimatedBytesForString(returnType) +
      10;
    const fieldStat = new OurFieldStat(returnType);
    this.perFieldStat[fieldName] = fieldStat;
    return fieldStat;
  }

  ensureCountsAreIntegers() {
    for (const fieldStat of Object.values(this.perFieldStat)) {
      fieldStat.ensureCountsAreIntegers();
    }
  }
}

class OurFieldStat implements Required<IFieldStat> {
  errorsCount = 0;
  observedExecutionCount = 0;
  // Note that this number isn't necessarily an integer while it is being
  // aggregated. Before encoding as a protobuf we call ensureCountsAreIntegers
  // which floors it.
  estimatedExecutionCount = 0;
  requestsWithErrorsCount = 0;
  latencyCount: DurationHistogram = new DurationHistogram();

  constructor(readonly returnType: string) {}

  ensureCountsAreIntegers() {
    // This is the only one that ever can receive non-integers.
    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
  }
}

function estimatedBytesForString(s: string) {
  // 2 is for the tag (field ID + wire type) plus the encoded length. (The
  // encoded length takes up more than 1 byte for strings that are longer than
  // 127 bytes, but this is an estimate.)
  return 2 + Buffer.byteLength(s);
}
Ÿ /dist/esm/externalTypes/index.jsƒ,export {};
//# sourceMappingURL=index.js.mapŸ./dist/esm/plugin/usageReporting/index.d.ts.map≈{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,gCAAgC,EAAE,MAAM,aAAa,CAAC;AAC/D,YAAY,EACV,uCAAuC,EACvC,qBAAqB,EACrB,oBAAoB,EACpB,iBAAiB,EACjB,UAAU,EACV,kBAAkB,GACnB,MAAM,cAAc,CAAC"}Ÿ:/src/plugin/usageReporting/defaultSendOperationsAsTrace.ts≈Ñimport LRUCache from 'lru-cache';
import type { Trace } from '@apollo/usage-reporting-protobuf';
import { iterateOverTrace } from './iterateOverTrace.js';
import { DurationHistogram } from './durationHistogram.js';

export function defaultSendOperationsAsTrace() {
  // We keep an LRU cache mapping from a trace key (which consists of the
  // operation as defined by statsReportKey, the rough duration of the
  // operation, what minute the operation ended at, etc) to `true` if we've seen
  // it recently. We actually split this into one cache per minute so we can
  // throw away a full minute's worth of cache at once; we keep only the last
  // three minutes.
  // Note that if a trace is over a certain size, we will always send it as
  // stats. We check this within the addTrace function of the OurReport class so
  // that we don't have to encode these large traces twice.
  const cache = new LRUCache<string, true>({
    // 3MiB limit, very much approximately since we can't be sure how V8 might
    // be storing these strings internally. Though this should be enough to
    // store a fair amount of trace keys.

    // A future version of this might expose some
    // configuration option to grow the cache, but ideally, we could do that
    // dynamically based on the resources available to the server, and not add
    // more configuration surface area. Hopefully the warning message will allow
    // us to evaluate the need with more validated input from those that receive
    // it.
    maxSize: Math.pow(2, 20),
    sizeCalculation: (_val, key) => {
      return (key && Buffer.byteLength(key)) || 0;
    },
  });

  return (trace: Trace, statsReportKey: string): boolean => {
    const endTimeSeconds = trace.endTime?.seconds;
    if (endTimeSeconds == null) {
      throw Error('programming error: endTime not set on trace');
    }

    const hasErrors = traceHasErrors(trace);
    const cacheKey = JSON.stringify([
      statsReportKey,
      DurationHistogram.durationToBucket(trace.durationNs),
      // What minute it started at
      Math.floor(endTimeSeconds / 60),
      // If the trace has an error, send one errored trace per 5 second interval
      // instead of the normal minutely bucket a non-errored trace takes.
      hasErrors ? Math.floor(endTimeSeconds / 5) : '',
    ]);

    // If we've already seen something roughly like this, don't send as a trace.
    if (cache.get(cacheKey)) {
      return false;
    }

    cache.set(cacheKey, true);
    return true;
  };
}

// Returns true if any node on the trace has errors. (If this ends up being a
// hot spot, we can precalculate it in TraceTreeBuilder.)
function traceHasErrors(trace: Trace): boolean {
  let hasErrors = false;

  function traceNodeStats(node: Trace.INode): boolean {
    if ((node.error?.length ?? 0) > 0) {
      hasErrors = true;
    }
    return hasErrors;
  }

  iterateOverTrace(trace, traceNodeStats, false);
  return hasErrors;
}
Ÿ$/src/plugin/usageReporting/plugin.ts≈àUimport { Report, ReportHeader, Trace } from '@apollo/usage-reporting-protobuf';
import type { Fetcher, FetcherResponse } from '@apollo/utils.fetcher';
import {
  usageReportingSignature,
  calculateReferencedFieldsByType,
  ReferencedFieldsByType,
} from '@apollo/utils.usagereporting';
import retry from 'async-retry';
import { GraphQLSchema, printSchema } from 'graphql';
import type LRUCache from 'lru-cache';
import { AbortController } from 'node-abort-controller';
import fetch from 'node-fetch';
import os from 'os';
import { promisify } from 'util';
import { gzip } from 'zlib';
import type {
  ApolloServerPlugin,
  BaseContext,
  GraphQLRequestContext,
  GraphQLRequestContextDidResolveOperation,
  GraphQLRequestContextWillSendResponse,
  GraphQLRequestListener,
  GraphQLServerListener,
} from '../../externalTypes/index.js';
import { internalPlugin } from '../../internalPlugin.js';
import { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder.js';
import { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace.js';
import {
  createOperationDerivedDataCache,
  OperationDerivedData,
  operationDerivedDataCacheKey,
} from './operationDerivedDataCache.js';
import type {
  ApolloServerPluginUsageReportingOptions,
  SendValuesBaseOptions,
} from './options.js';
import { OurReport } from './stats.js';
import { makeTraceDetails } from './traceDetails.js';
import { packageVersion } from '../../generated/packageVersion.js';
import { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';
import type { HeaderMap } from '../../utils/HeaderMap.js';

const gzipPromise = promisify(gzip);

const reportHeaderDefaults = {
  hostname: os.hostname(),
  agentVersion: `@apollo/server@${packageVersion}`,
  runtimeVersion: `node ${process.version}`,
  // XXX not actually uname, but what node has easily.
  uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,
};

export function ApolloServerPluginUsageReporting<TContext extends BaseContext>(
  options: ApolloServerPluginUsageReportingOptions<TContext> = Object.create(
    null,
  ),
): ApolloServerPlugin<TContext> {
  // Note: We'd like to change the default to false in Apollo Server 4, so that
  // the default usage reporting experience doesn't include *anything* that
  // could potentially be PII (like error messages) --- just operations and
  // numbers.
  const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
  const fieldLevelInstrumentation =
    typeof fieldLevelInstrumentationOption === 'number'
      ? async () =>
          Math.random() < fieldLevelInstrumentationOption
            ? 1 / fieldLevelInstrumentationOption
            : 0
      : fieldLevelInstrumentationOption
      ? fieldLevelInstrumentationOption
      : async () => true;

  let requestDidStartHandler: (
    requestContext: GraphQLRequestContext<TContext>,
  ) => GraphQLRequestListener<TContext>;
  return internalPlugin({
    __internal_plugin_id__: 'UsageReporting',
    __is_disabled_plugin__: false,

    // We want to be able to access locals from `serverWillStart` in our `requestDidStart`, thus
    // this little hack. (Perhaps we should also allow GraphQLServerListener to contain
    // a requestDidStart?)
    async requestDidStart(requestContext: GraphQLRequestContext<TContext>) {
      if (!requestDidStartHandler) {
        throw Error(
          'The usage reporting plugin has been asked to handle a request before the ' +
            'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' +
            'for more details.',
        );
      }
      return requestDidStartHandler(requestContext);
    },

    async serverWillStart({
      logger: serverLogger,
      apollo,
      startedInBackground,
    }): Promise<GraphQLServerListener> {
      // Use the plugin-specific logger if one is provided; otherwise the general server one.
      const logger = options.logger ?? serverLogger;
      const { key, graphRef } = apollo;
      if (!(key && graphRef)) {
        throw new Error(
          "You've enabled usage reporting via ApolloServerPluginUsageReporting, " +
            'but you also need to provide your Apollo API key and graph ref, via ' +
            'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +
            'variables or via `new ApolloServer({apollo: {key, graphRef})`.',
        );
      }

      logger.info(
        'Apollo usage reporting starting! See your graph at ' +
          `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`,
      );

      // If sendReportsImmediately is not specified, we default to true if we're running
      // with the ApolloServer designed for Lambda or similar. That's because these
      // environments aren't designed around letting us run a background task to
      // send reports later or hook into container destruction to flush buffered reports.
      const sendReportsImmediately =
        options.sendReportsImmediately ?? startedInBackground;

      // Since calculating the signature and referenced fields for usage
      // reporting is potentially an expensive operation, we'll cache the data
      // we generate and re-use them for repeated operations for the same
      // `queryHash`. However, because referenced fields depend on the current
      // schema, we want to throw it out entirely any time the schema changes.
      let operationDerivedDataCache: {
        forSchema: GraphQLSchema;
        cache: LRUCache<string, OperationDerivedData>;
      } | null = null;

      // This map maps from executable schema ID (schema hash, basically) to the
      // report we'll send about it. That's because when we're using a gateway,
      // the schema can change over time, but each report needs to be about a
      // single schema. We avoid having this function be a memory leak by
      // removing values from it when we're in the process of sending reports.
      // That means we have to be very careful never to pull a Report out of it
      // and hang on to it for a while before writing to it, because the report
      // might have gotten sent and discarded in the meantime. So you should
      // only access the values of this Map via
      // getReportWhichMustBeUsedImmediately and getAndDeleteReport, and never
      // hang on to the value returned by getReportWhichMustBeUsedImmediately.
      const reportByExecutableSchemaId = new Map<string, OurReport>();
      const getReportWhichMustBeUsedImmediately = (
        executableSchemaId: string,
      ): OurReport => {
        const existing = reportByExecutableSchemaId.get(executableSchemaId);
        if (existing) {
          return existing;
        }
        const report = new OurReport(
          new ReportHeader({
            ...reportHeaderDefaults,
            executableSchemaId,
            graphRef,
          }),
        );
        reportByExecutableSchemaId.set(executableSchemaId, report);
        return report;
      };
      const getAndDeleteReport = (
        executableSchemaId: string,
      ): OurReport | null => {
        const report = reportByExecutableSchemaId.get(executableSchemaId);
        if (report) {
          reportByExecutableSchemaId.delete(executableSchemaId);
          return report;
        }
        return null;
      };

      const overriddenExecutableSchemaId = options.overrideReportedSchema
        ? computeCoreSchemaHash(options.overrideReportedSchema)
        : undefined;

      let lastSeenExecutableSchemaToId:
        | {
            executableSchema: GraphQLSchema;
            executableSchemaId: string;
          }
        | undefined;

      let reportTimer: NodeJS.Timer | undefined;
      if (!sendReportsImmediately) {
        reportTimer = setInterval(
          () => sendAllReportsAndReportErrors(),
          options.reportIntervalMs || 10 * 1000,
        );
      }

      // We don't send traces if the user set `sendTraces: false`. We also may
      // set this to false later if the usage-reporting ingress informs us that
      // this graph does not support viewing traces.
      let sendTraces = options.sendTraces ?? true;
      const sendOperationAsTrace =
        options.experimental_sendOperationAsTrace ??
        defaultSendOperationsAsTrace();

      let stopped = false;

      function executableSchemaIdForSchema(schema: GraphQLSchema) {
        if (lastSeenExecutableSchemaToId?.executableSchema === schema) {
          return lastSeenExecutableSchemaToId.executableSchemaId;
        }
        const id = computeCoreSchemaHash(printSchema(schema));

        // We override this variable every time we get a new schema so we cache
        // the last seen value. It is a single-entry cache.
        lastSeenExecutableSchemaToId = {
          executableSchema: schema,
          executableSchemaId: id,
        };

        return id;
      }

      async function sendAllReportsAndReportErrors(): Promise<void> {
        await Promise.all(
          [...reportByExecutableSchemaId.keys()].map((executableSchemaId) =>
            sendReportAndReportErrors(executableSchemaId),
          ),
        );
      }

      async function sendReportAndReportErrors(
        executableSchemaId: string,
      ): Promise<void> {
        return sendReport(executableSchemaId).catch((err) => {
          // This catch block is primarily intended to catch network errors from
          // the retried request itself, which include network errors and non-2xx
          // HTTP errors.
          if (options.reportErrorFunction) {
            options.reportErrorFunction(err);
          } else {
            logger.error(err.message);
          }
        });
      }

      // Needs to be an arrow function to be confident that key is defined.
      const sendReport = async (executableSchemaId: string): Promise<void> => {
        let report = getAndDeleteReport(executableSchemaId);
        if (
          !report ||
          (Object.keys(report.tracesPerQuery).length === 0 &&
            report.operationCount === 0)
        ) {
          return;
        }

        // Set the report's overall end time. This is the timestamp that will be
        // associated with the summarized statistics.
        report.endTime = dateToProtoTimestamp(new Date());

        report.ensureCountsAreIntegers();

        const protobufError = Report.verify(report);
        if (protobufError) {
          throw new Error(`Error verifying report: ${protobufError}`);
        }
        let message: Uint8Array | null = Report.encode(report).finish();
        // Let the original protobuf object be garbage collected (helpful if the
        // HTTP request hangs).
        report = null;

        // Potential follow-up: we can compare message.length to
        // report.sizeEstimator.bytes and use it to "learn" if our estimation is
        // off and adjust it based on what we learn.

        if (options.debugPrintReports) {
          // We decode the report rather than printing the original `report`
          // so that it includes all of the pre-encoded traces.
          const decodedReport = Report.decode(message);
          logger.info(
            `Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`,
          );
        }

        const compressed = await gzipPromise(message);
        // Let the uncompressed message be garbage collected (helpful if the
        // HTTP request is slow).
        message = null;

        // Wrap fetcher with async-retry for automatic retrying
        const fetcher: Fetcher = options.fetcher ?? fetch;
        const response: FetcherResponse = await retry(
          // Retry on network errors and 5xx HTTP
          // responses.
          async () => {
            // Note that once we require Node v16 we can use its global
            // AbortController instead of the one from `node-abort-controller`.
            const controller = new AbortController();
            const abortTimeout = setTimeout(() => {
              controller.abort();
            }, options.requestTimeoutMs ?? 30_000);
            let curResponse;
            try {
              curResponse = await fetcher(
                (options.endpointUrl ||
                  'https://usage-reporting.api.apollographql.com') +
                  '/api/ingress/traces',
                {
                  method: 'POST',
                  headers: {
                    'user-agent': 'ApolloServerPluginUsageReporting',
                    'x-api-key': key,
                    'content-encoding': 'gzip',
                    accept: 'application/json',
                  },
                  body: compressed,
                  signal: controller.signal,
                },
              );
            } finally {
              clearTimeout(abortTimeout);
            }

            if (curResponse.status >= 500 && curResponse.status < 600) {
              throw new Error(
                `HTTP status ${curResponse.status}, ${
                  (await curResponse.text()) || '(no body)'
                }`,
              );
            } else {
              return curResponse;
            }
          },
          {
            retries: (options.maxAttempts || 5) - 1,
            minTimeout: options.minimumRetryDelayMs || 100,
            factor: 2,
          },
        ).catch((err: Error) => {
          throw new Error(
            `Error sending report to Apollo servers: ${err.message}`,
          );
        });

        if (response.status < 200 || response.status >= 300) {
          // Note that we don't expect to see a 3xx here because request follows
          // redirects.
          throw new Error(
            `Error sending report to Apollo servers: HTTP status ${
              response.status
            }, ${(await response.text()) || '(no body)'}`,
          );
        }

        if (
          sendTraces &&
          response.status === 200 &&
          response.headers
            .get('content-type')
            ?.match(/^\s*application\/json\s*(?:;|$)/i)
        ) {
          const body = await response.text();
          let parsedBody;
          try {
            parsedBody = JSON.parse(body);
          } catch (e) {
            throw new Error(`Error parsing response from Apollo servers: ${e}`);
          }
          if (parsedBody.tracesIgnored === true) {
            logger.debug(
              "This graph's organization does not have access to traces; sending all " +
                'subsequent operations as stats.',
            );
            sendTraces = false;
          }
        }
        if (options.debugPrintReports) {
          logger.info(`Apollo usage report: status ${response.status}`);
        }
      };

      requestDidStartHandler = ({
        metrics,
        schema,
        request: { http, variables },
      }): GraphQLRequestListener<TContext> => {
        const treeBuilder: TraceTreeBuilder = new TraceTreeBuilder({
          maskedBy: 'ApolloServerPluginUsageReporting',
          sendErrors: options.sendErrors,
          logger,
        });
        treeBuilder.startTiming();
        metrics.startHrTime = treeBuilder.startHrTime;
        let graphqlValidationFailure = false;
        let graphqlUnknownOperationName = false;
        let includeOperationInUsageReporting: boolean | null = null;

        if (http) {
          treeBuilder.trace.http = new Trace.HTTP({
            method:
              Trace.HTTP.Method[
                http.method as keyof typeof Trace.HTTP.Method
              ] || Trace.HTTP.Method.UNKNOWN,
            // Host and path are not used anywhere on the backend, so let's not bother
            // trying to parse request.url to get them, which is a potential
            // source of bugs because integrations have different behavior here.
            // On Node's HTTP module, request.url only includes the path
            // (see https://nodejs.org/api/http.html#http_message_url)
            // The same is true on Lambda (where we pass event.path)
            // But on environments like Cloudflare we do get a complete URL.
            host: null,
            path: null,
          });

          if (options.sendHeaders) {
            makeHTTPRequestHeaders(
              treeBuilder.trace.http,
              http.headers,
              options.sendHeaders,
            );
          }
        }

        // After this function completes, includeOperationInUsageReporting is
        // defined.
        async function maybeCallIncludeRequestHook(
          requestContext:
            | GraphQLRequestContextDidResolveOperation<TContext>
            | GraphQLRequestContextWillSendResponse<TContext>,
        ): Promise<void> {
          // If this is the second call in `willSendResponse` after
          // `didResolveOperation`, we're done.
          if (includeOperationInUsageReporting !== null) return;

          if (typeof options.includeRequest !== 'function') {
            // Default case we always report
            includeOperationInUsageReporting = true;
            return;
          }
          includeOperationInUsageReporting = await options.includeRequest(
            requestContext,
          );

          // Help the user understand they've returned an unexpected value,
          // which might be a subtle mistake.
          if (typeof includeOperationInUsageReporting !== 'boolean') {
            logger.warn(
              "The 'includeRequest' async predicate function must return a boolean value.",
            );
            includeOperationInUsageReporting = true;
          }
        }

        // Our usage reporting groups everything by operation, so we don't
        // actually report about any issues that prevent us from getting an
        // operation string (eg, a missing operation, or APQ problems).
        // This is effectively bypassing the reporting of:
        //   - PersistedQueryNotFoundError
        //   - PersistedQueryNotSupportedError
        //   - Missing `query` error
        // We may want to report them some other way later!
        let didResolveSource = false;

        return {
          async didResolveSource(requestContext) {
            didResolveSource = true;

            if (metrics.persistedQueryHit) {
              treeBuilder.trace.persistedQueryHit = true;
            }
            if (metrics.persistedQueryRegister) {
              treeBuilder.trace.persistedQueryRegister = true;
            }

            if (variables) {
              treeBuilder.trace.details = makeTraceDetails(
                variables,
                options.sendVariableValues,
                requestContext.source,
              );
            }

            const clientInfo = (
              options.generateClientInfo || defaultGenerateClientInfo
            )(requestContext);
            if (clientInfo) {
              // While there is a clientAddress protobuf field, the backend
              // doesn't pay attention to it yet, so we'll ignore it for now.
              const { clientName, clientVersion } = clientInfo;
              treeBuilder.trace.clientVersion = clientVersion || '';
              treeBuilder.trace.clientName = clientName || '';
            }
          },
          async validationDidStart() {
            return async (validationErrors?: ReadonlyArray<Error>) => {
              graphqlValidationFailure = validationErrors
                ? validationErrors.length !== 0
                : false;
            };
          },
          async didResolveOperation(requestContext) {
            // If operation is undefined then `getOperationAST` returned null
            // and an unknown operation was specified.
            graphqlUnknownOperationName =
              requestContext.operation === undefined;
            await maybeCallIncludeRequestHook(requestContext);

            if (
              includeOperationInUsageReporting &&
              // No need to capture traces if the operation is going to
              // immediately fail due to unknown operation name.
              !graphqlUnknownOperationName
            ) {
              if (metrics.captureTraces === undefined) {
                // We're not completely ignoring the operation. But should we
                // calculate a detailed trace of every field while we do so (either
                // directly in this plugin, or in a subgraph by sending the
                // apollo-federation-include-trace header)? That will allow this
                // operation to contribute to the "field executions" column in the
                // Studio Fields page, to the timing hints in Explorer and
                // vscode-graphql, and to the traces visible under Operations. (Note
                // that `true` here does not imply that this operation will
                // necessarily be *sent* to the usage-reporting endpoint in the form
                // of a trace --- it still might be aggregated into stats first. But
                // capturing a trace will mean we can understand exactly what fields
                // were executed and what their performance was, at the tradeoff of
                // some overhead for tracking the trace (and transmitting it between
                // subgraph and gateway).
                const rawWeight = await fieldLevelInstrumentation(
                  requestContext,
                );
                treeBuilder.trace.fieldExecutionWeight =
                  typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;

                metrics.captureTraces =
                  !!treeBuilder.trace.fieldExecutionWeight;
              }
            }
          },
          async executionDidStart() {
            // If we're not capturing traces, don't return a willResolveField so
            // that we don't build up a detailed trace inside treeBuilder. (We still
            // will use treeBuilder as a convenient place to put top-level facts
            // about the operation which can end up aggregated as stats, and we do
            // eventually put *errors* onto the trace tree.)
            if (!metrics.captureTraces) return;

            return {
              willResolveField({ info }) {
                return treeBuilder.willResolveField(info);
                // We could save the error into the trace during the end handler, but
                // it won't have all the information that graphql-js adds to it later,
                // like 'locations'.
              },
            };
          },

          async didEncounterSubsequentErrors(_requestContext, errors) {
            treeBuilder.didEncounterErrors(errors);
          },

          async willSendSubsequentPayload(requestContext, payload) {
            if (!payload.hasNext) {
              await operationFinished(requestContext);
            }
          },

          async willSendResponse(requestContext) {
            // Search above for a comment about "didResolveSource" to see which
            // of the pre-source-resolution errors we are intentionally avoiding.
            if (!didResolveSource) return;
            if (requestContext.errors) {
              treeBuilder.didEncounterErrors(requestContext.errors);
            }

            // If there isn't any defer/stream coming later, we're done.
            // Otherwise willSendSubsequentPayload will trigger
            // operationFinished.
            if (requestContext.response.body.kind === 'single') {
              await operationFinished(requestContext);
            }
          },
        };

        async function operationFinished(
          requestContext: GraphQLRequestContextWillSendResponse<TContext>,
        ) {
          const resolvedOperation = !!requestContext.operation;

          // If we got an error before we called didResolveOperation (eg parse or
          // validation error), check to see if we should include the request.
          await maybeCallIncludeRequestHook(requestContext);

          treeBuilder.stopTiming();
          const executableSchemaId =
            overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema);

          if (includeOperationInUsageReporting === false) {
            if (resolvedOperation) {
              getReportWhichMustBeUsedImmediately(executableSchemaId)
                .operationCount++;
            }
            return;
          }

          treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
          treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
          treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;

          const policyIfCacheable =
            requestContext.overallCachePolicy.policyIfCacheable();
          if (policyIfCacheable) {
            treeBuilder.trace.cachePolicy = new Trace.CachePolicy({
              scope:
                policyIfCacheable.scope === 'PRIVATE'
                  ? Trace.CachePolicy.Scope.PRIVATE
                  : policyIfCacheable.scope === 'PUBLIC'
                  ? Trace.CachePolicy.Scope.PUBLIC
                  : Trace.CachePolicy.Scope.UNKNOWN,
              // Convert from seconds to ns.
              maxAgeNs: policyIfCacheable.maxAge * 1e9,
            });
          }

          // If this was a federated operation and we're the gateway, add the query plan
          // to the trace.
          if (metrics.queryPlanTrace) {
            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
          }

          // Intentionally un-awaited so as not to block the response.  Any
          // errors will be logged, but will not manifest a user-facing error.
          // The logger in this case is a request specific logger OR the logger
          // defined by the plugin if that's unavailable.  The request-specific
          // logger is preferred since this is very much coupled directly to a
          // client-triggered action which might be more granularly tagged by
          // logging implementations.
          addTrace().catch(logger.error);

          async function addTrace(): Promise<void> {
            // Ignore traces that come in after stop().
            if (stopped) {
              return;
            }

            // Ensure that the caller of addTrace (which does not await it) is
            // not blocked. We use setImmediate rather than process.nextTick or
            // just relying on the Promise microtask queue because setImmediate
            // comes after IO, which is what we want.
            await new Promise((res) => setImmediate(res));

            const executableSchemaId =
              overriddenExecutableSchemaId ??
              executableSchemaIdForSchema(schema);

            const { trace } = treeBuilder;

            let statsReportKey: string | undefined = undefined;
            let referencedFieldsByType: ReferencedFieldsByType;
            if (!requestContext.document) {
              statsReportKey = `## GraphQLParseFailure\n`;
            } else if (graphqlValidationFailure) {
              statsReportKey = `## GraphQLValidationFailure\n`;
            } else if (graphqlUnknownOperationName) {
              statsReportKey = `## GraphQLUnknownOperationName\n`;
            }

            const isExecutable = statsReportKey === undefined;

            if (statsReportKey) {
              if (options.sendUnexecutableOperationDocuments) {
                trace.unexecutedOperationBody = requestContext.source;
                // Get the operation name from the request (which might not
                // correspond to an actual operation).
                trace.unexecutedOperationName =
                  requestContext.request.operationName || '';
              }
              referencedFieldsByType = Object.create(null);
            } else {
              const operationDerivedData = getOperationDerivedData();
              statsReportKey = `# ${requestContext.operationName || '-'}\n${
                operationDerivedData.signature
              }`;
              referencedFieldsByType =
                operationDerivedData.referencedFieldsByType;
            }

            const protobufError = Trace.verify(trace);
            if (protobufError) {
              throw new Error(`Error encoding trace: ${protobufError}`);
            }

            if (resolvedOperation) {
              getReportWhichMustBeUsedImmediately(executableSchemaId)
                .operationCount++;
            }

            getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({
              statsReportKey,
              trace,
              // We include the operation as a trace (rather than aggregated
              // into stats) only if the user didn't set `sendTraces: false`
              // *and* we believe it's possible that our organization's plan
              // allows for viewing traces *and* we actually captured this as
              // a full trace *and* sendOperationAsTrace says so.
              //
              // (As an edge case, if the reason metrics.captureTraces is
              // falsey is that this is an unexecutable operation and thus we
              // never ran the code in didResolveOperation that sets
              // metrics.captureTrace, we allow it to be sent as a trace. This
              // means we'll still send some parse and validation failures as
              // traces, for the sake of the Errors page.)
              asTrace:
                sendTraces &&
                (!isExecutable || !!metrics.captureTraces) &&
                sendOperationAsTrace(trace, statsReportKey),
              referencedFieldsByType,
            });

            // If the buffer gets big (according to our estimate), send.
            if (
              sendReportsImmediately ||
              getReportWhichMustBeUsedImmediately(executableSchemaId)
                .sizeEstimator.bytes >=
                (options.maxUncompressedReportSize || 4 * 1024 * 1024)
            ) {
              await sendReportAndReportErrors(executableSchemaId);
            }
          }

          // Calculates signature and referenced fields for the current document.
          // Only call this when the document properly parses and validates and
          // the given operation name (if any) is known!
          function getOperationDerivedData(): OperationDerivedData {
            if (!requestContext.document) {
              // This shouldn't happen: no document means parse failure, which
              // uses its own special statsReportKey.
              throw new Error('No document?');
            }

            const cacheKey = operationDerivedDataCacheKey(
              requestContext.queryHash,
              requestContext.operationName || '',
            );

            // Ensure that the cache we have is for the right schema.
            if (
              !operationDerivedDataCache ||
              operationDerivedDataCache.forSchema !== schema
            ) {
              operationDerivedDataCache = {
                forSchema: schema,
                cache: createOperationDerivedDataCache({ logger }),
              };
            }

            // If we didn't have the signature in the cache, we'll resort to
            // calculating it.
            const cachedOperationDerivedData =
              operationDerivedDataCache.cache.get(cacheKey);
            if (cachedOperationDerivedData) {
              return cachedOperationDerivedData;
            }

            const generatedSignature = (
              options.calculateSignature || usageReportingSignature
            )(requestContext.document, requestContext.operationName || '');

            const generatedOperationDerivedData: OperationDerivedData = {
              signature: generatedSignature,
              referencedFieldsByType: calculateReferencedFieldsByType({
                document: requestContext.document,
                schema,
                resolvedOperationName: requestContext.operationName ?? null,
              }),
            };

            // Note that this cache is always an in-memory cache.
            // If we replace it with a more generic async cache, we should
            // not await the write operation.
            operationDerivedDataCache.cache.set(
              cacheKey,
              generatedOperationDerivedData,
            );
            return generatedOperationDerivedData;
          }
        }
      };

      return {
        async serverWillStop() {
          if (reportTimer) {
            clearInterval(reportTimer);
            reportTimer = undefined;
          }

          stopped = true;
          await sendAllReportsAndReportErrors();
        },
      };
    },
  });
}

export function makeHTTPRequestHeaders(
  http: Trace.IHTTP,
  headers: HeaderMap,
  sendHeaders?: SendValuesBaseOptions,
): void {
  if (
    !sendHeaders ||
    ('none' in sendHeaders && sendHeaders.none) ||
    ('all' in sendHeaders && !sendHeaders.all)
  ) {
    return;
  }
  for (const [key, value] of headers) {
    // Note that HeaderMap keys are already lower-case.
    if (
      ('exceptNames' in sendHeaders &&
        // We assume that most users only have a few headers to hide, or will
        // just set {none: true} ; we can change this linear-time
        // operation if it causes real performance issues.
        sendHeaders.exceptNames.some((exceptHeader) => {
          // Headers are case-insensitive, and should be compared as such.
          return exceptHeader.toLowerCase() === key;
        })) ||
      ('onlyNames' in sendHeaders &&
        !sendHeaders.onlyNames.some((header) => {
          return header.toLowerCase() === key;
        }))
    ) {
      continue;
    }

    switch (key) {
      case 'authorization':
      case 'cookie':
      case 'set-cookie':
        break;
      default:
        http!.requestHeaders![key] = new Trace.HTTP.Values({
          value: [value],
        });
    }
  }
}

function defaultGenerateClientInfo<TContext extends BaseContext>({
  request,
}: GraphQLRequestContext<TContext>) {
  const clientNameHeaderKey = 'apollographql-client-name';
  const clientVersionHeaderKey = 'apollographql-client-version';

  // Default to using the `apollo-client-x` header fields if present.
  // If none are present, fallback on the `clientInfo` query extension
  // for backwards compatibility.
  // The default value if neither header values nor query extension is
  // set is the empty String for all fields (as per protobuf defaults)
  if (
    request.http?.headers?.get(clientNameHeaderKey) ||
    request.http?.headers?.get(clientVersionHeaderKey)
  ) {
    return {
      clientName: request.http?.headers?.get(clientNameHeaderKey),
      clientVersion: request.http?.headers?.get(clientVersionHeaderKey),
    };
  } else if (request.extensions?.clientInfo) {
    return request.extensions.clientInfo;
  } else {
    return {};
  }
}
Ω/plugin/disabled/package.jsonƒˇ{
  "name": "@apollo/server/plugin/disabled",
  "type": "module",
  "main": "../../dist/cjs/plugin/disabled/index.js",
  "module": "../../dist/esm/plugin/disabled/index.js",
  "types": "../../dist/esm/plugin/disabled/index.d.ts",
  "sideEffects": false
}
Ÿ</dist/esm/plugin/usageReporting/operationDerivedDataCache.js≈¿import LRUCache from 'lru-cache';
export function createOperationDerivedDataCache({ logger, }) {
    let lastWarn;
    let lastDisposals = 0;
    return new LRUCache({
        sizeCalculation(obj) {
            return Buffer.byteLength(JSON.stringify(obj), 'utf8');
        },
        maxSize: Math.pow(2, 20) * 10,
        dispose() {
            lastDisposals++;
            if (!lastWarn || new Date().getTime() - lastWarn.getTime() > 60000) {
                lastWarn = new Date();
                logger.warn([
                    'This server is processing a high number of unique operations.  ',
                    `A total of ${lastDisposals} records have been `,
                    'ejected from the ApolloServerPluginUsageReporting signature cache in the past ',
                    'interval.  If you see this warning frequently, please open an ',
                    'issue on the Apollo Server repository.',
                ].join(''));
                lastDisposals = 0;
            }
        },
    });
}
export function operationDerivedDataCacheKey(queryHash, operationName) {
    return `${queryHash}${operationName && ':' + operationName}`;
}
//# sourceMappingURL=operationDerivedDataCache.js.map∏/dist/esm/cachePolicy.js≈∑export function newCachePolicy() {
    return {
        maxAge: undefined,
        scope: undefined,
        restrict(hint) {
            if (hint.maxAge !== undefined &&
                (this.maxAge === undefined || hint.maxAge < this.maxAge)) {
                this.maxAge = hint.maxAge;
            }
            if (hint.scope !== undefined && this.scope !== 'PRIVATE') {
                this.scope = hint.scope;
            }
        },
        replace(hint) {
            if (hint.maxAge !== undefined) {
                this.maxAge = hint.maxAge;
            }
            if (hint.scope !== undefined) {
                this.scope = hint.scope;
            }
        },
        policyIfCacheable() {
            if (this.maxAge === undefined || this.maxAge === 0) {
                return null;
            }
            return { maxAge: this.maxAge, scope: this.scope ?? 'PUBLIC' };
        },
    };
}
//# sourceMappingURL=cachePolicy.js.mapŸ//dist/esm/plugin/usageReporting/traceDetails.js≈	 import { Trace } from '@apollo/usage-reporting-protobuf';
export function makeTraceDetails(variables, sendVariableValues, operationString) {
    const details = new Trace.Details();
    const variablesToRecord = (() => {
        if (sendVariableValues && 'transform' in sendVariableValues) {
            const originalKeys = Object.keys(variables);
            try {
                const modifiedVariables = sendVariableValues.transform({
                    variables: variables,
                    operationString: operationString,
                });
                return cleanModifiedVariables(originalKeys, modifiedVariables);
            }
            catch (e) {
                return handleVariableValueTransformError(originalKeys);
            }
        }
        else {
            return variables;
        }
    })();
    Object.keys(variablesToRecord).forEach((name) => {
        if (!sendVariableValues ||
            ('none' in sendVariableValues && sendVariableValues.none) ||
            ('all' in sendVariableValues && !sendVariableValues.all) ||
            ('exceptNames' in sendVariableValues &&
                sendVariableValues.exceptNames.includes(name)) ||
            ('onlyNames' in sendVariableValues &&
                !sendVariableValues.onlyNames.includes(name))) {
            details.variablesJson[name] = '';
        }
        else {
            try {
                details.variablesJson[name] =
                    typeof variablesToRecord[name] === 'undefined'
                        ? ''
                        : JSON.stringify(variablesToRecord[name]);
            }
            catch (e) {
                details.variablesJson[name] = JSON.stringify('[Unable to convert value to JSON]');
            }
        }
    });
    return details;
}
function handleVariableValueTransformError(variableNames) {
    const modifiedVariables = Object.create(null);
    variableNames.forEach((name) => {
        modifiedVariables[name] = '[PREDICATE_FUNCTION_ERROR]';
    });
    return modifiedVariables;
}
function cleanModifiedVariables(originalKeys, modifiedVariables) {
    const cleanedVariables = Object.create(null);
    originalKeys.forEach((name) => {
        cleanedVariables[name] = modifiedVariables[name];
    });
    return cleanedVariables;
}
//# sourceMappingURL=traceDetails.js.mapŸ*/dist/cjs/plugin/cacheControl/index.js.map≈+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/cacheControl/index.ts"],"names":[],"mappings":"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"}Ÿ6/dist/esm/plugin/schemaReporting/schemaReporter.js.map≈{"version":3,"file":"schemaReporter.js","sourceRoot":"","sources":["../../../../src/plugin/schemaReporting/schemaReporter.ts"],"names":[],"mappings":"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"}Ÿ1/dist/cjs/plugin/landingPage/default/index.js.map≈ {"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/index.ts"],"names":[],"mappings":";;;AAUA,6DAG8B;AAO9B,SAAgB,yCAAyC,CACvD,UAA4D,EAAE;IAE9D,MAAM,EAAE,OAAO,EAAE,4BAA4B,EAAE,GAAG,IAAI,EAAE,GAAG;QAEzD,KAAK,EAAE,IAAa;QACpB,GAAG,OAAO;KACX,CAAC;IACF,OAAO,oCAAoC,CAAC,OAAO,EAAE;QACnD,MAAM,EAAE,KAAK;QACb,eAAe,EAAE,4BAA4B;QAC7C,GAAG,IAAI;KACR,CAAC,CAAC;AACL,CAAC;AAbD,8FAaC;AAED,SAAgB,8CAA8C,CAC5D,UAAiE,EAAE;IAEnE,MAAM,EAAE,OAAO,EAAE,4BAA4B,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;IACnE,OAAO,oCAAoC,CAAC,OAAO,EAAE;QACnD,MAAM,EAAE,IAAI;QACZ,eAAe,EAAE,4BAA4B;QAC7C,GAAG,IAAI;KACR,CAAC,CAAC;AACL,CAAC;AATD,wGASC;AAUD,SAAS,YAAY,CAAC,MAAyB;IAC7C,OAAO,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACpE,CAAC;AAED,MAAM,6BAA6B,GAAG,CACpC,OAAe,EACf,MAAyB,EACzB,EAAE;IACF,MAAM,aAAa,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC;IAE3C,OAAO;;;;;+BAKsB,aAAa;wEAC4B,OAAO,+BAA+B,CAAC;AAC/G,CAAC,CAAC;AAGF,SAAS,oCAAoC,CAC3C,YAAgC,EAChC,MAGC;IAED,MAAM,OAAO,GAAG,YAAY,IAAI,SAAS,CAAC;IAE1C,OAAO;QACL,iCAAiC,EAAE,KAAK;QACxC,KAAK,CAAC,eAAe;YACnB,OAAO;gBACL,KAAK,CAAC,iBAAiB;oBACrB,MAAM,IAAI,GAAG;;;;;;;uEAOgD,OAAO;;;;;;;;;;;;uEAYP,OAAO;;;;uEAIP,OAAO;;;;;;;;;;;;;;;;;;;;MAqBxE,MAAM,CAAC,KAAK;wBACV,CAAC,CAAC,UAAU,IAAI,MAAM,IAAI,MAAM,CAAC,QAAQ;4BACvC,CAAC,CAAC,IAAA,4CAAuB,EAAC,OAAO,EAAE,MAAM,CAAC;4BAC1C,CAAC,CAAC,IAAA,2CAAsB,EAAC,OAAO,EAAE,MAAM,CAAC;wBAC3C,CAAC,CAAC,6BAA6B,CAAC,OAAO,EAAE,MAAM,CACnD;;;;WAIO,CAAC;oBACF,OAAO,EAAE,IAAI,EAAE,CAAC;gBAClB,CAAC;aACF,CAAC;QACJ,CAAC;KACF,CAAC;AACJ,CAAC"}Ÿ&/dist/cjs/plugin/disabled/index.js.map≈ã{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/disabled/index.ts"],"names":[],"mappings":";;;AAcA,SAAS,cAAc,CAAC,EAAoB;IAC1C,MAAM,MAAM,GAA4C;QACtD,sBAAsB,EAAE,EAAE;QAC1B,sBAAsB,EAAE,IAAI;KAC7B,CAAC;IACF,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAgB,sCAAsC;IACpD,OAAO,cAAc,CAAC,cAAc,CAAC,CAAC;AACxC,CAAC;AAFD,wFAEC;AAED,SAAgB,qCAAqC;IACnD,OAAO,cAAc,CAAC,aAAa,CAAC,CAAC;AACvC,CAAC;AAFD,sFAEC;AAED,SAAgB,qCAAqC;IACnD,OAAO,cAAc,CAAC,qBAAqB,CAAC,CAAC;AAC/C,CAAC;AAFD,sFAEC;AAED,SAAgB,yCAAyC;IACvD,OAAO,cAAc,CAAC,iBAAiB,CAAC,CAAC;AAC3C,CAAC;AAFD,8FAEC;AAED,SAAgB,wCAAwC;IACtD,OAAO,cAAc,CAAC,gBAAgB,CAAC,CAAC;AAC1C,CAAC;AAFD,4FAEC"}Ÿ8/dist/esm/plugin/schemaReporting/schemaReporter.d.ts.map≈L{"version":3,"file":"schemaReporter.d.ts","sourceRoot":"","sources":["../../../../src/plugin/schemaReporting/schemaReporter.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,KAAK,EACV,YAAY,EAGZ,oBAAoB,EACrB,MAAM,wBAAwB,CAAC;AAChC,OAAO,KAAK,EAAE,OAAO,EAAE,MAAM,uBAAuB,CAAC;AAGrD,eAAO,MAAM,eAAe,kTAa3B,CAAC;AAGF,qBAAa,cAAc;IAEzB,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAe;IAC5C,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAS;IACpC,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAS;IACrC,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAS;IAChC,OAAO,CAAC,QAAQ,CAAC,yBAAyB,CAAS;IACnD,OAAO,CAAC,QAAQ,CAAC,0BAA0B,CAAS;IACpD,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAU;IAElC,OAAO,CAAC,SAAS,CAAU;IAC3B,OAAO,CAAC,SAAS,CAAC,CAAe;IACjC,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAyB;gBAErC,OAAO,EAAE;QACnB,YAAY,EAAE,YAAY,CAAC;QAC3B,UAAU,EAAE,MAAM,CAAC;QACnB,MAAM,EAAE,MAAM,CAAC;QACf,WAAW,EAAE,MAAM,GAAG,SAAS,CAAC;QAChC,MAAM,EAAE,MAAM,CAAC;QACf,yBAAyB,EAAE,MAAM,CAAC;QAClC,0BAA0B,EAAE,MAAM,CAAC;QACnC,OAAO,CAAC,EAAE,OAAO,CAAC;KACnB;IAqBM,OAAO,IAAI,OAAO;IAIlB,KAAK;IAOL,IAAI;YAQG,4BAA4B;IAiC7B,YAAY,CACvB,cAAc,EAAE,OAAO,GACtB,OAAO,CAAC,oBAAoB,GAAG,IAAI,CAAC;YAwCzB,WAAW;CAsC1B"}æ/dist/esm/requestPipeline.d.ts≈Ñimport type { GraphQLRequestContext, BaseContext, GraphQLResponse } from './externalTypes/index.js';
import type { ApolloServer, ApolloServerInternals, SchemaDerivedData } from './ApolloServer.js';
export declare const APQ_CACHE_PREFIX = "apq:";
declare type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
export declare function processGraphQLRequest<TContext extends BaseContext>(schemaDerivedData: SchemaDerivedData, server: ApolloServer<TContext>, internals: ApolloServerInternals<TContext>, requestContext: Mutable<GraphQLRequestContext<TContext>>): Promise<GraphQLResponse>;
export {};
//# sourceMappingURL=requestPipeline.d.ts.mapŸ+/dist/esm/plugin/schemaIsFederated.d.ts.mapƒÓ{"version":3,"file":"schemaIsFederated.d.ts","sourceRoot":"","sources":["../../../src/plugin/schemaIsFederated.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,aAAa,EAA8B,MAAM,SAAS,CAAC;AAkBpE,wBAAgB,iBAAiB,CAAC,MAAM,EAAE,aAAa,GAAG,OAAO,CAchE"}Ÿ1/dist/esm/plugin/landingPage/default/index.js.map≈{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/index.ts"],"names":[],"mappings":"AAUA,OAAO,EACL,uBAAuB,EACvB,sBAAsB,GACvB,MAAM,sBAAsB,CAAC;AAO9B,MAAM,UAAU,yCAAyC,CACvD,UAA4D,EAAE;IAE9D,MAAM,EAAE,OAAO,EAAE,4BAA4B,EAAE,GAAG,IAAI,EAAE,GAAG;QAEzD,KAAK,EAAE,IAAa;QACpB,GAAG,OAAO;KACX,CAAC;IACF,OAAO,oCAAoC,CAAC,OAAO,EAAE;QACnD,MAAM,EAAE,KAAK;QACb,eAAe,EAAE,4BAA4B;QAC7C,GAAG,IAAI;KACR,CAAC,CAAC;AACL,CAAC;AAED,MAAM,UAAU,8CAA8C,CAC5D,UAAiE,EAAE;IAEnE,MAAM,EAAE,OAAO,EAAE,4BAA4B,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;IACnE,OAAO,oCAAoC,CAAC,OAAO,EAAE;QACnD,MAAM,EAAE,IAAI;QACZ,eAAe,EAAE,4BAA4B;QAC7C,GAAG,IAAI;KACR,CAAC,CAAC;AACL,CAAC;AAUD,SAAS,YAAY,CAAC,MAAyB;IAC7C,OAAO,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACpE,CAAC;AAED,MAAM,6BAA6B,GAAG,CACpC,OAAe,EACf,MAAyB,EACzB,EAAE;IACF,MAAM,aAAa,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC;IAE3C,OAAO;;;;;+BAKsB,aAAa;wEAC4B,OAAO,+BAA+B,CAAC;AAC/G,CAAC,CAAC;AAGF,SAAS,oCAAoC,CAC3C,YAAgC,EAChC,MAGC;IAED,MAAM,OAAO,GAAG,YAAY,IAAI,SAAS,CAAC;IAE1C,OAAO;QACL,iCAAiC,EAAE,KAAK;QACxC,KAAK,CAAC,eAAe;YACnB,OAAO;gBACL,KAAK,CAAC,iBAAiB;oBACrB,MAAM,IAAI,GAAG;;;;;;;uEAOgD,OAAO;;;;;;;;;;;;uEAYP,OAAO;;;;uEAIP,OAAO;;;;;;;;;;;;;;;;;;;;MAqBxE,MAAM,CAAC,KAAK;wBACV,CAAC,CAAC,UAAU,IAAI,MAAM,IAAI,MAAM,CAAC,QAAQ;4BACvC,CAAC,CAAC,uBAAuB,CAAC,OAAO,EAAE,MAAM,CAAC;4BAC1C,CAAC,CAAC,sBAAsB,CAAC,OAAO,EAAE,MAAM,CAAC;wBAC3C,CAAC,CAAC,6BAA6B,CAAC,OAAO,EAAE,MAAM,CACnD;;;;WAIO,CAAC;oBACF,OAAO,EAAE,IAAI,EAAE,CAAC;gBAClB,CAAC;aACF,CAAC;QACJ,CAAC;KACF,CAAC;AACJ,CAAC"}≠/src/index.tsƒπexport { ApolloServer } from './ApolloServer.js';
export { HeaderMap } from './utils/HeaderMap.js';
// Note that this is purely a type export.
export * from './externalTypes/index.js';
Ÿ-/dist/cjs/plugin/drainHttpServer/stoppable.js≈¯"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stopper = void 0;
const https_1 = __importDefault(require("https"));
class Stopper {
    constructor(server) {
        this.server = server;
        this.requestCountPerSocket = new Map();
        this.stopped = false;
        server.on(server instanceof https_1.default.Server ? 'secureConnection' : 'connection', (socket) => {
            this.requestCountPerSocket.set(socket, 0);
            socket.once('close', () => this.requestCountPerSocket.delete(socket));
        });
        server.on('request', (req, res) => {
            this.requestCountPerSocket.set(req.socket, (this.requestCountPerSocket.get(req.socket) ?? 0) + 1);
            res.once('finish', () => {
                const pending = (this.requestCountPerSocket.get(req.socket) ?? 0) - 1;
                this.requestCountPerSocket.set(req.socket, pending);
                if (this.stopped && pending === 0) {
                    req.socket.end();
                }
            });
        });
    }
    async stop(stopGracePeriodMillis = Infinity) {
        let gracefully = true;
        await new Promise((resolve) => setImmediate(resolve));
        this.stopped = true;
        let timeout = null;
        if (stopGracePeriodMillis < Infinity) {
            timeout = setTimeout(() => {
                gracefully = false;
                this.requestCountPerSocket.forEach((_, socket) => socket.end());
                setImmediate(() => {
                    this.requestCountPerSocket.forEach((_, socket) => socket.destroy());
                });
            }, stopGracePeriodMillis);
        }
        const closePromise = new Promise((resolve) => this.server.close(() => {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            resolve();
        }));
        this.requestCountPerSocket.forEach((requests, socket) => {
            if (requests === 0)
                socket.end();
        });
        await closePromise;
        return gracefully;
    }
}
exports.Stopper = Stopper;
//# sourceMappingURL=stoppable.js.mapŸ./dist/esm/externalTypes/requestPipeline.js.mapƒé{"version":3,"file":"requestPipeline.js","sourceRoot":"","sources":["../../../src/externalTypes/requestPipeline.ts"],"names":[],"mappings":""}Ÿ /dist/esm/utils/schemaManager.js≈üexport class SchemaManager {
    constructor(options) {
        this.onSchemaLoadOrUpdateListeners = new Set();
        this.isStopped = false;
        this.logger = options.logger;
        this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
        if ('gateway' in options) {
            this.modeSpecificState = {
                mode: 'gateway',
                gateway: options.gateway,
                apolloConfig: options.apolloConfig,
            };
        }
        else {
            this.modeSpecificState = {
                mode: 'schema',
                apiSchema: options.apiSchema,
                schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema),
            };
        }
    }
    async start() {
        if (this.modeSpecificState.mode === 'gateway') {
            const gateway = this.modeSpecificState.gateway;
            if (gateway.onSchemaLoadOrUpdate) {
                this.modeSpecificState.unsubscribeFromGateway =
                    gateway.onSchemaLoadOrUpdate((schemaContext) => {
                        this.processSchemaLoadOrUpdateEvent(schemaContext);
                    });
            }
            else {
                throw new Error("Unexpectedly couldn't find onSchemaLoadOrUpdate on gateway");
            }
            const config = await this.modeSpecificState.gateway.load({
                apollo: this.modeSpecificState.apolloConfig,
            });
            return config.executor;
        }
        else {
            this.processSchemaLoadOrUpdateEvent({
                apiSchema: this.modeSpecificState.apiSchema,
            }, this.modeSpecificState.schemaDerivedData);
            return null;
        }
    }
    onSchemaLoadOrUpdate(callback) {
        if (!this.schemaContext) {
            throw new Error('You must call start() before onSchemaLoadOrUpdate()');
        }
        if (!this.isStopped) {
            try {
                callback(this.schemaContext);
            }
            catch (e) {
                throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);
            }
        }
        this.onSchemaLoadOrUpdateListeners.add(callback);
        return () => {
            this.onSchemaLoadOrUpdateListeners.delete(callback);
        };
    }
    getSchemaDerivedData() {
        if (!this.schemaDerivedData) {
            throw new Error('You must call start() before getSchemaDerivedData()');
        }
        return this.schemaDerivedData;
    }
    async stop() {
        this.isStopped = true;
        if (this.modeSpecificState.mode === 'gateway') {
            this.modeSpecificState.unsubscribeFromGateway?.();
            await this.modeSpecificState.gateway.stop?.();
        }
    }
    processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {
        if (!this.isStopped) {
            this.schemaDerivedData =
                schemaDerivedData ??
                    this.schemaDerivedDataProvider(schemaContext.apiSchema);
            this.schemaContext = schemaContext;
            this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
                try {
                    listener(schemaContext);
                }
                catch (e) {
                    this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener");
                    this.logger.error(e);
                }
            });
        }
    }
}
//# sourceMappingURL=schemaManager.js.mapŸ:/dist/cjs/externalTypes/incrementalDeliveryPolyfill.js.mapƒ¶{"version":3,"file":"incrementalDeliveryPolyfill.js","sourceRoot":"","sources":["../../../src/externalTypes/incrementalDeliveryPolyfill.ts"],"names":[],"mappings":""}Ω/dist/cjs/errors/index.js.map≈Ü{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/errors/index.ts"],"names":[],"mappings":";;;AAAA,qCAAuC;AAEvC,IAAY,qBASX;AATD,WAAY,qBAAqB;IAC/B,wEAA+C,CAAA;IAC/C,sEAA6C,CAAA;IAC7C,gFAAuD,CAAA;IACvD,gFAAuD,CAAA;IACvD,wFAA+D,CAAA;IAC/D,0DAAiC,CAAA;IACjC,sFAA6D,CAAA;IAC7D,oDAA2B,CAAA;AAC7B,CAAC,EATW,qBAAqB,GAArB,6BAAqB,KAArB,6BAAqB,QAShC;AAED,IAAY,+BAEX;AAFD,WAAY,+BAA+B;IACzC,oFAAiD,CAAA;AACnD,CAAC,EAFW,+BAA+B,GAA/B,uCAA+B,KAA/B,uCAA+B,QAE1C;AAWD,SAAgB,mBAAmB,CAAC,KAAc;IAChD,IAAI,KAAK,YAAY,sBAAY,IAAI,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,aAAa,EAAE;QACtE,OAAO,KAAK,CAAC,aAAa,CAAC;KAC5B;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AALD,kDAKC"}Ÿ8/dist/esm/externalTypes/incrementalDeliveryPolyfill.d.ts≈limport type { FormattedExecutionResult, GraphQLFormattedError } from 'graphql';
interface ObjMap<T> {
    [key: string]: T;
}
export interface GraphQLExperimentalFormattedInitialIncrementalExecutionResult<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> extends FormattedExecutionResult<TData, TExtensions> {
    hasNext: boolean;
    incremental?: ReadonlyArray<GraphQLExperimentalFormattedIncrementalResult<TData, TExtensions>>;
    extensions?: TExtensions;
}
export interface GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> {
    hasNext: boolean;
    incremental?: ReadonlyArray<GraphQLExperimentalFormattedIncrementalResult<TData, TExtensions>>;
    extensions?: TExtensions;
}
export declare type GraphQLExperimentalFormattedIncrementalResult<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> = GraphQLExperimentalFormattedIncrementalDeferResult<TData, TExtensions> | GraphQLExperimentalFormattedIncrementalStreamResult<TData, TExtensions>;
export interface GraphQLExperimentalFormattedIncrementalDeferResult<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> extends FormattedExecutionResult<TData, TExtensions> {
    path?: ReadonlyArray<string | number>;
    label?: string;
}
export interface GraphQLExperimentalFormattedIncrementalStreamResult<TData = Array<unknown>, TExtensions = ObjMap<unknown>> {
    errors?: ReadonlyArray<GraphQLFormattedError>;
    items?: TData | null;
    path?: ReadonlyArray<string | number>;
    label?: string;
    extensions?: TExtensions;
}
export {};
//# sourceMappingURL=incrementalDeliveryPolyfill.d.ts.mapŸ//dist/esm/plugin/usageReporting/plugin.d.ts.map≈D{"version":3,"file":"plugin.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/plugin.ts"],"names":[],"mappings":"AAAA,OAAO,EAAwB,KAAK,EAAE,MAAM,kCAAkC,CAAC;AAe/E,OAAO,KAAK,EACV,kBAAkB,EAClB,WAAW,EAMZ,MAAM,8BAA8B,CAAC;AAStC,OAAO,KAAK,EACV,uCAAuC,EACvC,qBAAqB,EACtB,MAAM,cAAc,CAAC;AAKtB,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,0BAA0B,CAAC;AAY1D,wBAAgB,gCAAgC,CAAC,QAAQ,SAAS,WAAW,EAC3E,OAAO,GAAE,uCAAuC,CAAC,QAAQ,CAExD,GACA,kBAAkB,CAAC,QAAQ,CAAC,CAquB9B;AAED,wBAAgB,sBAAsB,CACpC,IAAI,EAAE,KAAK,CAAC,KAAK,EACjB,OAAO,EAAE,SAAS,EAClB,WAAW,CAAC,EAAE,qBAAqB,GAClC,IAAI,CAsCN"}Ÿ5/dist/esm/utils/makeGatewayGraphQLRequestContext.d.ts≈Dimport type { GatewayGraphQLRequestContext } from '@apollo/server-gateway-interface';
import type { ApolloServer, ApolloServerInternals } from '../ApolloServer';
import type { BaseContext, GraphQLRequestContextExecutionDidStart } from '../externalTypes';
export declare function makeGatewayGraphQLRequestContext<TContext extends BaseContext>(as4RequestContext: GraphQLRequestContextExecutionDidStart<TContext>, server: ApolloServer<TContext>, internals: ApolloServerInternals<TContext>): GatewayGraphQLRequestContext;
//# sourceMappingURL=makeGatewayGraphQLRequestContext.d.ts.mapæ/dist/esm/cachePolicy.d.ts.mapƒ»{"version":3,"file":"cachePolicy.d.ts","sourceRoot":"","sources":["../../src/cachePolicy.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAa,WAAW,EAAE,MAAM,6BAA6B,CAAC;AAE1E,wBAAgB,cAAc,IAAI,WAAW,CA8B5C"}ª/dist/esm/express4/index.js≈Kimport { parse as urlParse } from 'url';
export function expressMiddleware(server, options) {
    server.assertStarted('expressMiddleware()');
    const defaultContext = async () => ({});
    const context = options?.context ?? defaultContext;
    return (req, res, next) => {
        if (!req.body) {
            res.status(500);
            res.send('`req.body` is not set; this probably means you forgot to set up the ' +
                '`body-parser` middleware before the Apollo Server middleware.');
            return;
        }
        const headers = new Map();
        for (const [key, value] of Object.entries(req.headers)) {
            if (value !== undefined) {
                headers.set(key, Array.isArray(value) ? value.join(', ') : value);
            }
        }
        const httpGraphQLRequest = {
            method: req.method.toUpperCase(),
            headers,
            search: urlParse(req.url).search ?? '',
            body: req.body,
        };
        server
            .executeHTTPGraphQLRequest({
            httpGraphQLRequest,
            context: () => context({ req, res }),
        })
            .then(async (httpGraphQLResponse) => {
            for (const [key, value] of httpGraphQLResponse.headers) {
                res.setHeader(key, value);
            }
            res.statusCode = httpGraphQLResponse.status || 200;
            if (httpGraphQLResponse.body.kind === 'complete') {
                res.send(httpGraphQLResponse.body.string);
                return;
            }
            for await (const chunk of httpGraphQLResponse.body.asyncIterator) {
                res.write(chunk);
                if (typeof res.flush === 'function') {
                    res.flush();
                }
            }
            res.end();
        })
            .catch(next);
    };
}
//# sourceMappingURL=index.js.map∂/src/errorNormalize.ts≈// The functions in this file are not part of Apollo Server's external API.

import {
  GraphQLError,
  GraphQLErrorExtensions,
  GraphQLFormattedError,
} from 'graphql';
import { ApolloServerErrorCode } from './errors/index.js';
import type { HTTPGraphQLHead } from './externalTypes/http.js';
import { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';
import { HeaderMap } from './utils/HeaderMap.js';

// This function accepts any value that were thrown and convert it to GraphQLFormattedError.
// It also add default extensions.code and copy stack trace onto an extension if requested.
// Additionally, it returns an `HTTPGraphQLHead` created from combining the values of any
// `HTTPGraphqlHead` objects found on `extensions.http` (the behavior when multiple errors
// set a status code or set the same header should be treated as undefined); these extensions
// are removed from the formatted error.
//
// This function should not throw.
export function normalizeAndFormatErrors(
  errors: ReadonlyArray<unknown>,
  options: {
    formatError?: (
      formattedError: GraphQLFormattedError,
      error: unknown,
    ) => GraphQLFormattedError;
    includeStacktraceInErrorResponses?: boolean;
  } = {},
): {
  formattedErrors: Array<GraphQLFormattedError>;
  httpFromErrors: HTTPGraphQLHead;
} {
  const formatError = options.formatError ?? ((error) => error);
  const httpFromErrors = newHTTPGraphQLHead();

  return {
    httpFromErrors,
    formattedErrors: errors.map((error) => {
      try {
        return formatError(enrichError(error), error);
      } catch (formattingError) {
        if (options.includeStacktraceInErrorResponses) {
          // includeStacktraceInErrorResponses is used in development
          // so it will be helpful to show errors thrown by formatError hooks in that mode
          return enrichError(formattingError);
        } else {
          // obscure error
          return {
            message: 'Internal server error',
            extensions: { code: ApolloServerErrorCode.INTERNAL_SERVER_ERROR },
          };
        }
      }
    }),
  };

  function enrichError(maybeError: unknown): GraphQLFormattedError {
    const graphqlError = ensureGraphQLError(maybeError);

    const extensions: GraphQLErrorExtensions = {
      ...graphqlError.extensions,
      code:
        graphqlError.extensions.code ??
        ApolloServerErrorCode.INTERNAL_SERVER_ERROR,
    };

    if (isPartialHTTPGraphQLHead(extensions.http)) {
      mergeHTTPGraphQLHead(httpFromErrors, {
        headers: new HeaderMap(),
        ...extensions.http,
      });
      delete extensions.http;
    }

    if (options.includeStacktraceInErrorResponses) {
      // Note that if ensureGraphQLError created graphqlError from an
      // originalError, graphqlError.stack will be the same as
      // originalError.stack due to some special code in the GraphQLError
      // constructor.
      extensions.stacktrace = graphqlError.stack?.split('\n');
    }

    return { ...graphqlError.toJSON(), extensions };
  }
}

export function ensureError(maybeError: unknown): Error {
  return maybeError instanceof Error
    ? maybeError
    : new GraphQLError('Unexpected error value: ' + String(maybeError));
}

export function ensureGraphQLError(
  maybeError: unknown,
  messagePrefixIfNotGraphQLError: string = '',
): GraphQLError {
  const error: Error = ensureError(maybeError);

  return error instanceof GraphQLError
    ? error
    : new GraphQLError(messagePrefixIfNotGraphQLError + error.message, {
        originalError: error,
      });
}

function isPartialHTTPGraphQLHead(x: unknown): x is Partial<HTTPGraphQLHead> {
  return (
    !!x &&
    typeof x === 'object' &&
    (!('status' in x) || typeof (x as any).status === 'number') &&
    (!('headers' in x) || (x as any).headers instanceof Map)
  );
}
Ÿ(/dist/cjs/incrementalDeliveryPolyfill.js≈˙"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeIncrementally = void 0;
const graphql_1 = require("graphql");
let graphqlExperimentalExecuteIncrementally = undefined;
async function tryToLoadGraphQL17() {
    if (graphqlExperimentalExecuteIncrementally !== undefined) {
        return;
    }
    const graphql = await Promise.resolve().then(() => __importStar(require('graphql')));
    if ('experimentalExecuteIncrementally' in graphql) {
        graphqlExperimentalExecuteIncrementally = graphql
            .experimentalExecuteIncrementally;
    }
    else {
        graphqlExperimentalExecuteIncrementally = null;
    }
}
async function executeIncrementally(args) {
    await tryToLoadGraphQL17();
    if (graphqlExperimentalExecuteIncrementally) {
        return graphqlExperimentalExecuteIncrementally(args);
    }
    return (0, graphql_1.execute)(args);
}
exports.executeIncrementally = executeIncrementally;
//# sourceMappingURL=incrementalDeliveryPolyfill.js.mapŸ7/dist/cjs/plugin/landingPage/default/getEmbeddedHTML.js≈
±"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEmbeddedSandboxHTML = exports.getEmbeddedExplorerHTML = void 0;
function getConfigStringForHtml(config) {
    return JSON.stringify(config)
        .replace('<', '\\u003c')
        .replace('>', '\\u003e')
        .replace('&', '\\u0026')
        .replace("'", '\\u0027');
}
const getEmbeddedExplorerHTML = (version, config) => {
    const productionLandingPageConfigOrDefault = {
        displayOptions: {},
        persistExplorerState: false,
        ...(typeof config.embed === 'boolean' ? {} : config.embed),
    };
    const embeddedExplorerParams = {
        ...config,
        target: '#embeddableExplorer',
        initialState: {
            ...config,
            displayOptions: {
                ...productionLandingPageConfigOrDefault.displayOptions,
            },
        },
        persistExplorerState: productionLandingPageConfigOrDefault.persistExplorerState,
    };
    return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableExplorer"
></div>
<script src="https://embeddable-explorer.cdn.apollographql.com/${version}/embeddable-explorer.umd.production.min.js"></script>
<script>
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(embeddedExplorerParams)};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
</script>
`;
};
exports.getEmbeddedExplorerHTML = getEmbeddedExplorerHTML;
const getEmbeddedSandboxHTML = (version, config) => {
    return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableSandbox"
></div>
<script src="https://embeddable-sandbox.cdn.apollographql.com/${version}/embeddable-sandbox.umd.production.min.js"></script>
<script>
  var initialEndpoint = window.location.href;
  new window.EmbeddedSandbox({
    target: '#embeddableSandbox',
    initialEndpoint,
    includeCookies: ${config.includeCookies ?? 'false'},
    initialState: ${getConfigStringForHtml({
        document: config.document ?? undefined,
        variables: config.variables ?? undefined,
        headers: config.headers ?? undefined,
    })},
  });
</script>
`;
};
exports.getEmbeddedSandboxHTML = getEmbeddedSandboxHTML;
//# sourceMappingURL=getEmbeddedHTML.js.mapŸ)/dist/esm/generated/packageVersion.js.mapƒØ{"version":3,"file":"packageVersion.js","sourceRoot":"","sources":["../../../src/generated/packageVersion.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,MAAM,cAAc,GAAG,OAAO,CAAC"}Ω/dist/esm/runHttpQuery.js.map≈s{"version":3,"file":"runHttpQuery.js","sourceRoot":"","sources":["../../src/runHttpQuery.ts"],"names":[],"mappings":"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"}¥/src/httpBatching.ts≈¡import type {
  BaseContext,
  HTTPGraphQLRequest,
  HTTPGraphQLResponse,
} from './externalTypes/index.js';
import type {
  ApolloServer,
  ApolloServerInternals,
  SchemaDerivedData,
} from './ApolloServer';
import { newHTTPGraphQLHead, runHttpQuery } from './runHttpQuery.js';
import { BadRequestError } from './internalErrorClasses.js';

async function runBatchedHttpQuery<TContext extends BaseContext>({
  server,
  batchRequest,
  body,
  contextValue,
  schemaDerivedData,
  internals,
}: {
  server: ApolloServer<TContext>;
  batchRequest: HTTPGraphQLRequest;
  body: unknown[];
  contextValue: TContext;
  schemaDerivedData: SchemaDerivedData;
  internals: ApolloServerInternals<TContext>;
}): Promise<HTTPGraphQLResponse> {
  if (body.length === 0) {
    throw new BadRequestError('No operations found in request.');
  }

  // This single HTTPGraphQLHead is shared across all the operations in the
  // batch. This means that any changes to response headers or status code from
  // one operation can be immediately seen by other operations. Plugins that set
  // response headers or status code can then choose to combine the data they
  // are setting with data that may already be there from another operation as
  // they choose.
  const sharedResponseHTTPGraphQLHead = newHTTPGraphQLHead();
  const responseBodies = await Promise.all(
    body.map(async (bodyPiece: unknown) => {
      const singleRequest: HTTPGraphQLRequest = {
        ...batchRequest,
        body: bodyPiece,
      };

      const response = await runHttpQuery({
        server,
        httpRequest: singleRequest,
        contextValue,
        schemaDerivedData,
        internals,
        sharedResponseHTTPGraphQLHead,
      });

      if (response.body.kind === 'chunked') {
        throw Error(
          'Incremental delivery is not implemented for batch requests',
        );
      }
      return response.body.string;
    }),
  );
  return {
    ...sharedResponseHTTPGraphQLHead,
    body: { kind: 'complete', string: `[${responseBodies.join(',')}]` },
  };
}

export async function runPotentiallyBatchedHttpQuery<
  TContext extends BaseContext,
>(
  server: ApolloServer<TContext>,
  httpGraphQLRequest: HTTPGraphQLRequest,
  contextValue: TContext,
  schemaDerivedData: SchemaDerivedData,
  internals: ApolloServerInternals<TContext>,
): Promise<HTTPGraphQLResponse> {
  if (
    !(
      httpGraphQLRequest.method === 'POST' &&
      Array.isArray(httpGraphQLRequest.body)
    )
  ) {
    return await runHttpQuery({
      server,
      httpRequest: httpGraphQLRequest,
      contextValue,
      schemaDerivedData,
      internals,
      sharedResponseHTTPGraphQLHead: null,
    });
  }
  if (internals.allowBatchedHttpRequests) {
    return await runBatchedHttpQuery({
      server,
      batchRequest: httpGraphQLRequest,
      body: httpGraphQLRequest.body as unknown[],
      contextValue,
      schemaDerivedData,
      internals,
    });
  }
  throw new BadRequestError('Operation batching disabled.');
}
Ÿ7/dist/esm/utils/makeGatewayGraphQLRequestContext.js.map≈ä{"version":3,"file":"makeGatewayGraphQLRequestContext.js","sourceRoot":"","sources":["../../../src/utils/makeGatewayGraphQLRequestContext.ts"],"names":[],"mappings":"AAoFA,MAAM,UAAU,gCAAgC,CAC9C,iBAAmE,EACnE,MAA8B,EAC9B,SAA0C;IAE1C,MAAM,OAAO,GAA0B,EAAE,CAAC;IAC1C,IAAI,OAAO,IAAI,iBAAiB,CAAC,OAAO,EAAE;QACxC,OAAO,CAAC,KAAK,GAAG,iBAAiB,CAAC,OAAO,CAAC,KAAK,CAAC;KACjD;IACD,IAAI,eAAe,IAAI,iBAAiB,CAAC,OAAO,EAAE;QAChD,OAAO,CAAC,aAAa,GAAG,iBAAiB,CAAC,OAAO,CAAC,aAAa,CAAC;KACjE;IACD,IAAI,WAAW,IAAI,iBAAiB,CAAC,OAAO,EAAE;QAC5C,OAAO,CAAC,SAAS,GAAG,iBAAiB,CAAC,OAAO,CAAC,SAAS,CAAC;KACzD;IACD,IAAI,YAAY,IAAI,iBAAiB,CAAC,OAAO,EAAE;QAC7C,OAAO,CAAC,UAAU,GAAG,iBAAiB,CAAC,OAAO,CAAC,UAAU,CAAC;KAC3D;IACD,IAAI,iBAAiB,CAAC,OAAO,CAAC,IAAI,EAAE;QAClC,MAAM,OAAO,GAAG,iBAAiB,CAAC,OAAO,CAAC,IAAI,CAAC;QAC/C,MAAM,YAAY,GAChB,OAAO,CAAC,MAAM,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;QAC3D,OAAO,CAAC,IAAI,GAAG;YACb,MAAM,EAAE,OAAO,CAAC,MAAM;YAGtB,GAAG,EAAE,+BAA+B,YAAY,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,GACzD,OAAO,CAAC,MACV,EAAE;YACF,OAAO,EAAE,IAAI,0BAA0B,CAAC,OAAO,CAAC,OAAO,CAAC;SACzD,CAAC;KACH;IAED,MAAM,QAAQ,GAA2B;QACvC,IAAI,EAAE;YACJ,OAAO,EAAE,IAAI,0BAA0B,CACrC,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CACxC;YACD,IAAI,MAAM;gBACR,OAAO,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC;YAChD,CAAC;YACD,IAAI,MAAM,CAAC,SAAS;gBAClB,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC;YACrD,CAAC;SACF;KAEF,CAAC;IAEF,OAAO;QACL,OAAO;QACP,QAAQ;QACR,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,MAAM,EAAE,iBAAiB,CAAC,MAAM;QAMhC,UAAU,EACR,gDAAqE;QACvE,OAAO,EAAE,iBAAiB,CAAC,YAAY;QACvC,KAAK,EAAE,MAAM,CAAC,KAAK;QACnB,SAAS,EAAE,iBAAiB,CAAC,SAAS;QACtC,QAAQ,EAAE,iBAAiB,CAAC,QAAQ;QACpC,MAAM,EAAE,iBAAiB,CAAC,MAAM;QAChC,aAAa,EAAE,iBAAiB,CAAC,aAAa;QAC9C,SAAS,EAAE,iBAAiB,CAAC,SAAS;QACtC,MAAM,EAAE,iBAAiB,CAAC,MAAM;QAChC,OAAO,EAAE,iBAAiB,CAAC,OAAO;QAClC,KAAK,EAAE,SAAS,CAAC,iCAAiC;QAClD,kBAAkB,EAAE,iBAAiB,CAAC,kBAAkB;QACxD,gBAAgB,EAAE,iBAAiB,CAAC,gBAAgB;KACrD,CAAC;AACJ,CAAC;AAMD,MAAM,0BAA0B;IAC9B,YAAoB,GAAc;QAAd,QAAG,GAAH,GAAG,CAAW;IAAG,CAAC;IACtC,MAAM,CAAC,IAAY,EAAE,KAAa;QAChC,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACtB,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,KAAK,CAAC,CAAC;SACvD;aAAM;YACL,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;SAC3B;IACH,CAAC;IACD,MAAM,CAAC,IAAY;QACjB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACxB,CAAC;IACD,GAAG,CAAC,IAAY;QACd,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC;IACpC,CAAC;IACD,GAAG,CAAC,IAAY;QACd,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC;IACD,GAAG,CAAC,IAAY,EAAE,KAAa;QAC7B,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAC5B,CAAC;IACD,OAAO;QACL,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;IAC5B,CAAC;IACD,IAAI;QACF,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC;IACzB,CAAC;IACD,MAAM;QACJ,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;IAC3B,CAAC;IACD,CAAC,MAAM,CAAC,QAAQ,CAAC;QACf,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;IAC5B,CAAC;CACF"}ŸB/dist/esm/plugin/usageReporting/operationDerivedDataCache.d.ts.map≈>{"version":3,"file":"operationDerivedDataCache.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/operationDerivedDataCache.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,KAAK,EAAE,sBAAsB,EAAE,MAAM,8BAA8B,CAAC;AAC3E,OAAO,QAAQ,MAAM,WAAW,CAAC;AAEjC,MAAM,WAAW,oBAAoB;IACnC,SAAS,EAAE,MAAM,CAAC;IAClB,sBAAsB,EAAE,sBAAsB,CAAC;CAChD;AAED,wBAAgB,+BAA+B,CAAC,EAC9C,MAAM,GACP,EAAE;IACD,MAAM,EAAE,MAAM,CAAC;CAChB,GAAG,QAAQ,CAAC,MAAM,EAAE,oBAAoB,CAAC,CAwCzC;AAED,wBAAgB,4BAA4B,CAC1C,SAAS,EAAE,MAAM,EACjB,aAAa,EAAE,MAAM,UAGtB"}∂/dist/esm/package.jsonƒ{"type":"module"}Ω/dist/esm/httpBatching.js.map≈E{"version":3,"file":"httpBatching.js","sourceRoot":"","sources":["../../src/httpBatching.ts"],"names":[],"mappings":"AAUA,OAAO,EAAE,kBAAkB,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACrE,OAAO,EAAE,eAAe,EAAE,MAAM,2BAA2B,CAAC;AAE5D,KAAK,UAAU,mBAAmB,CAA+B,EAC/D,MAAM,EACN,YAAY,EACZ,IAAI,EACJ,YAAY,EACZ,iBAAiB,EACjB,SAAS,GAQV;IACC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACrB,MAAM,IAAI,eAAe,CAAC,iCAAiC,CAAC,CAAC;KAC9D;IAQD,MAAM,6BAA6B,GAAG,kBAAkB,EAAE,CAAC;IAC3D,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,GAAG,CACtC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,SAAkB,EAAE,EAAE;QACpC,MAAM,aAAa,GAAuB;YACxC,GAAG,YAAY;YACf,IAAI,EAAE,SAAS;SAChB,CAAC;QAEF,MAAM,QAAQ,GAAG,MAAM,YAAY,CAAC;YAClC,MAAM;YACN,WAAW,EAAE,aAAa;YAC1B,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,6BAA6B;SAC9B,CAAC,CAAC;QAEH,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,EAAE;YACpC,MAAM,KAAK,CACT,4DAA4D,CAC7D,CAAC;SACH;QACD,OAAO,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC;IAC9B,CAAC,CAAC,CACH,CAAC;IACF,OAAO;QACL,GAAG,6BAA6B;QAChC,IAAI,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,IAAI,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;KACpE,CAAC;AACJ,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,8BAA8B,CAGlD,MAA8B,EAC9B,kBAAsC,EACtC,YAAsB,EACtB,iBAAoC,EACpC,SAA0C;IAE1C,IACE,CAAC,CACC,kBAAkB,CAAC,MAAM,KAAK,MAAM;QACpC,KAAK,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CACvC,EACD;QACA,OAAO,MAAM,YAAY,CAAC;YACxB,MAAM;YACN,WAAW,EAAE,kBAAkB;YAC/B,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,6BAA6B,EAAE,IAAI;SACpC,CAAC,CAAC;KACJ;IACD,IAAI,SAAS,CAAC,wBAAwB,EAAE;QACtC,OAAO,MAAM,mBAAmB,CAAC;YAC/B,MAAM;YACN,YAAY,EAAE,kBAAkB;YAChC,IAAI,EAAE,kBAAkB,CAAC,IAAiB;YAC1C,YAAY;YACZ,iBAAiB;YACjB,SAAS;SACV,CAAC,CAAC;KACJ;IACD,MAAM,IAAI,eAAe,CAAC,8BAA8B,CAAC,CAAC;AAC5D,CAAC"}ø/dist/esm/errorNormalize.js.map≈Q{"version":3,"file":"errorNormalize.js","sourceRoot":"","sources":["../../src/errorNormalize.ts"],"names":[],"mappings":"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"}Ÿ)/dist/esm/utils/UnreachableCaseError.d.tsƒãexport declare class UnreachableCaseError extends Error {
    constructor(val: never);
}
//# sourceMappingURL=UnreachableCaseError.d.ts.mapŸ%/dist/cjs/plugin/schemaIsFederated.js≈¶"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schemaIsFederated = void 0;
const graphql_1 = require("graphql");
function schemaIsFederated(schema) {
    const serviceType = schema.getType('_Service');
    if (!(0, graphql_1.isObjectType)(serviceType)) {
        return false;
    }
    const sdlField = serviceType.getFields().sdl;
    if (!sdlField) {
        return false;
    }
    const sdlFieldType = sdlField.type;
    if (!(0, graphql_1.isScalarType)(sdlFieldType)) {
        return false;
    }
    return sdlFieldType.name == 'String';
}
exports.schemaIsFederated = schemaIsFederated;
//# sourceMappingURL=schemaIsFederated.js.mapŸ3/dist/esm/plugin/landingPage/default/types.d.ts.map≈e{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/types.ts"],"names":[],"mappings":"AAAA,MAAM,WAAW,+CAA+C;IAQ9D,OAAO,CAAC,EAAE,MAAM,CAAC;IAKjB,MAAM,CAAC,EAAE,OAAO,CAAC;IAKjB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAKlB,SAAS,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAKhC,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAEjC,cAAc,CAAC,EAAE,OAAO,CAAC;IAEzB,4BAA4B,CAAC,EAAE,SAAS,GAAG,MAAM,CAAC;CACnD;AAED,MAAM,WAAW,2DACf,SAAQ,+CAA+C;IAKvD,KAAK,EAAE,KAAK,CAAC;CACd;AAED,MAAM,WAAW,gEACf,SAAQ,+CAA+C;IAOvD,QAAQ,CAAC,EAAE,MAAM,CAAC;IAKlB,KAAK,CAAC,EAAE,KAAK,CAAC;CACf;AAED,MAAM,WAAW,wDACf,SAAQ,+CAA+C;IAKvD,KAAK,CAAC,EAAE,IAAI,CAAC;CACd;AAED,MAAM,WAAW,6DACf,SAAQ,+CAA+C;IAKvD,QAAQ,EAAE,MAAM,CAAC;IAIjB,KAAK,EAAE,IAAI,GAAG,yBAAyB,CAAC;CACzC;AAED,aAAK,yBAAyB,GAAG;IAI/B,cAAc,CAAC,EAAE;QAQf,qBAAqB,EAAE,OAAO,CAAC;QAO/B,cAAc,EAAE,MAAM,GAAG,QAAQ,CAAC;QAMlC,KAAK,EAAE,OAAO,GAAG,MAAM,CAAC;KACzB,CAAC;IAWF,oBAAoB,EAAE,OAAO,CAAC;CAC/B,CAAC;AAEF,oBAAY,gDAAgD,GACxD,wDAAwD,GACxD,2DAA2D,CAAC;AAEhE,oBAAY,qDAAqD,GAC7D,6DAA6D,GAC7D,gEAAgE,CAAC;AAErE,oBAAY,iBAAiB,GACzB,gDAAgD,GAChD,qDAAqD,CAAC"}Ÿ//src/plugin/usageReporting/durationHistogram.ts≈export interface DurationHistogramOptions {
  initSize?: number;
  buckets?: number[];
}
export class DurationHistogram {
  // Note that it's legal for the values in "buckets" to be non-integers; they
  // will be floored by toArray (which is called by the protobuf encoder).
  // (We take advantage of this for field latencies specifically, because
  // the ability to return a non-1 weight from fieldLevelInstrumentation
  // means we want to build up our histograms as floating-point rather than
  // rounding after every operation.)
  private readonly buckets: number[];
  static readonly BUCKET_COUNT = 384;
  static readonly EXPONENT_LOG = Math.log(1.1);

  toArray(): number[] {
    let bufferedZeroes = 0;
    const outputArray: number[] = [];

    for (const value of this.buckets) {
      if (value === 0) {
        bufferedZeroes++;
      } else {
        if (bufferedZeroes === 1) {
          outputArray.push(0);
        } else if (bufferedZeroes !== 0) {
          outputArray.push(-bufferedZeroes);
        }
        outputArray.push(Math.floor(value));
        bufferedZeroes = 0;
      }
    }
    return outputArray;
  }

  static durationToBucket(durationNs: number): number {
    const log = Math.log(durationNs / 1000.0);
    const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);

    // Compare <= 0 to catch -0 and -infinity
    return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)
      ? 0
      : unboundedBucket >= DurationHistogram.BUCKET_COUNT
      ? DurationHistogram.BUCKET_COUNT - 1
      : unboundedBucket;
  }

  incrementDuration(durationNs: number, value = 1): DurationHistogram {
    this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);
    return this;
  }

  incrementBucket(bucket: number, value = 1) {
    if (bucket >= DurationHistogram.BUCKET_COUNT) {
      // Since we don't have fixed size arrays I'd rather throw the error manually
      throw Error('Bucket is out of bounds of the buckets array');
    }

    // Extend the array if we haven't gotten it long enough to handle the new bucket
    if (bucket >= this.buckets.length) {
      const oldLength = this.buckets.length;
      this.buckets.length = bucket + 1;
      this.buckets.fill(0, oldLength);
    }

    this.buckets[bucket] += value;
  }

  combine(otherHistogram: DurationHistogram) {
    for (let i = 0; i < otherHistogram.buckets.length; i++) {
      this.incrementBucket(i, otherHistogram.buckets[i]);
    }
  }

  constructor(options?: DurationHistogramOptions) {
    const initSize = options?.initSize || 74;
    const buckets = options?.buckets;

    const arrayInitSize = Math.max(buckets?.length || 0, initSize);

    this.buckets = Array<number>(arrayInitSize).fill(0);

    if (buckets) {
      buckets.forEach((val, index) => (this.buckets[index] = val));
    }
  }
}
º/dist/cjs/requestPipeline.js≈:ı"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processGraphQLRequest = exports.APQ_CACHE_PREFIX = void 0;
const utils_createhash_1 = require("@apollo/utils.createhash");
const graphql_1 = require("graphql");
const schemaInstrumentation_js_1 = require("./utils/schemaInstrumentation.js");
const internalErrorClasses_js_1 = require("./internalErrorClasses.js");
const errorNormalize_js_1 = require("./errorNormalize.js");
const invokeHooks_js_1 = require("./utils/invokeHooks.js");
const makeGatewayGraphQLRequestContext_js_1 = require("./utils/makeGatewayGraphQLRequestContext.js");
const runHttpQuery_js_1 = require("./runHttpQuery.js");
const isDefined_js_1 = require("./utils/isDefined.js");
const incrementalDeliveryPolyfill_js_1 = require("./incrementalDeliveryPolyfill.js");
const HeaderMap_js_1 = require("./utils/HeaderMap.js");
exports.APQ_CACHE_PREFIX = 'apq:';
function computeQueryHash(query) {
    return (0, utils_createhash_1.createHash)('sha256').update(query).digest('hex');
}
function isBadUserInputGraphQLError(error) {
    return (error.nodes?.length === 1 &&
        error.nodes[0].kind === graphql_1.Kind.VARIABLE_DEFINITION &&
        (error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" got invalid value `) ||
            error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of required type `) ||
            error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of non-null type `)));
}
async function processGraphQLRequest(schemaDerivedData, server, internals, requestContext) {
    const requestListeners = (await Promise.all(internals.plugins.map((p) => p.requestDidStart?.(requestContext)))).filter(isDefined_js_1.isDefined);
    const request = requestContext.request;
    let { query, extensions } = request;
    let queryHash;
    requestContext.metrics.persistedQueryHit = false;
    requestContext.metrics.persistedQueryRegister = false;
    if (extensions?.persistedQuery) {
        if (!internals.persistedQueries) {
            return await sendErrorResponse([new internalErrorClasses_js_1.PersistedQueryNotSupportedError()]);
        }
        else if (extensions.persistedQuery.version !== 1) {
            return await sendErrorResponse([
                new graphql_1.GraphQLError('Unsupported persisted query version', {
                    extensions: { http: (0, runHttpQuery_js_1.newHTTPGraphQLHead)(400) },
                }),
            ]);
        }
        queryHash = extensions.persistedQuery.sha256Hash;
        if (query === undefined) {
            query = await internals.persistedQueries.cache.get(queryHash);
            if (query) {
                requestContext.metrics.persistedQueryHit = true;
            }
            else {
                return await sendErrorResponse([new internalErrorClasses_js_1.PersistedQueryNotFoundError()]);
            }
        }
        else {
            const computedQueryHash = computeQueryHash(query);
            if (queryHash !== computedQueryHash) {
                return await sendErrorResponse([
                    new graphql_1.GraphQLError('provided sha does not match query', {
                        extensions: { http: (0, runHttpQuery_js_1.newHTTPGraphQLHead)(400) },
                    }),
                ]);
            }
            requestContext.metrics.persistedQueryRegister = true;
        }
    }
    else if (query) {
        queryHash = computeQueryHash(query);
    }
    else {
        return await sendErrorResponse([
            new internalErrorClasses_js_1.BadRequestError('GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.'),
        ]);
    }
    requestContext.queryHash = queryHash;
    requestContext.source = query;
    await Promise.all(requestListeners.map((l) => l.didResolveSource?.(requestContext)));
    if (schemaDerivedData.documentStore) {
        try {
            requestContext.document = await schemaDerivedData.documentStore.get(queryHash);
        }
        catch (err) {
            server.logger.warn('An error occurred while attempting to read from the documentStore. ' +
                (0, errorNormalize_js_1.ensureError)(err).message);
        }
    }
    if (!requestContext.document) {
        const parsingDidEnd = await (0, invokeHooks_js_1.invokeDidStartHook)(requestListeners, async (l) => l.parsingDidStart?.(requestContext));
        try {
            requestContext.document = (0, graphql_1.parse)(query, internals.parseOptions);
        }
        catch (syntaxMaybeError) {
            const error = (0, errorNormalize_js_1.ensureError)(syntaxMaybeError);
            await parsingDidEnd(error);
            return await sendErrorResponse([
                new internalErrorClasses_js_1.SyntaxError((0, errorNormalize_js_1.ensureGraphQLError)(error)),
            ]);
        }
        await parsingDidEnd();
        const validationDidEnd = await (0, invokeHooks_js_1.invokeDidStartHook)(requestListeners, async (l) => l.validationDidStart?.(requestContext));
        const validationErrors = (0, graphql_1.validate)(schemaDerivedData.schema, requestContext.document, [...graphql_1.specifiedRules, ...internals.validationRules]);
        if (validationErrors.length === 0) {
            await validationDidEnd();
        }
        else {
            await validationDidEnd(validationErrors);
            return await sendErrorResponse(validationErrors.map((error) => new internalErrorClasses_js_1.ValidationError(error)));
        }
        if (schemaDerivedData.documentStore) {
            Promise.resolve(schemaDerivedData.documentStore.set(queryHash, requestContext.document)).catch((err) => server.logger.warn('Could not store validated document. ' + err?.message || err));
        }
    }
    const operation = (0, graphql_1.getOperationAST)(requestContext.document, request.operationName);
    requestContext.operation = operation || undefined;
    requestContext.operationName = operation?.name?.value || null;
    if (request.http?.method === 'GET' &&
        operation?.operation &&
        operation.operation !== 'query') {
        return await sendErrorResponse([
            new internalErrorClasses_js_1.BadRequestError(`GET requests only support query operations, not ${operation.operation} operations`, {
                extensions: {
                    http: { status: 405, headers: new HeaderMap_js_1.HeaderMap([['allow', 'POST']]) },
                },
            }),
        ]);
    }
    try {
        await Promise.all(requestListeners.map((l) => l.didResolveOperation?.(requestContext)));
    }
    catch (err) {
        return await sendErrorResponse([(0, errorNormalize_js_1.ensureGraphQLError)(err)]);
    }
    if (requestContext.metrics.persistedQueryRegister &&
        internals.persistedQueries) {
        const ttl = internals.persistedQueries?.ttl;
        Promise.resolve(internals.persistedQueries.cache.set(queryHash, query, ttl !== undefined
            ? { ttl: internals.persistedQueries?.ttl }
            : undefined)).catch(server.logger.warn);
    }
    const responseFromPlugin = await (0, invokeHooks_js_1.invokeHooksUntilDefinedAndNonNull)(requestListeners, async (l) => await l.responseForOperation?.(requestContext));
    if (responseFromPlugin !== null) {
        requestContext.response.body = responseFromPlugin.body;
        (0, runHttpQuery_js_1.mergeHTTPGraphQLHead)(requestContext.response.http, responseFromPlugin.http);
    }
    else {
        const executionListeners = (await Promise.all(requestListeners.map((l) => l.executionDidStart?.(requestContext)))).filter(isDefined_js_1.isDefined);
        executionListeners.reverse();
        if (executionListeners.some((l) => l.willResolveField)) {
            const invokeWillResolveField = (...args) => (0, invokeHooks_js_1.invokeSyncDidStartHook)(executionListeners, (l) => l.willResolveField?.(...args));
            Object.defineProperty(requestContext.contextValue, schemaInstrumentation_js_1.symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
            if (internals.fieldResolver) {
                Object.defineProperty(requestContext.contextValue, schemaInstrumentation_js_1.symbolUserFieldResolver, {
                    value: internals.fieldResolver,
                });
            }
            (0, schemaInstrumentation_js_1.enablePluginsForSchemaResolvers)(schemaDerivedData.schema);
        }
        try {
            const fullResult = await execute(requestContext);
            const result = 'singleResult' in fullResult
                ? fullResult.singleResult
                : fullResult.initialResult;
            if (!requestContext.operation) {
                if (!result.errors?.length) {
                    throw new Error('Unexpected error: Apollo Server did not resolve an operation but execute did not return errors');
                }
                throw new internalErrorClasses_js_1.OperationResolutionError(result.errors[0]);
            }
            const resultErrors = result.errors?.map((e) => {
                if (isBadUserInputGraphQLError(e)) {
                    return new internalErrorClasses_js_1.UserInputError(e);
                }
                return e;
            });
            if (resultErrors) {
                await didEncounterErrors(resultErrors);
            }
            const { formattedErrors, httpFromErrors } = resultErrors
                ? formatErrors(resultErrors)
                : { formattedErrors: undefined, httpFromErrors: (0, runHttpQuery_js_1.newHTTPGraphQLHead)() };
            (0, runHttpQuery_js_1.mergeHTTPGraphQLHead)(requestContext.response.http, httpFromErrors);
            if ('singleResult' in fullResult) {
                requestContext.response.body = {
                    kind: 'single',
                    singleResult: {
                        ...result,
                        errors: formattedErrors,
                    },
                };
            }
            else {
                requestContext.response.body = {
                    kind: 'incremental',
                    initialResult: {
                        ...fullResult.initialResult,
                        errors: formattedErrors,
                    },
                    subsequentResults: fullResult.subsequentResults,
                };
            }
        }
        catch (executionMaybeError) {
            const executionError = (0, errorNormalize_js_1.ensureError)(executionMaybeError);
            await Promise.all(executionListeners.map((l) => l.executionDidEnd?.(executionError)));
            return await sendErrorResponse([(0, errorNormalize_js_1.ensureGraphQLError)(executionError)]);
        }
        await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));
    }
    await invokeWillSendResponse();
    if (!requestContext.response.body) {
        throw Error('got to end of processGraphQLRequest without setting body?');
    }
    return requestContext.response;
    async function execute(requestContext) {
        const { request, document } = requestContext;
        if (internals.__testing_incrementalExecutionResults) {
            return internals.__testing_incrementalExecutionResults;
        }
        else if (internals.gatewayExecutor) {
            const result = await internals.gatewayExecutor((0, makeGatewayGraphQLRequestContext_js_1.makeGatewayGraphQLRequestContext)(requestContext, server, internals));
            return { singleResult: result };
        }
        else {
            const resultOrResults = await (0, incrementalDeliveryPolyfill_js_1.executeIncrementally)({
                schema: schemaDerivedData.schema,
                document,
                rootValue: typeof internals.rootValue === 'function'
                    ? internals.rootValue(document)
                    : internals.rootValue,
                contextValue: requestContext.contextValue,
                variableValues: request.variables,
                operationName: request.operationName,
                fieldResolver: internals.fieldResolver,
            });
            if ('initialResult' in resultOrResults) {
                return {
                    initialResult: resultOrResults.initialResult,
                    subsequentResults: formatErrorsInSubsequentResults(resultOrResults.subsequentResults),
                };
            }
            else {
                return { singleResult: resultOrResults };
            }
        }
    }
    async function* formatErrorsInSubsequentResults(results) {
        for await (const result of results) {
            const payload = result.incremental
                ? {
                    ...result,
                    incremental: await seriesAsyncMap(result.incremental, async (incrementalResult) => {
                        const { errors } = incrementalResult;
                        if (errors) {
                            await Promise.all(requestListeners.map((l) => l.didEncounterSubsequentErrors?.(requestContext, errors)));
                            return {
                                ...incrementalResult,
                                errors: formatErrors(errors).formattedErrors,
                            };
                        }
                        return incrementalResult;
                    }),
                }
                : result;
            await Promise.all(requestListeners.map((l) => l.willSendSubsequentPayload?.(requestContext, payload)));
            yield payload;
        }
    }
    async function invokeWillSendResponse() {
        await Promise.all(requestListeners.map((l) => l.willSendResponse?.(requestContext)));
    }
    async function didEncounterErrors(errors) {
        requestContext.errors = errors;
        return await Promise.all(requestListeners.map((l) => l.didEncounterErrors?.(requestContext)));
    }
    async function sendErrorResponse(errors) {
        await didEncounterErrors(errors);
        const { formattedErrors, httpFromErrors } = formatErrors(errors);
        requestContext.response.body = {
            kind: 'single',
            singleResult: {
                errors: formattedErrors,
            },
        };
        (0, runHttpQuery_js_1.mergeHTTPGraphQLHead)(requestContext.response.http, httpFromErrors);
        if (!requestContext.response.http.status) {
            requestContext.response.http.status = 500;
        }
        await invokeWillSendResponse();
        return requestContext.response;
    }
    function formatErrors(errors) {
        return (0, errorNormalize_js_1.normalizeAndFormatErrors)(errors, {
            formatError: internals.formatError,
            includeStacktraceInErrorResponses: internals.includeStacktraceInErrorResponses,
        });
    }
}
exports.processGraphQLRequest = processGraphQLRequest;
async function seriesAsyncMap(ts, fn) {
    const us = [];
    for (const t of ts) {
        const u = await fn(t);
        us.push(u);
    }
    return us;
}
//# sourceMappingURL=requestPipeline.js.mapŸ!/src/externalTypes/constructor.ts≈B/**
 * This file consists of types used to define the arguments to the ApolloServer
 * constructor. The top-level and likely most interesting type exported from
 * here is `ApolloServerOptions` which is used to define the input object to the
 * `ApolloServer` constructor.
 */
import type { Logger } from '@apollo/utils.logger';
import type { IExecutableSchemaDefinition } from '@graphql-tools/schema';
import type {
  DocumentNode,
  GraphQLFieldResolver,
  GraphQLFormattedError,
  GraphQLSchema,
  ParseOptions,
  ValidationRule,
} from 'graphql';
import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { GatewayInterface } from '@apollo/server-gateway-interface';
import type { ApolloServerPlugin } from './plugins.js';
import type { BaseContext } from './index.js';
import type { GraphQLExperimentalIncrementalExecutionResults } from '../incrementalDeliveryPolyfill.js';

export type DocumentStore = KeyValueCache<DocumentNode>;

// Configuration for how Apollo Server talks to the Apollo registry, as passed
// to the ApolloServer constructor. Each field can also be provided as an
// environment variable.
export interface ApolloConfigInput {
  // Your Apollo API key. Environment variable: APOLLO_KEY.
  key?: string;
  // The graph ref for your graph, eg `my-graph@my-variant` or `my-graph` to use
  // your graph's default variant. Environment variable: APOLLO_GRAPH_REF. For
  // backwards compatibility, may alternatively specify the ref as graphId and
  // graphVariant separately.
  graphRef?: string;
  // The graph ID of your graph, eg `my-graph`. Environment variable:
  // APOLLO_GRAPH_ID.
  graphId?: string;
  // Your graph's variant name, eg `my-variant`. Environment variable:
  // APOLLO_GRAPH_VARIANT.
  graphVariant?: string;
}

// some defaults filled in from the ApolloConfigInput passed to the constructor.
export interface ApolloConfig {
  key?: string;
  keyHash?: string;
  graphRef?: string;
}

export interface PersistedQueryOptions {
  cache?: KeyValueCache<string>;
  /**
   * Specified in **seconds**, this time-to-live (TTL) value limits the lifespan
   * of how long the persisted query should be cached.  To specify a desired
   * lifespan of "infinite", set this to `null`, in which case the eviction will
   * be determined by the cache's eviction policy, but the record will never
   * simply expire.
   */
  ttl?: number | null;
}

export interface CSRFPreventionOptions {
  // CSRF prevention works by only processing operations from requests whose
  // structure indicates that if they were sent by a web browser, then the
  // browser would have had to send a preflight OPTIONS request already. We do
  // this by specifying some headers that a browser will never automatically set
  // and which will trigger the browser to preflight. Apollo Server will reject
  // any operation that does not set at least one of these headers *and* does
  // not set a content-type (to a header whose parsed type is not
  // application/x-www-form-urlencoded, multipart/form-data, or text/plain). If
  // CSRF prevention is enabled (eg, with `csrfPrevention: true`) this list
  // defaults to ['x-apollo-operation-name', 'apollo-require-preflight']. This
  // will allow POST operations from any client and GET operations from Apollo
  // Client Web, Apollo iOS, and Apollo Kotlin.
  requestHeaders?: string[];
}

interface ApolloServerOptionsBase<TContext extends BaseContext> {
  formatError?: (
    formattedError: GraphQLFormattedError,
    error: unknown,
  ) => GraphQLFormattedError;
  rootValue?: ((parsedQuery: DocumentNode) => unknown) | unknown;
  validationRules?: Array<ValidationRule>;
  fieldResolver?: GraphQLFieldResolver<any, TContext>;
  cache?: KeyValueCache<string>;
  includeStacktraceInErrorResponses?: boolean;
  logger?: Logger;
  allowBatchedHttpRequests?: boolean;

  introspection?: boolean;
  plugins?: ApolloServerPlugin<TContext>[];
  persistedQueries?: PersistedQueryOptions | false;
  stopOnTerminationSignals?: boolean;
  apollo?: ApolloConfigInput;
  nodeEnv?: string;
  documentStore?: DocumentStore | null;
  csrfPrevention?: CSRFPreventionOptions | boolean;

  // Used for parsing operations; unlike in AS3, this is not also used for
  // parsing the schema.
  parseOptions?: ParseOptions;

  // For testing only.
  __testing_incrementalExecutionResults?: GraphQLExperimentalIncrementalExecutionResults;
}

interface ApolloServerOptionsWithGateway<TContext extends BaseContext>
  extends ApolloServerOptionsBase<TContext> {
  gateway: GatewayInterface;
  schema?: undefined;
  typeDefs?: undefined;
  resolvers?: undefined;
}

interface ApolloServerOptionsWithSchema<TContext extends BaseContext>
  extends ApolloServerOptionsBase<TContext> {
  schema: GraphQLSchema;
  gateway?: undefined;
  typeDefs?: undefined;
  resolvers?: undefined;
}

interface ApolloServerOptionsWithTypeDefs<TContext extends BaseContext>
  extends ApolloServerOptionsBase<TContext> {
  // These two options are always only passed directly through to
  // makeExecutableSchema. (If you don't want to use makeExecutableSchema, pass
  // `schema` instead.)
  typeDefs: IExecutableSchemaDefinition<TContext>['typeDefs'];
  resolvers?: IExecutableSchemaDefinition<TContext>['resolvers'];
  gateway?: undefined;
  schema?: undefined;
}

// Used internally in ApolloServer.ts but not publicly exported.
export type ApolloServerOptionsWithStaticSchema<TContext extends BaseContext> =
  | ApolloServerOptionsWithSchema<TContext>
  | ApolloServerOptionsWithTypeDefs<TContext>;

export type ApolloServerOptions<TContext extends BaseContext> =
  | ApolloServerOptionsWithGateway<TContext>
  | ApolloServerOptionsWithStaticSchema<TContext>;
Ÿ#/src/utils/schemaInstrumentation.ts≈«import {
  GraphQLSchema,
  GraphQLField,
  getNamedType,
  GraphQLObjectType,
  GraphQLFieldResolver,
  defaultFieldResolver,
} from 'graphql';
import type {
  BaseContext,
  GraphQLRequestExecutionListener,
} from '../externalTypes/index.js';

export const symbolExecutionDispatcherWillResolveField = Symbol(
  'apolloServerExecutionDispatcherWillResolveField',
);
export const symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');
const symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');

export function enablePluginsForSchemaResolvers<TContext extends BaseContext>(
  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },
) {
  if (pluginsEnabledForSchemaResolvers(schema)) {
    return schema;
  }
  Object.defineProperty(schema, symbolPluginsEnabled, {
    value: true,
  });

  const typeMap = schema.getTypeMap();
  Object.values(typeMap).forEach((type) => {
    if (
      !getNamedType(type).name.startsWith('__') &&
      type instanceof GraphQLObjectType
    ) {
      const fields = type.getFields();
      Object.values(fields).forEach((field) => {
        wrapField<TContext>(field);
      });
    }
  });

  return schema;
}

export function pluginsEnabledForSchemaResolvers(
  schema: GraphQLSchema & { [symbolPluginsEnabled]?: boolean },
): boolean {
  return !!schema[symbolPluginsEnabled];
}

function wrapField<TContext extends BaseContext>(
  field: GraphQLField<any, any>,
): void {
  const originalFieldResolve = field.resolve;

  field.resolve = (source, args, contextValue, info) => {
    const willResolveField = contextValue?.[
      symbolExecutionDispatcherWillResolveField
    ] as
      | GraphQLRequestExecutionListener<TContext>['willResolveField']
      | undefined;

    const userFieldResolver = contextValue?.[symbolUserFieldResolver] as
      | GraphQLFieldResolver<any, any>
      | undefined;

    // The technique for implementing a  "did resolve field" is accomplished by
    // returning a function from the `willResolveField` handler.  While there
    // may be several callbacks, depending on the number of plugins which have
    // implemented a `willResolveField` hook, this hook will call them all
    // as dictated by the dispatcher.  We will call this when object
    // resolution is complete.
    const didResolveField =
      typeof willResolveField === 'function' &&
      willResolveField({ source, args, contextValue, info });

    const fieldResolver =
      originalFieldResolve || userFieldResolver || defaultFieldResolver;

    try {
      const result = fieldResolver(source, args, contextValue, info);

      // Call the stack's handlers either immediately (if result is not a
      // Promise) or once the Promise is done. Then return that same
      // maybe-Promise value.
      if (typeof didResolveField === 'function') {
        whenResultIsFinished(result, didResolveField);
      }
      return result;
    } catch (error) {
      // Normally it's a bad sign to see an error both handled and
      // re-thrown. But it is useful to allow extensions to track errors while
      // still handling them in the normal GraphQL way.
      if (typeof didResolveField === 'function') {
        didResolveField(error as Error);
      }
      throw error;
    }
  };
}

function isPromise(x: any): boolean {
  return x && typeof x.then === 'function';
}

// Given result (which may be a Promise or an array some of whose elements are
// promises) Promises, set up 'callback' to be invoked when result is fully
// resolved.
export function whenResultIsFinished(
  result: any,
  callback: (err: Error | null, result?: any) => void,
) {
  if (isPromise(result)) {
    result.then(
      (r: any) => callback(null, r),
      (err: Error) => callback(err),
    );
  } else if (Array.isArray(result)) {
    if (result.some(isPromise)) {
      Promise.all(result).then(
        (r: any) => callback(null, r),
        (err: Error) => callback(err),
      );
    } else {
      callback(null, result);
    }
  } else {
    callback(null, result);
  }
}
Ÿ&/dist/esm/externalTypes/constructor.jsƒ2export {};
//# sourceMappingURL=constructor.js.mapŸ*/dist/esm/plugin/usageReporting/index.d.ts≈export { ApolloServerPluginUsageReporting } from './plugin.js';
export type { ApolloServerPluginUsageReportingOptions, SendValuesBaseOptions, VariableValueOptions, SendErrorsOptions, ClientInfo, GenerateClientInfo, } from './options.js';
//# sourceMappingURL=index.d.ts.mapº/dist/esm/preventCsrf.js.map≈{"version":3,"file":"preventCsrf.js","sourceRoot":"","sources":["../../src/preventCsrf.ts"],"names":[],"mappings":"AAAA,OAAO,QAAQ,MAAM,iBAAiB,CAAC;AACvC,OAAO,EAAE,eAAe,EAAE,MAAM,2BAA2B,CAAC;AAa5D,MAAM,CAAC,MAAM,uCAAuC,GAAG;IACrD,yBAAyB;IACzB,0BAA0B;CAC3B,CAAC;AAGF,MAAM,6BAA6B,GAAG;IACpC,mCAAmC;IACnC,qBAAqB;IACrB,YAAY;CACb,CAAC;AAqBF,MAAM,UAAU,WAAW,CACzB,OAAkB,EAClB,4BAAsC;IAEtC,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAOhD,IAAI,WAAW,KAAK,SAAS,EAAE;QAC7B,MAAM,iBAAiB,GAAG,QAAQ,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;QACtD,IAAI,iBAAiB,KAAK,IAAI,EAAE;YAQ9B,OAAO;SACR;QACD,IAAI,CAAC,6BAA6B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE;YAKtE,OAAO;SACR;KACF;IAMD,IACE,4BAA4B,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE;QAC3C,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAClC,OAAO,KAAK,KAAK,SAAS,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;IACjD,CAAC,CAAC,EACF;QACA,OAAO;KACR;IAED,MAAM,IAAI,eAAe,CACvB,4EAA4E;QAC1E,0EAA0E;QAC1E,iBAAiB,6BAA6B,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe;QACxE,uDAAuD,4BAA4B,CAAC,IAAI,CACtF,IAAI,CACL,IAAI,CACR,CAAC;AACJ,CAAC"}Ÿ+/dist/esm/generated/packageVersion.d.ts.mapƒß{"version":3,"file":"packageVersion.d.ts","sourceRoot":"","sources":["../../../src/generated/packageVersion.ts"],"names":[],"mappings":"AAAA,eAAO,MAAM,cAAc,UAAU,CAAC"}Ω/dist/esm/standalone/index.js≈¿import bodyParser from 'body-parser';
import cors from 'cors';
import express from 'express';
import http from 'http';
import { expressMiddleware } from '../express4/index.js';
import { ApolloServerPluginDrainHttpServer } from '../plugin/drainHttpServer/index.js';
import { urlForHttpServer } from '../utils/urlForHttpServer.js';
export async function startStandaloneServer(server, options) {
    const app = express();
    const httpServer = http.createServer(app);
    server.addPlugin(ApolloServerPluginDrainHttpServer({ httpServer: httpServer }));
    await server.start();
    const context = options?.context ?? (async () => ({}));
    app.use(cors(), bodyParser.json(), expressMiddleware(server, { context }));
    const listenOptions = options?.listen ?? { port: 4000 };
    await new Promise((resolve) => {
        httpServer.listen(listenOptions, resolve);
    });
    return { url: urlForHttpServer(httpServer) };
}
//# sourceMappingURL=index.js.mapº/dist/cjs/utils/HeaderMap.js≈È"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeaderMap = void 0;
class HeaderMap extends Map {
    set(key, value) {
        return super.set(key.toLowerCase(), value);
    }
    get(key) {
        return super.get(key.toLowerCase());
    }
    delete(key) {
        return super.delete(key.toLowerCase());
    }
    has(key) {
        return super.has(key.toLowerCase());
    }
}
exports.HeaderMap = HeaderMap;
//# sourceMappingURL=HeaderMap.js.mapŸ%/dist/esm/plugin/schemaIsFederated.js≈ˇimport { isObjectType, isScalarType } from 'graphql';
export function schemaIsFederated(schema) {
    const serviceType = schema.getType('_Service');
    if (!isObjectType(serviceType)) {
        return false;
    }
    const sdlField = serviceType.getFields().sdl;
    if (!sdlField) {
        return false;
    }
    const sdlFieldType = sdlField.type;
    if (!isScalarType(sdlFieldType)) {
        return false;
    }
    return sdlFieldType.name == 'String';
}
//# sourceMappingURL=schemaIsFederated.js.mapŸ%/dist/cjs/generated/packageVersion.jsƒ∫"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.packageVersion = void 0;
exports.packageVersion = "4.1.1";
//# sourceMappingURL=packageVersion.js.mapŸ9/dist/esm/plugin/usageReporting/iterateOverTrace.d.ts.map≈…{"version":3,"file":"iterateOverTrace.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/iterateOverTrace.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AAoB9D,wBAAgB,gBAAgB,CAC9B,KAAK,EAAE,KAAK,EACZ,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,EAAE,IAAI,EAAE,gBAAgB,KAAK,OAAO,EACzD,WAAW,EAAE,OAAO,QAYrB;AA8DD,MAAM,WAAW,gBAAgB;IAC/B,OAAO,IAAI,MAAM,EAAE,CAAC;IACpB,KAAK,CAAC,YAAY,EAAE,MAAM,GAAG,gBAAgB,CAAC;CAC/C"}≥/src/cachePolicy.ts≈yimport type { CacheHint, CachePolicy } from '@apollo/cache-control-types';

export function newCachePolicy(): CachePolicy {
  return {
    maxAge: undefined,
    scope: undefined,
    restrict(hint: CacheHint) {
      if (
        hint.maxAge !== undefined &&
        (this.maxAge === undefined || hint.maxAge < this.maxAge)
      ) {
        this.maxAge = hint.maxAge;
      }
      if (hint.scope !== undefined && this.scope !== 'PRIVATE') {
        this.scope = hint.scope;
      }
    },
    replace(hint: CacheHint) {
      if (hint.maxAge !== undefined) {
        this.maxAge = hint.maxAge;
      }
      if (hint.scope !== undefined) {
        this.scope = hint.scope;
      }
    },
    policyIfCacheable() {
      if (this.maxAge === undefined || this.maxAge === 0) {
        return null;
      }
      return { maxAge: this.maxAge, scope: this.scope ?? 'PUBLIC' };
    },
  };
}
∏/dist/esm/preventCsrf.js≈cimport MIMEType from 'whatwg-mimetype';
import { BadRequestError } from './internalErrorClasses.js';
export const recommendedCsrfPreventionRequestHeaders = [
    'x-apollo-operation-name',
    'apollo-require-preflight',
];
const NON_PREFLIGHTED_CONTENT_TYPES = [
    'application/x-www-form-urlencoded',
    'multipart/form-data',
    'text/plain',
];
export function preventCsrf(headers, csrfPreventionRequestHeaders) {
    const contentType = headers.get('content-type');
    if (contentType !== undefined) {
        const contentTypeParsed = MIMEType.parse(contentType);
        if (contentTypeParsed === null) {
            return;
        }
        if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
            return;
        }
    }
    if (csrfPreventionRequestHeaders.some((header) => {
        const value = headers.get(header);
        return value !== undefined && value.length > 0;
    })) {
        return;
    }
    throw new BadRequestError(`This operation has been blocked as a potential Cross-Site Request Forgery ` +
        `(CSRF). Please either specify a 'content-type' header (with a type that ` +
        `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +
        `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(', ')}\n`);
}
//# sourceMappingURL=preventCsrf.js.mapº/dist/esm/requestPipeline.js≈7Íimport { createHash } from '@apollo/utils.createhash';
import { specifiedRules, getOperationAST, GraphQLError, validate, parse, Kind, } from 'graphql';
import { symbolExecutionDispatcherWillResolveField, enablePluginsForSchemaResolvers, symbolUserFieldResolver, } from './utils/schemaInstrumentation.js';
import { PersistedQueryNotSupportedError, PersistedQueryNotFoundError, UserInputError, BadRequestError, ValidationError, SyntaxError, OperationResolutionError, } from './internalErrorClasses.js';
import { ensureError, normalizeAndFormatErrors, ensureGraphQLError, } from './errorNormalize.js';
import { invokeDidStartHook, invokeHooksUntilDefinedAndNonNull, invokeSyncDidStartHook, } from './utils/invokeHooks.js';
import { makeGatewayGraphQLRequestContext } from './utils/makeGatewayGraphQLRequestContext.js';
import { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';
import { isDefined } from './utils/isDefined.js';
import { executeIncrementally, } from './incrementalDeliveryPolyfill.js';
import { HeaderMap } from './utils/HeaderMap.js';
export const APQ_CACHE_PREFIX = 'apq:';
function computeQueryHash(query) {
    return createHash('sha256').update(query).digest('hex');
}
function isBadUserInputGraphQLError(error) {
    return (error.nodes?.length === 1 &&
        error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&
        (error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" got invalid value `) ||
            error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of required type `) ||
            error.message.startsWith(`Variable "$${error.nodes[0].variable.name.value}" of non-null type `)));
}
export async function processGraphQLRequest(schemaDerivedData, server, internals, requestContext) {
    const requestListeners = (await Promise.all(internals.plugins.map((p) => p.requestDidStart?.(requestContext)))).filter(isDefined);
    const request = requestContext.request;
    let { query, extensions } = request;
    let queryHash;
    requestContext.metrics.persistedQueryHit = false;
    requestContext.metrics.persistedQueryRegister = false;
    if (extensions?.persistedQuery) {
        if (!internals.persistedQueries) {
            return await sendErrorResponse([new PersistedQueryNotSupportedError()]);
        }
        else if (extensions.persistedQuery.version !== 1) {
            return await sendErrorResponse([
                new GraphQLError('Unsupported persisted query version', {
                    extensions: { http: newHTTPGraphQLHead(400) },
                }),
            ]);
        }
        queryHash = extensions.persistedQuery.sha256Hash;
        if (query === undefined) {
            query = await internals.persistedQueries.cache.get(queryHash);
            if (query) {
                requestContext.metrics.persistedQueryHit = true;
            }
            else {
                return await sendErrorResponse([new PersistedQueryNotFoundError()]);
            }
        }
        else {
            const computedQueryHash = computeQueryHash(query);
            if (queryHash !== computedQueryHash) {
                return await sendErrorResponse([
                    new GraphQLError('provided sha does not match query', {
                        extensions: { http: newHTTPGraphQLHead(400) },
                    }),
                ]);
            }
            requestContext.metrics.persistedQueryRegister = true;
        }
    }
    else if (query) {
        queryHash = computeQueryHash(query);
    }
    else {
        return await sendErrorResponse([
            new BadRequestError('GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.'),
        ]);
    }
    requestContext.queryHash = queryHash;
    requestContext.source = query;
    await Promise.all(requestListeners.map((l) => l.didResolveSource?.(requestContext)));
    if (schemaDerivedData.documentStore) {
        try {
            requestContext.document = await schemaDerivedData.documentStore.get(queryHash);
        }
        catch (err) {
            server.logger.warn('An error occurred while attempting to read from the documentStore. ' +
                ensureError(err).message);
        }
    }
    if (!requestContext.document) {
        const parsingDidEnd = await invokeDidStartHook(requestListeners, async (l) => l.parsingDidStart?.(requestContext));
        try {
            requestContext.document = parse(query, internals.parseOptions);
        }
        catch (syntaxMaybeError) {
            const error = ensureError(syntaxMaybeError);
            await parsingDidEnd(error);
            return await sendErrorResponse([
                new SyntaxError(ensureGraphQLError(error)),
            ]);
        }
        await parsingDidEnd();
        const validationDidEnd = await invokeDidStartHook(requestListeners, async (l) => l.validationDidStart?.(requestContext));
        const validationErrors = validate(schemaDerivedData.schema, requestContext.document, [...specifiedRules, ...internals.validationRules]);
        if (validationErrors.length === 0) {
            await validationDidEnd();
        }
        else {
            await validationDidEnd(validationErrors);
            return await sendErrorResponse(validationErrors.map((error) => new ValidationError(error)));
        }
        if (schemaDerivedData.documentStore) {
            Promise.resolve(schemaDerivedData.documentStore.set(queryHash, requestContext.document)).catch((err) => server.logger.warn('Could not store validated document. ' + err?.message || err));
        }
    }
    const operation = getOperationAST(requestContext.document, request.operationName);
    requestContext.operation = operation || undefined;
    requestContext.operationName = operation?.name?.value || null;
    if (request.http?.method === 'GET' &&
        operation?.operation &&
        operation.operation !== 'query') {
        return await sendErrorResponse([
            new BadRequestError(`GET requests only support query operations, not ${operation.operation} operations`, {
                extensions: {
                    http: { status: 405, headers: new HeaderMap([['allow', 'POST']]) },
                },
            }),
        ]);
    }
    try {
        await Promise.all(requestListeners.map((l) => l.didResolveOperation?.(requestContext)));
    }
    catch (err) {
        return await sendErrorResponse([ensureGraphQLError(err)]);
    }
    if (requestContext.metrics.persistedQueryRegister &&
        internals.persistedQueries) {
        const ttl = internals.persistedQueries?.ttl;
        Promise.resolve(internals.persistedQueries.cache.set(queryHash, query, ttl !== undefined
            ? { ttl: internals.persistedQueries?.ttl }
            : undefined)).catch(server.logger.warn);
    }
    const responseFromPlugin = await invokeHooksUntilDefinedAndNonNull(requestListeners, async (l) => await l.responseForOperation?.(requestContext));
    if (responseFromPlugin !== null) {
        requestContext.response.body = responseFromPlugin.body;
        mergeHTTPGraphQLHead(requestContext.response.http, responseFromPlugin.http);
    }
    else {
        const executionListeners = (await Promise.all(requestListeners.map((l) => l.executionDidStart?.(requestContext)))).filter(isDefined);
        executionListeners.reverse();
        if (executionListeners.some((l) => l.willResolveField)) {
            const invokeWillResolveField = (...args) => invokeSyncDidStartHook(executionListeners, (l) => l.willResolveField?.(...args));
            Object.defineProperty(requestContext.contextValue, symbolExecutionDispatcherWillResolveField, { value: invokeWillResolveField });
            if (internals.fieldResolver) {
                Object.defineProperty(requestContext.contextValue, symbolUserFieldResolver, {
                    value: internals.fieldResolver,
                });
            }
            enablePluginsForSchemaResolvers(schemaDerivedData.schema);
        }
        try {
            const fullResult = await execute(requestContext);
            const result = 'singleResult' in fullResult
                ? fullResult.singleResult
                : fullResult.initialResult;
            if (!requestContext.operation) {
                if (!result.errors?.length) {
                    throw new Error('Unexpected error: Apollo Server did not resolve an operation but execute did not return errors');
                }
                throw new OperationResolutionError(result.errors[0]);
            }
            const resultErrors = result.errors?.map((e) => {
                if (isBadUserInputGraphQLError(e)) {
                    return new UserInputError(e);
                }
                return e;
            });
            if (resultErrors) {
                await didEncounterErrors(resultErrors);
            }
            const { formattedErrors, httpFromErrors } = resultErrors
                ? formatErrors(resultErrors)
                : { formattedErrors: undefined, httpFromErrors: newHTTPGraphQLHead() };
            mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);
            if ('singleResult' in fullResult) {
                requestContext.response.body = {
                    kind: 'single',
                    singleResult: {
                        ...result,
                        errors: formattedErrors,
                    },
                };
            }
            else {
                requestContext.response.body = {
                    kind: 'incremental',
                    initialResult: {
                        ...fullResult.initialResult,
                        errors: formattedErrors,
                    },
                    subsequentResults: fullResult.subsequentResults,
                };
            }
        }
        catch (executionMaybeError) {
            const executionError = ensureError(executionMaybeError);
            await Promise.all(executionListeners.map((l) => l.executionDidEnd?.(executionError)));
            return await sendErrorResponse([ensureGraphQLError(executionError)]);
        }
        await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));
    }
    await invokeWillSendResponse();
    if (!requestContext.response.body) {
        throw Error('got to end of processGraphQLRequest without setting body?');
    }
    return requestContext.response;
    async function execute(requestContext) {
        const { request, document } = requestContext;
        if (internals.__testing_incrementalExecutionResults) {
            return internals.__testing_incrementalExecutionResults;
        }
        else if (internals.gatewayExecutor) {
            const result = await internals.gatewayExecutor(makeGatewayGraphQLRequestContext(requestContext, server, internals));
            return { singleResult: result };
        }
        else {
            const resultOrResults = await executeIncrementally({
                schema: schemaDerivedData.schema,
                document,
                rootValue: typeof internals.rootValue === 'function'
                    ? internals.rootValue(document)
                    : internals.rootValue,
                contextValue: requestContext.contextValue,
                variableValues: request.variables,
                operationName: request.operationName,
                fieldResolver: internals.fieldResolver,
            });
            if ('initialResult' in resultOrResults) {
                return {
                    initialResult: resultOrResults.initialResult,
                    subsequentResults: formatErrorsInSubsequentResults(resultOrResults.subsequentResults),
                };
            }
            else {
                return { singleResult: resultOrResults };
            }
        }
    }
    async function* formatErrorsInSubsequentResults(results) {
        for await (const result of results) {
            const payload = result.incremental
                ? {
                    ...result,
                    incremental: await seriesAsyncMap(result.incremental, async (incrementalResult) => {
                        const { errors } = incrementalResult;
                        if (errors) {
                            await Promise.all(requestListeners.map((l) => l.didEncounterSubsequentErrors?.(requestContext, errors)));
                            return {
                                ...incrementalResult,
                                errors: formatErrors(errors).formattedErrors,
                            };
                        }
                        return incrementalResult;
                    }),
                }
                : result;
            await Promise.all(requestListeners.map((l) => l.willSendSubsequentPayload?.(requestContext, payload)));
            yield payload;
        }
    }
    async function invokeWillSendResponse() {
        await Promise.all(requestListeners.map((l) => l.willSendResponse?.(requestContext)));
    }
    async function didEncounterErrors(errors) {
        requestContext.errors = errors;
        return await Promise.all(requestListeners.map((l) => l.didEncounterErrors?.(requestContext)));
    }
    async function sendErrorResponse(errors) {
        await didEncounterErrors(errors);
        const { formattedErrors, httpFromErrors } = formatErrors(errors);
        requestContext.response.body = {
            kind: 'single',
            singleResult: {
                errors: formattedErrors,
            },
        };
        mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);
        if (!requestContext.response.http.status) {
            requestContext.response.http.status = 500;
        }
        await invokeWillSendResponse();
        return requestContext.response;
    }
    function formatErrors(errors) {
        return normalizeAndFormatErrors(errors, {
            formatError: internals.formatError,
            includeStacktraceInErrorResponses: internals.includeStacktraceInErrorResponses,
        });
    }
}
async function seriesAsyncMap(ts, fn) {
    const us = [];
    for (const t of ts) {
        const u = await fn(t);
        us.push(u);
    }
    return us;
}
//# sourceMappingURL=requestPipeline.js.mapŸ//dist/esm/plugin/landingPage/default/types.d.ts≈export interface ApolloServerPluginLandingPageDefaultBaseOptions {
    version?: string;
    footer?: boolean;
    document?: string;
    variables?: Record<string, any>;
    headers?: Record<string, string>;
    includeCookies?: boolean;
    __internal_apolloStudioEnv__?: 'staging' | 'prod';
}
export interface ApolloServerPluginNonEmbeddedLandingPageLocalDefaultOptions extends ApolloServerPluginLandingPageDefaultBaseOptions {
    embed: false;
}
export interface ApolloServerPluginNonEmbeddedLandingPageProductionDefaultOptions extends ApolloServerPluginLandingPageDefaultBaseOptions {
    graphRef?: string;
    embed?: false;
}
export interface ApolloServerPluginEmbeddedLandingPageLocalDefaultOptions extends ApolloServerPluginLandingPageDefaultBaseOptions {
    embed?: true;
}
export interface ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions extends ApolloServerPluginLandingPageDefaultBaseOptions {
    graphRef: string;
    embed: true | EmbeddableExplorerOptions;
}
declare type EmbeddableExplorerOptions = {
    displayOptions?: {
        showHeadersAndEnvVars: boolean;
        docsPanelState: 'open' | 'closed';
        theme: 'light' | 'dark';
    };
    persistExplorerState: boolean;
};
export declare type ApolloServerPluginLandingPageLocalDefaultOptions = ApolloServerPluginEmbeddedLandingPageLocalDefaultOptions | ApolloServerPluginNonEmbeddedLandingPageLocalDefaultOptions;
export declare type ApolloServerPluginLandingPageProductionDefaultOptions = ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions | ApolloServerPluginNonEmbeddedLandingPageProductionDefaultOptions;
export declare type LandingPageConfig = ApolloServerPluginLandingPageLocalDefaultOptions | ApolloServerPluginLandingPageProductionDefaultOptions;
export {};
//# sourceMappingURL=types.d.ts.mapŸ"/dist/esm/utils/HeaderMap.d.ts.map≈M{"version":3,"file":"HeaderMap.d.ts","sourceRoot":"","sources":["../../../src/utils/HeaderMap.ts"],"names":[],"mappings":"AAAA,qBAAa,SAAU,SAAQ,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC;IACvC,GAAG,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,IAAI;IAIrC,GAAG,CAAC,GAAG,EAAE,MAAM;IAIf,MAAM,CAAC,GAAG,EAAE,MAAM;IAIlB,GAAG,CAAC,GAAG,EAAE,MAAM;CAGzB"}Ÿ?/dist/cjs/plugin/usageReporting/defaultSendOperationsAsTrace.js≈"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultSendOperationsAsTrace = void 0;
const lru_cache_1 = __importDefault(require("lru-cache"));
const iterateOverTrace_js_1 = require("./iterateOverTrace.js");
const durationHistogram_js_1 = require("./durationHistogram.js");
function defaultSendOperationsAsTrace() {
    const cache = new lru_cache_1.default({
        maxSize: Math.pow(2, 20),
        sizeCalculation: (_val, key) => {
            return (key && Buffer.byteLength(key)) || 0;
        },
    });
    return (trace, statsReportKey) => {
        const endTimeSeconds = trace.endTime?.seconds;
        if (endTimeSeconds == null) {
            throw Error('programming error: endTime not set on trace');
        }
        const hasErrors = traceHasErrors(trace);
        const cacheKey = JSON.stringify([
            statsReportKey,
            durationHistogram_js_1.DurationHistogram.durationToBucket(trace.durationNs),
            Math.floor(endTimeSeconds / 60),
            hasErrors ? Math.floor(endTimeSeconds / 5) : '',
        ]);
        if (cache.get(cacheKey)) {
            return false;
        }
        cache.set(cacheKey, true);
        return true;
    };
}
exports.defaultSendOperationsAsTrace = defaultSendOperationsAsTrace;
function traceHasErrors(trace) {
    let hasErrors = false;
    function traceNodeStats(node) {
        if ((node.error?.length ?? 0) > 0) {
            hasErrors = true;
        }
        return hasErrors;
    }
    (0, iterateOverTrace_js_1.iterateOverTrace)(trace, traceNodeStats, false);
    return hasErrors;
}
//# sourceMappingURL=defaultSendOperationsAsTrace.js.mapŸ /dist/cjs/requestPipeline.js.map≈,P{"version":3,"file":"requestPipeline.js","sourceRoot":"","sources":["../../src/requestPipeline.ts"],"names":[],"mappings":"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"}Ÿ4/dist/esm/plugin/usageReporting/durationHistogram.js≈Ûexport class DurationHistogram {
    constructor(options) {
        const initSize = options?.initSize || 74;
        const buckets = options?.buckets;
        const arrayInitSize = Math.max(buckets?.length || 0, initSize);
        this.buckets = Array(arrayInitSize).fill(0);
        if (buckets) {
            buckets.forEach((val, index) => (this.buckets[index] = val));
        }
    }
    toArray() {
        let bufferedZeroes = 0;
        const outputArray = [];
        for (const value of this.buckets) {
            if (value === 0) {
                bufferedZeroes++;
            }
            else {
                if (bufferedZeroes === 1) {
                    outputArray.push(0);
                }
                else if (bufferedZeroes !== 0) {
                    outputArray.push(-bufferedZeroes);
                }
                outputArray.push(Math.floor(value));
                bufferedZeroes = 0;
            }
        }
        return outputArray;
    }
    static durationToBucket(durationNs) {
        const log = Math.log(durationNs / 1000.0);
        const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);
        return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)
            ? 0
            : unboundedBucket >= DurationHistogram.BUCKET_COUNT
                ? DurationHistogram.BUCKET_COUNT - 1
                : unboundedBucket;
    }
    incrementDuration(durationNs, value = 1) {
        this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);
        return this;
    }
    incrementBucket(bucket, value = 1) {
        if (bucket >= DurationHistogram.BUCKET_COUNT) {
            throw Error('Bucket is out of bounds of the buckets array');
        }
        if (bucket >= this.buckets.length) {
            const oldLength = this.buckets.length;
            this.buckets.length = bucket + 1;
            this.buckets.fill(0, oldLength);
        }
        this.buckets[bucket] += value;
    }
    combine(otherHistogram) {
        for (let i = 0; i < otherHistogram.buckets.length; i++) {
            this.incrementBucket(i, otherHistogram.buckets[i]);
        }
    }
}
DurationHistogram.BUCKET_COUNT = 384;
DurationHistogram.EXPONENT_LOG = Math.log(1.1);
//# sourceMappingURL=durationHistogram.js.mapŸ//dist/esm/plugin/drainHttpServer/index.d.ts.map≈|{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/plugin/drainHttpServer/index.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,EAAE,kBAAkB,EAAE,MAAM,8BAA8B,CAAC;AAMvE,MAAM,WAAW,wCAAwC;IAIvD,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC;IAKxB,qBAAqB,CAAC,EAAE,MAAM,CAAC;CAChC;AAQD,wBAAgB,iCAAiC,CAC/C,OAAO,EAAE,wCAAwC,GAChD,kBAAkB,CAWpB"}Ÿ(/dist/esm/determineApolloConfig.d.ts.map≈{"version":3,"file":"determineApolloConfig.d.ts","sourceRoot":"","sources":["../../src/determineApolloConfig.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,YAAY,EAAE,iBAAiB,EAAE,MAAM,0BAA0B,CAAC;AAIhF,wBAAgB,qBAAqB,CACnC,KAAK,EAAE,iBAAiB,GAAG,SAAS,GACnC,YAAY,CA2Dd"}Ÿ-/dist/esm/utils/UnreachableCaseError.d.ts.mapƒ…{"version":3,"file":"UnreachableCaseError.d.ts","sourceRoot":"","sources":["../../../src/utils/UnreachableCaseError.ts"],"names":[],"mappings":"AAKA,qBAAa,oBAAqB,SAAQ,KAAK;gBACjC,GAAG,EAAE,KAAK;CAGvB"}Ÿ?/dist/esm/plugin/usageReporting/defaultSendOperationsAsTrace.js≈iimport LRUCache from 'lru-cache';
import { iterateOverTrace } from './iterateOverTrace.js';
import { DurationHistogram } from './durationHistogram.js';
export function defaultSendOperationsAsTrace() {
    const cache = new LRUCache({
        maxSize: Math.pow(2, 20),
        sizeCalculation: (_val, key) => {
            return (key && Buffer.byteLength(key)) || 0;
        },
    });
    return (trace, statsReportKey) => {
        const endTimeSeconds = trace.endTime?.seconds;
        if (endTimeSeconds == null) {
            throw Error('programming error: endTime not set on trace');
        }
        const hasErrors = traceHasErrors(trace);
        const cacheKey = JSON.stringify([
            statsReportKey,
            DurationHistogram.durationToBucket(trace.durationNs),
            Math.floor(endTimeSeconds / 60),
            hasErrors ? Math.floor(endTimeSeconds / 5) : '',
        ]);
        if (cache.get(cacheKey)) {
            return false;
        }
        cache.set(cacheKey, true);
        return true;
    };
}
function traceHasErrors(trace) {
    let hasErrors = false;
    function traceNodeStats(node) {
        if ((node.error?.length ?? 0) > 0) {
            hasErrors = true;
        }
        return hasErrors;
    }
    iterateOverTrace(trace, traceNodeStats, false);
    return hasErrors;
}
//# sourceMappingURL=defaultSendOperationsAsTrace.js.mapΩ/src/externalTypes/graphql.ts≈&/**
 * This file exports types related specifically to GraphQL execution, most
 * notably `GraphQLRequest` and `GraphQLResponse`, used most heavily by
 * `executeHTTPGraphQLRequest` and `executeOperation`. The
 * `responseForOperation` plugin hook also returns a `GraphQLResponse`.
 */
import type { FormattedExecutionResult } from 'graphql';
import type { BaseContext } from './context.js';
import type { HTTPGraphQLHead, HTTPGraphQLRequest } from './http.js';
import type { WithRequired } from '@apollo/utils.withrequired';
import type {
  GraphQLExperimentalFormattedInitialIncrementalExecutionResult,
  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,
} from './incrementalDeliveryPolyfill.js';

export interface GraphQLRequest<
  TVariables extends VariableValues = VariableValues,
> {
  query?: string;
  operationName?: string;
  variables?: TVariables;
  extensions?: Record<string, any>;
  http?: HTTPGraphQLRequest;
}

export type VariableValues = { [name: string]: any };

// A GraphQL response can either be a single result, or an initial result
// followed by a stream of subsequent results. The latter occurs when the
// GraphQL operation uses incremental delivery directives such as `@defer` or
// `@stream`. Note that incremental delivery currently requires using a
// pre-release of graphql-js v17.
export type GraphQLResponseBody<TData = Record<string, unknown>> =
  | {
      kind: 'single';
      singleResult: FormattedExecutionResult<TData>;
    }
  | {
      kind: 'incremental';
      initialResult: GraphQLExperimentalFormattedInitialIncrementalExecutionResult;
      subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>;
    };

export type GraphQLInProgressResponse<TData = Record<string, unknown>> = {
  http: HTTPGraphQLHead;
  body?: GraphQLResponseBody<TData>;
};

export type GraphQLResponse<TData = Record<string, unknown>> = WithRequired<
  GraphQLInProgressResponse<TData>,
  'body'
>;
export interface ExecuteOperationOptions<TContext extends BaseContext> {
  contextValue?: TContext;
}
Ÿ"/dist/esm/utils/schemaManager.d.ts≈import type { Logger } from '@apollo/utils.logger';
import type { GraphQLSchema } from 'graphql';
import type { GatewayExecutor, GatewayInterface, GatewayUnsubscriber } from '@apollo/server-gateway-interface';
import type { SchemaDerivedData } from '../ApolloServer.js';
import type { ApolloConfig, GraphQLSchemaContext } from '../externalTypes/index.js';
declare type SchemaDerivedDataProvider = (apiSchema: GraphQLSchema) => SchemaDerivedData;
export declare class SchemaManager {
    private readonly logger;
    private readonly schemaDerivedDataProvider;
    private readonly onSchemaLoadOrUpdateListeners;
    private isStopped;
    private schemaDerivedData?;
    private schemaContext?;
    private readonly modeSpecificState;
    constructor(options: ({
        gateway: GatewayInterface;
        apolloConfig: ApolloConfig;
    } | {
        apiSchema: GraphQLSchema;
    }) & {
        logger: Logger;
        schemaDerivedDataProvider: SchemaDerivedDataProvider;
    });
    start(): Promise<GatewayExecutor | null>;
    onSchemaLoadOrUpdate(callback: (schemaContext: GraphQLSchemaContext) => void): GatewayUnsubscriber;
    getSchemaDerivedData(): SchemaDerivedData;
    stop(): Promise<void>;
    private processSchemaLoadOrUpdateEvent;
}
export {};
//# sourceMappingURL=schemaManager.d.ts.map¥/dist/esm/index.d.tsƒ±export { ApolloServer } from './ApolloServer.js';
export { HeaderMap } from './utils/HeaderMap.js';
export * from './externalTypes/index.js';
//# sourceMappingURL=index.d.ts.map∂/src/express4/index.ts≈°import type { WithRequired } from '@apollo/utils.withrequired';
import type express from 'express';
import type { ApolloServer } from '../index.js';
import type {
  BaseContext,
  ContextFunction,
  HTTPGraphQLRequest,
} from '../externalTypes/index.js';
import { parse as urlParse } from 'url';

export interface ExpressContextFunctionArgument {
  req: express.Request;
  res: express.Response;
}

export interface ExpressMiddlewareOptions<TContext extends BaseContext> {
  context?: ContextFunction<[ExpressContextFunctionArgument], TContext>;
}

export function expressMiddleware(
  server: ApolloServer<BaseContext>,
  options?: ExpressMiddlewareOptions<BaseContext>,
): express.RequestHandler;
export function expressMiddleware<TContext extends BaseContext>(
  server: ApolloServer<TContext>,
  options: WithRequired<ExpressMiddlewareOptions<TContext>, 'context'>,
): express.RequestHandler;
export function expressMiddleware<TContext extends BaseContext>(
  server: ApolloServer<TContext>,
  options?: ExpressMiddlewareOptions<TContext>,
): express.RequestHandler {
  server.assertStarted('expressMiddleware()');

  // This `any` is safe because the overload above shows that context can
  // only be left out if you're using BaseContext as your context, and {} is a
  // valid BaseContext.
  const defaultContext: ContextFunction<
    [ExpressContextFunctionArgument],
    any
  > = async () => ({});

  const context: ContextFunction<[ExpressContextFunctionArgument], TContext> =
    options?.context ?? defaultContext;

  return (req, res, next) => {
    if (!req.body) {
      // The json body-parser *always* sets req.body to {} if it's unset (even
      // if the Content-Type doesn't match), so if it isn't set, you probably
      // forgot to set up body-parser. (Note that this may change in the future
      // body-parser@2.)
      res.status(500);
      res.send(
        '`req.body` is not set; this probably means you forgot to set up the ' +
          '`body-parser` middleware before the Apollo Server middleware.',
      );
      return;
    }

    const headers = new Map<string, string>();
    for (const [key, value] of Object.entries(req.headers)) {
      if (value !== undefined) {
        // Node/Express headers can be an array or a single value. We join
        // multi-valued headers with `, ` just like the Fetch API's `Headers`
        // does. We assume that keys are already lower-cased (as per the Node
        // docs on IncomingMessage.headers) and so we don't bother to lower-case
        // them or combine across multiple keys that would lower-case to the
        // same value.
        headers.set(key, Array.isArray(value) ? value.join(', ') : value);
      }
    }

    const httpGraphQLRequest: HTTPGraphQLRequest = {
      method: req.method.toUpperCase(),
      headers,
      search: urlParse(req.url).search ?? '',
      body: req.body,
    };

    server
      .executeHTTPGraphQLRequest({
        httpGraphQLRequest,
        context: () => context({ req, res }),
      })
      .then(async (httpGraphQLResponse) => {
        for (const [key, value] of httpGraphQLResponse.headers) {
          res.setHeader(key, value);
        }
        res.statusCode = httpGraphQLResponse.status || 200;

        if (httpGraphQLResponse.body.kind === 'complete') {
          res.send(httpGraphQLResponse.body.string);
          return;
        }

        for await (const chunk of httpGraphQLResponse.body.asyncIterator) {
          res.write(chunk);
          // Express/Node doesn't define a way of saying "it's time to send this
          // data over the wire"... but the popular `compression` middleware
          // (which implements `accept-encoding: gzip` and friends) does, by
          // monkey-patching a `flush` method onto the response. So we call it
          // if it's there.
          if (typeof (res as any).flush === 'function') {
            (res as any).flush();
          }
        }
        res.end();
      })
      .catch(next);
  };
}
Ÿ)/dist/esm/plugin/schemaReporting/index.js≈™import os from 'os';
import { internalPlugin } from '../../internalPlugin.js';
import { v4 as uuidv4 } from 'uuid';
import { printSchema, validateSchema, buildSchema } from 'graphql';
import { SchemaReporter } from './schemaReporter.js';
import { schemaIsFederated } from '../schemaIsFederated.js';
import { packageVersion } from '../../generated/packageVersion.js';
import { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';
export function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher, } = Object.create(null)) {
    const bootId = uuidv4();
    return internalPlugin({
        __internal_plugin_id__: 'SchemaReporting',
        __is_disabled_plugin__: false,
        async serverWillStart({ apollo, schema, logger }) {
            const { key, graphRef } = apollo;
            if (!key) {
                throw Error('To use ApolloServerPluginSchemaReporting, you must provide an Apollo API ' +
                    'key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`');
            }
            if (!graphRef) {
                throw Error('To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, ' +
                    "'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment " +
                    'variable or passing `new ApolloServer({apollo: {graphRef}})`.');
            }
            if (overrideReportedSchema) {
                try {
                    const validationErrors = validateSchema(buildSchema(overrideReportedSchema, { noLocation: true }));
                    if (validationErrors.length) {
                        throw new Error(validationErrors.map((error) => error.message).join('\n'));
                    }
                }
                catch (err) {
                    throw new Error('The schema provided to overrideReportedSchema failed to parse or ' +
                        `validate: ${err.message}`);
                }
            }
            if (schemaIsFederated(schema)) {
                throw Error([
                    'Schema reporting is not yet compatible with federated services.',
                    "If you're interested in using schema reporting with federated",
                    'services, please contact Apollo support. To set up managed federation, see',
                    'https://go.apollo.dev/s/managed-federation',
                ].join(' '));
            }
            if (endpointUrl !== undefined) {
                logger.info(`Apollo schema reporting: schema reporting URL override: ${endpointUrl}`);
            }
            const baseSchemaReport = {
                bootId,
                graphRef,
                platform: process.env.APOLLO_SERVER_PLATFORM || 'local',
                runtimeVersion: `node ${process.version}`,
                userVersion: process.env.APOLLO_SERVER_USER_VERSION,
                serverId: process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os.hostname(),
                libraryVersion: `@apollo/server@${packageVersion}`,
            };
            let currentSchemaReporter;
            return {
                schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }) {
                    if (overrideReportedSchema !== undefined) {
                        if (currentSchemaReporter) {
                            return;
                        }
                        else {
                            logger.info('Apollo schema reporting: schema to report has been overridden');
                        }
                    }
                    const coreSchema = overrideReportedSchema ??
                        coreSupergraphSdl ??
                        printSchema(apiSchema);
                    const coreSchemaHash = computeCoreSchemaHash(coreSchema);
                    const schemaReport = {
                        ...baseSchemaReport,
                        coreSchemaHash,
                    };
                    currentSchemaReporter?.stop();
                    currentSchemaReporter = new SchemaReporter({
                        schemaReport,
                        coreSchema,
                        apiKey: key,
                        endpointUrl,
                        logger,
                        initialReportingDelayInMs: Math.floor(Math.random() * (initialDelayMaxMs ?? 10000)),
                        fallbackReportingDelayInMs: 20000,
                        fetcher,
                    });
                    currentSchemaReporter.start();
                    logger.info('Apollo schema reporting: reporting a new schema to Studio! See your graph at ' +
                        `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/ with server info ${JSON.stringify(schemaReport)}`);
                },
                async serverWillStop() {
                    currentSchemaReporter?.stop();
                },
            };
        },
    });
}
//# sourceMappingURL=index.js.mapŸ./src/utils/makeGatewayGraphQLRequestContext.ts≈!´import type {
  GatewayGraphQLRequest,
  GatewayGraphQLRequestContext,
  GatewayGraphQLResponse,
  GatewaySchemaHash,
} from '@apollo/server-gateway-interface';
import type { FetcherHeaders } from '@apollo/utils.fetcher';
import type { ApolloServer, ApolloServerInternals } from '../ApolloServer';
import type {
  BaseContext,
  GraphQLRequestContextExecutionDidStart,
} from '../externalTypes';
import type { HeaderMap } from './HeaderMap';

// Apollo Gateway's API included `GraphQLRequestContext` from AS2/AS3.
// Specifically, a request context is passed to the main executor method, which
// it then exposes to user-configurable `GraphQLDataSource`s.
// `GraphQLRequestContext` has changed in incompatible ways in AS4; for example,
// we represent HTTP messages using our own data structures rather than Fetches,
// and some fields have been removed because they relate to features that don't
// exist any more.
//
// In general, the future of Apollo's development is in Apollo Router, not
// Gateway. So rather than have a big transition where a new version of Gateway
// supports AS4's GraphQLRequestContext instead of AS3's, we simply teach AS4
// how to produce AS3-style GraphQLRequestContext objects specifically for use
// by Gateway. We have changed Gateway to get its TS type definitions from a new
// package rather than from AS3 itself, so that Gateway no longer needs to
// depend on Apollo Server.
//
// This function turn an AS4 GraphQLRequestContext into a
// GatewayGraphQLRequestContext (which is basically an AS3
// GraphQLRequestContext).
//
// You might think that *after* invoking the executor, we would then need to
// propagate any changes made by the gateway back onto the "real"
// GraphQLRequestContext. It turns out that for each bit of data on the request
// context, this is either unnecessary or impossible. (We don't need to support
// use cases where people break type safe, eg by changing the values of readonly
// fields.) Here's why:
//
// Many fields on GatewayGraphQLRequestContext are declared readonly and their
// values are taken directly from the real GraphQLRequestContext. This means
// that gateways should not change the field's value, and any mutations of the
// object stored in the field (say, calling
// `requestContext.overallCachePolicy.restrict`, as RemoteGraphQLDataSource
// does) already take effect.
//
//  The only two fields not declared as readonly are `logger` and `debug`.
//
// Technically, a gateway implementation could set `requestContext.logger` to a
// different Logger without breaking the TypeScript declarations. In AS4 we
// don't actually have a requestContext.logger; we have `readonly
// requestContext.server` and `readonly server.logger`. So there's not an easy
// way for us to carry out this change: AS4 just doesn't let gateway or plugins
// override the server's logger (and generally doesn't allow the logger to
// change after the server is created), which seems like a simpler model. If it
// turns out there is a real use case for the gateway to be able to change the
// overall logger for the request as seen by plugins, we can fix that later.
//
// Similarly, it's not clear what the intended use case of mutating `debug` in
// gateway would be. `debug` has now mostly changed into
// `includeStacktraceInErrorResponses`. So perhaps this could be used to let you
// decide whether or not to include the stacktrace on a per-operation basis...
// but you can also use `formatError` or `didEncounterErrors` for this perhaps?
// In any case, AS4 doesn't track `includeStacktraceInErrorResponses` on a
// per-operation basis; if we find a use case for this we can add it later.
//
// So we'll just ignore changes to `logger` and `debug`.
//
// Next, there's `request`. We don't know of a use case for mutating the
// *request* at execution time. If there was a real use case, we could add a
// function that copies pieces back from the gateway `request` to the AS4
// request, but we're not bothering to yet.
//
// Finally, there's `response`. Sure, the executor *could* mutate `response`.
// But the main thing the executor is doing is *returning* a response, which
// then semi-overwrites `requestContext.response` anyway. So it doesn't seem
// like we need to support `executor` *also* overwriting response. Yet again, we
// can fix this if it turns out it's necessary. (That said, the executor could
// in theory write HTTP response headers or status, so we make sure to hook them
// up directly to the appropriate data in the real GraphQLRequestContext.)
//
// So all in all, it looks like it's OK for this to be a "one-way" conversion.
export function makeGatewayGraphQLRequestContext<TContext extends BaseContext>(
  as4RequestContext: GraphQLRequestContextExecutionDidStart<TContext>,
  server: ApolloServer<TContext>,
  internals: ApolloServerInternals<TContext>,
): GatewayGraphQLRequestContext {
  const request: GatewayGraphQLRequest = {};
  if ('query' in as4RequestContext.request) {
    request.query = as4RequestContext.request.query;
  }
  if ('operationName' in as4RequestContext.request) {
    request.operationName = as4RequestContext.request.operationName;
  }
  if ('variables' in as4RequestContext.request) {
    request.variables = as4RequestContext.request.variables;
  }
  if ('extensions' in as4RequestContext.request) {
    request.extensions = as4RequestContext.request.extensions;
  }
  if (as4RequestContext.request.http) {
    const as4http = as4RequestContext.request.http;
    const needQuestion =
      as4http.search !== '' && !as4http.search.startsWith('?');
    request.http = {
      method: as4http.method,
      // As of AS4, we no longer attempt to track complete URLs (just the search
      // parameters used in GET requests). So we have to fake them for Gateway.
      url: `https://unknown-url.invalid/${needQuestion ? '?' : ''}${
        as4http.search
      }`,
      headers: new FetcherHeadersForHeaderMap(as4http.headers),
    };
  }

  const response: GatewayGraphQLResponse = {
    http: {
      headers: new FetcherHeadersForHeaderMap(
        as4RequestContext.response.http.headers,
      ),
      get status() {
        return as4RequestContext.response.http.status;
      },
      set status(newStatus) {
        as4RequestContext.response.http.status = newStatus;
      },
    },
    // We leave off `body` because it hasn't been set yet.
  };

  return {
    request,
    response,
    logger: server.logger,
    schema: as4RequestContext.schema,
    // For the sake of typechecking, we still provide this field, but we don't
    // calculate it. If somebody really needs it in their gateway
    // implementation, they're welcome to copy
    // https://github.com/apollographql/apollo-server/blob/3f218e78/packages/apollo-server-core/src/utils/schemaHash.ts
    // into their code.
    schemaHash:
      'schemaHash no longer exists in Apollo Server 4' as GatewaySchemaHash,
    context: as4RequestContext.contextValue,
    cache: server.cache,
    queryHash: as4RequestContext.queryHash,
    document: as4RequestContext.document,
    source: as4RequestContext.source,
    operationName: as4RequestContext.operationName,
    operation: as4RequestContext.operation,
    errors: as4RequestContext.errors,
    metrics: as4RequestContext.metrics,
    debug: internals.includeStacktraceInErrorResponses,
    overallCachePolicy: as4RequestContext.overallCachePolicy,
    requestIsBatched: as4RequestContext.requestIsBatched,
  };
}

// An implementation of the W3C-style headers class used by Gateway (and AS3),
// backed by AS4's HeaderMap. Changes are written directly to the HeaderMap, so
// any concurrent writes to the underlying HeaderMap (eg from a plugin) can be
// seen immediately by the gateway and vice versa.
class FetcherHeadersForHeaderMap implements FetcherHeaders {
  constructor(private map: HeaderMap) {}
  append(name: string, value: string) {
    if (this.map.has(name)) {
      this.map.set(name, this.map.get(name) + ', ' + value);
    } else {
      this.map.set(name, value);
    }
  }
  delete(name: string) {
    this.map.delete(name);
  }
  get(name: string): string | null {
    return this.map.get(name) ?? null;
  }
  has(name: string): boolean {
    return this.map.has(name);
  }
  set(name: string, value: string) {
    this.map.set(name, value);
  }
  entries(): Iterator<[string, string]> {
    return this.map.entries();
  }
  keys(): Iterator<string> {
    return this.map.keys();
  }
  values(): Iterator<string> {
    return this.map.values();
  }
  [Symbol.iterator](): Iterator<[string, string]> {
    return this.map.entries();
  }
}
º/dist/cjs/utils/isDefined.jsƒ›"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDefined = void 0;
function isDefined(t) {
    return t != null;
}
exports.isDefined = isDefined;
//# sourceMappingURL=isDefined.js.mapŸ:/dist/esm/plugin/usageReporting/durationHistogram.d.ts.map≈{{"version":3,"file":"durationHistogram.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/durationHistogram.ts"],"names":[],"mappings":"AAAA,MAAM,WAAW,wBAAwB;IACvC,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,OAAO,CAAC,EAAE,MAAM,EAAE,CAAC;CACpB;AACD,qBAAa,iBAAiB;IAO5B,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAW;IACnC,MAAM,CAAC,QAAQ,CAAC,YAAY,OAAO;IACnC,MAAM,CAAC,QAAQ,CAAC,YAAY,SAAiB;IAE7C,OAAO,IAAI,MAAM,EAAE;IAoBnB,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,MAAM,GAAG,MAAM;IAYnD,iBAAiB,CAAC,UAAU,EAAE,MAAM,EAAE,KAAK,SAAI,GAAG,iBAAiB;IAKnE,eAAe,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,SAAI;IAgBzC,OAAO,CAAC,cAAc,EAAE,iBAAiB;gBAM7B,OAAO,CAAC,EAAE,wBAAwB;CAY/C"}Ÿ$/dist/esm/externalTypes/plugins.d.ts≈import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { Logger } from '@apollo/utils.logger';
import type { GraphQLError, GraphQLResolveInfo, GraphQLSchema } from 'graphql';
import type { ApolloConfig } from './constructor.js';
import type { BaseContext } from './context.js';
import type { GraphQLResponse } from './graphql.js';
import type { GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult } from './incrementalDeliveryPolyfill.js';
import type { GraphQLRequestContext, GraphQLRequestContextDidEncounterErrors, GraphQLRequestContextDidEncounterSubsequentErrors, GraphQLRequestContextDidResolveOperation, GraphQLRequestContextDidResolveSource, GraphQLRequestContextExecutionDidStart, GraphQLRequestContextParsingDidStart, GraphQLRequestContextResponseForOperation, GraphQLRequestContextValidationDidStart, GraphQLRequestContextWillSendResponse, GraphQLRequestContextWillSendSubsequentPayload } from './requestPipeline.js';
export interface GraphQLServerContext {
    readonly logger: Logger;
    readonly cache: KeyValueCache<string>;
    schema: GraphQLSchema;
    apollo: ApolloConfig;
    startedInBackground: boolean;
}
export interface GraphQLSchemaContext {
    apiSchema: GraphQLSchema;
    coreSupergraphSdl?: string;
}
export interface ApolloServerPlugin<in TContext extends BaseContext = BaseContext> {
    serverWillStart?(service: GraphQLServerContext): Promise<GraphQLServerListener | void>;
    requestDidStart?(requestContext: GraphQLRequestContext<TContext>): Promise<GraphQLRequestListener<TContext> | void>;
    unexpectedErrorProcessingRequest?({ requestContext, error, }: {
        requestContext: GraphQLRequestContext<TContext>;
        error: Error;
    }): Promise<void>;
    contextCreationDidFail?({ error }: {
        error: Error;
    }): Promise<void>;
    invalidRequestWasReceived?({ error }: {
        error: Error;
    }): Promise<void>;
    startupDidFail?({ error }: {
        error: Error;
    }): Promise<void>;
}
export interface GraphQLServerListener {
    schemaDidLoadOrUpdate?(schemaContext: GraphQLSchemaContext): void;
    drainServer?(): Promise<void>;
    serverWillStop?(): Promise<void>;
    renderLandingPage?(): Promise<LandingPage>;
}
export interface LandingPage {
    html: string;
}
export declare type GraphQLRequestListenerParsingDidEnd = (err?: Error) => Promise<void>;
export declare type GraphQLRequestListenerValidationDidEnd = (err?: ReadonlyArray<Error>) => Promise<void>;
export declare type GraphQLRequestListenerExecutionDidEnd = (err?: Error) => Promise<void>;
export declare type GraphQLRequestListenerDidResolveField = (error: Error | null, result?: any) => void;
export interface GraphQLRequestListener<TContext extends BaseContext> {
    didResolveSource?(requestContext: GraphQLRequestContextDidResolveSource<TContext>): Promise<void>;
    parsingDidStart?(requestContext: GraphQLRequestContextParsingDidStart<TContext>): Promise<GraphQLRequestListenerParsingDidEnd | void>;
    validationDidStart?(requestContext: GraphQLRequestContextValidationDidStart<TContext>): Promise<GraphQLRequestListenerValidationDidEnd | void>;
    didResolveOperation?(requestContext: GraphQLRequestContextDidResolveOperation<TContext>): Promise<void>;
    didEncounterErrors?(requestContext: GraphQLRequestContextDidEncounterErrors<TContext>): Promise<void>;
    responseForOperation?(requestContext: GraphQLRequestContextResponseForOperation<TContext>): Promise<GraphQLResponse | null>;
    executionDidStart?(requestContext: GraphQLRequestContextExecutionDidStart<TContext>): Promise<GraphQLRequestExecutionListener<TContext> | void>;
    willSendResponse?(requestContext: GraphQLRequestContextWillSendResponse<TContext>): Promise<void>;
    didEncounterSubsequentErrors?(requestContext: GraphQLRequestContextDidEncounterSubsequentErrors<TContext>, errors: ReadonlyArray<GraphQLError>): Promise<void>;
    willSendSubsequentPayload?(requestContext: GraphQLRequestContextWillSendSubsequentPayload<TContext>, payload: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult): Promise<void>;
}
export declare type GraphQLFieldResolverParams<TSource, TContext, TArgs = {
    [argName: string]: any;
}> = {
    source: TSource;
    args: TArgs;
    contextValue: TContext;
    info: GraphQLResolveInfo;
};
export interface GraphQLRequestExecutionListener<TContext extends BaseContext> {
    executionDidEnd?: GraphQLRequestListenerExecutionDidEnd;
    willResolveField?(fieldResolverParams: GraphQLFieldResolverParams<any, TContext>): GraphQLRequestListenerDidResolveField | void;
}
//# sourceMappingURL=plugins.d.ts.map∂/dist/cjs/index.js.mapƒÀ{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,qDAAiD;AAAxC,+GAAA,YAAY,OAAA;AACrB,qDAAiD;AAAxC,yGAAA,SAAS,OAAA;AAElB,2DAAyC"}Ÿ%/dist/cjs/plugin/inlineTrace/index.js≈!"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApolloServerPluginInlineTrace = void 0;
const usage_reporting_protobuf_1 = require("@apollo/usage-reporting-protobuf");
const traceTreeBuilder_js_1 = require("../traceTreeBuilder.js");
const internalPlugin_js_1 = require("../../internalPlugin.js");
const schemaIsFederated_js_1 = require("../schemaIsFederated.js");
function ApolloServerPluginInlineTrace(options = Object.create(null)) {
    let enabled = options.__onlyIfSchemaIsFederated ? null : true;
    return (0, internalPlugin_js_1.internalPlugin)({
        __internal_plugin_id__: 'InlineTrace',
        __is_disabled_plugin__: false,
        async serverWillStart({ schema, logger }) {
            if (enabled === null) {
                enabled = (0, schemaIsFederated_js_1.schemaIsFederated)(schema);
                if (enabled) {
                    logger.info('Enabling inline tracing for this federated service. To disable, use ' +
                        'ApolloServerPluginInlineTraceDisabled.');
                }
            }
        },
        async requestDidStart({ request: { http }, metrics, logger }) {
            if (!enabled) {
                return;
            }
            const treeBuilder = new traceTreeBuilder_js_1.TraceTreeBuilder({
                maskedBy: 'ApolloServerPluginInlineTrace',
                sendErrors: options.includeErrors,
                logger,
            });
            if (http?.headers.get('apollo-federation-include-trace') !== 'ftv1') {
                return;
            }
            if (metrics.captureTraces === false) {
                return;
            }
            metrics.captureTraces = true;
            treeBuilder.startTiming();
            return {
                async executionDidStart() {
                    return {
                        willResolveField({ info }) {
                            return treeBuilder.willResolveField(info);
                        },
                    };
                },
                async didEncounterErrors({ errors }) {
                    treeBuilder.didEncounterErrors(errors);
                },
                async willSendResponse({ response }) {
                    treeBuilder.stopTiming();
                    if (response.body.kind === 'incremental') {
                        return;
                    }
                    if (metrics.queryPlanTrace) {
                        treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                    }
                    const encodedUint8Array = usage_reporting_protobuf_1.Trace.encode(treeBuilder.trace).finish();
                    const encodedBuffer = Buffer.from(encodedUint8Array, encodedUint8Array.byteOffset, encodedUint8Array.byteLength);
                    const extensions = response.body.singleResult.extensions ||
                        (response.body.singleResult.extensions = Object.create(null));
                    if (typeof extensions.ftv1 !== 'undefined') {
                        throw new Error('The `ftv1` extension was already present.');
                    }
                    extensions.ftv1 = encodedBuffer.toString('base64');
                },
            };
        },
    });
}
exports.ApolloServerPluginInlineTrace = ApolloServerPluginInlineTrace;
//# sourceMappingURL=index.js.mapŸ./dist/esm/plugin/usageReporting/options.js.mapƒâ{"version":3,"file":"options.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/options.ts"],"names":[],"mappings":""}Ÿ /src/plugin/inlineTrace/index.ts≈import { Trace } from '@apollo/usage-reporting-protobuf';
import { TraceTreeBuilder } from '../traceTreeBuilder.js';
import type { SendErrorsOptions } from '../usageReporting/index.js';
import { internalPlugin } from '../../internalPlugin.js';
import { schemaIsFederated } from '../schemaIsFederated.js';
import type { ApolloServerPlugin } from '../../externalTypes/index.js';

export interface ApolloServerPluginInlineTraceOptions {
  /**
   * By default, if a trace contains errors, the errors are included in the
   * trace with the message `<masked>`. The errors are associated with specific
   * paths in the operation, but do not include the original error message or
   * any extensions such as the error `code`, as those details may contain your
   * users' private data. The extension `maskedBy:
   * 'ApolloServerPluginInlineTrace'` is added.
   *
   * If you'd like details about the error included in traces, set this option.
   * This option can take several forms:
   *
   * - { masked: true }: mask error messages and omit extensions (DEFAULT)
   * - { unmodified: true }: include all error messages and extensions
   * - { transform: ... }: a custom function for transforming errors. This
   *   function receives a `GraphQLError` and may return a `GraphQLError`
   *   (either a new error, or its potentially-modified argument) or `null`.
   *   This error is used in the trace; if `null`, the error is not included in
   *   traces or error statistics.
   */
  includeErrors?: SendErrorsOptions;
  /**
   * This option is for internal use by `@apollo/server` only.
   *
   * By default we want to enable this plugin for federated schemas only, but we
   * need to come up with our list of plugins before we have necessarily loaded
   * the schema. So (unless the user installs this plugin or
   * ApolloServerPluginInlineTraceDisabled themselves), `@apollo/server`
   * always installs this plugin and uses this option to make sure traces are
   * only included if the schema appears to be federated.
   */
  __onlyIfSchemaIsFederated?: boolean;
}

// This ftv1 plugin produces a base64'd Trace protobuf containing only the
// durationNs, startTime, endTime, and root fields.  This output is placed
// on the `extensions`.`ftv1` property of the response.  The Apollo Gateway
// utilizes this data to construct the full trace and submit it to Apollo's
// usage reporting ingress.
export function ApolloServerPluginInlineTrace(
  options: ApolloServerPluginInlineTraceOptions = Object.create(null),
): ApolloServerPlugin {
  let enabled: boolean | null = options.__onlyIfSchemaIsFederated ? null : true;
  return internalPlugin({
    __internal_plugin_id__: 'InlineTrace',
    __is_disabled_plugin__: false,
    async serverWillStart({ schema, logger }) {
      // Handle the case that the plugin was implicitly installed. We only want it
      // to actually be active if the schema appears to be federated. If you don't
      // like the log line, just install `ApolloServerPluginInlineTrace()` in
      // `plugins` yourself.
      if (enabled === null) {
        enabled = schemaIsFederated(schema);
        if (enabled) {
          logger.info(
            'Enabling inline tracing for this federated service. To disable, use ' +
              'ApolloServerPluginInlineTraceDisabled.',
          );
        }
      }
    },
    async requestDidStart({ request: { http }, metrics, logger }) {
      if (!enabled) {
        return;
      }

      const treeBuilder = new TraceTreeBuilder({
        maskedBy: 'ApolloServerPluginInlineTrace',
        sendErrors: options.includeErrors,
        logger,
      });

      // XXX Provide a mechanism to customize this logic.
      if (http?.headers.get('apollo-federation-include-trace') !== 'ftv1') {
        return;
      }

      // If some other (user-written?) plugin already decided that we are not
      // capturing traces, then we should not capture traces.
      if (metrics.captureTraces === false) {
        return;
      }

      // Note that this will override any `fieldLevelInstrumentation` parameter
      // to the usage reporting plugin for requests with the
      // `apollo-federation-include-trace` header set.
      metrics.captureTraces = true;

      treeBuilder.startTiming();

      return {
        async executionDidStart() {
          return {
            willResolveField({ info }) {
              return treeBuilder.willResolveField(info);
            },
          };
        },

        async didEncounterErrors({ errors }) {
          treeBuilder.didEncounterErrors(errors);
        },

        async willSendResponse({ response }) {
          // We record the end time at the latest possible time: right before serializing the trace.
          // If we wait any longer, the time we record won't actually be sent anywhere!
          treeBuilder.stopTiming();

          // For now, we don't support inline traces on incremental delivery
          // responses. (We could perhaps place the trace on the final chunk, or
          // even deliver it bit by bit. For now, since Gateway does not support
          // incremental delivery and Router does not pass through defers to
          // subgraphs, this doesn't affect the "federated tracing" use case,
          // though it does affect the ability to look at inline traces in other
          // tools like Explorer.
          if (response.body.kind === 'incremental') {
            return;
          }

          // If we're in a gateway, include the query plan (and subgraph traces)
          // in the inline trace. This is designed more for manually querying
          // your graph while running locally to see what the query planner is
          // doing rather than for running in production.
          if (metrics.queryPlanTrace) {
            treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
          }

          const encodedUint8Array = Trace.encode(treeBuilder.trace).finish();
          const encodedBuffer = Buffer.from(
            encodedUint8Array,
            encodedUint8Array.byteOffset,
            encodedUint8Array.byteLength,
          );

          const extensions =
            response.body.singleResult.extensions ||
            (response.body.singleResult.extensions = Object.create(null));

          // This should only happen if another plugin is using the same name-
          // space within the `extensions` object and got to it before us.
          if (typeof extensions.ftv1 !== 'undefined') {
            throw new Error('The `ftv1` extension was already present.');
          }

          extensions.ftv1 = encodedBuffer.toString('base64');
        },
      };
    },
  });
}
Ÿ+/dist/esm/utils/UnreachableCaseError.js.mapƒ˙{"version":3,"file":"UnreachableCaseError.js","sourceRoot":"","sources":["../../../src/utils/UnreachableCaseError.ts"],"names":[],"mappings":"AAKA,MAAM,OAAO,oBAAqB,SAAQ,KAAK;IAC7C,YAAY,GAAU;QACpB,KAAK,CAAC,qBAAqB,GAAG,EAAE,CAAC,CAAC;IACpC,CAAC;CACF"}Ÿ$/dist/cjs/plugin/traceTreeBuilder.js≈"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dateToProtoTimestamp = exports.TraceTreeBuilder = void 0;
const graphql_1 = require("graphql");
const usage_reporting_protobuf_1 = require("@apollo/usage-reporting-protobuf");
const UnreachableCaseError_js_1 = require("../utils/UnreachableCaseError.js");
function internalError(message) {
    return new Error(`[internal apollo-server error] ${message}`);
}
class TraceTreeBuilder {
    constructor(options) {
        this.rootNode = new usage_reporting_protobuf_1.Trace.Node();
        this.trace = new usage_reporting_protobuf_1.Trace({
            root: this.rootNode,
            fieldExecutionWeight: 1,
        });
        this.stopped = false;
        this.nodes = new Map([
            [responsePathAsString(), this.rootNode],
        ]);
        const { logger, sendErrors, maskedBy } = options;
        if (!sendErrors || 'masked' in sendErrors) {
            this.transformError = () => new graphql_1.GraphQLError('<masked>', {
                extensions: { maskedBy },
            });
        }
        else if ('transform' in sendErrors) {
            this.transformError = sendErrors.transform;
        }
        else if ('unmodified' in sendErrors) {
            this.transformError = null;
        }
        else {
            throw new UnreachableCaseError_js_1.UnreachableCaseError(sendErrors);
        }
        this.logger = logger;
    }
    startTiming() {
        if (this.startHrTime) {
            throw internalError('startTiming called twice!');
        }
        if (this.stopped) {
            throw internalError('startTiming called after stopTiming!');
        }
        this.trace.startTime = dateToProtoTimestamp(new Date());
        this.startHrTime = process.hrtime();
    }
    stopTiming() {
        if (!this.startHrTime) {
            throw internalError('stopTiming called before startTiming!');
        }
        if (this.stopped) {
            throw internalError('stopTiming called twice!');
        }
        this.trace.durationNs = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        this.trace.endTime = dateToProtoTimestamp(new Date());
        this.stopped = true;
    }
    willResolveField(info) {
        if (!this.startHrTime) {
            throw internalError('willResolveField called before startTiming!');
        }
        if (this.stopped) {
            throw internalError('willResolveField called after stopTiming!');
        }
        const path = info.path;
        const node = this.newNode(path);
        node.type = info.returnType.toString();
        node.parentType = info.parentType.toString();
        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        if (typeof path.key === 'string' && path.key !== info.fieldName) {
            node.originalFieldName = info.fieldName;
        }
        return () => {
            node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        };
    }
    didEncounterErrors(errors) {
        errors.forEach((err) => {
            if (err.extensions?.serviceName) {
                return;
            }
            const errorForReporting = this.transformAndNormalizeError(err);
            if (errorForReporting === null) {
                return;
            }
            this.addProtobufError(errorForReporting.path, errorToProtobufError(errorForReporting));
        });
    }
    addProtobufError(path, error) {
        if (!this.startHrTime) {
            throw internalError('addProtobufError called before startTiming!');
        }
        if (this.stopped) {
            throw internalError('addProtobufError called after stopTiming!');
        }
        let node = this.rootNode;
        if (Array.isArray(path)) {
            const specificNode = this.nodes.get(path.join('.'));
            if (specificNode) {
                node = specificNode;
            }
            else {
                this.logger.warn(`Could not find node with path ${path.join('.')}; defaulting to put errors on root node.`);
            }
        }
        node.error.push(error);
    }
    newNode(path) {
        const node = new usage_reporting_protobuf_1.Trace.Node();
        const id = path.key;
        if (typeof id === 'number') {
            node.index = id;
        }
        else {
            node.responseName = id;
        }
        this.nodes.set(responsePathAsString(path), node);
        const parentNode = this.ensureParentNode(path);
        parentNode.child.push(node);
        return node;
    }
    ensureParentNode(path) {
        const parentPath = responsePathAsString(path.prev);
        const parentNode = this.nodes.get(parentPath);
        if (parentNode) {
            return parentNode;
        }
        return this.newNode(path.prev);
    }
    transformAndNormalizeError(err) {
        if (this.transformError) {
            const clonedError = Object.assign(Object.create(Object.getPrototypeOf(err)), err);
            const rewrittenError = this.transformError(clonedError);
            if (rewrittenError === null) {
                return null;
            }
            if (!(rewrittenError instanceof graphql_1.GraphQLError)) {
                return err;
            }
            return new graphql_1.GraphQLError(rewrittenError.message, {
                nodes: err.nodes,
                source: err.source,
                positions: err.positions,
                path: err.path,
                originalError: err.originalError,
                extensions: rewrittenError.extensions || err.extensions,
            });
        }
        return err;
    }
}
exports.TraceTreeBuilder = TraceTreeBuilder;
function durationHrTimeToNanos(hrtime) {
    return hrtime[0] * 1e9 + hrtime[1];
}
function responsePathAsString(p) {
    if (p === undefined) {
        return '';
    }
    let res = String(p.key);
    while ((p = p.prev) !== undefined) {
        res = `${p.key}.${res}`;
    }
    return res;
}
function errorToProtobufError(error) {
    return new usage_reporting_protobuf_1.Trace.Error({
        message: error.message,
        location: (error.locations || []).map(({ line, column }) => new usage_reporting_protobuf_1.Trace.Location({ line, column })),
        json: JSON.stringify(error),
    });
}
function dateToProtoTimestamp(date) {
    const totalMillis = +date;
    const millis = totalMillis % 1000;
    return new usage_reporting_protobuf_1.google.protobuf.Timestamp({
        seconds: (totalMillis - millis) / 1000,
        nanos: millis * 1e6,
    });
}
exports.dateToProtoTimestamp = dateToProtoTimestamp;
//# sourceMappingURL=traceTreeBuilder.js.mapπ/dist/cjs/ApolloServer.js≈uƒ"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chooseContentTypeForSingleResultResponse = exports.MEDIA_TYPES = exports.isImplicitlyInstallablePlugin = exports.internalExecuteOperation = exports.ApolloServer = void 0;
const utils_isnodelike_1 = require("@apollo/utils.isnodelike");
const schema_1 = require("@graphql-tools/schema");
const resolvable_1 = __importDefault(require("@josephg/resolvable"));
const graphql_1 = require("graphql");
const utils_keyvaluecache_1 = require("@apollo/utils.keyvaluecache");
const loglevel_1 = __importDefault(require("loglevel"));
const negotiator_1 = __importDefault(require("negotiator"));
const uuid = __importStar(require("uuid"));
const cachePolicy_js_1 = require("./cachePolicy.js");
const determineApolloConfig_js_1 = require("./determineApolloConfig.js");
const errorNormalize_js_1 = require("./errorNormalize.js");
const index_js_1 = require("./errors/index.js");
const httpBatching_js_1 = require("./httpBatching.js");
const internalPlugin_js_1 = require("./internalPlugin.js");
const preventCsrf_js_1 = require("./preventCsrf.js");
const requestPipeline_js_1 = require("./requestPipeline.js");
const runHttpQuery_js_1 = require("./runHttpQuery.js");
const schemaManager_js_1 = require("./utils/schemaManager.js");
const isDefined_js_1 = require("./utils/isDefined.js");
const UnreachableCaseError_js_1 = require("./utils/UnreachableCaseError.js");
const HeaderMap_js_1 = require("./utils/HeaderMap.js");
const NoIntrospection = (context) => ({
    Field(node) {
        if (node.name.value === '__schema' || node.name.value === '__type') {
            context.reportError(new graphql_1.GraphQLError('GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production', {
                nodes: [node],
                extensions: {
                    validationErrorCode: index_js_1.ApolloServerValidationErrorCode.INTROSPECTION_DISABLED,
                },
            }));
        }
    },
});
function defaultLogger() {
    const loglevelLogger = loglevel_1.default.getLogger('apollo-server');
    loglevelLogger.setLevel(loglevel_1.default.levels.INFO);
    return loglevelLogger;
}
class ApolloServer {
    constructor(config) {
        const nodeEnv = config.nodeEnv ?? process.env.NODE_ENV ?? '';
        this.logger = config.logger ?? defaultLogger();
        const apolloConfig = (0, determineApolloConfig_js_1.determineApolloConfig)(config.apollo);
        const isDev = nodeEnv !== 'production';
        const state = config.gateway
            ?
                {
                    phase: 'initialized',
                    schemaManager: new schemaManager_js_1.SchemaManager({
                        gateway: config.gateway,
                        apolloConfig,
                        schemaDerivedDataProvider: (schema) => ApolloServer.generateSchemaDerivedData(schema, config.documentStore),
                        logger: this.logger,
                    }),
                }
            :
                {
                    phase: 'initialized',
                    schemaManager: new schemaManager_js_1.SchemaManager({
                        apiSchema: ApolloServer.constructSchema(config),
                        schemaDerivedDataProvider: (schema) => ApolloServer.generateSchemaDerivedData(schema, config.documentStore),
                        logger: this.logger,
                    }),
                };
        const introspectionEnabled = config.introspection ?? isDev;
        this.cache = config.cache ?? new utils_keyvaluecache_1.InMemoryLRUCache();
        this.internals = {
            formatError: config.formatError,
            rootValue: config.rootValue,
            validationRules: [
                ...(config.validationRules ?? []),
                ...(introspectionEnabled ? [] : [NoIntrospection]),
            ],
            fieldResolver: config.fieldResolver,
            includeStacktraceInErrorResponses: config.includeStacktraceInErrorResponses ??
                (nodeEnv !== 'production' && nodeEnv !== 'test'),
            persistedQueries: config.persistedQueries === false
                ? undefined
                : {
                    ...config.persistedQueries,
                    cache: new utils_keyvaluecache_1.PrefixingKeyValueCache(config.persistedQueries?.cache ?? this.cache, requestPipeline_js_1.APQ_CACHE_PREFIX),
                },
            nodeEnv,
            allowBatchedHttpRequests: config.allowBatchedHttpRequests ?? false,
            apolloConfig,
            plugins: config.plugins ?? [],
            parseOptions: config.parseOptions ?? {},
            state,
            stopOnTerminationSignals: config.stopOnTerminationSignals,
            gatewayExecutor: null,
            csrfPreventionRequestHeaders: config.csrfPrevention === true || config.csrfPrevention === undefined
                ? preventCsrf_js_1.recommendedCsrfPreventionRequestHeaders
                : config.csrfPrevention === false
                    ? null
                    : config.csrfPrevention.requestHeaders ??
                        preventCsrf_js_1.recommendedCsrfPreventionRequestHeaders,
            __testing_incrementalExecutionResults: config.__testing_incrementalExecutionResults,
        };
    }
    async start() {
        return await this._start(false);
    }
    startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests() {
        this._start(true).catch((e) => this.logStartupError(e));
    }
    async _start(startedInBackground) {
        if (this.internals.state.phase !== 'initialized') {
            throw new Error(`You should only call 'start()' or ` +
                `'startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()' ` +
                `once on your ApolloServer.`);
        }
        const schemaManager = this.internals.state.schemaManager;
        const barrier = (0, resolvable_1.default)();
        this.internals.state = {
            phase: 'starting',
            barrier,
            schemaManager,
            startedInBackground,
        };
        try {
            await this.addDefaultPlugins();
            const toDispose = [];
            const executor = await schemaManager.start();
            if (executor) {
                this.internals.gatewayExecutor = executor;
            }
            toDispose.push(async () => {
                await schemaManager.stop();
            });
            const schemaDerivedData = schemaManager.getSchemaDerivedData();
            const service = {
                logger: this.logger,
                cache: this.cache,
                schema: schemaDerivedData.schema,
                apollo: this.internals.apolloConfig,
                startedInBackground,
            };
            const taggedServerListeners = (await Promise.all(this.internals.plugins.map(async (plugin) => ({
                serverListener: plugin.serverWillStart && (await plugin.serverWillStart(service)),
                installedImplicitly: isImplicitlyInstallablePlugin(plugin) &&
                    plugin.__internal_installed_implicitly__,
            })))).filter((maybeTaggedServerListener) => typeof maybeTaggedServerListener.serverListener === 'object');
            taggedServerListeners.forEach(({ serverListener: { schemaDidLoadOrUpdate } }) => {
                if (schemaDidLoadOrUpdate) {
                    schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
                }
            });
            const serverWillStops = taggedServerListeners
                .map((l) => l.serverListener.serverWillStop)
                .filter(isDefined_js_1.isDefined);
            if (serverWillStops.length) {
                toDispose.push(async () => {
                    await Promise.all(serverWillStops.map((serverWillStop) => serverWillStop()));
                });
            }
            const drainServerCallbacks = taggedServerListeners
                .map((l) => l.serverListener.drainServer)
                .filter(isDefined_js_1.isDefined);
            const drainServers = drainServerCallbacks.length
                ? async () => {
                    await Promise.all(drainServerCallbacks.map((drainServer) => drainServer()));
                }
                : null;
            let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
            if (taggedServerListenersWithRenderLandingPage.length > 1) {
                taggedServerListenersWithRenderLandingPage =
                    taggedServerListenersWithRenderLandingPage.filter((l) => !l.installedImplicitly);
            }
            let landingPage = null;
            if (taggedServerListenersWithRenderLandingPage.length > 1) {
                throw Error('Only one plugin can implement renderLandingPage.');
            }
            else if (taggedServerListenersWithRenderLandingPage.length) {
                landingPage = await taggedServerListenersWithRenderLandingPage[0]
                    .serverListener.renderLandingPage();
            }
            const toDisposeLast = this.maybeRegisterTerminationSignalHandlers(['SIGINT', 'SIGTERM'], startedInBackground);
            this.internals.state = {
                phase: 'started',
                schemaManager,
                drainServers,
                landingPage,
                toDispose,
                toDisposeLast,
            };
        }
        catch (maybeError) {
            const error = (0, errorNormalize_js_1.ensureError)(maybeError);
            try {
                await Promise.all(this.internals.plugins.map(async (plugin) => plugin.startupDidFail?.({ error })));
            }
            catch (pluginError) {
                this.logger.error(`startupDidFail hook threw: ${pluginError}`);
            }
            this.internals.state = {
                phase: 'failed to start',
                error,
            };
            throw error;
        }
        finally {
            barrier.resolve();
        }
    }
    maybeRegisterTerminationSignalHandlers(signals, startedInBackground) {
        const toDisposeLast = [];
        if (this.internals.stopOnTerminationSignals === false ||
            (this.internals.stopOnTerminationSignals === undefined &&
                !(utils_isnodelike_1.isNodeLike &&
                    this.internals.nodeEnv !== 'test' &&
                    !startedInBackground))) {
            return toDisposeLast;
        }
        let receivedSignal = false;
        const signalHandler = async (signal) => {
            if (receivedSignal) {
                return;
            }
            receivedSignal = true;
            try {
                await this.stop();
            }
            catch (e) {
                this.logger.error(`stop() threw during ${signal} shutdown`);
                this.logger.error(e);
                process.exit(1);
            }
            process.kill(process.pid, signal);
        };
        signals.forEach((signal) => {
            process.on(signal, signalHandler);
            toDisposeLast.push(async () => {
                process.removeListener(signal, signalHandler);
            });
        });
        return toDisposeLast;
    }
    async _ensureStarted() {
        while (true) {
            switch (this.internals.state.phase) {
                case 'initialized':
                    throw new Error('You need to call `server.start()` before using your Apollo Server.');
                case 'starting':
                    await this.internals.state.barrier;
                    break;
                case 'failed to start':
                    this.logStartupError(this.internals.state.error);
                    throw new Error('This data graph is missing a valid configuration. More details may be available in the server logs.');
                case 'started':
                case 'draining':
                    return this.internals.state;
                case 'stopping':
                case 'stopped':
                    this.logger.warn('A GraphQL operation was received during server shutdown. The ' +
                        'operation will fail. Consider draining the HTTP server on shutdown; ' +
                        'see https://go.apollo.dev/s/drain for details.');
                    throw new Error(`Cannot execute GraphQL operations ${this.internals.state.phase === 'stopping'
                        ? 'while the server is stopping'
                        : 'after the server has stopped'}.'`);
                default:
                    throw new UnreachableCaseError_js_1.UnreachableCaseError(this.internals.state);
            }
        }
    }
    assertStarted(expressionForError) {
        if (this.internals.state.phase !== 'started' &&
            this.internals.state.phase !== 'draining' &&
            !(this.internals.state.phase === 'starting' &&
                this.internals.state.startedInBackground)) {
            throw new Error('You must `await server.start()` before calling `' +
                expressionForError +
                '`');
        }
    }
    logStartupError(err) {
        this.logger.error('An error occurred during Apollo Server startup. All GraphQL requests ' +
            'will now fail. The startup error was: ' +
            (err?.message || err));
    }
    static constructSchema(config) {
        if (config.schema) {
            return config.schema;
        }
        const { typeDefs, resolvers } = config;
        const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];
        return (0, schema_1.makeExecutableSchema)({
            typeDefs: augmentedTypeDefs,
            resolvers,
        });
    }
    static generateSchemaDerivedData(schema, providedUnprefixedDocumentStore) {
        (0, graphql_1.assertValidSchema)(schema);
        return {
            schema,
            documentStore: providedUnprefixedDocumentStore === undefined
                ? new utils_keyvaluecache_1.InMemoryLRUCache()
                : providedUnprefixedDocumentStore === null
                    ? null
                    : new utils_keyvaluecache_1.PrefixingKeyValueCache(providedUnprefixedDocumentStore, `${uuid.v4()}:`),
        };
    }
    async stop() {
        switch (this.internals.state.phase) {
            case 'initialized':
            case 'starting':
            case 'failed to start':
                throw Error('apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded');
            case 'stopped':
                if (this.internals.state.stopError) {
                    throw this.internals.state.stopError;
                }
                return;
            case 'stopping':
            case 'draining': {
                await this.internals.state.barrier;
                const state = this.internals.state;
                if (state.phase !== 'stopped') {
                    throw Error(`Surprising post-stopping state ${state.phase}`);
                }
                if (state.stopError) {
                    throw state.stopError;
                }
                return;
            }
            case 'started':
                break;
            default:
                throw new UnreachableCaseError_js_1.UnreachableCaseError(this.internals.state);
        }
        const barrier = (0, resolvable_1.default)();
        const { schemaManager, drainServers, landingPage, toDispose, toDisposeLast, } = this.internals.state;
        this.internals.state = {
            phase: 'draining',
            barrier,
            schemaManager,
            landingPage,
        };
        try {
            await drainServers?.();
            this.internals.state = { phase: 'stopping', barrier };
            await Promise.all([...toDispose].map((dispose) => dispose()));
            await Promise.all([...toDisposeLast].map((dispose) => dispose()));
        }
        catch (stopError) {
            this.internals.state = {
                phase: 'stopped',
                stopError: stopError,
            };
            barrier.resolve();
            throw stopError;
        }
        this.internals.state = { phase: 'stopped', stopError: null };
    }
    async addDefaultPlugins() {
        const { plugins, apolloConfig, nodeEnv } = this.internals;
        const isDev = nodeEnv !== 'production';
        const alreadyHavePluginWithInternalId = (id) => plugins.some((p) => (0, internalPlugin_js_1.pluginIsInternal)(p) && p.__internal_plugin_id__ === id);
        const pluginsByInternalID = new Map();
        for (const p of plugins) {
            if ((0, internalPlugin_js_1.pluginIsInternal)(p)) {
                const id = p.__internal_plugin_id__;
                if (!pluginsByInternalID.has(id)) {
                    pluginsByInternalID.set(id, {
                        sawDisabled: false,
                        sawNonDisabled: false,
                    });
                }
                const seen = pluginsByInternalID.get(id);
                if (p.__is_disabled_plugin__) {
                    seen.sawDisabled = true;
                }
                else {
                    seen.sawNonDisabled = true;
                }
                if (seen.sawDisabled && seen.sawNonDisabled) {
                    throw new Error(`You have tried to install both ApolloServerPlugin${id} and ` +
                        `ApolloServerPlugin${id}Disabled in your server. Please choose ` +
                        `whether or not you want to disable the feature and install the ` +
                        `appropriate plugin for your use case.`);
                }
            }
        }
        {
            if (!alreadyHavePluginWithInternalId('CacheControl')) {
                const { ApolloServerPluginCacheControl } = await Promise.resolve().then(() => __importStar(require('./plugin/cacheControl/index.js')));
                plugins.push(ApolloServerPluginCacheControl());
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('UsageReporting');
            if (!alreadyHavePlugin && apolloConfig.key) {
                if (apolloConfig.graphRef) {
                    const { ApolloServerPluginUsageReporting } = await Promise.resolve().then(() => __importStar(require('./plugin/usageReporting/index.js')));
                    plugins.unshift(ApolloServerPluginUsageReporting());
                }
                else {
                    this.logger.warn('You have specified an Apollo key but have not specified a graph ref; usage ' +
                        'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +
                        'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +
                        'warning, install `ApolloServerPluginUsageReportingDisabled`.');
                }
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('SchemaReporting');
            const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';
            if (!alreadyHavePlugin && enabledViaEnvVar) {
                if (apolloConfig.key) {
                    const { ApolloServerPluginSchemaReporting } = await Promise.resolve().then(() => __importStar(require('./plugin/schemaReporting/index.js')));
                    plugins.push(ApolloServerPluginSchemaReporting());
                }
                else {
                    throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING " +
                        'environment variable to true, but you also need to provide your ' +
                        'Apollo API key, via the APOLLO_KEY environment ' +
                        'variable or via `new ApolloServer({apollo: {key})');
                }
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');
            if (!alreadyHavePlugin) {
                const { ApolloServerPluginInlineTrace } = await Promise.resolve().then(() => __importStar(require('./plugin/inlineTrace/index.js')));
                plugins.push(ApolloServerPluginInlineTrace({ __onlyIfSchemaIsFederated: true }));
            }
        }
        const alreadyHavePlugin = alreadyHavePluginWithInternalId('LandingPageDisabled');
        if (!alreadyHavePlugin) {
            const { ApolloServerPluginLandingPageLocalDefault, ApolloServerPluginLandingPageProductionDefault, } = await Promise.resolve().then(() => __importStar(require('./plugin/landingPage/default/index.js')));
            const plugin = isDev
                ? ApolloServerPluginLandingPageLocalDefault()
                : ApolloServerPluginLandingPageProductionDefault();
            if (!isImplicitlyInstallablePlugin(plugin)) {
                throw Error('default landing page plugin should be implicitly installable?');
            }
            plugin.__internal_installed_implicitly__ = true;
            plugins.push(plugin);
        }
    }
    addPlugin(plugin) {
        if (this.internals.state.phase !== 'initialized') {
            throw new Error("Can't add plugins after the server has started");
        }
        this.internals.plugins.push(plugin);
    }
    async executeHTTPGraphQLRequest({ httpGraphQLRequest, context, }) {
        try {
            let runningServerState;
            try {
                runningServerState = await this._ensureStarted();
            }
            catch (error) {
                return this.errorResponse(error, httpGraphQLRequest);
            }
            if (runningServerState.landingPage &&
                this.prefersHTML(httpGraphQLRequest)) {
                return {
                    headers: new HeaderMap_js_1.HeaderMap([['content-type', 'text/html']]),
                    body: {
                        kind: 'complete',
                        string: runningServerState.landingPage.html,
                    },
                };
            }
            if (this.internals.csrfPreventionRequestHeaders) {
                (0, preventCsrf_js_1.preventCsrf)(httpGraphQLRequest.headers, this.internals.csrfPreventionRequestHeaders);
            }
            let contextValue;
            try {
                contextValue = await context();
            }
            catch (maybeError) {
                const error = (0, errorNormalize_js_1.ensureError)(maybeError);
                try {
                    await Promise.all(this.internals.plugins.map(async (plugin) => plugin.contextCreationDidFail?.({
                        error,
                    })));
                }
                catch (pluginError) {
                    this.logger.error(`contextCreationDidFail hook threw: ${pluginError}`);
                }
                return this.errorResponse((0, errorNormalize_js_1.ensureGraphQLError)(error, 'Context creation failed: '), httpGraphQLRequest);
            }
            return await (0, httpBatching_js_1.runPotentiallyBatchedHttpQuery)(this, httpGraphQLRequest, contextValue, runningServerState.schemaManager.getSchemaDerivedData(), this.internals);
        }
        catch (maybeError_) {
            const maybeError = maybeError_;
            if (maybeError instanceof graphql_1.GraphQLError &&
                maybeError.extensions.code === index_js_1.ApolloServerErrorCode.BAD_REQUEST) {
                try {
                    await Promise.all(this.internals.plugins.map(async (plugin) => plugin.invalidRequestWasReceived?.({ error: maybeError })));
                }
                catch (pluginError) {
                    this.logger.error(`invalidRequestWasReceived hook threw: ${pluginError}`);
                }
            }
            return this.errorResponse(maybeError, httpGraphQLRequest);
        }
    }
    errorResponse(error, requestHead) {
        const { formattedErrors, httpFromErrors } = (0, errorNormalize_js_1.normalizeAndFormatErrors)([error], {
            includeStacktraceInErrorResponses: this.internals.includeStacktraceInErrorResponses,
            formatError: this.internals.formatError,
        });
        return {
            status: httpFromErrors.status ?? 500,
            headers: new HeaderMap_js_1.HeaderMap([
                ...httpFromErrors.headers,
                [
                    'content-type',
                    chooseContentTypeForSingleResultResponse(requestHead) ??
                        exports.MEDIA_TYPES.APPLICATION_JSON,
                ],
            ]),
            body: {
                kind: 'complete',
                string: (0, runHttpQuery_js_1.prettyJSONStringify)({
                    errors: formattedErrors,
                }),
            },
        };
    }
    prefersHTML(request) {
        const acceptHeader = request.headers.get('accept');
        return (request.method === 'GET' &&
            !!acceptHeader &&
            new negotiator_1.default({
                headers: { accept: acceptHeader },
            }).mediaType([
                exports.MEDIA_TYPES.APPLICATION_JSON,
                exports.MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,
                exports.MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,
                exports.MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,
                exports.MEDIA_TYPES.TEXT_HTML,
            ]) === exports.MEDIA_TYPES.TEXT_HTML);
    }
    async executeOperation(request, options = {}) {
        if (this.internals.state.phase === 'initialized') {
            await this.start();
        }
        const schemaDerivedData = (await this._ensureStarted()).schemaManager.getSchemaDerivedData();
        const graphQLRequest = {
            ...request,
            query: request.query && typeof request.query !== 'string'
                ? (0, graphql_1.print)(request.query)
                : request.query,
        };
        const response = await internalExecuteOperation({
            server: this,
            graphQLRequest,
            internals: this.internals,
            schemaDerivedData,
            sharedResponseHTTPGraphQLHead: null,
        }, options);
        return response;
    }
}
exports.ApolloServer = ApolloServer;
async function internalExecuteOperation({ server, graphQLRequest, internals, schemaDerivedData, sharedResponseHTTPGraphQLHead, }, options) {
    const requestContext = {
        logger: server.logger,
        cache: server.cache,
        schema: schemaDerivedData.schema,
        request: graphQLRequest,
        response: {
            http: sharedResponseHTTPGraphQLHead ?? (0, runHttpQuery_js_1.newHTTPGraphQLHead)(),
        },
        contextValue: cloneObject(options?.contextValue ?? {}),
        metrics: {},
        overallCachePolicy: (0, cachePolicy_js_1.newCachePolicy)(),
        requestIsBatched: sharedResponseHTTPGraphQLHead !== null,
    };
    try {
        return await (0, requestPipeline_js_1.processGraphQLRequest)(schemaDerivedData, server, internals, requestContext);
    }
    catch (maybeError) {
        const error = (0, errorNormalize_js_1.ensureError)(maybeError);
        await Promise.all(internals.plugins.map(async (plugin) => plugin.unexpectedErrorProcessingRequest?.({
            requestContext,
            error,
        })));
        server.logger.error(`Unexpected error processing request: ${error}`);
        throw new Error('Internal server error');
    }
}
exports.internalExecuteOperation = internalExecuteOperation;
function isImplicitlyInstallablePlugin(p) {
    return '__internal_installed_implicitly__' in p;
}
exports.isImplicitlyInstallablePlugin = isImplicitlyInstallablePlugin;
exports.MEDIA_TYPES = {
    APPLICATION_JSON: 'application/json; charset=utf-8',
    APPLICATION_GRAPHQL_RESPONSE_JSON: 'application/graphql-response+json; charset=utf-8',
    MULTIPART_MIXED_NO_DEFER_SPEC: 'multipart/mixed',
    MULTIPART_MIXED_EXPERIMENTAL: 'multipart/mixed; deferSpec=20220824',
    TEXT_HTML: 'text/html',
};
function chooseContentTypeForSingleResultResponse(head) {
    const acceptHeader = head.headers.get('accept');
    if (!acceptHeader) {
        return exports.MEDIA_TYPES.APPLICATION_JSON;
    }
    else {
        const preferred = new negotiator_1.default({
            headers: { accept: head.headers.get('accept') },
        }).mediaType([
            exports.MEDIA_TYPES.APPLICATION_JSON,
            exports.MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,
        ]);
        if (preferred) {
            return preferred;
        }
        else {
            return null;
        }
    }
}
exports.chooseContentTypeForSingleResultResponse = chooseContentTypeForSingleResultResponse;
function cloneObject(object) {
    return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
}
//# sourceMappingURL=ApolloServer.js.map¥/src/errors/index.ts≈2import { GraphQLError } from 'graphql';

export enum ApolloServerErrorCode {
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  GRAPHQL_PARSE_FAILED = 'GRAPHQL_PARSE_FAILED',
  GRAPHQL_VALIDATION_FAILED = 'GRAPHQL_VALIDATION_FAILED',
  PERSISTED_QUERY_NOT_FOUND = 'PERSISTED_QUERY_NOT_FOUND',
  PERSISTED_QUERY_NOT_SUPPORTED = 'PERSISTED_QUERY_NOT_SUPPORTED',
  BAD_USER_INPUT = 'BAD_USER_INPUT',
  OPERATION_RESOLUTION_FAILURE = 'OPERATION_RESOLUTION_FAILURE',
  BAD_REQUEST = 'BAD_REQUEST',
}

export enum ApolloServerValidationErrorCode {
  INTROSPECTION_DISABLED = 'INTROSPECTION_DISABLED',
}

/**
 * unwrapResolverError is a useful helper function for `formatError` hooks.
 * Errors thrown in resolvers are wrapped by graphql-js in a GraphQLError that
 * adds context such as the `path` to the field in the operation. If you'd like
 * to look directly at the original error thrown in the resolver (with whatever
 * data is on that error object, but without fields like `path`), you can use
 * this function. Note that other GraphQLErrors that contain `originalError`
 * (like parse errors) are not unwrapped by this function.
 */
export function unwrapResolverError(error: unknown): unknown {
  if (error instanceof GraphQLError && error.path && error.originalError) {
    return error.originalError;
  }
  return error;
}
Ÿ&/dist/cjs/externalTypes/graphql.js.mapƒ~{"version":3,"file":"graphql.js","sourceRoot":"","sources":["../../../src/externalTypes/graphql.ts"],"names":[],"mappings":""}Ÿ#/dist/esm/internalErrorClasses.d.ts≈timport { GraphQLError, GraphQLErrorOptions } from 'graphql';
import { ApolloServerErrorCode } from './errors/index.js';
declare class GraphQLErrorWithCode extends GraphQLError {
    constructor(message: string, code: ApolloServerErrorCode, options?: GraphQLErrorOptions);
}
export declare class SyntaxError extends GraphQLErrorWithCode {
    constructor(graphqlError: GraphQLError);
}
export declare class ValidationError extends GraphQLErrorWithCode {
    constructor(graphqlError: GraphQLError);
}
export declare class PersistedQueryNotFoundError extends GraphQLErrorWithCode {
    constructor();
}
export declare class PersistedQueryNotSupportedError extends GraphQLErrorWithCode {
    constructor();
}
export declare class UserInputError extends GraphQLErrorWithCode {
    constructor(graphqlError: GraphQLError);
}
export declare class OperationResolutionError extends GraphQLErrorWithCode {
    constructor(graphqlError: GraphQLError);
}
export declare class BadRequestError extends GraphQLErrorWithCode {
    constructor(message: string, options?: GraphQLErrorOptions);
}
export {};
//# sourceMappingURL=internalErrorClasses.d.ts.map∂/dist/esm/index.js.mapƒ‘{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACjD,OAAO,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAC;AAEjD,cAAc,0BAA0B,CAAC"}Ÿ@/dist/cjs/plugin/usageReporting/operationDerivedDataCache.js.map≈Ï{"version":3,"file":"operationDerivedDataCache.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/operationDerivedDataCache.ts"],"names":[],"mappings":";;;;;;AAEA,0DAAiC;AAOjC,SAAgB,+BAA+B,CAAC,EAC9C,MAAM,GAGP;IACC,IAAI,QAAc,CAAC;IACnB,IAAI,aAAa,GAAG,CAAC,CAAC;IACtB,OAAO,IAAI,mBAAQ,CAA+B;QAEhD,eAAe,CAAC,GAAG;YACjB,OAAO,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC;QACxD,CAAC;QASD,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE;QAC7B,OAAO;YAEL,aAAa,EAAE,CAAC;YAGhB,IAAI,CAAC,QAAQ,IAAI,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,QAAQ,CAAC,OAAO,EAAE,GAAG,KAAK,EAAE;gBAElE,QAAQ,GAAG,IAAI,IAAI,EAAE,CAAC;gBACtB,MAAM,CAAC,IAAI,CACT;oBACE,iEAAiE;oBACjE,cAAc,aAAa,qBAAqB;oBAChD,gFAAgF;oBAChF,gEAAgE;oBAChE,wCAAwC;iBACzC,CAAC,IAAI,CAAC,EAAE,CAAC,CACX,CAAC;gBAGF,aAAa,GAAG,CAAC,CAAC;aACnB;QACH,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AA5CD,0EA4CC;AAED,SAAgB,4BAA4B,CAC1C,SAAiB,EACjB,aAAqB;IAErB,OAAO,GAAG,SAAS,GAAG,aAAa,IAAI,GAAG,GAAG,aAAa,EAAE,CAAC;AAC/D,CAAC;AALD,oEAKC"}Ÿ&/dist/cjs/externalTypes/plugins.js.mapƒ~{"version":3,"file":"plugins.js","sourceRoot":"","sources":["../../../src/externalTypes/plugins.ts"],"names":[],"mappings":""}Ÿ!/dist/esm/externalTypes/http.d.ts≈5import type { HeaderMap } from '../utils/HeaderMap.js';
export interface HTTPGraphQLRequest {
    method: string;
    headers: HeaderMap;
    search: string;
    body: unknown;
}
export interface HTTPGraphQLHead {
    status?: number;
    headers: HeaderMap;
}
export declare type HTTPGraphQLResponseBody = {
    kind: 'complete';
    string: string;
} | {
    kind: 'chunked';
    asyncIterator: AsyncIterableIterator<string>;
};
export declare type HTTPGraphQLResponse = HTTPGraphQLHead & {
    body: HTTPGraphQLResponseBody;
};
//# sourceMappingURL=http.d.ts.mapŸ6/dist/esm/externalTypes/incrementalDeliveryPolyfill.jsƒBexport {};
//# sourceMappingURL=incrementalDeliveryPolyfill.js.mapŸ0/dist/esm/plugin/usageReporting/options.d.ts.map≈˜{"version":3,"file":"options.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/options.ts"],"names":[],"mappings":"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"}ø/src/plugin/traceTreeBuilder.ts≈(˜// This class is a helper for ApolloServerPluginUsageReporting and
// ApolloServerPluginInlineTrace.
import { GraphQLError, GraphQLResolveInfo, ResponsePath } from 'graphql';
import { Trace, google } from '@apollo/usage-reporting-protobuf';
import type { Logger } from '@apollo/utils.logger';
import type { SendErrorsOptions } from './usageReporting';
import { UnreachableCaseError } from '../utils/UnreachableCaseError.js';

function internalError(message: string) {
  return new Error(`[internal apollo-server error] ${message}`);
}

export class TraceTreeBuilder {
  private rootNode = new Trace.Node();
  private logger: Logger;
  public trace = new Trace({
    root: this.rootNode,
    // By default, each trace counts as one operation for the sake of field
    // execution counts. If we end up calling the fieldLevelInstrumentation
    // callback (once we've successfully resolved the operation) then we
    // may set this to a higher number; but we'll start it at 1 so that traces
    // that don't successfully resolve the operation (eg parse failures) or
    // where we don't call the callback because a plugin set captureTraces to
    // true have a reasonable default.
    fieldExecutionWeight: 1,
  });
  public startHrTime?: [number, number];
  private stopped = false;
  private nodes = new Map<string, Trace.Node>([
    [responsePathAsString(), this.rootNode],
  ]);
  private readonly transformError:
    | ((err: GraphQLError) => GraphQLError | null)
    | null;

  public constructor(options: {
    maskedBy: string;
    logger: Logger;
    sendErrors?: SendErrorsOptions;
  }) {
    const { logger, sendErrors, maskedBy } = options;
    if (!sendErrors || 'masked' in sendErrors) {
      this.transformError = () =>
        new GraphQLError('<masked>', {
          extensions: { maskedBy },
        });
    } else if ('transform' in sendErrors) {
      this.transformError = sendErrors.transform;
    } else if ('unmodified' in sendErrors) {
      this.transformError = null;
    } else {
      throw new UnreachableCaseError(sendErrors);
    }
    this.logger = logger;
  }

  public startTiming() {
    if (this.startHrTime) {
      throw internalError('startTiming called twice!');
    }
    if (this.stopped) {
      throw internalError('startTiming called after stopTiming!');
    }
    this.trace.startTime = dateToProtoTimestamp(new Date());
    this.startHrTime = process.hrtime();
  }

  public stopTiming() {
    if (!this.startHrTime) {
      throw internalError('stopTiming called before startTiming!');
    }
    if (this.stopped) {
      throw internalError('stopTiming called twice!');
    }

    this.trace.durationNs = durationHrTimeToNanos(
      process.hrtime(this.startHrTime),
    );
    this.trace.endTime = dateToProtoTimestamp(new Date());
    this.stopped = true;
  }

  public willResolveField(info: GraphQLResolveInfo): () => void {
    if (!this.startHrTime) {
      throw internalError('willResolveField called before startTiming!');
    }
    if (this.stopped) {
      throw internalError('willResolveField called after stopTiming!');
    }

    const path = info.path;
    const node = this.newNode(path);
    node.type = info.returnType.toString();
    node.parentType = info.parentType.toString();
    node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
    if (typeof path.key === 'string' && path.key !== info.fieldName) {
      // This field was aliased; send the original field name too (for FieldStats).
      node.originalFieldName = info.fieldName;
    }

    return () => {
      node.endTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
    };
  }

  public didEncounterErrors(errors: readonly GraphQLError[]) {
    errors.forEach((err) => {
      // This is an error from a federated service. We will already be reporting
      // it in the nested Trace in the query plan.
      //
      // XXX This probably shouldn't skip query or validation errors, which are
      //      not in nested Traces because format() isn't called in this case! Or
      //      maybe format() should be called in that case?
      if (err.extensions?.serviceName) {
        return;
      }

      // In terms of reporting, errors can be re-written by the user by
      // utilizing the `transformError` parameter.  This allows changing
      // the message or stack to remove potentially sensitive information.
      // Returning `null` will result in the error not being reported at all.
      const errorForReporting = this.transformAndNormalizeError(err);

      if (errorForReporting === null) {
        return;
      }

      this.addProtobufError(
        errorForReporting.path,
        errorToProtobufError(errorForReporting),
      );
    });
  }

  private addProtobufError(
    path: ReadonlyArray<string | number> | undefined,
    error: Trace.Error,
  ) {
    if (!this.startHrTime) {
      throw internalError('addProtobufError called before startTiming!');
    }
    if (this.stopped) {
      throw internalError('addProtobufError called after stopTiming!');
    }

    // By default, put errors on the root node.
    let node = this.rootNode;
    // If a non-GraphQLError Error sneaks in here somehow with a non-array
    // path, don't crash.
    if (Array.isArray(path)) {
      const specificNode = this.nodes.get(path.join('.'));
      if (specificNode) {
        node = specificNode;
      } else {
        this.logger.warn(
          `Could not find node with path ${path.join(
            '.',
          )}; defaulting to put errors on root node.`,
        );
      }
    }

    node.error.push(error);
  }

  private newNode(path: ResponsePath): Trace.Node {
    const node = new Trace.Node();
    const id = path.key;
    if (typeof id === 'number') {
      node.index = id;
    } else {
      node.responseName = id;
    }
    this.nodes.set(responsePathAsString(path), node);
    const parentNode = this.ensureParentNode(path);
    parentNode.child.push(node);
    return node;
  }

  private ensureParentNode(path: ResponsePath): Trace.Node {
    const parentPath = responsePathAsString(path.prev);
    const parentNode = this.nodes.get(parentPath);
    if (parentNode) {
      return parentNode;
    }
    // Because we set up the root path when creating this.nodes, we now know
    // that path.prev isn't undefined.
    return this.newNode(path.prev!);
  }

  private transformAndNormalizeError(err: GraphQLError): GraphQLError | null {
    if (this.transformError) {
      // Before passing the error to the user-provided `transformError` function,
      // we'll make a shadow copy of the error so the user is free to change
      // the object as they see fit.

      // At this stage, this error is only for the purposes of reporting, but
      // this is even more important since this is still a reference to the
      // original error object and changing it would also change the error which
      // is returned in the response to the client.

      // For the clone, we'll create a new object which utilizes the exact same
      // prototype of the error being reported.
      const clonedError = Object.assign(
        Object.create(Object.getPrototypeOf(err)),
        err,
      );

      const rewrittenError = this.transformError(clonedError);

      // Returning an explicit `null` means the user is requesting that the error
      // not be reported to Apollo.
      if (rewrittenError === null) {
        return null;
      }

      // We don't want users to be inadvertently not reporting errors, so if
      // they haven't returned an explicit `GraphQLError` (or `null`, handled
      // above), then we'll report the error as usual.
      if (!(rewrittenError instanceof GraphQLError)) {
        return err;
      }

      // We only allow transformError to change the message and extensions of the
      // error; we keep everything else the same. That way people don't have to
      // do extra work to keep the error on the same trace node. We also keep
      // extensions the same if it isn't explicitly changed (to, eg, {}). (Note
      // that many of the fields of GraphQLError are not enumerable and won't
      // show up in the trace (even in the json field) anyway.)
      return new GraphQLError(rewrittenError.message, {
        nodes: err.nodes,
        source: err.source,
        positions: err.positions,
        path: err.path,
        originalError: err.originalError,
        extensions: rewrittenError.extensions || err.extensions,
      });
    }
    return err;
  }
}

// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.
//
// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE
// FROM process.hrtime() WITH NO ARGUMENTS.
//
// The entire point of the hrtime data structure is that the JavaScript Number
// type can't represent all int64 values without loss of precision:
// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function
// on a duration that represents a value less than 104 days is fine. Calling
// this function on an absolute time (which is generally roughly time since
// system boot) is not a good idea.
//
// XXX We should probably use google.protobuf.Duration on the wire instead of
// ever trying to store durations in a single number.
function durationHrTimeToNanos(hrtime: [number, number]) {
  return hrtime[0] * 1e9 + hrtime[1];
}

// Convert from the linked-list ResponsePath format to a dot-joined
// string. Includes the full path (field names and array indices).
function responsePathAsString(p?: ResponsePath): string {
  if (p === undefined) {
    return '';
  }

  // A previous implementation used `responsePathAsArray` from `graphql-js/execution`,
  // however, that employed an approach that created new arrays unnecessarily.
  let res = String(p.key);

  while ((p = p.prev) !== undefined) {
    res = `${p.key}.${res}`;
  }

  return res;
}

function errorToProtobufError(error: GraphQLError): Trace.Error {
  return new Trace.Error({
    message: error.message,
    location: (error.locations || []).map(
      ({ line, column }) => new Trace.Location({ line, column }),
    ),
    json: JSON.stringify(error),
  });
}

// Converts a JS Date into a Timestamp.
export function dateToProtoTimestamp(date: Date): google.protobuf.Timestamp {
  const totalMillis = +date;
  const millis = totalMillis % 1000;
  return new google.protobuf.Timestamp({
    seconds: (totalMillis - millis) / 1000,
    nanos: millis * 1e6,
  });
}
π/dist/esm/httpBatching.js≈˙import { newHTTPGraphQLHead, runHttpQuery } from './runHttpQuery.js';
import { BadRequestError } from './internalErrorClasses.js';
async function runBatchedHttpQuery({ server, batchRequest, body, contextValue, schemaDerivedData, internals, }) {
    if (body.length === 0) {
        throw new BadRequestError('No operations found in request.');
    }
    const sharedResponseHTTPGraphQLHead = newHTTPGraphQLHead();
    const responseBodies = await Promise.all(body.map(async (bodyPiece) => {
        const singleRequest = {
            ...batchRequest,
            body: bodyPiece,
        };
        const response = await runHttpQuery({
            server,
            httpRequest: singleRequest,
            contextValue,
            schemaDerivedData,
            internals,
            sharedResponseHTTPGraphQLHead,
        });
        if (response.body.kind === 'chunked') {
            throw Error('Incremental delivery is not implemented for batch requests');
        }
        return response.body.string;
    }));
    return {
        ...sharedResponseHTTPGraphQLHead,
        body: { kind: 'complete', string: `[${responseBodies.join(',')}]` },
    };
}
export async function runPotentiallyBatchedHttpQuery(server, httpGraphQLRequest, contextValue, schemaDerivedData, internals) {
    if (!(httpGraphQLRequest.method === 'POST' &&
        Array.isArray(httpGraphQLRequest.body))) {
        return await runHttpQuery({
            server,
            httpRequest: httpGraphQLRequest,
            contextValue,
            schemaDerivedData,
            internals,
            sharedResponseHTTPGraphQLHead: null,
        });
    }
    if (internals.allowBatchedHttpRequests) {
        return await runBatchedHttpQuery({
            server,
            batchRequest: httpGraphQLRequest,
            body: httpGraphQLRequest.body,
            contextValue,
            schemaDerivedData,
            internals,
        });
    }
    throw new BadRequestError('Operation batching disabled.');
}
//# sourceMappingURL=httpBatching.js.mapŸ$/dist/cjs/externalTypes/index.js.mapƒz{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/externalTypes/index.ts"],"names":[],"mappings":""}Ÿ)/dist/esm/plugin/usageReporting/plugin.js≈a9import { Report, ReportHeader, Trace } from '@apollo/usage-reporting-protobuf';
import { usageReportingSignature, calculateReferencedFieldsByType, } from '@apollo/utils.usagereporting';
import retry from 'async-retry';
import { printSchema } from 'graphql';
import { AbortController } from 'node-abort-controller';
import fetch from 'node-fetch';
import os from 'os';
import { promisify } from 'util';
import { gzip } from 'zlib';
import { internalPlugin } from '../../internalPlugin.js';
import { dateToProtoTimestamp, TraceTreeBuilder } from '../traceTreeBuilder.js';
import { defaultSendOperationsAsTrace } from './defaultSendOperationsAsTrace.js';
import { createOperationDerivedDataCache, operationDerivedDataCacheKey, } from './operationDerivedDataCache.js';
import { OurReport } from './stats.js';
import { makeTraceDetails } from './traceDetails.js';
import { packageVersion } from '../../generated/packageVersion.js';
import { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';
const gzipPromise = promisify(gzip);
const reportHeaderDefaults = {
    hostname: os.hostname(),
    agentVersion: `@apollo/server@${packageVersion}`,
    runtimeVersion: `node ${process.version}`,
    uname: `${os.platform()}, ${os.type()}, ${os.release()}, ${os.arch()})`,
};
export function ApolloServerPluginUsageReporting(options = Object.create(null)) {
    const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
    const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === 'number'
        ? async () => Math.random() < fieldLevelInstrumentationOption
            ? 1 / fieldLevelInstrumentationOption
            : 0
        : fieldLevelInstrumentationOption
            ? fieldLevelInstrumentationOption
            : async () => true;
    let requestDidStartHandler;
    return internalPlugin({
        __internal_plugin_id__: 'UsageReporting',
        __is_disabled_plugin__: false,
        async requestDidStart(requestContext) {
            if (!requestDidStartHandler) {
                throw Error('The usage reporting plugin has been asked to handle a request before the ' +
                    'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' +
                    'for more details.');
            }
            return requestDidStartHandler(requestContext);
        },
        async serverWillStart({ logger: serverLogger, apollo, startedInBackground, }) {
            const logger = options.logger ?? serverLogger;
            const { key, graphRef } = apollo;
            if (!(key && graphRef)) {
                throw new Error("You've enabled usage reporting via ApolloServerPluginUsageReporting, " +
                    'but you also need to provide your Apollo API key and graph ref, via ' +
                    'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +
                    'variables or via `new ApolloServer({apollo: {key, graphRef})`.');
            }
            logger.info('Apollo usage reporting starting! See your graph at ' +
                `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);
            const sendReportsImmediately = options.sendReportsImmediately ?? startedInBackground;
            let operationDerivedDataCache = null;
            const reportByExecutableSchemaId = new Map();
            const getReportWhichMustBeUsedImmediately = (executableSchemaId) => {
                const existing = reportByExecutableSchemaId.get(executableSchemaId);
                if (existing) {
                    return existing;
                }
                const report = new OurReport(new ReportHeader({
                    ...reportHeaderDefaults,
                    executableSchemaId,
                    graphRef,
                }));
                reportByExecutableSchemaId.set(executableSchemaId, report);
                return report;
            };
            const getAndDeleteReport = (executableSchemaId) => {
                const report = reportByExecutableSchemaId.get(executableSchemaId);
                if (report) {
                    reportByExecutableSchemaId.delete(executableSchemaId);
                    return report;
                }
                return null;
            };
            const overriddenExecutableSchemaId = options.overrideReportedSchema
                ? computeCoreSchemaHash(options.overrideReportedSchema)
                : undefined;
            let lastSeenExecutableSchemaToId;
            let reportTimer;
            if (!sendReportsImmediately) {
                reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1000);
            }
            let sendTraces = options.sendTraces ?? true;
            const sendOperationAsTrace = options.experimental_sendOperationAsTrace ??
                defaultSendOperationsAsTrace();
            let stopped = false;
            function executableSchemaIdForSchema(schema) {
                if (lastSeenExecutableSchemaToId?.executableSchema === schema) {
                    return lastSeenExecutableSchemaToId.executableSchemaId;
                }
                const id = computeCoreSchemaHash(printSchema(schema));
                lastSeenExecutableSchemaToId = {
                    executableSchema: schema,
                    executableSchemaId: id,
                };
                return id;
            }
            async function sendAllReportsAndReportErrors() {
                await Promise.all([...reportByExecutableSchemaId.keys()].map((executableSchemaId) => sendReportAndReportErrors(executableSchemaId)));
            }
            async function sendReportAndReportErrors(executableSchemaId) {
                return sendReport(executableSchemaId).catch((err) => {
                    if (options.reportErrorFunction) {
                        options.reportErrorFunction(err);
                    }
                    else {
                        logger.error(err.message);
                    }
                });
            }
            const sendReport = async (executableSchemaId) => {
                let report = getAndDeleteReport(executableSchemaId);
                if (!report ||
                    (Object.keys(report.tracesPerQuery).length === 0 &&
                        report.operationCount === 0)) {
                    return;
                }
                report.endTime = dateToProtoTimestamp(new Date());
                report.ensureCountsAreIntegers();
                const protobufError = Report.verify(report);
                if (protobufError) {
                    throw new Error(`Error verifying report: ${protobufError}`);
                }
                let message = Report.encode(report).finish();
                report = null;
                if (options.debugPrintReports) {
                    const decodedReport = Report.decode(message);
                    logger.info(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);
                }
                const compressed = await gzipPromise(message);
                message = null;
                const fetcher = options.fetcher ?? fetch;
                const response = await retry(async () => {
                    const controller = new AbortController();
                    const abortTimeout = setTimeout(() => {
                        controller.abort();
                    }, options.requestTimeoutMs ?? 30000);
                    let curResponse;
                    try {
                        curResponse = await fetcher((options.endpointUrl ||
                            'https://usage-reporting.api.apollographql.com') +
                            '/api/ingress/traces', {
                            method: 'POST',
                            headers: {
                                'user-agent': 'ApolloServerPluginUsageReporting',
                                'x-api-key': key,
                                'content-encoding': 'gzip',
                                accept: 'application/json',
                            },
                            body: compressed,
                            signal: controller.signal,
                        });
                    }
                    finally {
                        clearTimeout(abortTimeout);
                    }
                    if (curResponse.status >= 500 && curResponse.status < 600) {
                        throw new Error(`HTTP status ${curResponse.status}, ${(await curResponse.text()) || '(no body)'}`);
                    }
                    else {
                        return curResponse;
                    }
                }, {
                    retries: (options.maxAttempts || 5) - 1,
                    minTimeout: options.minimumRetryDelayMs || 100,
                    factor: 2,
                }).catch((err) => {
                    throw new Error(`Error sending report to Apollo servers: ${err.message}`);
                });
                if (response.status < 200 || response.status >= 300) {
                    throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${(await response.text()) || '(no body)'}`);
                }
                if (sendTraces &&
                    response.status === 200 &&
                    response.headers
                        .get('content-type')
                        ?.match(/^\s*application\/json\s*(?:;|$)/i)) {
                    const body = await response.text();
                    let parsedBody;
                    try {
                        parsedBody = JSON.parse(body);
                    }
                    catch (e) {
                        throw new Error(`Error parsing response from Apollo servers: ${e}`);
                    }
                    if (parsedBody.tracesIgnored === true) {
                        logger.debug("This graph's organization does not have access to traces; sending all " +
                            'subsequent operations as stats.');
                        sendTraces = false;
                    }
                }
                if (options.debugPrintReports) {
                    logger.info(`Apollo usage report: status ${response.status}`);
                }
            };
            requestDidStartHandler = ({ metrics, schema, request: { http, variables }, }) => {
                const treeBuilder = new TraceTreeBuilder({
                    maskedBy: 'ApolloServerPluginUsageReporting',
                    sendErrors: options.sendErrors,
                    logger,
                });
                treeBuilder.startTiming();
                metrics.startHrTime = treeBuilder.startHrTime;
                let graphqlValidationFailure = false;
                let graphqlUnknownOperationName = false;
                let includeOperationInUsageReporting = null;
                if (http) {
                    treeBuilder.trace.http = new Trace.HTTP({
                        method: Trace.HTTP.Method[http.method] || Trace.HTTP.Method.UNKNOWN,
                        host: null,
                        path: null,
                    });
                    if (options.sendHeaders) {
                        makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);
                    }
                }
                async function maybeCallIncludeRequestHook(requestContext) {
                    if (includeOperationInUsageReporting !== null)
                        return;
                    if (typeof options.includeRequest !== 'function') {
                        includeOperationInUsageReporting = true;
                        return;
                    }
                    includeOperationInUsageReporting = await options.includeRequest(requestContext);
                    if (typeof includeOperationInUsageReporting !== 'boolean') {
                        logger.warn("The 'includeRequest' async predicate function must return a boolean value.");
                        includeOperationInUsageReporting = true;
                    }
                }
                let didResolveSource = false;
                return {
                    async didResolveSource(requestContext) {
                        didResolveSource = true;
                        if (metrics.persistedQueryHit) {
                            treeBuilder.trace.persistedQueryHit = true;
                        }
                        if (metrics.persistedQueryRegister) {
                            treeBuilder.trace.persistedQueryRegister = true;
                        }
                        if (variables) {
                            treeBuilder.trace.details = makeTraceDetails(variables, options.sendVariableValues, requestContext.source);
                        }
                        const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);
                        if (clientInfo) {
                            const { clientName, clientVersion } = clientInfo;
                            treeBuilder.trace.clientVersion = clientVersion || '';
                            treeBuilder.trace.clientName = clientName || '';
                        }
                    },
                    async validationDidStart() {
                        return async (validationErrors) => {
                            graphqlValidationFailure = validationErrors
                                ? validationErrors.length !== 0
                                : false;
                        };
                    },
                    async didResolveOperation(requestContext) {
                        graphqlUnknownOperationName =
                            requestContext.operation === undefined;
                        await maybeCallIncludeRequestHook(requestContext);
                        if (includeOperationInUsageReporting &&
                            !graphqlUnknownOperationName) {
                            if (metrics.captureTraces === undefined) {
                                const rawWeight = await fieldLevelInstrumentation(requestContext);
                                treeBuilder.trace.fieldExecutionWeight =
                                    typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;
                                metrics.captureTraces =
                                    !!treeBuilder.trace.fieldExecutionWeight;
                            }
                        }
                    },
                    async executionDidStart() {
                        if (!metrics.captureTraces)
                            return;
                        return {
                            willResolveField({ info }) {
                                return treeBuilder.willResolveField(info);
                            },
                        };
                    },
                    async didEncounterSubsequentErrors(_requestContext, errors) {
                        treeBuilder.didEncounterErrors(errors);
                    },
                    async willSendSubsequentPayload(requestContext, payload) {
                        if (!payload.hasNext) {
                            await operationFinished(requestContext);
                        }
                    },
                    async willSendResponse(requestContext) {
                        if (!didResolveSource)
                            return;
                        if (requestContext.errors) {
                            treeBuilder.didEncounterErrors(requestContext.errors);
                        }
                        if (requestContext.response.body.kind === 'single') {
                            await operationFinished(requestContext);
                        }
                    },
                };
                async function operationFinished(requestContext) {
                    const resolvedOperation = !!requestContext.operation;
                    await maybeCallIncludeRequestHook(requestContext);
                    treeBuilder.stopTiming();
                    const executableSchemaId = overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema);
                    if (includeOperationInUsageReporting === false) {
                        if (resolvedOperation) {
                            getReportWhichMustBeUsedImmediately(executableSchemaId)
                                .operationCount++;
                        }
                        return;
                    }
                    treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
                    treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
                    treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;
                    const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();
                    if (policyIfCacheable) {
                        treeBuilder.trace.cachePolicy = new Trace.CachePolicy({
                            scope: policyIfCacheable.scope === 'PRIVATE'
                                ? Trace.CachePolicy.Scope.PRIVATE
                                : policyIfCacheable.scope === 'PUBLIC'
                                    ? Trace.CachePolicy.Scope.PUBLIC
                                    : Trace.CachePolicy.Scope.UNKNOWN,
                            maxAgeNs: policyIfCacheable.maxAge * 1e9,
                        });
                    }
                    if (metrics.queryPlanTrace) {
                        treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                    }
                    addTrace().catch(logger.error);
                    async function addTrace() {
                        if (stopped) {
                            return;
                        }
                        await new Promise((res) => setImmediate(res));
                        const executableSchemaId = overriddenExecutableSchemaId ??
                            executableSchemaIdForSchema(schema);
                        const { trace } = treeBuilder;
                        let statsReportKey = undefined;
                        let referencedFieldsByType;
                        if (!requestContext.document) {
                            statsReportKey = `## GraphQLParseFailure\n`;
                        }
                        else if (graphqlValidationFailure) {
                            statsReportKey = `## GraphQLValidationFailure\n`;
                        }
                        else if (graphqlUnknownOperationName) {
                            statsReportKey = `## GraphQLUnknownOperationName\n`;
                        }
                        const isExecutable = statsReportKey === undefined;
                        if (statsReportKey) {
                            if (options.sendUnexecutableOperationDocuments) {
                                trace.unexecutedOperationBody = requestContext.source;
                                trace.unexecutedOperationName =
                                    requestContext.request.operationName || '';
                            }
                            referencedFieldsByType = Object.create(null);
                        }
                        else {
                            const operationDerivedData = getOperationDerivedData();
                            statsReportKey = `# ${requestContext.operationName || '-'}\n${operationDerivedData.signature}`;
                            referencedFieldsByType =
                                operationDerivedData.referencedFieldsByType;
                        }
                        const protobufError = Trace.verify(trace);
                        if (protobufError) {
                            throw new Error(`Error encoding trace: ${protobufError}`);
                        }
                        if (resolvedOperation) {
                            getReportWhichMustBeUsedImmediately(executableSchemaId)
                                .operationCount++;
                        }
                        getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({
                            statsReportKey,
                            trace,
                            asTrace: sendTraces &&
                                (!isExecutable || !!metrics.captureTraces) &&
                                sendOperationAsTrace(trace, statsReportKey),
                            referencedFieldsByType,
                        });
                        if (sendReportsImmediately ||
                            getReportWhichMustBeUsedImmediately(executableSchemaId)
                                .sizeEstimator.bytes >=
                                (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {
                            await sendReportAndReportErrors(executableSchemaId);
                        }
                    }
                    function getOperationDerivedData() {
                        if (!requestContext.document) {
                            throw new Error('No document?');
                        }
                        const cacheKey = operationDerivedDataCacheKey(requestContext.queryHash, requestContext.operationName || '');
                        if (!operationDerivedDataCache ||
                            operationDerivedDataCache.forSchema !== schema) {
                            operationDerivedDataCache = {
                                forSchema: schema,
                                cache: createOperationDerivedDataCache({ logger }),
                            };
                        }
                        const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);
                        if (cachedOperationDerivedData) {
                            return cachedOperationDerivedData;
                        }
                        const generatedSignature = (options.calculateSignature || usageReportingSignature)(requestContext.document, requestContext.operationName || '');
                        const generatedOperationDerivedData = {
                            signature: generatedSignature,
                            referencedFieldsByType: calculateReferencedFieldsByType({
                                document: requestContext.document,
                                schema,
                                resolvedOperationName: requestContext.operationName ?? null,
                            }),
                        };
                        operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);
                        return generatedOperationDerivedData;
                    }
                }
            };
            return {
                async serverWillStop() {
                    if (reportTimer) {
                        clearInterval(reportTimer);
                        reportTimer = undefined;
                    }
                    stopped = true;
                    await sendAllReportsAndReportErrors();
                },
            };
        },
    });
}
export function makeHTTPRequestHeaders(http, headers, sendHeaders) {
    if (!sendHeaders ||
        ('none' in sendHeaders && sendHeaders.none) ||
        ('all' in sendHeaders && !sendHeaders.all)) {
        return;
    }
    for (const [key, value] of headers) {
        if (('exceptNames' in sendHeaders &&
            sendHeaders.exceptNames.some((exceptHeader) => {
                return exceptHeader.toLowerCase() === key;
            })) ||
            ('onlyNames' in sendHeaders &&
                !sendHeaders.onlyNames.some((header) => {
                    return header.toLowerCase() === key;
                }))) {
            continue;
        }
        switch (key) {
            case 'authorization':
            case 'cookie':
            case 'set-cookie':
                break;
            default:
                http.requestHeaders[key] = new Trace.HTTP.Values({
                    value: [value],
                });
        }
    }
}
function defaultGenerateClientInfo({ request, }) {
    const clientNameHeaderKey = 'apollographql-client-name';
    const clientVersionHeaderKey = 'apollographql-client-version';
    if (request.http?.headers?.get(clientNameHeaderKey) ||
        request.http?.headers?.get(clientVersionHeaderKey)) {
        return {
            clientName: request.http?.headers?.get(clientNameHeaderKey),
            clientVersion: request.http?.headers?.get(clientVersionHeaderKey),
        };
    }
    else if (request.extensions?.clientInfo) {
        return request.extensions.clientInfo;
    }
    else {
        return {};
    }
}
//# sourceMappingURL=plugin.js.mapŸ4/dist/cjs/plugin/usageReporting/durationHistogram.js≈	å"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DurationHistogram = void 0;
class DurationHistogram {
    constructor(options) {
        const initSize = options?.initSize || 74;
        const buckets = options?.buckets;
        const arrayInitSize = Math.max(buckets?.length || 0, initSize);
        this.buckets = Array(arrayInitSize).fill(0);
        if (buckets) {
            buckets.forEach((val, index) => (this.buckets[index] = val));
        }
    }
    toArray() {
        let bufferedZeroes = 0;
        const outputArray = [];
        for (const value of this.buckets) {
            if (value === 0) {
                bufferedZeroes++;
            }
            else {
                if (bufferedZeroes === 1) {
                    outputArray.push(0);
                }
                else if (bufferedZeroes !== 0) {
                    outputArray.push(-bufferedZeroes);
                }
                outputArray.push(Math.floor(value));
                bufferedZeroes = 0;
            }
        }
        return outputArray;
    }
    static durationToBucket(durationNs) {
        const log = Math.log(durationNs / 1000.0);
        const unboundedBucket = Math.ceil(log / DurationHistogram.EXPONENT_LOG);
        return unboundedBucket <= 0 || Number.isNaN(unboundedBucket)
            ? 0
            : unboundedBucket >= DurationHistogram.BUCKET_COUNT
                ? DurationHistogram.BUCKET_COUNT - 1
                : unboundedBucket;
    }
    incrementDuration(durationNs, value = 1) {
        this.incrementBucket(DurationHistogram.durationToBucket(durationNs), value);
        return this;
    }
    incrementBucket(bucket, value = 1) {
        if (bucket >= DurationHistogram.BUCKET_COUNT) {
            throw Error('Bucket is out of bounds of the buckets array');
        }
        if (bucket >= this.buckets.length) {
            const oldLength = this.buckets.length;
            this.buckets.length = bucket + 1;
            this.buckets.fill(0, oldLength);
        }
        this.buckets[bucket] += value;
    }
    combine(otherHistogram) {
        for (let i = 0; i < otherHistogram.buckets.length; i++) {
            this.incrementBucket(i, otherHistogram.buckets[i]);
        }
    }
}
exports.DurationHistogram = DurationHistogram;
DurationHistogram.BUCKET_COUNT = 384;
DurationHistogram.EXPONENT_LOG = Math.log(1.1);
//# sourceMappingURL=durationHistogram.js.mapŸ,/dist/esm/externalTypes/constructor.d.ts.map≈
π{"version":3,"file":"constructor.d.ts","sourceRoot":"","sources":["../../../src/externalTypes/constructor.ts"],"names":[],"mappings":"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"}Ω/dist/cjs/ApolloServer.js.map≈Jä{"version":3,"file":"ApolloServer.js","sourceRoot":"","sources":["../../src/ApolloServer.ts"],"names":[],"mappings":"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"}Ÿ1/src/externalTypes/incrementalDeliveryPolyfill.ts≈‰import type { FormattedExecutionResult, GraphQLFormattedError } from 'graphql';

// This file defines types used in our public interface that will be imported
// from `graphql-js` once graphql 17 is released. It is possible that these
// types will change slightly before the final v17 is released, in which case
// the relevant parts of our API may change incompatibly in a minor version of
// AS4; this should not affect any users who aren't explicitly installing
// pre-releases of graphql 17.

interface ObjMap<T> {
  [key: string]: T;
}

export interface GraphQLExperimentalFormattedInitialIncrementalExecutionResult<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> extends FormattedExecutionResult<TData, TExtensions> {
  hasNext: boolean;
  incremental?: ReadonlyArray<
    GraphQLExperimentalFormattedIncrementalResult<TData, TExtensions>
  >;
  extensions?: TExtensions;
}

export interface GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> {
  hasNext: boolean;
  incremental?: ReadonlyArray<
    GraphQLExperimentalFormattedIncrementalResult<TData, TExtensions>
  >;
  extensions?: TExtensions;
}

export type GraphQLExperimentalFormattedIncrementalResult<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> =
  | GraphQLExperimentalFormattedIncrementalDeferResult<TData, TExtensions>
  | GraphQLExperimentalFormattedIncrementalStreamResult<TData, TExtensions>;

export interface GraphQLExperimentalFormattedIncrementalDeferResult<
  TData = ObjMap<unknown>,
  TExtensions = ObjMap<unknown>,
> extends FormattedExecutionResult<TData, TExtensions> {
  path?: ReadonlyArray<string | number>;
  label?: string;
}

export interface GraphQLExperimentalFormattedIncrementalStreamResult<
  TData = Array<unknown>,
  TExtensions = ObjMap<unknown>,
> {
  errors?: ReadonlyArray<GraphQLFormattedError>;
  items?: TData | null;
  path?: ReadonlyArray<string | number>;
  label?: string;
  extensions?: TExtensions;
}
Ÿ%/dist/esm/generated/packageVersion.jsƒQexport const packageVersion = "4.1.1";
//# sourceMappingURL=packageVersion.js.mapŸ1/dist/cjs/plugin/drainHttpServer/stoppable.js.map≈…{"version":3,"file":"stoppable.js","sourceRoot":"","sources":["../../../../src/plugin/drainHttpServer/stoppable.ts"],"names":[],"mappings":"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"}Ÿ$/dist/esm/plugin/disabled/index.d.ts≈\import type { BaseContext, ApolloServerPlugin } from '../../index.js';
export declare function ApolloServerPluginCacheControlDisabled(): ApolloServerPlugin<BaseContext>;
export declare function ApolloServerPluginInlineTraceDisabled(): ApolloServerPlugin<BaseContext>;
export declare function ApolloServerPluginLandingPageDisabled(): ApolloServerPlugin<BaseContext>;
export declare function ApolloServerPluginSchemaReportingDisabled(): ApolloServerPlugin<BaseContext>;
export declare function ApolloServerPluginUsageReportingDisabled(): ApolloServerPlugin<BaseContext>;
//# sourceMappingURL=index.d.ts.mapŸ+/dist/cjs/utils/UnreachableCaseError.js.map≈{"version":3,"file":"UnreachableCaseError.js","sourceRoot":"","sources":["../../../src/utils/UnreachableCaseError.ts"],"names":[],"mappings":";;;AAKA,MAAa,oBAAqB,SAAQ,KAAK;IAC7C,YAAY,GAAU;QACpB,KAAK,CAAC,qBAAqB,GAAG,EAAE,CAAC,CAAC;IACpC,CAAC;CACF;AAJD,oDAIC"}Ÿ'/dist/esm/utils/UnreachableCaseError.jsƒ¨export class UnreachableCaseError extends Error {
    constructor(val) {
        super(`Unreachable case: ${val}`);
    }
}
//# sourceMappingURL=UnreachableCaseError.js.mapΩ/dist/esm/ApolloServer.js.map≈L€{"version":3,"file":"ApolloServer.js","sourceRoot":"","sources":["../../src/ApolloServer.ts"],"names":[],"mappings":"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"}Ÿ$/dist/cjs/utils/schemaManager.js.map≈
p{"version":3,"file":"schemaManager.js","sourceRoot":"","sources":["../../../src/utils/schemaManager.ts"],"names":[],"mappings":"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"}Ÿ!/dist/esm/standalone/index.js.map≈U{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/standalone/index.ts"],"names":[],"mappings":"AACA,OAAO,UAAU,MAAM,aAAa,CAAC;AACrC,OAAO,IAAI,MAAM,MAAM,CAAC;AACxB,OAAO,OAAO,MAAM,SAAS,CAAC;AAC9B,OAAO,IAAyC,MAAM,MAAM,CAAC;AAG7D,OAAO,EAAE,iBAAiB,EAAE,MAAM,sBAAsB,CAAC;AAEzD,OAAO,EAAE,iCAAiC,EAAE,MAAM,oCAAoC,CAAC;AACvF,OAAO,EAAE,gBAAgB,EAAE,MAAM,8BAA8B,CAAC;AAkChE,MAAM,CAAC,KAAK,UAAU,qBAAqB,CACzC,MAA8B,EAC9B,OAA6E;IAE7E,MAAM,GAAG,GAAoB,OAAO,EAAE,CAAC;IACvC,MAAM,UAAU,GAAgB,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;IAEvD,MAAM,CAAC,SAAS,CACd,iCAAiC,CAAC,EAAE,UAAU,EAAE,UAAU,EAAE,CAAC,CAC9D,CAAC;IAEF,MAAM,MAAM,CAAC,KAAK,EAAE,CAAC;IAErB,MAAM,OAAO,GAAG,OAAO,EAAE,OAAO,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC,EAAe,CAAA,CAAC,CAAC;IACnE,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,UAAU,CAAC,IAAI,EAAE,EAAE,iBAAiB,CAAC,MAAM,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;IAE3E,MAAM,aAAa,GAAG,OAAO,EAAE,MAAM,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;IAExD,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;QAClC,UAAU,CAAC,MAAM,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;IAEH,OAAO,EAAE,GAAG,EAAE,gBAAgB,CAAC,UAAU,CAAC,EAAE,CAAC;AAC/C,CAAC"}Ω/dist/esm/errors/index.js.map≈ë{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/errors/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAEvC,MAAM,CAAN,IAAY,qBASX;AATD,WAAY,qBAAqB;IAC/B,wEAA+C,CAAA;IAC/C,sEAA6C,CAAA;IAC7C,gFAAuD,CAAA;IACvD,gFAAuD,CAAA;IACvD,wFAA+D,CAAA;IAC/D,0DAAiC,CAAA;IACjC,sFAA6D,CAAA;IAC7D,oDAA2B,CAAA;AAC7B,CAAC,EATW,qBAAqB,KAArB,qBAAqB,QAShC;AAED,MAAM,CAAN,IAAY,+BAEX;AAFD,WAAY,+BAA+B;IACzC,oFAAiD,CAAA;AACnD,CAAC,EAFW,+BAA+B,KAA/B,+BAA+B,QAE1C;AAWD,MAAM,UAAU,mBAAmB,CAAC,KAAc;IAChD,IAAI,KAAK,YAAY,YAAY,IAAI,KAAK,CAAC,IAAI,IAAI,KAAK,CAAC,aAAa,EAAE;QACtE,OAAO,KAAK,CAAC,aAAa,CAAC;KAC5B;IACD,OAAO,KAAK,CAAC;AACf,CAAC"}æ/src/utils/urlForHttpServer.ts≈‹import type { Server } from 'http';
import type { AddressInfo } from 'net';
import { format } from 'url';

export function urlForHttpServer(httpServer: Server): string {
  const { address, port } = httpServer.address() as AddressInfo;

  // Convert IPs which mean "any address" (IPv4 or IPv6) into localhost
  // corresponding loopback ip. Note that the url field we're setting is
  // primarily for consumption by our test suite. If this heuristic is wrong for
  // your use case, explicitly specify a frontend host (in the `host` option
  // when listening).
  const hostname = address === '' || address === '::' ? 'localhost' : address;

  return format({
    protocol: 'http',
    hostname,
    port,
    pathname: '/',
  });
}
ª/dist/cjs/express4/index.js≈·"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expressMiddleware = void 0;
const url_1 = require("url");
function expressMiddleware(server, options) {
    server.assertStarted('expressMiddleware()');
    const defaultContext = async () => ({});
    const context = options?.context ?? defaultContext;
    return (req, res, next) => {
        if (!req.body) {
            res.status(500);
            res.send('`req.body` is not set; this probably means you forgot to set up the ' +
                '`body-parser` middleware before the Apollo Server middleware.');
            return;
        }
        const headers = new Map();
        for (const [key, value] of Object.entries(req.headers)) {
            if (value !== undefined) {
                headers.set(key, Array.isArray(value) ? value.join(', ') : value);
            }
        }
        const httpGraphQLRequest = {
            method: req.method.toUpperCase(),
            headers,
            search: (0, url_1.parse)(req.url).search ?? '',
            body: req.body,
        };
        server
            .executeHTTPGraphQLRequest({
            httpGraphQLRequest,
            context: () => context({ req, res }),
        })
            .then(async (httpGraphQLResponse) => {
            for (const [key, value] of httpGraphQLResponse.headers) {
                res.setHeader(key, value);
            }
            res.statusCode = httpGraphQLResponse.status || 200;
            if (httpGraphQLResponse.body.kind === 'complete') {
                res.send(httpGraphQLResponse.body.string);
                return;
            }
            for await (const chunk of httpGraphQLResponse.body.asyncIterator) {
                res.write(chunk);
                if (typeof res.flush === 'function') {
                    res.flush();
                }
            }
            res.end();
        })
            .catch(next);
    };
}
exports.expressMiddleware = expressMiddleware;
//# sourceMappingURL=index.js.mapŸ#/src/utils/computeCoreSchemaHash.ts≈Íimport { createHash } from '@apollo/utils.createhash';

// This hash function is used in both the schema reporting and usage reporting
// plugins. Making sure we use the same hash function hypothetically allows the
// two reporting features to work well together, though in practice nothing on
// the Studio side currently correlates this ID across both features.
export function computeCoreSchemaHash(schema: string): string {
  return createHash('sha256').update(schema).digest('hex');
}
Ÿ2/dist/cjs/plugin/schemaReporting/schemaReporter.js≈$"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaReporter = exports.schemaReportGql = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const packageVersion_js_1 = require("../../generated/packageVersion.js");
exports.schemaReportGql = `mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
  reportSchema(report: $report, coreSchema: $coreSchema) {
    __typename
    ... on ReportSchemaError {
      message
      code
    }
    ... on ReportSchemaResponse {
      inSeconds
      withCoreSchema
    }
  }
}
`;
class SchemaReporter {
    constructor(options) {
        this.headers = {
            'Content-Type': 'application/json',
            'x-api-key': options.apiKey,
            'apollographql-client-name': 'ApolloServerPluginSchemaReporting',
            'apollographql-client-version': packageVersion_js_1.packageVersion,
        };
        this.endpointUrl =
            options.endpointUrl ||
                'https://schema-reporting.api.apollographql.com/api/graphql';
        this.schemaReport = options.schemaReport;
        this.coreSchema = options.coreSchema;
        this.isStopped = false;
        this.logger = options.logger;
        this.initialReportingDelayInMs = options.initialReportingDelayInMs;
        this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
        this.fetcher = options.fetcher ?? node_fetch_1.default;
    }
    stopped() {
        return this.isStopped;
    }
    start() {
        this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.initialReportingDelayInMs);
    }
    stop() {
        this.isStopped = true;
        if (this.pollTimer) {
            clearTimeout(this.pollTimer);
            this.pollTimer = undefined;
        }
    }
    async sendOneReportAndScheduleNext(sendNextWithCoreSchema) {
        this.pollTimer = undefined;
        if (this.stopped())
            return;
        try {
            const result = await this.reportSchema(sendNextWithCoreSchema);
            if (!result) {
                return;
            }
            if (!this.stopped()) {
                this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(result.withCoreSchema), result.inSeconds * 1000);
            }
            return;
        }
        catch (error) {
            this.logger.error(`Error reporting server info to Apollo during schema reporting: ${error}`);
            if (!this.stopped()) {
                this.pollTimer = setTimeout(() => this.sendOneReportAndScheduleNext(false), this.fallbackReportingDelayInMs);
            }
        }
    }
    async reportSchema(withCoreSchema) {
        const { data, errors } = await this.apolloQuery({
            report: this.schemaReport,
            coreSchema: withCoreSchema ? this.coreSchema : null,
        });
        if (errors) {
            throw new Error(errors.map((x) => x.message).join('\n'));
        }
        function msgForUnexpectedResponse(data) {
            return [
                'Unexpected response shape from Apollo when',
                'reporting schema. If this continues, please reach',
                'out to support@apollographql.com.',
                'Received response:',
                JSON.stringify(data),
            ].join(' ');
        }
        if (!data || !data.reportSchema) {
            throw new Error(msgForUnexpectedResponse(data));
        }
        if (data.reportSchema.__typename === 'ReportSchemaResponse') {
            return data.reportSchema;
        }
        else if (data.reportSchema.__typename === 'ReportSchemaError') {
            this.logger.error([
                'Received input validation error from Apollo:',
                data.reportSchema.message,
                'Stopping reporting. Please fix the input errors.',
            ].join(' '));
            this.stop();
            return null;
        }
        throw new Error(msgForUnexpectedResponse(data));
    }
    async apolloQuery(variables) {
        const request = {
            query: exports.schemaReportGql,
            variables,
        };
        const httpResponse = await this.fetcher(this.endpointUrl, {
            method: 'POST',
            headers: this.headers,
            body: JSON.stringify(request),
        });
        if (!httpResponse.ok) {
            throw new Error([
                `An unexpected HTTP status code (${httpResponse.status}) was`,
                'encountered during schema reporting.',
            ].join(' '));
        }
        try {
            return await httpResponse.json();
        }
        catch (error) {
            throw new Error([
                "Couldn't report schema to Apollo.",
                'Parsing response as JSON failed.',
                'If this continues please reach out to support@apollographql.com',
                error,
            ].join(' '));
        }
    }
}
exports.SchemaReporter = SchemaReporter;
//# sourceMappingURL=schemaReporter.js.mapŸ$/dist/esm/utils/invokeHooks.d.ts.map≈ì{"version":3,"file":"invokeHooks.d.ts","sourceRoot":"","sources":["../../../src/utils/invokeHooks.ts"],"names":[],"mappings":"AAEA,aAAK,eAAe,CAAC,KAAK,SAAS,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,EAAE,KAAK,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;AAC9E,aAAK,cAAc,CAAC,KAAK,SAAS,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,EAAE,KAAK,KAAK,IAAI,CAAC;AAEpE,wBAAsB,kBAAkB,CAAC,CAAC,EAAE,YAAY,SAAS,OAAO,EAAE,EACxE,OAAO,EAAE,CAAC,EAAE,EACZ,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,GAAG,SAAS,GAAG,IAAI,CAAC,GACxE,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAYxC;AAID,wBAAgB,sBAAsB,CAAC,CAAC,EAAE,YAAY,SAAS,OAAO,EAAE,EACtE,OAAO,EAAE,CAAC,EAAE,EACZ,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,cAAc,CAAC,YAAY,CAAC,GAAG,SAAS,GAAG,IAAI,GAC9D,cAAc,CAAC,YAAY,CAAC,CAY9B;AAED,wBAAsB,iCAAiC,CAAC,CAAC,EAAE,IAAI,EAC7D,OAAO,EAAE,CAAC,EAAE,EACZ,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,OAAO,CAAC,IAAI,GAAG,IAAI,GAAG,SAAS,CAAC,GAC/C,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,CAQtB"}Ÿ2/src/plugin/landingPage/default/getEmbeddedHTML.ts≈Œimport type {
  ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions,
  LandingPageConfig,
} from './types';

// This function turns an object into a string and replaces
// <, >, &, ' with their unicode chars to avoid adding html tags to
// the landing page html that might be passed from the config.
// The only place these characters can appear in the output of
// JSON.stringify is within string literals, where they can equally
// well appear \u-escaped. This specifically means that
// `</script>` won't terminate the script block early.
// (Perhaps we should have done this instead of the triple-encoding
// of encodeConfig for the main landing page.)
function getConfigStringForHtml(config: LandingPageConfig) {
  return JSON.stringify(config)
    .replace('<', '\\u003c')
    .replace('>', '\\u003e')
    .replace('&', '\\u0026')
    .replace("'", '\\u0027');
}

export const getEmbeddedExplorerHTML = (
  version: string,
  config: ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions,
) => {
  interface EmbeddableExplorerOptions {
    graphRef: string;
    target: string;

    initialState?: {
      document?: string;
      variables?: Record<string, any>;
      headers?: Record<string, string>;
      displayOptions: {
        docsPanelState?: 'open' | 'closed'; // default to 'open',
        showHeadersAndEnvVars?: boolean; // default to `false`
        theme?: 'dark' | 'light';
      };
    };
    persistExplorerState?: boolean; // defaults to 'false'

    endpointUrl: string;

    includeCookies?: boolean; // defaults to 'false'
  }
  const productionLandingPageConfigOrDefault = {
    displayOptions: {},
    persistExplorerState: false,
    ...(typeof config.embed === 'boolean' ? {} : config.embed),
  };
  const embeddedExplorerParams: Omit<EmbeddableExplorerOptions, 'endpointUrl'> =
    {
      ...config,
      target: '#embeddableExplorer',
      initialState: {
        ...config,
        displayOptions: {
          ...productionLandingPageConfigOrDefault.displayOptions,
        },
      },
      persistExplorerState:
        productionLandingPageConfigOrDefault.persistExplorerState,
    };

  return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableExplorer"
></div>
<script src="https://embeddable-explorer.cdn.apollographql.com/${version}/embeddable-explorer.umd.production.min.js"></script>
<script>
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(
    embeddedExplorerParams,
  )};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
</script>
`;
};

export const getEmbeddedSandboxHTML = (
  version: string,
  config: LandingPageConfig,
) => {
  return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableSandbox"
></div>
<script src="https://embeddable-sandbox.cdn.apollographql.com/${version}/embeddable-sandbox.umd.production.min.js"></script>
<script>
  var initialEndpoint = window.location.href;
  new window.EmbeddedSandbox({
    target: '#embeddableSandbox',
    initialEndpoint,
    includeCookies: ${config.includeCookies ?? 'false'},
    initialState: ${getConfigStringForHtml({
      document: config.document ?? undefined,
      variables: config.variables ?? undefined,
      headers: config.headers ?? undefined,
    })},
  });
</script>
`;
};
ø/dist/esm/httpBatching.d.ts.map≈È{"version":3,"file":"httpBatching.d.ts","sourceRoot":"","sources":["../../src/httpBatching.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,WAAW,EACX,kBAAkB,EAClB,mBAAmB,EACpB,MAAM,0BAA0B,CAAC;AAClC,OAAO,KAAK,EACV,YAAY,EACZ,qBAAqB,EACrB,iBAAiB,EAClB,MAAM,gBAAgB,CAAC;AA4DxB,wBAAsB,8BAA8B,CAClD,QAAQ,SAAS,WAAW,EAE5B,MAAM,EAAE,YAAY,CAAC,QAAQ,CAAC,EAC9B,kBAAkB,EAAE,kBAAkB,EACtC,YAAY,EAAE,QAAQ,EACtB,iBAAiB,EAAE,iBAAiB,EACpC,SAAS,EAAE,qBAAqB,CAAC,QAAQ,CAAC,GACzC,OAAO,CAAC,mBAAmB,CAAC,CA2B9B"}Ÿ)/dist/cjs/plugin/schemaReporting/index.js≈Õ"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApolloServerPluginSchemaReporting = void 0;
const os_1 = __importDefault(require("os"));
const internalPlugin_js_1 = require("../../internalPlugin.js");
const uuid_1 = require("uuid");
const graphql_1 = require("graphql");
const schemaReporter_js_1 = require("./schemaReporter.js");
const schemaIsFederated_js_1 = require("../schemaIsFederated.js");
const packageVersion_js_1 = require("../../generated/packageVersion.js");
const computeCoreSchemaHash_js_1 = require("../../utils/computeCoreSchemaHash.js");
function ApolloServerPluginSchemaReporting({ initialDelayMaxMs, overrideReportedSchema, endpointUrl, fetcher, } = Object.create(null)) {
    const bootId = (0, uuid_1.v4)();
    return (0, internalPlugin_js_1.internalPlugin)({
        __internal_plugin_id__: 'SchemaReporting',
        __is_disabled_plugin__: false,
        async serverWillStart({ apollo, schema, logger }) {
            const { key, graphRef } = apollo;
            if (!key) {
                throw Error('To use ApolloServerPluginSchemaReporting, you must provide an Apollo API ' +
                    'key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`');
            }
            if (!graphRef) {
                throw Error('To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, ' +
                    "'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment " +
                    'variable or passing `new ApolloServer({apollo: {graphRef}})`.');
            }
            if (overrideReportedSchema) {
                try {
                    const validationErrors = (0, graphql_1.validateSchema)((0, graphql_1.buildSchema)(overrideReportedSchema, { noLocation: true }));
                    if (validationErrors.length) {
                        throw new Error(validationErrors.map((error) => error.message).join('\n'));
                    }
                }
                catch (err) {
                    throw new Error('The schema provided to overrideReportedSchema failed to parse or ' +
                        `validate: ${err.message}`);
                }
            }
            if ((0, schemaIsFederated_js_1.schemaIsFederated)(schema)) {
                throw Error([
                    'Schema reporting is not yet compatible with federated services.',
                    "If you're interested in using schema reporting with federated",
                    'services, please contact Apollo support. To set up managed federation, see',
                    'https://go.apollo.dev/s/managed-federation',
                ].join(' '));
            }
            if (endpointUrl !== undefined) {
                logger.info(`Apollo schema reporting: schema reporting URL override: ${endpointUrl}`);
            }
            const baseSchemaReport = {
                bootId,
                graphRef,
                platform: process.env.APOLLO_SERVER_PLATFORM || 'local',
                runtimeVersion: `node ${process.version}`,
                userVersion: process.env.APOLLO_SERVER_USER_VERSION,
                serverId: process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os_1.default.hostname(),
                libraryVersion: `@apollo/server@${packageVersion_js_1.packageVersion}`,
            };
            let currentSchemaReporter;
            return {
                schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }) {
                    if (overrideReportedSchema !== undefined) {
                        if (currentSchemaReporter) {
                            return;
                        }
                        else {
                            logger.info('Apollo schema reporting: schema to report has been overridden');
                        }
                    }
                    const coreSchema = overrideReportedSchema ??
                        coreSupergraphSdl ??
                        (0, graphql_1.printSchema)(apiSchema);
                    const coreSchemaHash = (0, computeCoreSchemaHash_js_1.computeCoreSchemaHash)(coreSchema);
                    const schemaReport = {
                        ...baseSchemaReport,
                        coreSchemaHash,
                    };
                    currentSchemaReporter?.stop();
                    currentSchemaReporter = new schemaReporter_js_1.SchemaReporter({
                        schemaReport,
                        coreSchema,
                        apiKey: key,
                        endpointUrl,
                        logger,
                        initialReportingDelayInMs: Math.floor(Math.random() * (initialDelayMaxMs ?? 10000)),
                        fallbackReportingDelayInMs: 20000,
                        fetcher,
                    });
                    currentSchemaReporter.start();
                    logger.info('Apollo schema reporting: reporting a new schema to Studio! See your graph at ' +
                        `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/ with server info ${JSON.stringify(schemaReport)}`);
                },
                async serverWillStop() {
                    currentSchemaReporter?.stop();
                },
            };
        },
    });
}
exports.ApolloServerPluginSchemaReporting = ApolloServerPluginSchemaReporting;
//# sourceMappingURL=index.js.mapŸ(/dist/esm/utils/schemaInstrumentation.js≈
8import { getNamedType, GraphQLObjectType, defaultFieldResolver, } from 'graphql';
export const symbolExecutionDispatcherWillResolveField = Symbol('apolloServerExecutionDispatcherWillResolveField');
export const symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');
const symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');
export function enablePluginsForSchemaResolvers(schema) {
    if (pluginsEnabledForSchemaResolvers(schema)) {
        return schema;
    }
    Object.defineProperty(schema, symbolPluginsEnabled, {
        value: true,
    });
    const typeMap = schema.getTypeMap();
    Object.values(typeMap).forEach((type) => {
        if (!getNamedType(type).name.startsWith('__') &&
            type instanceof GraphQLObjectType) {
            const fields = type.getFields();
            Object.values(fields).forEach((field) => {
                wrapField(field);
            });
        }
    });
    return schema;
}
export function pluginsEnabledForSchemaResolvers(schema) {
    return !!schema[symbolPluginsEnabled];
}
function wrapField(field) {
    const originalFieldResolve = field.resolve;
    field.resolve = (source, args, contextValue, info) => {
        const willResolveField = contextValue?.[symbolExecutionDispatcherWillResolveField];
        const userFieldResolver = contextValue?.[symbolUserFieldResolver];
        const didResolveField = typeof willResolveField === 'function' &&
            willResolveField({ source, args, contextValue, info });
        const fieldResolver = originalFieldResolve || userFieldResolver || defaultFieldResolver;
        try {
            const result = fieldResolver(source, args, contextValue, info);
            if (typeof didResolveField === 'function') {
                whenResultIsFinished(result, didResolveField);
            }
            return result;
        }
        catch (error) {
            if (typeof didResolveField === 'function') {
                didResolveField(error);
            }
            throw error;
        }
    };
}
function isPromise(x) {
    return x && typeof x.then === 'function';
}
export function whenResultIsFinished(result, callback) {
    if (isPromise(result)) {
        result.then((r) => callback(null, r), (err) => callback(err));
    }
    else if (Array.isArray(result)) {
        if (result.some(isPromise)) {
            Promise.all(result).then((r) => callback(null, r), (err) => callback(err));
        }
        else {
            callback(null, result);
        }
    }
    else {
        callback(null, result);
    }
}
//# sourceMappingURL=schemaInstrumentation.js.mapŸ$/dist/esm/externalTypes/context.d.ts≈uexport declare type BaseContext = {};
export declare type ContextFunction<TIntegrationSpecificArgs extends any[], TContext extends BaseContext = BaseContext> = (...integrationContext: TIntegrationSpecificArgs) => Promise<TContext>;
export declare type ContextThunk<TContext extends BaseContext = BaseContext> = () => Promise<TContext>;
//# sourceMappingURL=context.d.ts.map∫/dist/esm/cachePolicy.d.tsƒ†import type { CachePolicy } from '@apollo/cache-control-types';
export declare function newCachePolicy(): CachePolicy;
//# sourceMappingURL=cachePolicy.d.ts.mapŸ!/dist/esm/internalErrorClasses.js≈+import { GraphQLError } from 'graphql';
import { ApolloServerErrorCode } from './errors/index.js';
import { newHTTPGraphQLHead } from './runHttpQuery.js';
import { HeaderMap } from './utils/HeaderMap.js';
class GraphQLErrorWithCode extends GraphQLError {
    constructor(message, code, options) {
        super(message, {
            ...options,
            extensions: { ...options?.extensions, code },
        });
        this.name = this.constructor.name;
    }
}
export class SyntaxError extends GraphQLErrorWithCode {
    constructor(graphqlError) {
        super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_PARSE_FAILED, {
            source: graphqlError.source,
            positions: graphqlError.positions,
            extensions: { http: newHTTPGraphQLHead(400), ...graphqlError.extensions },
            originalError: graphqlError,
        });
    }
}
export class ValidationError extends GraphQLErrorWithCode {
    constructor(graphqlError) {
        super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED, {
            nodes: graphqlError.nodes,
            extensions: {
                http: newHTTPGraphQLHead(400),
                ...graphqlError.extensions,
            },
            originalError: graphqlError.originalError ?? graphqlError,
        });
    }
}
const getPersistedQueryErrorHttp = () => ({
    status: 200,
    headers: new HeaderMap([
        ['cache-control', 'private, no-cache, must-revalidate'],
    ]),
});
export class PersistedQueryNotFoundError extends GraphQLErrorWithCode {
    constructor() {
        super('PersistedQueryNotFound', ApolloServerErrorCode.PERSISTED_QUERY_NOT_FOUND, { extensions: { http: getPersistedQueryErrorHttp() } });
    }
}
export class PersistedQueryNotSupportedError extends GraphQLErrorWithCode {
    constructor() {
        super('PersistedQueryNotSupported', ApolloServerErrorCode.PERSISTED_QUERY_NOT_SUPPORTED, { extensions: { http: getPersistedQueryErrorHttp() } });
    }
}
export class UserInputError extends GraphQLErrorWithCode {
    constructor(graphqlError) {
        super(graphqlError.message, ApolloServerErrorCode.BAD_USER_INPUT, {
            nodes: graphqlError.nodes,
            originalError: graphqlError.originalError ?? graphqlError,
            extensions: graphqlError.extensions,
        });
    }
}
export class OperationResolutionError extends GraphQLErrorWithCode {
    constructor(graphqlError) {
        super(graphqlError.message, ApolloServerErrorCode.OPERATION_RESOLUTION_FAILURE, {
            nodes: graphqlError.nodes,
            originalError: graphqlError.originalError ?? graphqlError,
            extensions: {
                http: newHTTPGraphQLHead(400),
                ...graphqlError.extensions,
            },
        });
    }
}
export class BadRequestError extends GraphQLErrorWithCode {
    constructor(message, options) {
        super(message, ApolloServerErrorCode.BAD_REQUEST, {
            ...options,
            extensions: { http: newHTTPGraphQLHead(400), ...options?.extensions },
        });
    }
}
//# sourceMappingURL=internalErrorClasses.js.mapæ/dist/esm/utils/isDefined.d.tsƒuexport declare function isDefined<T>(t: T | undefined | null | void): t is T;
//# sourceMappingURL=isDefined.d.ts.mapŸ"/dist/cjs/utils/invokeHooks.js.map≈]{"version":3,"file":"invokeHooks.js","sourceRoot":"","sources":["../../../src/utils/invokeHooks.ts"],"names":[],"mappings":";;;AAAA,iDAA2C;AAKpC,KAAK,UAAU,kBAAkB,CACtC,OAAY,EACZ,IAAyE;IAEzE,MAAM,WAAW,GAAG,CAClB,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CACzD,CAAC,MAAM,CAAC,wBAAS,CAAC,CAAC;IAEpB,WAAW,CAAC,OAAO,EAAE,CAAC;IAEtB,OAAO,KAAK,EAAE,GAAG,IAAkB,EAAE,EAAE;QACrC,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;SACrB;IACH,CAAC,CAAC;AACJ,CAAC;AAfD,gDAeC;AAID,SAAgB,sBAAsB,CACpC,OAAY,EACZ,IAA+D;IAE/D,MAAM,WAAW,GAAmC,OAAO;SACxD,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAC7B,MAAM,CAAC,wBAAS,CAAC,CAAC;IAErB,WAAW,CAAC,OAAO,EAAE,CAAC;IAEtB,OAAO,CAAC,GAAG,IAAkB,EAAE,EAAE;QAC/B,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YACpC,UAAU,CAAC,GAAG,IAAI,CAAC,CAAC;SACrB;IACH,CAAC,CAAC;AACJ,CAAC;AAfD,wDAeC;AAEM,KAAK,UAAU,iCAAiC,CACrD,OAAY,EACZ,IAAgD;IAEhD,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;QAC5B,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,CAAC;QACjC,IAAI,KAAK,IAAI,IAAI,EAAE;YACjB,OAAO,KAAK,CAAC;SACd;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAXD,8EAWC"}Ÿ,/dist/esm/plugin/usageReporting/stats.js.map≈!{"version":3,"file":"stats.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/stats.ts"],"names":[],"mappings":"AAAA,OAAO,EAWL,KAAK,GACN,MAAM,kCAAkC,CAAC;AAE1C,OAAO,EAAE,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;AAC3D,OAAO,EAAE,gBAAgB,EAAoB,MAAM,uBAAuB,CAAC;AAiB3E,MAAM,OAAO,aAAa;IAA1B;QACE,UAAK,GAAG,CAAC,CAAC;IACZ,CAAC;CAAA;AACD,MAAM,OAAO,SAAS;IACpB,YAAqB,MAAoB;QAApB,WAAM,GAAN,MAAM,CAAc;QAChC,mBAAc,GACrB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACtB,YAAO,GAAsC,IAAI,CAAC;QAClD,mBAAc,GAAG,CAAC,CAAC;QAUV,kBAAa,GAAG,IAAI,aAAa,EAAE,CAAC;IAdD,CAAC;IAgB7C,uBAAuB;QACrB,KAAK,MAAM,cAAc,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE;YAC/D,cAAc,CAAC,uBAAuB,EAAE,CAAC;SAC1C;IACH,CAAC;IAED,QAAQ,CAAC,EACP,cAAc,EACd,KAAK,EACL,OAAO,EACP,sBAAsB,EAItB,aAAa,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAOjC;QACC,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC;YAC5C,cAAc;YACd,sBAAsB;SACvB,CAAC,CAAC;QACH,IAAI,OAAO,EAAE;YACX,MAAM,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,CAAC;YAElD,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,YAAY,CAAC,MAAM,GAAG,aAAa,EAAE;gBAChE,cAAc,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;aACrE;iBAAM;gBACL,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBACxC,IAAI,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC,GAAG,YAAY,CAAC,MAAM,CAAC;aACrD;SACF;aAAM;YACL,cAAc,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;SACrE;IACH,CAAC;IAEO,iBAAiB,CAAC,EACxB,cAAc,EACd,sBAAsB,GAIvB;QACC,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;QACrD,IAAI,QAAQ,EAAE;YACZ,OAAO,QAAQ,CAAC;SACjB;QACD,IAAI,CAAC,aAAa,CAAC,KAAK,IAAI,uBAAuB,CAAC,cAAc,CAAC,CAAC;QAGpE,KAAK,MAAM,CAAC,QAAQ,EAAE,uBAAuB,CAAC,IAAI,MAAM,CAAC,OAAO,CAC9D,sBAAsB,CACvB,EAAE;YAGD,IAAI,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC;YAClC,IAAI,uBAAuB,CAAC,WAAW,EAAE;gBACvC,IAAI,CAAC,aAAa,CAAC,KAAK,IAAI,CAAC,CAAC;aAC/B;YACD,IAAI,CAAC,aAAa,CAAC,KAAK,IAAI,uBAAuB,CAAC,QAAQ,CAAC,CAAC;YAC9D,KAAK,MAAM,SAAS,IAAI,uBAAuB,CAAC,UAAU,EAAE;gBAC1D,IAAI,CAAC,aAAa,CAAC,KAAK,IAAI,uBAAuB,CAAC,SAAS,CAAC,CAAC;aAChE;SACF;QAMD,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,GAAG,IAAI,iBAAiB,CACjE,sBAAsB,CACvB,CAAC,CAAC;IACL,CAAC;CACF;AAED,MAAM,iBAAiB;IACrB,YAAqB,sBAA8C;QAA9C,2BAAsB,GAAtB,sBAAsB,CAAwB;QAC1D,UAAK,GAAiB,EAAE,CAAC;QACzB,qBAAgB,GAAG,IAAI,cAAc,EAAE,CAAC;QACxC,sCAAiC,GAAiB,EAAE,CAAC;IAHQ,CAAC;IAKvE,uBAAuB;QACrB,IAAI,CAAC,gBAAgB,CAAC,uBAAuB,EAAE,CAAC;IAClD,CAAC;CACF;AAED,MAAM,cAAc;IAApB;QACW,QAAG,GAA4C,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAgD9E,CAAC;IA1CC,OAAO;QACL,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACjC,CAAC;IAED,uBAAuB;QACrB,KAAK,MAAM,mBAAmB,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YACzD,mBAAmB,CAAC,uBAAuB,EAAE,CAAC;SAC/C;IACH,CAAC;IAED,QAAQ,CAAC,KAAY,EAAE,aAA4B;QACjD,IAAI,CAAC,sBAAsB,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC,QAAQ,CACxD,KAAK,EACL,aAAa,CACd,CAAC;IACJ,CAAC;IAEO,sBAAsB,CAC5B,KAAY,EACZ,aAA4B;QAE5B,MAAM,YAAY,GAAkB;YAClC,UAAU,EAAE,KAAK,CAAC,UAAU;YAC5B,aAAa,EAAE,KAAK,CAAC,aAAa;SACnC,CAAC;QACF,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;QAErD,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;QAC3C,IAAI,QAAQ,EAAE;YACZ,OAAO,QAAQ,CAAC;SACjB;QAID,aAAa,CAAC,KAAK;YACjB,EAAE;gBACF,uBAAuB,CAAC,KAAK,CAAC,UAAU,CAAC;gBACzC,uBAAuB,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;QAC/C,MAAM,mBAAmB,GAAG,IAAI,sBAAsB,CAAC,YAAY,CAAC,CAAC;QACrE,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,GAAG,mBAAmB,CAAC;QAChD,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CACF;AAED,MAAM,OAAO,sBAAsB;IAIjC,YAAqB,OAAsB;QAAtB,YAAO,GAAP,OAAO,CAAe;QAH3C,sBAAiB,GAAG,IAAI,oBAAoB,EAAE,CAAC;QAC/C,gBAAW,GAAiC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAElB,CAAC;IAE/C,uBAAuB;QACrB,KAAK,MAAM,QAAQ,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;YACtD,QAAQ,CAAC,uBAAuB,EAAE,CAAC;SACpC;IACH,CAAC;IAMD,QAAQ,CAAC,KAAY,EAAE,aAA4B;QACjD,MAAM,EAAE,oBAAoB,EAAE,GAAG,KAAK,CAAC;QACvC,IAAI,CAAC,oBAAoB,EAAE;YACzB,IAAI,CAAC,iBAAiB,CAAC,mCAAmC,EAAE,CAAC;SAC9D;QAED,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE,CAAC;QACtC,IAAI,KAAK,CAAC,iBAAiB,EAAE;YAC3B,IAAI,CAAC,iBAAiB,CAAC,iBAAiB,CAAC,iBAAiB,CACxD,KAAK,CAAC,UAAU,CACjB,CAAC;YACF,IAAI,CAAC,iBAAiB,CAAC,SAAS,EAAE,CAAC;SACpC;aAAM;YACL,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,iBAAiB,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;SACzE;QAMD,IAAI,CAAC,KAAK,CAAC,iBAAiB,IAAI,KAAK,CAAC,WAAW,EAAE,QAAQ,IAAI,IAAI,EAAE;YACnE,QAAQ,KAAK,CAAC,WAAW,CAAC,KAAK,EAAE;gBAC/B,KAAK,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,OAAO;oBAClC,IAAI,CAAC,iBAAiB,CAAC,oBAAoB,CAAC,iBAAiB,CAC3D,KAAK,CAAC,WAAW,CAAC,QAAQ,CAC3B,CAAC;oBACF,MAAM;gBACR,KAAK,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,MAAM;oBACjC,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,CAAC,iBAAiB,CAC1D,KAAK,CAAC,WAAW,CAAC,QAAQ,CAC3B,CAAC;oBACF,MAAM;aACT;SACF;QAED,IAAI,KAAK,CAAC,iBAAiB,EAAE;YAC3B,IAAI,CAAC,iBAAiB,CAAC,kBAAkB,EAAE,CAAC;SAC7C;QACD,IAAI,KAAK,CAAC,sBAAsB,EAAE;YAChC,IAAI,CAAC,iBAAiB,CAAC,oBAAoB,EAAE,CAAC;SAC/C;QAED,IAAI,KAAK,CAAC,kBAAkB,EAAE;YAC5B,IAAI,CAAC,iBAAiB,CAAC,uBAAuB,EAAE,CAAC;SAClD;QACD,IAAI,KAAK,CAAC,mBAAmB,EAAE;YAC7B,IAAI,CAAC,iBAAiB,CAAC,wBAAwB,EAAE,CAAC;SACnD;QAED,IAAI,QAAQ,GAAG,KAAK,CAAC;QAErB,MAAM,cAAc,GAAG,CAAC,IAAiB,EAAE,IAAsB,EAAE,EAAE;YAEnE,IAAI,IAAI,CAAC,KAAK,EAAE,MAAM,EAAE;gBACtB,QAAQ,GAAG,IAAI,CAAC;gBAEhB,IAAI,kBAAkB,GAAG,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC;gBAC/D,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;oBACjC,kBAAkB,GAAG,kBAAkB,CAAC,QAAQ,CAC9C,OAAO,EACP,aAAa,CACd,CAAC;gBACJ,CAAC,CAAC,CAAC;gBAEH,kBAAkB,CAAC,uBAAuB,IAAI,CAAC,CAAC;gBAChD,kBAAkB,CAAC,WAAW,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;aACrD;YAED,IAAI,oBAAoB,EAAE;gBAIxB,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,YAAY,CAAC;gBAa9D,IACE,IAAI,CAAC,UAAU;oBACf,SAAS;oBACT,IAAI,CAAC,IAAI;oBACT,IAAI,CAAC,OAAO,IAAI,IAAI;oBACpB,IAAI,CAAC,SAAS,IAAI,IAAI;oBACtB,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,SAAS,EAC9B;oBACA,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,EAAE,aAAa,CAAC,CAAC;oBAElE,MAAM,SAAS,GAAG,QAAQ,CAAC,YAAY,CACrC,SAAS,EACT,IAAI,CAAC,IAAI,EACT,aAAa,CACd,CAAC;oBAEF,SAAS,CAAC,WAAW,IAAI,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC;oBACjD,SAAS,CAAC,sBAAsB,EAAE,CAAC;oBACnC,SAAS,CAAC,uBAAuB,IAAI,oBAAoB,CAAC;oBAM1D,SAAS,CAAC,uBAAuB;wBAC/B,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;oBACxC,SAAS,CAAC,YAAY,CAAC,iBAAiB,CACtC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,EAG7B,oBAAoB,CACrB,CAAC;iBACH;aACF;YAED,OAAO,KAAK,CAAC;QACf,CAAC,CAAC;QAEF,gBAAgB,CAAC,KAAK,EAAE,cAAc,EAAE,IAAI,CAAC,CAAC;QAC9C,IAAI,QAAQ,EAAE;YACZ,IAAI,CAAC,iBAAiB,CAAC,uBAAuB,EAAE,CAAC;SAClD;IACH,CAAC;IAED,WAAW,CAAC,UAAkB,EAAE,aAA4B;QAC1D,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAC9C,IAAI,QAAQ,EAAE;YACZ,OAAO,QAAQ,CAAC;SACjB;QACD,aAAa,CAAC,KAAK,IAAI,uBAAuB,CAAC,UAAU,CAAC,CAAC;QAC3D,MAAM,QAAQ,GAAG,IAAI,WAAW,EAAE,CAAC;QACnC,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,QAAQ,CAAC;QACxC,OAAO,QAAQ,CAAC;IAClB,CAAC;CACF;AAED,MAAM,oBAAoB;IAA1B;QACE,iBAAY,GAAsB,IAAI,iBAAiB,EAAE,CAAC;QAC1D,iBAAY,GAAG,CAAC,CAAC;QACjB,wCAAmC,GAAG,CAAC,CAAC;QACxC,cAAS,GAAG,CAAC,CAAC;QACd,uBAAkB,GAAG,CAAC,CAAC;QACvB,yBAAoB,GAAG,CAAC,CAAC;QACzB,sBAAiB,GAAsB,IAAI,iBAAiB,EAAE,CAAC;QAC/D,mBAAc,GAAsB,IAAI,iBAAiB,EAAE,CAAC;QAC5D,4BAAuB,GAAG,CAAC,CAAC;QAC5B,wBAAmB,GAAsB,IAAI,iBAAiB,EAAE,CAAC;QACjE,yBAAoB,GAAsB,IAAI,iBAAiB,EAAE,CAAC;QAClE,6BAAwB,GAAG,CAAC,CAAC;QAC7B,4BAAuB,GAAG,CAAC,CAAC;IAC9B,CAAC;CAAA;AAED,MAAM,iBAAiB;IAAvB;QACE,aAAQ,GAAuC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnE,gBAAW,GAAG,CAAC,CAAC;QAChB,4BAAuB,GAAG,CAAC,CAAC;IAa9B,CAAC;IAXC,QAAQ,CAAC,OAAe,EAAE,aAA4B;QACpD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACxC,IAAI,QAAQ,EAAE;YACZ,OAAO,QAAQ,CAAC;SACjB;QACD,MAAM,KAAK,GAAG,IAAI,iBAAiB,EAAE,CAAC;QACtC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC;QAE/B,aAAa,CAAC,KAAK,IAAI,uBAAuB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QAC5D,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AAED,MAAM,WAAW;IAAjB;QACE,iBAAY,GAAkC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IA0BpE,CAAC;IAxBC,YAAY,CACV,SAAiB,EACjB,UAAkB,EAClB,aAA4B;QAE5B,MAAM,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;QAC9C,IAAI,QAAQ,EAAE;YACZ,OAAO,QAAQ,CAAC;SACjB;QAED,aAAa,CAAC,KAAK;YACjB,uBAAuB,CAAC,SAAS,CAAC;gBAClC,uBAAuB,CAAC,UAAU,CAAC;gBACnC,EAAE,CAAC;QACL,MAAM,SAAS,GAAG,IAAI,YAAY,CAAC,UAAU,CAAC,CAAC;QAC/C,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC;QACzC,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,uBAAuB;QACrB,KAAK,MAAM,SAAS,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE;YACxD,SAAS,CAAC,uBAAuB,EAAE,CAAC;SACrC;IACH,CAAC;CACF;AAED,MAAM,YAAY;IAUhB,YAAqB,UAAkB;QAAlB,eAAU,GAAV,UAAU,CAAQ;QATvC,gBAAW,GAAG,CAAC,CAAC;QAChB,2BAAsB,GAAG,CAAC,CAAC;QAI3B,4BAAuB,GAAG,CAAC,CAAC;QAC5B,4BAAuB,GAAG,CAAC,CAAC;QAC5B,iBAAY,GAAsB,IAAI,iBAAiB,EAAE,CAAC;IAEhB,CAAC;IAE3C,uBAAuB;QAErB,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;IAC1E,CAAC;CACF;AAED,SAAS,uBAAuB,CAAC,CAAS;IAIxC,OAAO,CAAC,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AAClC,CAAC"}∏/dist/cjs/cachePolicy.js≈G"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newCachePolicy = void 0;
function newCachePolicy() {
    return {
        maxAge: undefined,
        scope: undefined,
        restrict(hint) {
            if (hint.maxAge !== undefined &&
                (this.maxAge === undefined || hint.maxAge < this.maxAge)) {
                this.maxAge = hint.maxAge;
            }
            if (hint.scope !== undefined && this.scope !== 'PRIVATE') {
                this.scope = hint.scope;
            }
        },
        replace(hint) {
            if (hint.maxAge !== undefined) {
                this.maxAge = hint.maxAge;
            }
            if (hint.scope !== undefined) {
                this.scope = hint.scope;
            }
        },
        policyIfCacheable() {
            if (this.maxAge === undefined || this.maxAge === 0) {
                return null;
            }
            return { maxAge: this.maxAge, scope: this.scope ?? 'PUBLIC' };
        },
    };
}
exports.newCachePolicy = newCachePolicy;
//# sourceMappingURL=cachePolicy.js.mapπ/dist/cjs/errors/index.js≈="use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrapResolverError = exports.ApolloServerValidationErrorCode = exports.ApolloServerErrorCode = void 0;
const graphql_1 = require("graphql");
var ApolloServerErrorCode;
(function (ApolloServerErrorCode) {
    ApolloServerErrorCode["INTERNAL_SERVER_ERROR"] = "INTERNAL_SERVER_ERROR";
    ApolloServerErrorCode["GRAPHQL_PARSE_FAILED"] = "GRAPHQL_PARSE_FAILED";
    ApolloServerErrorCode["GRAPHQL_VALIDATION_FAILED"] = "GRAPHQL_VALIDATION_FAILED";
    ApolloServerErrorCode["PERSISTED_QUERY_NOT_FOUND"] = "PERSISTED_QUERY_NOT_FOUND";
    ApolloServerErrorCode["PERSISTED_QUERY_NOT_SUPPORTED"] = "PERSISTED_QUERY_NOT_SUPPORTED";
    ApolloServerErrorCode["BAD_USER_INPUT"] = "BAD_USER_INPUT";
    ApolloServerErrorCode["OPERATION_RESOLUTION_FAILURE"] = "OPERATION_RESOLUTION_FAILURE";
    ApolloServerErrorCode["BAD_REQUEST"] = "BAD_REQUEST";
})(ApolloServerErrorCode = exports.ApolloServerErrorCode || (exports.ApolloServerErrorCode = {}));
var ApolloServerValidationErrorCode;
(function (ApolloServerValidationErrorCode) {
    ApolloServerValidationErrorCode["INTROSPECTION_DISABLED"] = "INTROSPECTION_DISABLED";
})(ApolloServerValidationErrorCode = exports.ApolloServerValidationErrorCode || (exports.ApolloServerValidationErrorCode = {}));
function unwrapResolverError(error) {
    if (error instanceof graphql_1.GraphQLError && error.path && error.originalError) {
        return error.originalError;
    }
    return error;
}
exports.unwrapResolverError = unwrapResolverError;
//# sourceMappingURL=index.js.mapŸ(/src/plugin/landingPage/default/index.ts≈‡import type {
  ApolloServerPlugin,
  BaseContext,
} from '../../../externalTypes/index.js';
import type { ImplicitlyInstallablePlugin } from '../../../ApolloServer.js';
import type {
  ApolloServerPluginLandingPageLocalDefaultOptions,
  ApolloServerPluginLandingPageProductionDefaultOptions,
  LandingPageConfig,
} from './types.js';
import {
  getEmbeddedExplorerHTML,
  getEmbeddedSandboxHTML,
} from './getEmbeddedHTML.js';

export type {
  ApolloServerPluginLandingPageLocalDefaultOptions,
  ApolloServerPluginLandingPageProductionDefaultOptions,
};

export function ApolloServerPluginLandingPageLocalDefault(
  options: ApolloServerPluginLandingPageLocalDefaultOptions = {},
): ApolloServerPlugin {
  const { version, __internal_apolloStudioEnv__, ...rest } = {
    // we default to Sandbox unless embed is specified as false
    embed: true as const,
    ...options,
  };
  return ApolloServerPluginLandingPageDefault(version, {
    isProd: false,
    apolloStudioEnv: __internal_apolloStudioEnv__,
    ...rest,
  });
}

export function ApolloServerPluginLandingPageProductionDefault(
  options: ApolloServerPluginLandingPageProductionDefaultOptions = {},
): ApolloServerPlugin {
  const { version, __internal_apolloStudioEnv__, ...rest } = options;
  return ApolloServerPluginLandingPageDefault(version, {
    isProd: true,
    apolloStudioEnv: __internal_apolloStudioEnv__,
    ...rest,
  });
}

// A triple encoding! Wow! First we use JSON.stringify to turn our object into a
// string. Then we encodeURIComponent so we don't have to stress about what
// would happen if the config contained `</script>`. Finally, we JSON.stringify
// it again, which in practice just wraps it in a pair of double quotes (since
// there shouldn't be any backslashes left after encodeURIComponent). The
// consumer of this needs to decodeURIComponent and then JSON.parse; there's
// only one JSON.parse because the outermost JSON string is parsed by the JS
// parser itself.
function encodeConfig(config: LandingPageConfig): string {
  return JSON.stringify(encodeURIComponent(JSON.stringify(config)));
}

const getNonEmbeddedLandingPageHTML = (
  version: string,
  config: LandingPageConfig,
) => {
  const encodedConfig = encodeConfig(config);

  return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script>window.landingPage = ${encodedConfig};</script>
<script src="https://apollo-server-landing-page.cdn.apollographql.com/${version}/static/js/main.js"></script>`;
};

// Helper for the two actual plugin functions.
function ApolloServerPluginLandingPageDefault<TContext extends BaseContext>(
  maybeVersion: string | undefined,
  config: LandingPageConfig & {
    isProd: boolean;
    apolloStudioEnv: 'staging' | 'prod' | undefined;
  },
): ImplicitlyInstallablePlugin<TContext> {
  const version = maybeVersion ?? '_latest';

  return {
    __internal_installed_implicitly__: false,
    async serverWillStart() {
      return {
        async renderLandingPage() {
          const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body style="margin: 0; overflow-x: hidden; overflow-y: hidden">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style>
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${
      config.embed
        ? 'graphRef' in config && config.graphRef
          ? getEmbeddedExplorerHTML(version, config)
          : getEmbeddedSandboxHTML(version, config)
        : getNonEmbeddedLandingPageHTML(version, config)
    }
    </div>
  </body>
</html>
          `;
          return { html };
        },
      };
    },
  };
}
ø/dist/esm/internalPlugin.js.map≈{"version":3,"file":"internalPlugin.js","sourceRoot":"","sources":["../../src/internalPlugin.ts"],"names":[],"mappings":"AAqBA,MAAM,UAAU,cAAc,CAC5B,CAAuC;IAEvC,OAAO,CAAC,CAAC;AACX,CAAC;AASD,MAAM,UAAU,gBAAgB,CAC9B,MAAoC;IAIpC,OAAO,wBAAwB,IAAI,MAAM,CAAC;AAC5C,CAAC"}Ÿ(/dist/esm/plugin/traceTreeBuilder.js.map≈{"version":3,"file":"traceTreeBuilder.js","sourceRoot":"","sources":["../../../src/plugin/traceTreeBuilder.ts"],"names":[],"mappings":"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"}Ÿ7/dist/esm/plugin/usageReporting/iterateOverTrace.js.map≈	ª{"version":3,"file":"iterateOverTrace.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/iterateOverTrace.ts"],"names":[],"mappings":"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"}Ÿ&/dist/cjs/determineApolloConfig.js.map≈ƒ{"version":3,"file":"determineApolloConfig.js","sourceRoot":"","sources":["../../src/determineApolloConfig.ts"],"names":[],"mappings":";;;AAAA,+DAAsD;AAKtD,SAAgB,qBAAqB,CACnC,KAAoC;IAEpC,MAAM,YAAY,GAAiB,EAAE,CAAC;IAEtC,MAAM,EACJ,UAAU,EACV,gBAAgB,EAChB,eAAe,EACf,oBAAoB,GACrB,GAAG,OAAO,CAAC,GAAG,CAAC;IAGhB,IAAI,KAAK,EAAE,GAAG,EAAE;QACd,YAAY,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC;KAC9B;SAAM,IAAI,UAAU,EAAE;QACrB,YAAY,CAAC,GAAG,GAAG,UAAU,CAAC;KAC/B;IAGD,IAAI,YAAY,CAAC,GAAG,EAAE;QACpB,YAAY,CAAC,OAAO,GAAG,IAAA,6BAAU,EAAC,QAAQ,CAAC;aACxC,MAAM,CAAC,YAAY,CAAC,GAAG,CAAC;aACxB,MAAM,CAAC,KAAK,CAAC,CAAC;KAClB;IAGD,IAAI,KAAK,EAAE,QAAQ,EAAE;QACnB,YAAY,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC;KACxC;SAAM,IAAI,gBAAgB,EAAE;QAC3B,YAAY,CAAC,QAAQ,GAAG,gBAAgB,CAAC;KAC1C;IAGD,MAAM,OAAO,GAAG,KAAK,EAAE,OAAO,IAAI,eAAe,CAAC;IAClD,MAAM,YAAY,GAAG,KAAK,EAAE,YAAY,IAAI,oBAAoB,CAAC;IAEjE,IAAI,YAAY,CAAC,QAAQ,EAAE;QACzB,IAAI,OAAO,EAAE;YACX,MAAM,IAAI,KAAK,CACb,yDAAyD;gBACvD,4EAA4E,CAC/E,CAAC;SACH;QACD,IAAI,YAAY,EAAE;YAChB,MAAM,IAAI,KAAK,CACb,8DAA8D;gBAC5D,iFAAiF,CACpF,CAAC;SACH;KACF;SAAM,IAAI,OAAO,EAAE;QAKlB,YAAY,CAAC,QAAQ,GAAG,YAAY;YAClC,CAAC,CAAC,GAAG,OAAO,IAAI,YAAY,EAAE;YAC9B,CAAC,CAAC,OAAO,CAAC;KACb;IAED,OAAO,YAAY,CAAC;AACtB,CAAC;AA7DD,sDA6DC"}Ÿ /src/plugin/schemaIsFederated.ts≈[import { GraphQLSchema, isObjectType, isScalarType } from 'graphql';

// Returns true if it appears that the schema was returned from
// @apollo/federation's buildFederatedSchema. This strategy avoids depending
// explicitly on @apollo/federation or relying on something that might not
// survive transformations like monkey-patching a boolean field onto the
// schema.
//
// This is used for two things:
// 1) Determining whether traces should be added to responses if requested
//    with an HTTP header. If you want to include these traces even for
//    non-federated schemas (when requested via header) you can use
//    ApolloServerPluginInlineTrace yourself; if you want to never
//    include these traces even for federated schemas you can use
//    ApolloServerPluginInlineTraceDisabled.
// 2) Determining whether schema-reporting should be allowed; federated
//    services shouldn't be reporting schemas, and we accordingly throw if
//    it's attempted.
export function schemaIsFederated(schema: GraphQLSchema): boolean {
  const serviceType = schema.getType('_Service');
  if (!isObjectType(serviceType)) {
    return false;
  }
  const sdlField = serviceType.getFields().sdl;
  if (!sdlField) {
    return false;
  }
  const sdlFieldType = sdlField.type;
  if (!isScalarType(sdlFieldType)) {
    return false;
  }
  return sdlFieldType.name == 'String';
}
Ω/dist/cjs/httpBatching.js.map≈{"version":3,"file":"httpBatching.js","sourceRoot":"","sources":["../../src/httpBatching.ts"],"names":[],"mappings":";;;AAUA,uDAAqE;AACrE,uEAA4D;AAE5D,KAAK,UAAU,mBAAmB,CAA+B,EAC/D,MAAM,EACN,YAAY,EACZ,IAAI,EACJ,YAAY,EACZ,iBAAiB,EACjB,SAAS,GAQV;IACC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACrB,MAAM,IAAI,yCAAe,CAAC,iCAAiC,CAAC,CAAC;KAC9D;IAQD,MAAM,6BAA6B,GAAG,IAAA,oCAAkB,GAAE,CAAC;IAC3D,MAAM,cAAc,GAAG,MAAM,OAAO,CAAC,GAAG,CACtC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,SAAkB,EAAE,EAAE;QACpC,MAAM,aAAa,GAAuB;YACxC,GAAG,YAAY;YACf,IAAI,EAAE,SAAS;SAChB,CAAC;QAEF,MAAM,QAAQ,GAAG,MAAM,IAAA,8BAAY,EAAC;YAClC,MAAM;YACN,WAAW,EAAE,aAAa;YAC1B,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,6BAA6B;SAC9B,CAAC,CAAC;QAEH,IAAI,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,EAAE;YACpC,MAAM,KAAK,CACT,4DAA4D,CAC7D,CAAC;SACH;QACD,OAAO,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC;IAC9B,CAAC,CAAC,CACH,CAAC;IACF,OAAO;QACL,GAAG,6BAA6B;QAChC,IAAI,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,IAAI,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE;KACpE,CAAC;AACJ,CAAC;AAEM,KAAK,UAAU,8BAA8B,CAGlD,MAA8B,EAC9B,kBAAsC,EACtC,YAAsB,EACtB,iBAAoC,EACpC,SAA0C;IAE1C,IACE,CAAC,CACC,kBAAkB,CAAC,MAAM,KAAK,MAAM;QACpC,KAAK,CAAC,OAAO,CAAC,kBAAkB,CAAC,IAAI,CAAC,CACvC,EACD;QACA,OAAO,MAAM,IAAA,8BAAY,EAAC;YACxB,MAAM;YACN,WAAW,EAAE,kBAAkB;YAC/B,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,6BAA6B,EAAE,IAAI;SACpC,CAAC,CAAC;KACJ;IACD,IAAI,SAAS,CAAC,wBAAwB,EAAE;QACtC,OAAO,MAAM,mBAAmB,CAAC;YAC/B,MAAM;YACN,YAAY,EAAE,kBAAkB;YAChC,IAAI,EAAE,kBAAkB,CAAC,IAAiB;YAC1C,YAAY;YACZ,iBAAiB;YACjB,SAAS;SACV,CAAC,CAAC;KACJ;IACD,MAAM,IAAI,yCAAe,CAAC,8BAA8B,CAAC,CAAC;AAC5D,CAAC;AAnCD,wEAmCC"}ø/dist/esm/ApolloServer.d.ts.map≈∆{"version":3,"file":"ApolloServer.d.ts","sourceRoot":"","sources":["../../src/ApolloServer.ts"],"names":[],"mappings":"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"}Ÿ"/dist/cjs/plugin/disabled/index.js≈Ω"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApolloServerPluginUsageReportingDisabled = exports.ApolloServerPluginSchemaReportingDisabled = exports.ApolloServerPluginLandingPageDisabled = exports.ApolloServerPluginInlineTraceDisabled = exports.ApolloServerPluginCacheControlDisabled = void 0;
function disabledPlugin(id) {
    const plugin = {
        __internal_plugin_id__: id,
        __is_disabled_plugin__: true,
    };
    return plugin;
}
function ApolloServerPluginCacheControlDisabled() {
    return disabledPlugin('CacheControl');
}
exports.ApolloServerPluginCacheControlDisabled = ApolloServerPluginCacheControlDisabled;
function ApolloServerPluginInlineTraceDisabled() {
    return disabledPlugin('InlineTrace');
}
exports.ApolloServerPluginInlineTraceDisabled = ApolloServerPluginInlineTraceDisabled;
function ApolloServerPluginLandingPageDisabled() {
    return disabledPlugin('LandingPageDisabled');
}
exports.ApolloServerPluginLandingPageDisabled = ApolloServerPluginLandingPageDisabled;
function ApolloServerPluginSchemaReportingDisabled() {
    return disabledPlugin('SchemaReporting');
}
exports.ApolloServerPluginSchemaReportingDisabled = ApolloServerPluginSchemaReportingDisabled;
function ApolloServerPluginUsageReportingDisabled() {
    return disabledPlugin('UsageReporting');
}
exports.ApolloServerPluginUsageReportingDisabled = ApolloServerPluginUsageReportingDisabled;
//# sourceMappingURL=index.js.mapŸ*/dist/cjs/plugin/usageReporting/options.jsƒp"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=options.js.mapŸ&/dist/cjs/externalTypes/context.js.mapƒ~{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../src/externalTypes/context.ts"],"names":[],"mappings":""}ª/dist/esm/errorNormalize.js≈	‚import { GraphQLError, } from 'graphql';
import { ApolloServerErrorCode } from './errors/index.js';
import { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';
import { HeaderMap } from './utils/HeaderMap.js';
export function normalizeAndFormatErrors(errors, options = {}) {
    const formatError = options.formatError ?? ((error) => error);
    const httpFromErrors = newHTTPGraphQLHead();
    return {
        httpFromErrors,
        formattedErrors: errors.map((error) => {
            try {
                return formatError(enrichError(error), error);
            }
            catch (formattingError) {
                if (options.includeStacktraceInErrorResponses) {
                    return enrichError(formattingError);
                }
                else {
                    return {
                        message: 'Internal server error',
                        extensions: { code: ApolloServerErrorCode.INTERNAL_SERVER_ERROR },
                    };
                }
            }
        }),
    };
    function enrichError(maybeError) {
        const graphqlError = ensureGraphQLError(maybeError);
        const extensions = {
            ...graphqlError.extensions,
            code: graphqlError.extensions.code ??
                ApolloServerErrorCode.INTERNAL_SERVER_ERROR,
        };
        if (isPartialHTTPGraphQLHead(extensions.http)) {
            mergeHTTPGraphQLHead(httpFromErrors, {
                headers: new HeaderMap(),
                ...extensions.http,
            });
            delete extensions.http;
        }
        if (options.includeStacktraceInErrorResponses) {
            extensions.stacktrace = graphqlError.stack?.split('\n');
        }
        return { ...graphqlError.toJSON(), extensions };
    }
}
export function ensureError(maybeError) {
    return maybeError instanceof Error
        ? maybeError
        : new GraphQLError('Unexpected error value: ' + String(maybeError));
}
export function ensureGraphQLError(maybeError, messagePrefixIfNotGraphQLError = '') {
    const error = ensureError(maybeError);
    return error instanceof GraphQLError
        ? error
        : new GraphQLError(messagePrefixIfNotGraphQLError + error.message, {
            originalError: error,
        });
}
function isPartialHTTPGraphQLHead(x) {
    return (!!x &&
        typeof x === 'object' &&
        (!('status' in x) || typeof x.status === 'number') &&
        (!('headers' in x) || x.headers instanceof Map));
}
//# sourceMappingURL=errorNormalize.js.mapŸ'/dist/esm/plugin/inlineTrace/index.d.ts≈µimport type { SendErrorsOptions } from '../usageReporting/index.js';
import type { ApolloServerPlugin } from '../../externalTypes/index.js';
export interface ApolloServerPluginInlineTraceOptions {
    includeErrors?: SendErrorsOptions;
    __onlyIfSchemaIsFederated?: boolean;
}
export declare function ApolloServerPluginInlineTrace(options?: ApolloServerPluginInlineTraceOptions): ApolloServerPlugin;
//# sourceMappingURL=index.d.ts.mapŸ,/dist/esm/plugin/cacheControl/index.d.ts.map≈ƒ{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/plugin/cacheControl/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,kBAAkB,EAAE,MAAM,8BAA8B,CAAC;AAcvE,OAAO,KAAK,EACV,SAAS,EAGV,MAAM,6BAA6B,CAAC;AAYrC,MAAM,WAAW,qCAAqC;IASpD,aAAa,CAAC,EAAE,MAAM,CAAC;IAUvB,oBAAoB,CAAC,EAAE,OAAO,GAAG,cAAc,CAAC;IAEhD,qBAAqB,CAAC,EAAE,GAAG,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;CAChD;AAED,wBAAgB,8BAA8B,CAC5C,OAAO,GAAE,qCAA2D,GACnE,kBAAkB,CAyRpB"}Ÿ(/dist/esm/incrementalDeliveryPolyfill.js≈import { execute } from 'graphql';
let graphqlExperimentalExecuteIncrementally = undefined;
async function tryToLoadGraphQL17() {
    if (graphqlExperimentalExecuteIncrementally !== undefined) {
        return;
    }
    const graphql = await import('graphql');
    if ('experimentalExecuteIncrementally' in graphql) {
        graphqlExperimentalExecuteIncrementally = graphql
            .experimentalExecuteIncrementally;
    }
    else {
        graphqlExperimentalExecuteIncrementally = null;
    }
}
export async function executeIncrementally(args) {
    await tryToLoadGraphQL17();
    if (graphqlExperimentalExecuteIncrementally) {
        return graphqlExperimentalExecuteIncrementally(args);
    }
    return execute(args);
}
//# sourceMappingURL=incrementalDeliveryPolyfill.js.mapŸ(/dist/esm/plugin/cacheControl/index.d.ts≈Êimport type { ApolloServerPlugin } from '../../externalTypes/index.js';
import type { CacheHint } from '@apollo/cache-control-types';
export interface ApolloServerPluginCacheControlOptions {
    defaultMaxAge?: number;
    calculateHttpHeaders?: boolean | 'if-cacheable';
    __testing__cacheHints?: Map<string, CacheHint>;
}
export declare function ApolloServerPluginCacheControl(options?: ApolloServerPluginCacheControlOptions): ApolloServerPlugin;
//# sourceMappingURL=index.d.ts.mapŸ(/src/plugin/drainHttpServer/stoppable.ts≈ // This file is adapted from the stoppable npm package:
// https://github.com/hunterloftis/stoppable
//
// We've ported it to TypeScript and simplified the API and fixed some bugs.
// Here's the license of the original code:
//
// The MIT License (MIT)
//
// Copyright (c) 2017 Hunter Loftis <hunter@hunterloftis.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import type http from 'http';
import https from 'https';
import type { Socket } from 'net';

export class Stopper {
  private requestCountPerSocket = new Map<Socket, number>();
  private stopped = false;

  constructor(private server: http.Server | https.Server) {
    // Keep a number in requestCountPerSocket for each current connection.
    server.on(
      server instanceof https.Server ? 'secureConnection' : 'connection',
      (socket: Socket) => {
        this.requestCountPerSocket.set(socket, 0);
        socket.once('close', () => this.requestCountPerSocket.delete(socket));
      },
    );

    // Track how many HTTP requests are active on the socket.
    server.on(
      'request',
      (req: http.IncomingMessage, res: http.ServerResponse) => {
        this.requestCountPerSocket.set(
          req.socket,
          (this.requestCountPerSocket.get(req.socket) ?? 0) + 1,
        );
        res.once('finish', () => {
          const pending = (this.requestCountPerSocket.get(req.socket) ?? 0) - 1;
          this.requestCountPerSocket.set(req.socket, pending);
          // If we're in the process of stopping and it's gone idle, close the
          // socket.
          if (this.stopped && pending === 0) {
            req.socket.end();
          }
        });
      },
    );
  }

  async stop(stopGracePeriodMillis = Infinity): Promise<boolean> {
    let gracefully = true;

    // In the off-chance that we are calling `stop` directly from within the
    // HTTP server's request handler (and so we haven't gotten to the
    // `connection` event yet), wait a moment so that `connection` can be called
    // and this request can actually count.
    await new Promise<void>((resolve) => setImmediate(resolve));
    this.stopped = true;

    let timeout: NodeJS.Timeout | null = null;
    // Soon, hard-destroy everything.
    if (stopGracePeriodMillis < Infinity) {
      timeout = setTimeout(() => {
        gracefully = false;
        this.requestCountPerSocket.forEach((_, socket) => socket.end());
        // (FYI, when importing from upstream, not sure why we need setImmediate
        // here.)
        setImmediate(() => {
          this.requestCountPerSocket.forEach((_, socket) => socket.destroy());
        });
      }, stopGracePeriodMillis);
    }

    // Close the server and create a Promise that resolves when all connections
    // are closed. Note that we ignore any error from `close` here.
    const closePromise = new Promise<void>((resolve) =>
      this.server.close(() => {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        resolve();
      }),
    );

    // Immediately close any idle sockets.
    this.requestCountPerSocket.forEach((requests, socket) => {
      if (requests === 0) socket.end();
    });

    // Wait for all connections to be closed.
    await closePromise;

    return gracefully;
  }
}
Ÿ*/src/plugin/usageReporting/traceDetails.ts≈}import { Trace } from '@apollo/usage-reporting-protobuf';
import type { VariableValueOptions } from './options.js';

// Creates trace details from request variables, given a specification for modifying
// values of private or sensitive variables.
// The details will include all variable names and their (possibly hidden or modified) values.
// If sendVariableValues is {all: bool}, {none: bool} or {exceptNames: Array}, the option will act similarly to
// to the to-be-deprecated options.privateVariables, except that the redacted variable
// names will still be visible in the UI even if the values are hidden.
// If sendVariableValues is null or undefined, we default to the {none: true} case.
export function makeTraceDetails(
  variables: Record<string, any>,
  sendVariableValues?: VariableValueOptions,
  operationString?: string,
): Trace.Details {
  const details = new Trace.Details();
  const variablesToRecord = (() => {
    if (sendVariableValues && 'transform' in sendVariableValues) {
      const originalKeys = Object.keys(variables);
      try {
        // Custom function to allow user to specify what variablesJson will look like
        const modifiedVariables = sendVariableValues.transform({
          variables: variables,
          operationString: operationString,
        });
        return cleanModifiedVariables(originalKeys, modifiedVariables);
      } catch (e) {
        // If the custom function provided by the user throws an exception,
        // change all the variable values to an appropriate error message.
        return handleVariableValueTransformError(originalKeys);
      }
    } else {
      return variables;
    }
  })();

  // Note: we explicitly do *not* include the details.rawQuery field. The
  // Studio web app currently does nothing with this other than store it in
  // the database and offer it up via its GraphQL API, and sending it means
  // that using calculateSignature to hide sensitive data in the query
  // string is ineffective.
  Object.keys(variablesToRecord).forEach((name) => {
    if (
      !sendVariableValues ||
      ('none' in sendVariableValues && sendVariableValues.none) ||
      ('all' in sendVariableValues && !sendVariableValues.all) ||
      ('exceptNames' in sendVariableValues &&
        // We assume that most users will have only a few variables values to hide,
        // or will just set {none: true}; we can change this
        // linear-time operation if it causes real performance issues.
        sendVariableValues.exceptNames.includes(name)) ||
      ('onlyNames' in sendVariableValues &&
        !sendVariableValues.onlyNames.includes(name))
    ) {
      // Special case for private variables. Note that this is a different
      // representation from a variable containing the empty string, as that
      // will be sent as '""'.
      details.variablesJson![name] = '';
    } else {
      try {
        details.variablesJson![name] =
          typeof variablesToRecord[name] === 'undefined'
            ? ''
            : JSON.stringify(variablesToRecord[name]);
      } catch (e) {
        details.variablesJson![name] = JSON.stringify(
          '[Unable to convert value to JSON]',
        );
      }
    }
  });
  return details;
}

function handleVariableValueTransformError(
  variableNames: string[],
): Record<string, any> {
  const modifiedVariables = Object.create(null);
  variableNames.forEach((name) => {
    modifiedVariables[name] = '[PREDICATE_FUNCTION_ERROR]';
  });
  return modifiedVariables;
}

// Helper for makeTraceDetails() to enforce that the keys of a modified 'variables'
// matches that of the original 'variables'
function cleanModifiedVariables(
  originalKeys: Array<string>,
  modifiedVariables: Record<string, any>,
): Record<string, any> {
  const cleanedVariables: Record<string, any> = Object.create(null);
  originalKeys.forEach((name) => {
    cleanedVariables[name] = modifiedVariables[name];
  });
  return cleanedVariables;
}
Ÿ//dist/cjs/plugin/usageReporting/traceDetails.js≈	Á"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeTraceDetails = void 0;
const usage_reporting_protobuf_1 = require("@apollo/usage-reporting-protobuf");
function makeTraceDetails(variables, sendVariableValues, operationString) {
    const details = new usage_reporting_protobuf_1.Trace.Details();
    const variablesToRecord = (() => {
        if (sendVariableValues && 'transform' in sendVariableValues) {
            const originalKeys = Object.keys(variables);
            try {
                const modifiedVariables = sendVariableValues.transform({
                    variables: variables,
                    operationString: operationString,
                });
                return cleanModifiedVariables(originalKeys, modifiedVariables);
            }
            catch (e) {
                return handleVariableValueTransformError(originalKeys);
            }
        }
        else {
            return variables;
        }
    })();
    Object.keys(variablesToRecord).forEach((name) => {
        if (!sendVariableValues ||
            ('none' in sendVariableValues && sendVariableValues.none) ||
            ('all' in sendVariableValues && !sendVariableValues.all) ||
            ('exceptNames' in sendVariableValues &&
                sendVariableValues.exceptNames.includes(name)) ||
            ('onlyNames' in sendVariableValues &&
                !sendVariableValues.onlyNames.includes(name))) {
            details.variablesJson[name] = '';
        }
        else {
            try {
                details.variablesJson[name] =
                    typeof variablesToRecord[name] === 'undefined'
                        ? ''
                        : JSON.stringify(variablesToRecord[name]);
            }
            catch (e) {
                details.variablesJson[name] = JSON.stringify('[Unable to convert value to JSON]');
            }
        }
    });
    return details;
}
exports.makeTraceDetails = makeTraceDetails;
function handleVariableValueTransformError(variableNames) {
    const modifiedVariables = Object.create(null);
    variableNames.forEach((name) => {
        modifiedVariables[name] = '[PREDICATE_FUNCTION_ERROR]';
    });
    return modifiedVariables;
}
function cleanModifiedVariables(originalKeys, modifiedVariables) {
    const cleanedVariables = Object.create(null);
    originalKeys.forEach((name) => {
        cleanedVariables[name] = modifiedVariables[name];
    });
    return cleanedVariables;
}
//# sourceMappingURL=traceDetails.js.mapŸ"/dist/esm/utils/isDefined.d.ts.mapƒ‚{"version":3,"file":"isDefined.d.ts","sourceRoot":"","sources":["../../../src/utils/isDefined.ts"],"names":[],"mappings":"AAAA,wBAAgB,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,SAAS,GAAG,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,CAEnE"}Ÿ"/dist/cjs/externalTypes/context.jsƒp"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=context.js.mapŸ!/dist/esm/internalPlugin.d.ts.map≈|{"version":3,"file":"internalPlugin.d.ts","sourceRoot":"","sources":["../../src/internalPlugin.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,WAAW,EAAE,kBAAkB,EAAE,MAAM,0BAA0B,CAAC;AAShF,MAAM,WAAW,0BAA0B,CAAC,QAAQ,SAAS,WAAW,CACtE,SAAQ,kBAAkB,CAAC,QAAQ,CAAC;IAGpC,sBAAsB,EAAE,gBAAgB,CAAC;IACzC,sBAAsB,EAAE,OAAO,CAAC;CACjC;AAMD,wBAAgB,cAAc,CAAC,QAAQ,SAAS,WAAW,EACzD,CAAC,EAAE,0BAA0B,CAAC,QAAQ,CAAC,GACtC,kBAAkB,CAAC,QAAQ,CAAC,CAE9B;AAED,oBAAY,gBAAgB,GACxB,cAAc,GACd,qBAAqB,GACrB,iBAAiB,GACjB,aAAa,GACb,gBAAgB,CAAC;AAErB,wBAAgB,gBAAgB,CAAC,QAAQ,SAAS,WAAW,EAC3D,MAAM,EAAE,kBAAkB,CAAC,QAAQ,CAAC,GACnC,MAAM,IAAI,0BAA0B,CAAC,QAAQ,CAAC,CAIhD"}Ÿ&/dist/cjs/externalTypes/constructor.jsƒt"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=constructor.js.map∂/express4/package.jsonƒ⁄{
  "name": "@apollo/server/express4",
  "type": "module",
  "main": "../dist/cjs/express4/index.js",
  "module": "../dist/esm/express4/index.js",
  "types": "../dist/esm/express4/index.d.ts",
  "sideEffects": false
}
ø/dist/esm/standalone/index.d.ts≈l/// <reference types="node" />
/// <reference types="node" />
import type { WithRequired } from '@apollo/utils.withrequired';
import { IncomingMessage, ServerResponse } from 'http';
import type { ListenOptions } from 'net';
import type { ApolloServer } from '../ApolloServer.js';
import type { BaseContext, ContextFunction } from '../externalTypes/index.js';
export interface StandaloneServerContextFunctionArgument {
    req: IncomingMessage;
    res: ServerResponse;
}
export interface StartStandaloneServerOptions<TContext extends BaseContext> {
    context?: ContextFunction<[
        StandaloneServerContextFunctionArgument
    ], TContext>;
}
export declare function startStandaloneServer(server: ApolloServer<BaseContext>, options?: StartStandaloneServerOptions<BaseContext> & {
    listen?: ListenOptions;
}): Promise<{
    url: string;
}>;
export declare function startStandaloneServer<TContext extends BaseContext>(server: ApolloServer<TContext>, options: WithRequired<StartStandaloneServerOptions<TContext>, 'context'> & {
    listen?: ListenOptions;
}): Promise<{
    url: string;
}>;
//# sourceMappingURL=index.d.ts.mapæ/dist/esm/utils/HeaderMap.d.tsƒ¸export declare class HeaderMap extends Map<string, string> {
    set(key: string, value: string): this;
    get(key: string): string | undefined;
    delete(key: string): boolean;
    has(key: string): boolean;
}
//# sourceMappingURL=HeaderMap.d.ts.mapŸ /dist/cjs/externalTypes/index.jsƒn"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.mapŸ$/dist/esm/externalTypes/index.js.mapƒz{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/externalTypes/index.ts"],"names":[],"mappings":""}Ÿ$/dist/esm/externalTypes/graphql.d.ts≈Èimport type { FormattedExecutionResult } from 'graphql';
import type { BaseContext } from './context.js';
import type { HTTPGraphQLHead, HTTPGraphQLRequest } from './http.js';
import type { WithRequired } from '@apollo/utils.withrequired';
import type { GraphQLExperimentalFormattedInitialIncrementalExecutionResult, GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult } from './incrementalDeliveryPolyfill.js';
export interface GraphQLRequest<TVariables extends VariableValues = VariableValues> {
    query?: string;
    operationName?: string;
    variables?: TVariables;
    extensions?: Record<string, any>;
    http?: HTTPGraphQLRequest;
}
export declare type VariableValues = {
    [name: string]: any;
};
export declare type GraphQLResponseBody<TData = Record<string, unknown>> = {
    kind: 'single';
    singleResult: FormattedExecutionResult<TData>;
} | {
    kind: 'incremental';
    initialResult: GraphQLExperimentalFormattedInitialIncrementalExecutionResult;
    subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>;
};
export declare type GraphQLInProgressResponse<TData = Record<string, unknown>> = {
    http: HTTPGraphQLHead;
    body?: GraphQLResponseBody<TData>;
};
export declare type GraphQLResponse<TData = Record<string, unknown>> = WithRequired<GraphQLInProgressResponse<TData>, 'body'>;
export interface ExecuteOperationOptions<TContext extends BaseContext> {
    contextValue?: TContext;
}
//# sourceMappingURL=graphql.d.ts.mapŸ3/dist/esm/utils/makeGatewayGraphQLRequestContext.js≈’export function makeGatewayGraphQLRequestContext(as4RequestContext, server, internals) {
    const request = {};
    if ('query' in as4RequestContext.request) {
        request.query = as4RequestContext.request.query;
    }
    if ('operationName' in as4RequestContext.request) {
        request.operationName = as4RequestContext.request.operationName;
    }
    if ('variables' in as4RequestContext.request) {
        request.variables = as4RequestContext.request.variables;
    }
    if ('extensions' in as4RequestContext.request) {
        request.extensions = as4RequestContext.request.extensions;
    }
    if (as4RequestContext.request.http) {
        const as4http = as4RequestContext.request.http;
        const needQuestion = as4http.search !== '' && !as4http.search.startsWith('?');
        request.http = {
            method: as4http.method,
            url: `https://unknown-url.invalid/${needQuestion ? '?' : ''}${as4http.search}`,
            headers: new FetcherHeadersForHeaderMap(as4http.headers),
        };
    }
    const response = {
        http: {
            headers: new FetcherHeadersForHeaderMap(as4RequestContext.response.http.headers),
            get status() {
                return as4RequestContext.response.http.status;
            },
            set status(newStatus) {
                as4RequestContext.response.http.status = newStatus;
            },
        },
    };
    return {
        request,
        response,
        logger: server.logger,
        schema: as4RequestContext.schema,
        schemaHash: 'schemaHash no longer exists in Apollo Server 4',
        context: as4RequestContext.contextValue,
        cache: server.cache,
        queryHash: as4RequestContext.queryHash,
        document: as4RequestContext.document,
        source: as4RequestContext.source,
        operationName: as4RequestContext.operationName,
        operation: as4RequestContext.operation,
        errors: as4RequestContext.errors,
        metrics: as4RequestContext.metrics,
        debug: internals.includeStacktraceInErrorResponses,
        overallCachePolicy: as4RequestContext.overallCachePolicy,
        requestIsBatched: as4RequestContext.requestIsBatched,
    };
}
class FetcherHeadersForHeaderMap {
    constructor(map) {
        this.map = map;
    }
    append(name, value) {
        if (this.map.has(name)) {
            this.map.set(name, this.map.get(name) + ', ' + value);
        }
        else {
            this.map.set(name, value);
        }
    }
    delete(name) {
        this.map.delete(name);
    }
    get(name) {
        return this.map.get(name) ?? null;
    }
    has(name) {
        return this.map.has(name);
    }
    set(name, value) {
        this.map.set(name, value);
    }
    entries() {
        return this.map.entries();
    }
    keys() {
        return this.map.keys();
    }
    values() {
        return this.map.values();
    }
    [Symbol.iterator]() {
        return this.map.entries();
    }
}
//# sourceMappingURL=makeGatewayGraphQLRequestContext.js.mapΩ/dist/esm/internalPlugin.d.ts≈Ùimport type { BaseContext, ApolloServerPlugin } from './externalTypes/index.js';
export interface InternalApolloServerPlugin<TContext extends BaseContext> extends ApolloServerPlugin<TContext> {
    __internal_plugin_id__: InternalPluginId;
    __is_disabled_plugin__: boolean;
}
export declare function internalPlugin<TContext extends BaseContext>(p: InternalApolloServerPlugin<TContext>): ApolloServerPlugin<TContext>;
export declare type InternalPluginId = 'CacheControl' | 'LandingPageDisabled' | 'SchemaReporting' | 'InlineTrace' | 'UsageReporting';
export declare function pluginIsInternal<TContext extends BaseContext>(plugin: ApolloServerPlugin<TContext>): plugin is InternalApolloServerPlugin<TContext>;
//# sourceMappingURL=internalPlugin.d.ts.mapŸ*/dist/cjs/externalTypes/requestPipeline.jsƒx"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=requestPipeline.js.mapŸ(/dist/esm/externalTypes/graphql.d.ts.map≈{"version":3,"file":"graphql.d.ts","sourceRoot":"","sources":["../../../src/externalTypes/graphql.ts"],"names":[],"mappings":"AAMA,OAAO,KAAK,EAAE,wBAAwB,EAAE,MAAM,SAAS,CAAC;AACxD,OAAO,KAAK,EAAE,WAAW,EAAE,MAAM,cAAc,CAAC;AAChD,OAAO,KAAK,EAAE,eAAe,EAAE,kBAAkB,EAAE,MAAM,WAAW,CAAC;AACrE,OAAO,KAAK,EAAE,YAAY,EAAE,MAAM,4BAA4B,CAAC;AAC/D,OAAO,KAAK,EACV,6DAA6D,EAC7D,gEAAgE,EACjE,MAAM,kCAAkC,CAAC;AAE1C,MAAM,WAAW,cAAc,CAC7B,UAAU,SAAS,cAAc,GAAG,cAAc;IAElD,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,aAAa,CAAC,EAAE,MAAM,CAAC;IACvB,SAAS,CAAC,EAAE,UAAU,CAAC;IACvB,UAAU,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IACjC,IAAI,CAAC,EAAE,kBAAkB,CAAC;CAC3B;AAED,oBAAY,cAAc,GAAG;IAAE,CAAC,IAAI,EAAE,MAAM,GAAG,GAAG,CAAA;CAAE,CAAC;AAOrD,oBAAY,mBAAmB,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,IAC3D;IACE,IAAI,EAAE,QAAQ,CAAC;IACf,YAAY,EAAE,wBAAwB,CAAC,KAAK,CAAC,CAAC;CAC/C,GACD;IACE,IAAI,EAAE,aAAa,CAAC;IACpB,aAAa,EAAE,6DAA6D,CAAC;IAC7E,iBAAiB,EAAE,aAAa,CAAC,gEAAgE,CAAC,CAAC;CACpG,CAAC;AAEN,oBAAY,yBAAyB,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,IAAI;IACvE,IAAI,EAAE,eAAe,CAAC;IACtB,IAAI,CAAC,EAAE,mBAAmB,CAAC,KAAK,CAAC,CAAC;CACnC,CAAC;AAEF,oBAAY,eAAe,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,IAAI,YAAY,CACzE,yBAAyB,CAAC,KAAK,CAAC,EAChC,MAAM,CACP,CAAC;AACF,MAAM,WAAW,uBAAuB,CAAC,QAAQ,SAAS,WAAW;IACnE,YAAY,CAAC,EAAE,QAAQ,CAAC;CACzB"}Ω/src/plugin/disabled/index.ts≈$// This file exports the "disabled" version of various plugins which are
// installed by default under certain circumstances. This lets users explicitly
// choose not to enable these plugins. Note that we explicitly keep these tiny
// plugins separate from the plugins they are enabling; this means that we don't
// have to load (say) the entire `plugin/usageReporting` entry point (which
// includes the whole generated protobuf library, etc) just in order to disable
// usage reporting.

import type { BaseContext, ApolloServerPlugin } from '../../index.js';
import type {
  InternalApolloServerPlugin,
  InternalPluginId,
} from '../../internalPlugin.js';

function disabledPlugin(id: InternalPluginId): ApolloServerPlugin {
  const plugin: InternalApolloServerPlugin<BaseContext> = {
    __internal_plugin_id__: id,
    __is_disabled_plugin__: true,
  };
  return plugin;
}

export function ApolloServerPluginCacheControlDisabled(): ApolloServerPlugin<BaseContext> {
  return disabledPlugin('CacheControl');
}

export function ApolloServerPluginInlineTraceDisabled(): ApolloServerPlugin<BaseContext> {
  return disabledPlugin('InlineTrace');
}

export function ApolloServerPluginLandingPageDisabled(): ApolloServerPlugin<BaseContext> {
  return disabledPlugin('LandingPageDisabled');
}

export function ApolloServerPluginSchemaReportingDisabled(): ApolloServerPlugin<BaseContext> {
  return disabledPlugin('SchemaReporting');
}

export function ApolloServerPluginUsageReportingDisabled(): ApolloServerPlugin<BaseContext> {
  return disabledPlugin('UsageReporting');
}
Ÿ /src/generated/packageVersion.tsƒ'export const packageVersion = "4.1.1";
Ÿ'/dist/cjs/utils/urlForHttpServer.js.map≈Ÿ{"version":3,"file":"urlForHttpServer.js","sourceRoot":"","sources":["../../../src/utils/urlForHttpServer.ts"],"names":[],"mappings":";;;AAEA,6BAA6B;AAE7B,SAAgB,gBAAgB,CAAC,UAAkB;IACjD,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,UAAU,CAAC,OAAO,EAAiB,CAAC;IAO9D,MAAM,QAAQ,GAAG,OAAO,KAAK,EAAE,IAAI,OAAO,KAAK,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,OAAO,CAAC;IAE5E,OAAO,IAAA,YAAM,EAAC;QACZ,QAAQ,EAAE,MAAM;QAChB,QAAQ;QACR,IAAI;QACJ,QAAQ,EAAE,GAAG;KACd,CAAC,CAAC;AACL,CAAC;AAhBD,4CAgBC"}ª/dist/esm/httpBatching.d.ts≈import type { BaseContext, HTTPGraphQLRequest, HTTPGraphQLResponse } from './externalTypes/index.js';
import type { ApolloServer, ApolloServerInternals, SchemaDerivedData } from './ApolloServer';
export declare function runPotentiallyBatchedHttpQuery<TContext extends BaseContext>(server: ApolloServer<TContext>, httpGraphQLRequest: HTTPGraphQLRequest, contextValue: TContext, schemaDerivedData: SchemaDerivedData, internals: ApolloServerInternals<TContext>): Promise<HTTPGraphQLResponse>;
//# sourceMappingURL=httpBatching.d.ts.map∫/dist/esm/preventCsrf.d.ts≈import type { HeaderMap } from './utils/HeaderMap.js';
export declare const recommendedCsrfPreventionRequestHeaders: string[];
export declare function preventCsrf(headers: HeaderMap, csrfPreventionRequestHeaders: string[]): void;
//# sourceMappingURL=preventCsrf.d.ts.mapŸ-/src/plugin/schemaReporting/schemaReporter.ts≈Üimport fetch from 'node-fetch';
import type { GraphQLRequest } from '../../externalTypes/index.js';
import type { Logger } from '@apollo/utils.logger';
import type {
  SchemaReport,
  SchemaReportMutationVariables,
  SchemaReportMutation,
  ReportSchemaResponse,
} from './generated/operations';
import type { Fetcher } from '@apollo/utils.fetcher';
import { packageVersion } from '../../generated/packageVersion.js';

export const schemaReportGql = `mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {
  reportSchema(report: $report, coreSchema: $coreSchema) {
    __typename
    ... on ReportSchemaError {
      message
      code
    }
    ... on ReportSchemaResponse {
      inSeconds
      withCoreSchema
    }
  }
}
`;

// This class is meant to be a thin shim around the gql mutations.
export class SchemaReporter {
  // These mirror the gql variables
  private readonly schemaReport: SchemaReport;
  private readonly coreSchema: string;
  private readonly endpointUrl: string;
  private readonly logger: Logger;
  private readonly initialReportingDelayInMs: number;
  private readonly fallbackReportingDelayInMs: number;
  private readonly fetcher: Fetcher;

  private isStopped: boolean;
  private pollTimer?: NodeJS.Timer;
  private readonly headers: Record<string, string>;

  constructor(options: {
    schemaReport: SchemaReport;
    coreSchema: string;
    apiKey: string;
    endpointUrl: string | undefined;
    logger: Logger;
    initialReportingDelayInMs: number;
    fallbackReportingDelayInMs: number;
    fetcher?: Fetcher;
  }) {
    this.headers = {
      'Content-Type': 'application/json',
      'x-api-key': options.apiKey,
      'apollographql-client-name': 'ApolloServerPluginSchemaReporting',
      'apollographql-client-version': packageVersion,
    };

    this.endpointUrl =
      options.endpointUrl ||
      'https://schema-reporting.api.apollographql.com/api/graphql';

    this.schemaReport = options.schemaReport;
    this.coreSchema = options.coreSchema;
    this.isStopped = false;
    this.logger = options.logger;
    this.initialReportingDelayInMs = options.initialReportingDelayInMs;
    this.fallbackReportingDelayInMs = options.fallbackReportingDelayInMs;
    this.fetcher = options.fetcher ?? fetch;
  }

  public stopped(): boolean {
    return this.isStopped;
  }

  public start() {
    this.pollTimer = setTimeout(
      () => this.sendOneReportAndScheduleNext(false),
      this.initialReportingDelayInMs,
    );
  }

  public stop() {
    this.isStopped = true;
    if (this.pollTimer) {
      clearTimeout(this.pollTimer);
      this.pollTimer = undefined;
    }
  }

  private async sendOneReportAndScheduleNext(sendNextWithCoreSchema: boolean) {
    this.pollTimer = undefined;

    // Bail out permanently
    if (this.stopped()) return;
    try {
      const result = await this.reportSchema(sendNextWithCoreSchema);
      if (!result) {
        return;
      }
      if (!this.stopped()) {
        this.pollTimer = setTimeout(
          () => this.sendOneReportAndScheduleNext(result.withCoreSchema),
          result.inSeconds * 1000,
        );
      }
      return;
    } catch (error) {
      // In the case of an error we want to continue looping
      // We can add hardcoded backoff in the future,
      // or on repeated failures stop responding reporting.
      this.logger.error(
        `Error reporting server info to Apollo during schema reporting: ${error}`,
      );
      if (!this.stopped()) {
        this.pollTimer = setTimeout(
          () => this.sendOneReportAndScheduleNext(false),
          this.fallbackReportingDelayInMs,
        );
      }
    }
  }

  public async reportSchema(
    withCoreSchema: boolean,
  ): Promise<ReportSchemaResponse | null> {
    const { data, errors } = await this.apolloQuery({
      report: this.schemaReport,
      coreSchema: withCoreSchema ? this.coreSchema : null,
    });

    if (errors) {
      throw new Error(errors.map((x: any) => x.message).join('\n'));
    }

    function msgForUnexpectedResponse(data: any): string {
      return [
        'Unexpected response shape from Apollo when',
        'reporting schema. If this continues, please reach',
        'out to support@apollographql.com.',
        'Received response:',
        JSON.stringify(data),
      ].join(' ');
    }

    if (!data || !data.reportSchema) {
      throw new Error(msgForUnexpectedResponse(data));
    }

    if (data.reportSchema.__typename === 'ReportSchemaResponse') {
      return data.reportSchema;
    } else if (data.reportSchema.__typename === 'ReportSchemaError') {
      this.logger.error(
        [
          'Received input validation error from Apollo:',
          data.reportSchema.message,
          'Stopping reporting. Please fix the input errors.',
        ].join(' '),
      );
      this.stop();
      return null;
    }
    throw new Error(msgForUnexpectedResponse(data));
  }

  private async apolloQuery(
    variables: SchemaReportMutationVariables,
  ): Promise<{ data?: SchemaReportMutation; errors?: any[] }> {
    const request: GraphQLRequest = {
      query: schemaReportGql,
      variables,
    };

    const httpResponse = await this.fetcher(this.endpointUrl, {
      method: 'POST',
      headers: this.headers,
      body: JSON.stringify(request),
    });

    if (!httpResponse.ok) {
      throw new Error(
        [
          `An unexpected HTTP status code (${httpResponse.status}) was`,
          'encountered during schema reporting.',
        ].join(' '),
      );
    }

    try {
      // JSON parsing failure due to malformed data is the likely failure case
      // here.  Any non-JSON response (e.g. HTML) is usually the suspect.
      return await httpResponse.json();
    } catch (error) {
      throw new Error(
        [
          "Couldn't report schema to Apollo.",
          'Parsing response as JSON failed.',
          'If this continues please reach out to support@apollographql.com',
          error,
        ].join(' '),
      );
    }
  }
}
Ÿ;/dist/esm/plugin/landingPage/default/getEmbeddedHTML.js.map≈€{"version":3,"file":"getEmbeddedHTML.js","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/getEmbeddedHTML.ts"],"names":[],"mappings":"AAcA,SAAS,sBAAsB,CAAC,MAAyB;IACvD,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC;SAC1B,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC;SACvB,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC;SACvB,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC;SACvB,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;AAC7B,CAAC;AAED,MAAM,CAAC,MAAM,uBAAuB,GAAG,CACrC,OAAe,EACf,MAAqE,EACrE,EAAE;IAqBF,MAAM,oCAAoC,GAAG;QAC3C,cAAc,EAAE,EAAE;QAClB,oBAAoB,EAAE,KAAK;QAC3B,GAAG,CAAC,OAAO,MAAM,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;KAC3D,CAAC;IACF,MAAM,sBAAsB,GAC1B;QACE,GAAG,MAAM;QACT,MAAM,EAAE,qBAAqB;QAC7B,YAAY,EAAE;YACZ,GAAG,MAAM;YACT,cAAc,EAAE;gBACd,GAAG,oCAAoC,CAAC,cAAc;aACvD;SACF;QACD,oBAAoB,EAClB,oCAAoC,CAAC,oBAAoB;KAC5D,CAAC;IAEJ,OAAO;;;;;;;;;;;;;;iEAcwD,OAAO;;;iCAGvC,sBAAsB,CACnD,sBAAsB,CACvB;;;;;;CAMF,CAAC;AACF,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,sBAAsB,GAAG,CACpC,OAAe,EACf,MAAyB,EACzB,EAAE;IACF,OAAO;;;;;;;;;;;;;;gEAcuD,OAAO;;;;;;sBAMjD,MAAM,CAAC,cAAc,IAAI,OAAO;oBAClC,sBAAsB,CAAC;QACrC,QAAQ,EAAE,MAAM,CAAC,QAAQ,IAAI,SAAS;QACtC,SAAS,EAAE,MAAM,CAAC,SAAS,IAAI,SAAS;QACxC,OAAO,EAAE,MAAM,CAAC,OAAO,IAAI,SAAS;KACrC,CAAC;;;CAGL,CAAC;AACF,CAAC,CAAC"}Ÿ7/dist/cjs/plugin/usageReporting/iterateOverTrace.js.map≈	≈{"version":3,"file":"iterateOverTrace.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/iterateOverTrace.ts"],"names":[],"mappings":"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"}Ÿ5/src/plugin/schemaReporting/generated/operations.d.ts∆ õãexport type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A blob (base64'ed in JSON & GraphQL) */
  Blob: any;
  GraphQLDocument: any;
  /** Long type */
  Long: any;
  /** Arbitrary JSON object */
  Object: any;
  /** A lowercase hexadecimal SHA-256 */
  SHA256: any;
  StringOrInt: any;
  /** ISO 8601, extended format with nanoseconds, Zulu (or '[+-]seconds' for times relative to now) */
  Timestamp: any;
  /** Always null */
  Void: any;
};

export type Account = {
  __typename?: 'Account';
  auditLogExports?: Maybe<Array<AuditLogExport>>;
  /** These are the roles that the account is able to use */
  availableRoles: Array<UserPermission>;
  /**
   * Get an URL to which an avatar image can be uploaded. Client uploads by sending a PUT request
   * with the image data to MediaUploadInfo.url. Client SHOULD set the "Content-Type" header to the
   * browser-inferred MIME type, and SHOULD set the "x-apollo-content-filename" header to the
   * filename, if such information is available. Client MUST set the "x-apollo-csrf-token" header to
   * MediaUploadInfo.csrfToken.
   */
  avatarUpload?: Maybe<AvatarUploadResult>;
  /**
   * Get an image URL for the account's avatar. Note that CORS is not enabled for these URLs. The size
   * argument is used for bandwidth reduction, and should be the size of the image as displayed in the
   * application. Apollo's media server will downscale larger images to at least the requested size,
   * but this will not happen for third-party media servers.
   */
  avatarUrl?: Maybe<Scalars['String']>;
  billingInfo?: Maybe<BillingInfo>;
  companyUrl?: Maybe<Scalars['String']>;
  currentBillingMonth?: Maybe<BillingMonth>;
  currentPlan: BillingPlan;
  currentSubscription?: Maybe<BillingSubscription>;
  experimentalFeatures: AccountExperimentalFeatures;
  expiredTrialSubscription?: Maybe<BillingSubscription>;
  graphIDAvailable: Scalars['Boolean'];
  hasBeenOnTrial: Scalars['Boolean'];
  id: Scalars['ID'];
  /**
   * Internal immutable identifier for the account. Only visible to Apollo admins (because it really
   * shouldn't be used in normal client apps).
   */
  internalID: Scalars['ID'];
  invitations?: Maybe<Array<AccountInvitation>>;
  invoices?: Maybe<Array<Invoice>>;
  isOnExpiredTrial: Scalars['Boolean'];
  isOnTrial: Scalars['Boolean'];
  legacyIsOnTrial: Scalars['Boolean'];
  memberships?: Maybe<Array<AccountMembership>>;
  name: Scalars['String'];
  provisionedAt?: Maybe<Scalars['Timestamp']>;
  recurlyEmail?: Maybe<Scalars['String']>;
  /** Returns a different registry related stats pertaining to this account. */
  registryStatsWindow?: Maybe<RegistryStatsWindow>;
  requests?: Maybe<Scalars['Long']>;
  requestsInCurrentBillingPeriod?: Maybe<Scalars['Long']>;
  roles?: Maybe<AccountRoles>;
  /** How many seats would be included in your next bill, as best estimated today */
  seatCountForNextBill?: Maybe<Scalars['Int']>;
  seats?: Maybe<Seats>;
  secondaryIDs: Array<Scalars['ID']>;
  services: Array<Service>;
  /**
   * If non-null, this organization tracks its members through an upstream, eg PingOne;
   * invitations are not possible on SSO-synchronized account.
   */
  sso?: Maybe<OrganizationSso>;
  state?: Maybe<AccountState>;
  /** A list of reusable invitations for the organization. */
  staticInvitations?: Maybe<Array<OrganizationInviteLink>>;
  /** @deprecated use Account.statsWindow instead */
  stats: AccountStatsWindow;
  statsWindow?: Maybe<AccountStatsWindow>;
  subscriptions?: Maybe<Array<BillingSubscription>>;
  /** Gets a ticket for this org, by id */
  ticket?: Maybe<ZendeskTicket>;
  /** List of Zendesk tickets submitted for this org */
  tickets?: Maybe<Array<ZendeskTicket>>;
};


export type AccountAvatarUrlArgs = {
  size?: Scalars['Int'];
};


export type AccountGraphIdAvailableArgs = {
  id: Scalars['ID'];
};


export type AccountInvitationsArgs = {
  includeAccepted?: Scalars['Boolean'];
};


export type AccountRegistryStatsWindowArgs = {
  from: Scalars['Timestamp'];
  resolution?: InputMaybe<Resolution>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type AccountRequestsArgs = {
  from: Scalars['Timestamp'];
  to: Scalars['Timestamp'];
};


export type AccountServicesArgs = {
  includeDeleted?: InputMaybe<Scalars['Boolean']>;
};


export type AccountStatsArgs = {
  from: Scalars['Timestamp'];
  resolution?: InputMaybe<Resolution>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type AccountStatsWindowArgs = {
  from: Scalars['Timestamp'];
  resolution?: InputMaybe<Resolution>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type AccountTicketArgs = {
  id: Scalars['ID'];
};

export type AccountChecksStatsMetrics = {
  __typename?: 'AccountChecksStatsMetrics';
  totalFailedChecks: Scalars['Long'];
  totalSuccessfulChecks: Scalars['Long'];
};

export type AccountChecksStatsRecord = {
  __typename?: 'AccountChecksStatsRecord';
  id: Scalars['ID'];
  metrics: AccountChecksStatsMetrics;
  timestamp: Scalars['Timestamp'];
};

/** Columns of AccountEdgeServerInfos. */
export enum AccountEdgeServerInfosColumn {
  BootId = 'BOOT_ID',
  ExecutableSchemaId = 'EXECUTABLE_SCHEMA_ID',
  LibraryVersion = 'LIBRARY_VERSION',
  Platform = 'PLATFORM',
  RuntimeVersion = 'RUNTIME_VERSION',
  SchemaTag = 'SCHEMA_TAG',
  ServerId = 'SERVER_ID',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  UserVersion = 'USER_VERSION'
}

export type AccountEdgeServerInfosDimensions = {
  __typename?: 'AccountEdgeServerInfosDimensions';
  bootId?: Maybe<Scalars['ID']>;
  executableSchemaId?: Maybe<Scalars['ID']>;
  libraryVersion?: Maybe<Scalars['String']>;
  platform?: Maybe<Scalars['String']>;
  runtimeVersion?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serverId?: Maybe<Scalars['ID']>;
  serviceId?: Maybe<Scalars['ID']>;
  userVersion?: Maybe<Scalars['String']>;
};

/** Filter for data in AccountEdgeServerInfos. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type AccountEdgeServerInfosFilter = {
  and?: InputMaybe<Array<AccountEdgeServerInfosFilter>>;
  /** Selects rows whose bootId dimension equals the given value if not null. To query for the null value, use {in: {bootId: [null]}} instead. */
  bootId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose executableSchemaId dimension equals the given value if not null. To query for the null value, use {in: {executableSchemaId: [null]}} instead. */
  executableSchemaId?: InputMaybe<Scalars['ID']>;
  in?: InputMaybe<AccountEdgeServerInfosFilterIn>;
  /** Selects rows whose libraryVersion dimension equals the given value if not null. To query for the null value, use {in: {libraryVersion: [null]}} instead. */
  libraryVersion?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<AccountEdgeServerInfosFilter>;
  or?: InputMaybe<Array<AccountEdgeServerInfosFilter>>;
  /** Selects rows whose platform dimension equals the given value if not null. To query for the null value, use {in: {platform: [null]}} instead. */
  platform?: InputMaybe<Scalars['String']>;
  /** Selects rows whose runtimeVersion dimension equals the given value if not null. To query for the null value, use {in: {runtimeVersion: [null]}} instead. */
  runtimeVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serverId dimension equals the given value if not null. To query for the null value, use {in: {serverId: [null]}} instead. */
  serverId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose userVersion dimension equals the given value if not null. To query for the null value, use {in: {userVersion: [null]}} instead. */
  userVersion?: InputMaybe<Scalars['String']>;
};

/** Filter for data in AccountEdgeServerInfos. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type AccountEdgeServerInfosFilterIn = {
  /** Selects rows whose bootId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  bootId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose executableSchemaId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  executableSchemaId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose libraryVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  libraryVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose platform dimension is in the given list. A null value in the list means a row with null for that dimension. */
  platform?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose runtimeVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  runtimeVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serverId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serverId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose userVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  userVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type AccountEdgeServerInfosOrderBySpec = {
  column: AccountEdgeServerInfosColumn;
  direction: Ordering;
};

export type AccountEdgeServerInfosRecord = {
  __typename?: 'AccountEdgeServerInfosRecord';
  /** Dimensions of AccountEdgeServerInfos that can be grouped by. */
  groupBy: AccountEdgeServerInfosDimensions;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of AccountErrorStats. */
export enum AccountErrorStatsColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  ErrorsCount = 'ERRORS_COUNT',
  Path = 'PATH',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  RequestsWithErrorsCount = 'REQUESTS_WITH_ERRORS_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP'
}

export type AccountErrorStatsDimensions = {
  __typename?: 'AccountErrorStatsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in AccountErrorStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type AccountErrorStatsFilter = {
  and?: InputMaybe<Array<AccountErrorStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<AccountErrorStatsFilterIn>;
  not?: InputMaybe<AccountErrorStatsFilter>;
  or?: InputMaybe<Array<AccountErrorStatsFilter>>;
  /** Selects rows whose path dimension equals the given value if not null. To query for the null value, use {in: {path: [null]}} instead. */
  path?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in AccountErrorStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type AccountErrorStatsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose path dimension is in the given list. A null value in the list means a row with null for that dimension. */
  path?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type AccountErrorStatsMetrics = {
  __typename?: 'AccountErrorStatsMetrics';
  errorsCount: Scalars['Long'];
  requestsWithErrorsCount: Scalars['Long'];
};

export type AccountErrorStatsOrderBySpec = {
  column: AccountErrorStatsColumn;
  direction: Ordering;
};

export type AccountErrorStatsRecord = {
  __typename?: 'AccountErrorStatsRecord';
  /** Dimensions of AccountErrorStats that can be grouped by. */
  groupBy: AccountErrorStatsDimensions;
  /** Metrics of AccountErrorStats that can be aggregated over. */
  metrics: AccountErrorStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type AccountExperimentalFeatures = {
  __typename?: 'AccountExperimentalFeatures';
  auditLogs: Scalars['Boolean'];
  championDashboard: Scalars['Boolean'];
  contractsPreview: Scalars['Boolean'];
  federation2Preview: Scalars['Boolean'];
  preRequestPreview: Scalars['Boolean'];
  publicVariants: Scalars['Boolean'];
  variantHomepage: Scalars['Boolean'];
  webhooksPreview: Scalars['Boolean'];
};

/** Columns of AccountFieldLatencies. */
export enum AccountFieldLatenciesColumn {
  FieldHistogram = 'FIELD_HISTOGRAM',
  FieldName = 'FIELD_NAME',
  ParentType = 'PARENT_TYPE',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP'
}

export type AccountFieldLatenciesDimensions = {
  __typename?: 'AccountFieldLatenciesDimensions';
  field?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  parentType?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in AccountFieldLatencies. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type AccountFieldLatenciesFilter = {
  and?: InputMaybe<Array<AccountFieldLatenciesFilter>>;
  /** Selects rows whose fieldName dimension equals the given value if not null. To query for the null value, use {in: {fieldName: [null]}} instead. */
  fieldName?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<AccountFieldLatenciesFilterIn>;
  not?: InputMaybe<AccountFieldLatenciesFilter>;
  or?: InputMaybe<Array<AccountFieldLatenciesFilter>>;
  /** Selects rows whose parentType dimension equals the given value if not null. To query for the null value, use {in: {parentType: [null]}} instead. */
  parentType?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in AccountFieldLatencies. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type AccountFieldLatenciesFilterIn = {
  /** Selects rows whose fieldName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fieldName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose parentType dimension is in the given list. A null value in the list means a row with null for that dimension. */
  parentType?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type AccountFieldLatenciesMetrics = {
  __typename?: 'AccountFieldLatenciesMetrics';
  fieldHistogram: DurationHistogram;
};

export type AccountFieldLatenciesOrderBySpec = {
  column: AccountFieldLatenciesColumn;
  direction: Ordering;
};

export type AccountFieldLatenciesRecord = {
  __typename?: 'AccountFieldLatenciesRecord';
  /** Dimensions of AccountFieldLatencies that can be grouped by. */
  groupBy: AccountFieldLatenciesDimensions;
  /** Metrics of AccountFieldLatencies that can be aggregated over. */
  metrics: AccountFieldLatenciesMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of AccountFieldUsage. */
export enum AccountFieldUsageColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  EstimatedExecutionCount = 'ESTIMATED_EXECUTION_COUNT',
  ExecutionCount = 'EXECUTION_COUNT',
  Field = 'FIELD',
  FieldName = 'FIELD_NAME',
  ParentType = 'PARENT_TYPE',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  ReferencingOperationCount = 'REFERENCING_OPERATION_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP'
}

export type AccountFieldUsageDimensions = {
  __typename?: 'AccountFieldUsageDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  field?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  parentType?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in AccountFieldUsage. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type AccountFieldUsageFilter = {
  and?: InputMaybe<Array<AccountFieldUsageFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose field dimension equals the given value if not null. To query for the null value, use {in: {field: [null]}} instead. */
  field?: InputMaybe<Scalars['String']>;
  /** Selects rows whose fieldName dimension equals the given value if not null. To query for the null value, use {in: {fieldName: [null]}} instead. */
  fieldName?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<AccountFieldUsageFilterIn>;
  not?: InputMaybe<AccountFieldUsageFilter>;
  or?: InputMaybe<Array<AccountFieldUsageFilter>>;
  /** Selects rows whose parentType dimension equals the given value if not null. To query for the null value, use {in: {parentType: [null]}} instead. */
  parentType?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in AccountFieldUsage. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type AccountFieldUsageFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose field dimension is in the given list. A null value in the list means a row with null for that dimension. */
  field?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose fieldName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fieldName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose parentType dimension is in the given list. A null value in the list means a row with null for that dimension. */
  parentType?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type AccountFieldUsageMetrics = {
  __typename?: 'AccountFieldUsageMetrics';
  estimatedExecutionCount: Scalars['Long'];
  executionCount: Scalars['Long'];
  referencingOperationCount: Scalars['Long'];
};

export type AccountFieldUsageOrderBySpec = {
  column: AccountFieldUsageColumn;
  direction: Ordering;
};

export type AccountFieldUsageRecord = {
  __typename?: 'AccountFieldUsageRecord';
  /** Dimensions of AccountFieldUsage that can be grouped by. */
  groupBy: AccountFieldUsageDimensions;
  /** Metrics of AccountFieldUsage that can be aggregated over. */
  metrics: AccountFieldUsageMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type AccountInvitation = {
  __typename?: 'AccountInvitation';
  /** An accepted invitation cannot be used anymore */
  acceptedAt?: Maybe<Scalars['Timestamp']>;
  /** Who accepted the invitation */
  acceptedBy?: Maybe<User>;
  /** Time the invitation was created */
  createdAt: Scalars['Timestamp'];
  /** Who created the invitation */
  createdBy?: Maybe<User>;
  email: Scalars['String'];
  id: Scalars['ID'];
  /** Last time we sent an email for the invitation */
  lastSentAt?: Maybe<Scalars['Timestamp']>;
  /** Access role for the invitee */
  role: UserPermission;
};

export type AccountMembership = {
  __typename?: 'AccountMembership';
  account: Account;
  createdAt: Scalars['Timestamp'];
  /** If this membership is a free seat (based on role) */
  free?: Maybe<Scalars['Boolean']>;
  permission: UserPermission;
  user: User;
};

export type AccountMutation = {
  __typename?: 'AccountMutation';
  auditExport?: Maybe<AuditLogExportMutation>;
  /** Cancel a pending change from an annual team subscription to a monthly team subscription when the current period expires. */
  cancelConvertAnnualTeamSubscriptionToMonthlyAtNextPeriod?: Maybe<Account>;
  /** Cancel account subscriptions, subscriptions will remain active until the end of the paid period */
  cancelSubscriptions?: Maybe<Account>;
  /** Changes an annual team subscription to a monthly team subscription when the current period expires. */
  convertAnnualTeamSubscriptionToMonthlyAtNextPeriod?: Maybe<Account>;
  /** Changes a monthly team subscription to an annual team subscription. */
  convertMonthlyTeamSubscriptionToAnnual?: Maybe<Account>;
  createStaticInvitation?: Maybe<OrganizationInviteLink>;
  /** Delete the account's avatar. Requires Account.canUpdateAvatar to be true. */
  deleteAvatar?: Maybe<AvatarDeleteError>;
  /** Acknowledge that a trial has expired and return to community */
  dismissExpiredTrial?: Maybe<Account>;
  /** Apollo admins only: extend an ongoing trial */
  extendTrial?: Maybe<Account>;
  /** Hard delete an account and all associated services */
  hardDelete?: Maybe<Scalars['Void']>;
  /** Send an invitation to join the account by E-mail */
  invite?: Maybe<AccountInvitation>;
  /** Reactivate a canceled current subscription */
  reactivateCurrentSubscription?: Maybe<Account>;
  /** Refresh billing information from third-party billing service */
  refreshBilling?: Maybe<Scalars['Void']>;
  /** Delete an invitation */
  removeInvitation?: Maybe<Scalars['Void']>;
  /** Remove a member of the account */
  removeMember?: Maybe<Account>;
  requestAuditExport?: Maybe<Account>;
  /** Send a new E-mail for an existing invitation */
  resendInvitation?: Maybe<AccountInvitation>;
  revokeStaticInvitation?: Maybe<OrganizationInviteLink>;
  /** Apollo admins only: set the billing plan to an arbitrary plan */
  setPlan?: Maybe<Scalars['Void']>;
  /** Start a new team subscription with the given billing period */
  startTeamSubscription?: Maybe<Account>;
  /** Start a team trial */
  startTrial?: Maybe<Account>;
  /** This is called by the form shown to users after they cancel their team subscription. */
  submitTeamCancellationFeedback?: Maybe<Scalars['Void']>;
  /** Apollo admins only: terminate any ongoing subscriptions in the account, without refunds */
  terminateSubscriptions?: Maybe<Account>;
  /** Update the billing address for a Recurly token */
  updateBillingAddress?: Maybe<Account>;
  /** Update the billing information from a Recurly token */
  updateBillingInfo?: Maybe<Scalars['Void']>;
  updateCompanyUrl?: Maybe<Account>;
  /** Set the E-mail address of the account, used notably for billing */
  updateEmail?: Maybe<Scalars['Void']>;
  /** Update the account ID */
  updateID?: Maybe<Account>;
  /** Update the company name */
  updateName?: Maybe<Scalars['Void']>;
  /** Apollo admins only: enable or disable an account for PingOne SSO login */
  updatePingOneSSOIDPID?: Maybe<Account>;
  /** Updates the role assigned to new SSO users. */
  updateSSODefaultRole?: Maybe<OrganizationSso>;
  /** A (currently) internal to Apollo mutation to update a user's role within an organization */
  updateUserPermission?: Maybe<User>;
};


export type AccountMutationAuditExportArgs = {
  id: Scalars['String'];
};


export type AccountMutationCreateStaticInvitationArgs = {
  role: UserPermission;
};


export type AccountMutationExtendTrialArgs = {
  to: Scalars['Timestamp'];
};


export type AccountMutationInviteArgs = {
  email: Scalars['String'];
  role?: InputMaybe<UserPermission>;
};


export type AccountMutationRemoveInvitationArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type AccountMutationRemoveMemberArgs = {
  id: Scalars['ID'];
};


export type AccountMutationRequestAuditExportArgs = {
  actors?: InputMaybe<Array<ActorInput>>;
  from: Scalars['Timestamp'];
  graphIds?: InputMaybe<Array<Scalars['String']>>;
  to: Scalars['Timestamp'];
};


export type AccountMutationResendInvitationArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type AccountMutationRevokeStaticInvitationArgs = {
  token: Scalars['String'];
};


export type AccountMutationSetPlanArgs = {
  id: Scalars['ID'];
};


export type AccountMutationStartTeamSubscriptionArgs = {
  billingPeriod: BillingPeriod;
};


export type AccountMutationSubmitTeamCancellationFeedbackArgs = {
  feedback: Scalars['String'];
};


export type AccountMutationUpdateBillingAddressArgs = {
  billingAddress: BillingAddressInput;
};


export type AccountMutationUpdateBillingInfoArgs = {
  token: Scalars['String'];
};


export type AccountMutationUpdateCompanyUrlArgs = {
  companyUrl?: InputMaybe<Scalars['String']>;
};


export type AccountMutationUpdateEmailArgs = {
  email: Scalars['String'];
};


export type AccountMutationUpdateIdArgs = {
  id: Scalars['ID'];
};


export type AccountMutationUpdateNameArgs = {
  name: Scalars['String'];
};


export type AccountMutationUpdatePingOneSsoidpidArgs = {
  idpid?: InputMaybe<Scalars['String']>;
};


export type AccountMutationUpdateSsoDefaultRoleArgs = {
  role: UserPermission;
};


export type AccountMutationUpdateUserPermissionArgs = {
  permission: UserPermission;
  userID: Scalars['ID'];
};

/** Columns of AccountOperationCheckStats. */
export enum AccountOperationCheckStatsColumn {
  CachedRequestsCount = 'CACHED_REQUESTS_COUNT',
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  UncachedRequestsCount = 'UNCACHED_REQUESTS_COUNT'
}

export type AccountOperationCheckStatsDimensions = {
  __typename?: 'AccountOperationCheckStatsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in AccountOperationCheckStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type AccountOperationCheckStatsFilter = {
  and?: InputMaybe<Array<AccountOperationCheckStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<AccountOperationCheckStatsFilterIn>;
  not?: InputMaybe<AccountOperationCheckStatsFilter>;
  or?: InputMaybe<Array<AccountOperationCheckStatsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in AccountOperationCheckStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type AccountOperationCheckStatsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type AccountOperationCheckStatsMetrics = {
  __typename?: 'AccountOperationCheckStatsMetrics';
  cachedRequestsCount: Scalars['Long'];
  uncachedRequestsCount: Scalars['Long'];
};

export type AccountOperationCheckStatsOrderBySpec = {
  column: AccountOperationCheckStatsColumn;
  direction: Ordering;
};

export type AccountOperationCheckStatsRecord = {
  __typename?: 'AccountOperationCheckStatsRecord';
  /** Dimensions of AccountOperationCheckStats that can be grouped by. */
  groupBy: AccountOperationCheckStatsDimensions;
  /** Metrics of AccountOperationCheckStats that can be aggregated over. */
  metrics: AccountOperationCheckStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type AccountPublishesStatsMetrics = {
  __typename?: 'AccountPublishesStatsMetrics';
  totalPublishes: Scalars['Long'];
};

export type AccountPublishesStatsRecord = {
  __typename?: 'AccountPublishesStatsRecord';
  id: Scalars['ID'];
  metrics: AccountPublishesStatsMetrics;
  timestamp: Scalars['Timestamp'];
};

/** Columns of AccountQueryStats. */
export enum AccountQueryStatsColumn {
  CachedHistogram = 'CACHED_HISTOGRAM',
  CachedRequestsCount = 'CACHED_REQUESTS_COUNT',
  CacheTtlHistogram = 'CACHE_TTL_HISTOGRAM',
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  ForbiddenOperationCount = 'FORBIDDEN_OPERATION_COUNT',
  FromEngineproxy = 'FROM_ENGINEPROXY',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  RegisteredOperationCount = 'REGISTERED_OPERATION_COUNT',
  RequestsWithErrorsCount = 'REQUESTS_WITH_ERRORS_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  UncachedHistogram = 'UNCACHED_HISTOGRAM',
  UncachedRequestsCount = 'UNCACHED_REQUESTS_COUNT'
}

export type AccountQueryStatsDimensions = {
  __typename?: 'AccountQueryStatsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  fromEngineproxy?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  querySignature?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in AccountQueryStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type AccountQueryStatsFilter = {
  and?: InputMaybe<Array<AccountQueryStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose fromEngineproxy dimension equals the given value if not null. To query for the null value, use {in: {fromEngineproxy: [null]}} instead. */
  fromEngineproxy?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<AccountQueryStatsFilterIn>;
  not?: InputMaybe<AccountQueryStatsFilter>;
  or?: InputMaybe<Array<AccountQueryStatsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in AccountQueryStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type AccountQueryStatsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose fromEngineproxy dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fromEngineproxy?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type AccountQueryStatsMetrics = {
  __typename?: 'AccountQueryStatsMetrics';
  cacheTtlHistogram: DurationHistogram;
  cachedHistogram: DurationHistogram;
  cachedRequestsCount: Scalars['Long'];
  forbiddenOperationCount: Scalars['Long'];
  registeredOperationCount: Scalars['Long'];
  requestsWithErrorsCount: Scalars['Long'];
  totalLatencyHistogram: DurationHistogram;
  totalRequestCount: Scalars['Long'];
  uncachedHistogram: DurationHistogram;
  uncachedRequestsCount: Scalars['Long'];
};

export type AccountQueryStatsOrderBySpec = {
  column: AccountQueryStatsColumn;
  direction: Ordering;
};

export type AccountQueryStatsRecord = {
  __typename?: 'AccountQueryStatsRecord';
  /** Dimensions of AccountQueryStats that can be grouped by. */
  groupBy: AccountQueryStatsDimensions;
  /** Metrics of AccountQueryStats that can be aggregated over. */
  metrics: AccountQueryStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type AccountRoles = {
  __typename?: 'AccountRoles';
  canAudit: Scalars['Boolean'];
  canCreateDevGraph: Scalars['Boolean'];
  canCreateService: Scalars['Boolean'];
  canDelete: Scalars['Boolean'];
  /** @deprecated Use canQueryBillingInfo instead */
  canDownloadInvoice: Scalars['Boolean'];
  canManageMembers: Scalars['Boolean'];
  canQuery: Scalars['Boolean'];
  canQueryAudit: Scalars['Boolean'];
  canQueryBillingInfo: Scalars['Boolean'];
  /** @deprecated Use canQueryBillingInfo instead */
  canQueryInvoices: Scalars['Boolean'];
  canQueryMembers: Scalars['Boolean'];
  canQueryStats: Scalars['Boolean'];
  canReadTickets: Scalars['Boolean'];
  canRemoveMembers: Scalars['Boolean'];
  canSetConstrainedPlan: Scalars['Boolean'];
  canUpdateBillingInfo: Scalars['Boolean'];
  canUpdateMetadata: Scalars['Boolean'];
};

export enum AccountState {
  Active = 'ACTIVE',
  Closed = 'CLOSED',
  Unknown = 'UNKNOWN',
  Unprovisioned = 'UNPROVISIONED'
}

/** A time window with a specified granularity over a given account. */
export type AccountStatsWindow = {
  __typename?: 'AccountStatsWindow';
  edgeServerInfos: Array<AccountEdgeServerInfosRecord>;
  errorStats: Array<AccountErrorStatsRecord>;
  fieldLatencies: Array<AccountFieldLatenciesRecord>;
  fieldUsage: Array<AccountFieldUsageRecord>;
  operationCheckStats: Array<AccountOperationCheckStatsRecord>;
  queryStats: Array<AccountQueryStatsRecord>;
  /** From field rounded down to the nearest resolution. */
  roundedDownFrom: Scalars['Timestamp'];
  /** To field rounded up to the nearest resolution. */
  roundedUpTo: Scalars['Timestamp'];
  tracePathErrorsRefs: Array<AccountTracePathErrorsRefsRecord>;
  traceRefs: Array<AccountTraceRefsRecord>;
};


/** A time window with a specified granularity over a given account. */
export type AccountStatsWindowEdgeServerInfosArgs = {
  filter?: InputMaybe<AccountEdgeServerInfosFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountEdgeServerInfosOrderBySpec>>;
};


/** A time window with a specified granularity over a given account. */
export type AccountStatsWindowErrorStatsArgs = {
  filter?: InputMaybe<AccountErrorStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountErrorStatsOrderBySpec>>;
};


/** A time window with a specified granularity over a given account. */
export type AccountStatsWindowFieldLatenciesArgs = {
  filter?: InputMaybe<AccountFieldLatenciesFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountFieldLatenciesOrderBySpec>>;
};


/** A time window with a specified granularity over a given account. */
export type AccountStatsWindowFieldUsageArgs = {
  filter?: InputMaybe<AccountFieldUsageFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountFieldUsageOrderBySpec>>;
};


/** A time window with a specified granularity over a given account. */
export type AccountStatsWindowOperationCheckStatsArgs = {
  filter?: InputMaybe<AccountOperationCheckStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountOperationCheckStatsOrderBySpec>>;
};


/** A time window with a specified granularity over a given account. */
export type AccountStatsWindowQueryStatsArgs = {
  filter?: InputMaybe<AccountQueryStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountQueryStatsOrderBySpec>>;
};


/** A time window with a specified granularity over a given account. */
export type AccountStatsWindowTracePathErrorsRefsArgs = {
  filter?: InputMaybe<AccountTracePathErrorsRefsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountTracePathErrorsRefsOrderBySpec>>;
};


/** A time window with a specified granularity over a given account. */
export type AccountStatsWindowTraceRefsArgs = {
  filter?: InputMaybe<AccountTraceRefsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountTraceRefsOrderBySpec>>;
};

/** Columns of AccountTracePathErrorsRefs. */
export enum AccountTracePathErrorsRefsColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  DurationBucket = 'DURATION_BUCKET',
  ErrorsCountInPath = 'ERRORS_COUNT_IN_PATH',
  ErrorsCountInTrace = 'ERRORS_COUNT_IN_TRACE',
  ErrorMessage = 'ERROR_MESSAGE',
  Path = 'PATH',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  TraceHttpStatusCode = 'TRACE_HTTP_STATUS_CODE',
  TraceId = 'TRACE_ID',
  TraceSizeBytes = 'TRACE_SIZE_BYTES',
  TraceStartsAt = 'TRACE_STARTS_AT'
}

export type AccountTracePathErrorsRefsDimensions = {
  __typename?: 'AccountTracePathErrorsRefsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  durationBucket?: Maybe<Scalars['Int']>;
  errorMessage?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
  traceHttpStatusCode?: Maybe<Scalars['Int']>;
  traceId?: Maybe<Scalars['ID']>;
  traceStartsAt?: Maybe<Scalars['Timestamp']>;
};

/** Filter for data in AccountTracePathErrorsRefs. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type AccountTracePathErrorsRefsFilter = {
  and?: InputMaybe<Array<AccountTracePathErrorsRefsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose durationBucket dimension equals the given value if not null. To query for the null value, use {in: {durationBucket: [null]}} instead. */
  durationBucket?: InputMaybe<Scalars['Int']>;
  /** Selects rows whose errorMessage dimension equals the given value if not null. To query for the null value, use {in: {errorMessage: [null]}} instead. */
  errorMessage?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<AccountTracePathErrorsRefsFilterIn>;
  not?: InputMaybe<AccountTracePathErrorsRefsFilter>;
  or?: InputMaybe<Array<AccountTracePathErrorsRefsFilter>>;
  /** Selects rows whose path dimension equals the given value if not null. To query for the null value, use {in: {path: [null]}} instead. */
  path?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose traceHttpStatusCode dimension equals the given value if not null. To query for the null value, use {in: {traceHttpStatusCode: [null]}} instead. */
  traceHttpStatusCode?: InputMaybe<Scalars['Int']>;
  /** Selects rows whose traceId dimension equals the given value if not null. To query for the null value, use {in: {traceId: [null]}} instead. */
  traceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in AccountTracePathErrorsRefs. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type AccountTracePathErrorsRefsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose durationBucket dimension is in the given list. A null value in the list means a row with null for that dimension. */
  durationBucket?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose errorMessage dimension is in the given list. A null value in the list means a row with null for that dimension. */
  errorMessage?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose path dimension is in the given list. A null value in the list means a row with null for that dimension. */
  path?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose traceHttpStatusCode dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceHttpStatusCode?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose traceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type AccountTracePathErrorsRefsMetrics = {
  __typename?: 'AccountTracePathErrorsRefsMetrics';
  errorsCountInPath: Scalars['Long'];
  errorsCountInTrace: Scalars['Long'];
  traceSizeBytes: Scalars['Long'];
};

export type AccountTracePathErrorsRefsOrderBySpec = {
  column: AccountTracePathErrorsRefsColumn;
  direction: Ordering;
};

export type AccountTracePathErrorsRefsRecord = {
  __typename?: 'AccountTracePathErrorsRefsRecord';
  /** Dimensions of AccountTracePathErrorsRefs that can be grouped by. */
  groupBy: AccountTracePathErrorsRefsDimensions;
  /** Metrics of AccountTracePathErrorsRefs that can be aggregated over. */
  metrics: AccountTracePathErrorsRefsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of AccountTraceRefs. */
export enum AccountTraceRefsColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  DurationBucket = 'DURATION_BUCKET',
  DurationNs = 'DURATION_NS',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  TraceId = 'TRACE_ID',
  TraceSizeBytes = 'TRACE_SIZE_BYTES'
}

export type AccountTraceRefsDimensions = {
  __typename?: 'AccountTraceRefsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  durationBucket?: Maybe<Scalars['Int']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  querySignature?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
  traceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in AccountTraceRefs. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type AccountTraceRefsFilter = {
  and?: InputMaybe<Array<AccountTraceRefsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose durationBucket dimension equals the given value if not null. To query for the null value, use {in: {durationBucket: [null]}} instead. */
  durationBucket?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<AccountTraceRefsFilterIn>;
  not?: InputMaybe<AccountTraceRefsFilter>;
  or?: InputMaybe<Array<AccountTraceRefsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose traceId dimension equals the given value if not null. To query for the null value, use {in: {traceId: [null]}} instead. */
  traceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in AccountTraceRefs. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type AccountTraceRefsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose durationBucket dimension is in the given list. A null value in the list means a row with null for that dimension. */
  durationBucket?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose traceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type AccountTraceRefsMetrics = {
  __typename?: 'AccountTraceRefsMetrics';
  durationNs: Scalars['Long'];
  traceSizeBytes: Scalars['Long'];
};

export type AccountTraceRefsOrderBySpec = {
  column: AccountTraceRefsColumn;
  direction: Ordering;
};

export type AccountTraceRefsRecord = {
  __typename?: 'AccountTraceRefsRecord';
  /** Dimensions of AccountTraceRefs that can be grouped by. */
  groupBy: AccountTraceRefsDimensions;
  /** Metrics of AccountTraceRefs that can be aggregated over. */
  metrics: AccountTraceRefsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type Actor = {
  __typename?: 'Actor';
  actorId: Scalars['ID'];
  type: ActorType;
};

export type ActorInput = {
  actorId: Scalars['ID'];
  type: ActorType;
};

export enum ActorType {
  AnonymousUser = 'ANONYMOUS_USER',
  Backfill = 'BACKFILL',
  Cron = 'CRON',
  Graph = 'GRAPH',
  InternalIdentity = 'INTERNAL_IDENTITY',
  Synchronization = 'SYNCHRONIZATION',
  User = 'USER'
}

export type AddOperationCollectionEntryResult = OperationCollectionEntry | ValidationError;

export type AddOperationCollectionToVariantResult = GraphVariant | InvalidTarget | ValidationError;

export type AffectedClient = {
  __typename?: 'AffectedClient';
  /**
   * ID, often the name, of the client set by the user and reported alongside metrics
   * @deprecated Unsupported.
   */
  clientReferenceId?: Maybe<Scalars['ID']>;
  /**
   * version of the client set by the user and reported alongside metrics
   * @deprecated Unsupported.
   */
  clientVersion?: Maybe<Scalars['String']>;
};

export type AffectedQuery = {
  __typename?: 'AffectedQuery';
  /** If the operation would be approved if the check ran again. Returns null if queried from SchemaDiff.changes.affectedQueries.alreadyApproved */
  alreadyApproved?: Maybe<Scalars['Boolean']>;
  /** If the operation would be ignored if the check ran again */
  alreadyIgnored?: Maybe<Scalars['Boolean']>;
  /** List of changes affecting this query. Returns null if queried from SchemaDiff.changes.affectedQueries.changes */
  changes?: Maybe<Array<ChangeOnOperation>>;
  /** Name to display to the user for the operation */
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Determines if this query validates against the proposed schema */
  isValid?: Maybe<Scalars['Boolean']>;
  /** Whether this operation was ignored and its severity was downgraded for that reason */
  markedAsIgnored?: Maybe<Scalars['Boolean']>;
  /** Whether the changes were marked as safe and its severity was downgraded for that reason */
  markedAsSafe?: Maybe<Scalars['Boolean']>;
  /** Name provided for the operation, which can be empty string if it is an anonymous operation */
  name?: Maybe<Scalars['String']>;
  /** First 128 characters of query signature for display */
  signature?: Maybe<Scalars['String']>;
};

export type ApiKey = {
  id: Scalars['ID'];
  keyName?: Maybe<Scalars['String']>;
  token: Scalars['String'];
};

export type ApiKeyProvision = {
  __typename?: 'ApiKeyProvision';
  apiKey: ApiKey;
  created: Scalars['Boolean'];
};

export type AuditLogExport = {
  __typename?: 'AuditLogExport';
  actors?: Maybe<Array<Identity>>;
  bigqueryTriggeredAt?: Maybe<Scalars['Timestamp']>;
  completedAt?: Maybe<Scalars['Timestamp']>;
  createdAt: Scalars['Timestamp'];
  exportedFiles?: Maybe<Array<Scalars['String']>>;
  from: Scalars['Timestamp'];
  graphs?: Maybe<Array<Service>>;
  id: Scalars['ID'];
  requester?: Maybe<User>;
  status: AuditStatus;
  to: Scalars['Timestamp'];
};

export type AuditLogExportMutation = {
  __typename?: 'AuditLogExportMutation';
  cancel?: Maybe<Account>;
  delete?: Maybe<Account>;
};

export enum AuditStatus {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Expired = 'EXPIRED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Queued = 'QUEUED'
}

export type AvatarDeleteError = {
  __typename?: 'AvatarDeleteError';
  clientMessage: Scalars['String'];
  code: AvatarDeleteErrorCode;
  serverMessage: Scalars['String'];
};

export enum AvatarDeleteErrorCode {
  SsoUsersCannotDeleteSelfAvatar = 'SSO_USERS_CANNOT_DELETE_SELF_AVATAR'
}

export type AvatarUploadError = {
  __typename?: 'AvatarUploadError';
  clientMessage: Scalars['String'];
  code: AvatarUploadErrorCode;
  serverMessage: Scalars['String'];
};

export enum AvatarUploadErrorCode {
  SsoUsersCannotUploadSelfAvatar = 'SSO_USERS_CANNOT_UPLOAD_SELF_AVATAR'
}

export type AvatarUploadResult = AvatarUploadError | MediaUploadInfo;

export type BillingAddress = {
  __typename?: 'BillingAddress';
  address1?: Maybe<Scalars['String']>;
  address2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  zip?: Maybe<Scalars['String']>;
};

/** Billing address inpnut */
export type BillingAddressInput = {
  address1: Scalars['String'];
  address2?: InputMaybe<Scalars['String']>;
  city: Scalars['String'];
  country: Scalars['String'];
  state: Scalars['String'];
  zip: Scalars['String'];
};

export type BillingInfo = {
  __typename?: 'BillingInfo';
  address: BillingAddress;
  cardType?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastFour?: Maybe<Scalars['Int']>;
  lastName?: Maybe<Scalars['String']>;
  month?: Maybe<Scalars['Int']>;
  vatNumber?: Maybe<Scalars['String']>;
  year?: Maybe<Scalars['Int']>;
};

export enum BillingModel {
  RequestBased = 'REQUEST_BASED',
  SeatBased = 'SEAT_BASED'
}

export type BillingMonth = {
  __typename?: 'BillingMonth';
  end: Scalars['Timestamp'];
  requests: Scalars['Long'];
  start: Scalars['Timestamp'];
};

export enum BillingPeriod {
  Monthly = 'MONTHLY',
  Quarterly = 'QUARTERLY',
  SemiAnnually = 'SEMI_ANNUALLY',
  Yearly = 'YEARLY'
}

export type BillingPlan = {
  __typename?: 'BillingPlan';
  addons: Array<BillingPlanAddon>;
  billingModel: BillingModel;
  billingPeriod?: Maybe<BillingPeriod>;
  capabilities: BillingPlanCapabilities;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  isTrial: Scalars['Boolean'];
  kind: BillingPlanKind;
  name: Scalars['String'];
  /** The price of every seat */
  pricePerSeatInUsdCents?: Maybe<Scalars['Int']>;
  /** The price of subscribing to this plan with a quantity of 1 (currently always the case) */
  pricePerUnitInUsdCents: Scalars['Int'];
  /** Whether the plan is accessible by all users in QueryRoot.allPlans, QueryRoot.plan, or AccountMutation.setPlan */
  public: Scalars['Boolean'];
  tier: BillingPlanTier;
};

export type BillingPlanAddon = {
  __typename?: 'BillingPlanAddon';
  id: Scalars['ID'];
  pricePerUnitInUsdCents: Scalars['Int'];
};

export type BillingPlanAddonV2 = {
  __typename?: 'BillingPlanAddonV2';
  id: Scalars['ID'];
  pricePerUnitInUsdCents: Scalars['Int'];
};

export type BillingPlanCapabilities = {
  __typename?: 'BillingPlanCapabilities';
  clients: Scalars['Boolean'];
  contracts: Scalars['Boolean'];
  datadog: Scalars['Boolean'];
  errors: Scalars['Boolean'];
  federation: Scalars['Boolean'];
  launches: Scalars['Boolean'];
  maxAuditInDays: Scalars['Int'];
  maxRangeInDays?: Maybe<Scalars['Int']>;
  maxRequestsPerMonth?: Maybe<Scalars['Long']>;
  metrics: Scalars['Boolean'];
  notifications: Scalars['Boolean'];
  operationRegistry: Scalars['Boolean'];
  ranges: Array<Scalars['String']>;
  schemaValidation: Scalars['Boolean'];
  traces: Scalars['Boolean'];
  userRoles: Scalars['Boolean'];
  webhooks: Scalars['Boolean'];
};

export enum BillingPlanKind {
  Community = 'COMMUNITY',
  EnterpriseInternal = 'ENTERPRISE_INTERNAL',
  EnterprisePaid = 'ENTERPRISE_PAID',
  EnterprisePilot = 'ENTERPRISE_PILOT',
  TeamPaid = 'TEAM_PAID',
  TeamTrial = 'TEAM_TRIAL'
}

export enum BillingPlanKindV2 {
  Community = 'COMMUNITY',
  EnterpriseInternal = 'ENTERPRISE_INTERNAL',
  EnterprisePaid = 'ENTERPRISE_PAID',
  EnterprisePilot = 'ENTERPRISE_PILOT',
  TeamPaid = 'TEAM_PAID',
  TeamTrial = 'TEAM_TRIAL',
  Unknown = 'UNKNOWN'
}

export enum BillingPlanTier {
  Community = 'COMMUNITY',
  Enterprise = 'ENTERPRISE',
  Team = 'TEAM'
}

export enum BillingPlanTierV2 {
  Community = 'COMMUNITY',
  Enterprise = 'ENTERPRISE',
  Team = 'TEAM',
  Unknown = 'UNKNOWN'
}

export type BillingPlanV2 = {
  __typename?: 'BillingPlanV2';
  addons: Array<BillingPlanAddonV2>;
  billingModel: BillingModel;
  billingPeriod?: Maybe<BillingPeriod>;
  clients: Scalars['Boolean'];
  contracts: Scalars['Boolean'];
  datadog: Scalars['Boolean'];
  description?: Maybe<Scalars['String']>;
  errors: Scalars['Boolean'];
  federation: Scalars['Boolean'];
  id: Scalars['ID'];
  isTrial: Scalars['Boolean'];
  kind: BillingPlanKindV2;
  launches: Scalars['Boolean'];
  maxAuditInDays: Scalars['Int'];
  maxRangeInDays?: Maybe<Scalars['Int']>;
  maxRequestsPerMonth?: Maybe<Scalars['Long']>;
  metrics: Scalars['Boolean'];
  name: Scalars['String'];
  notifications: Scalars['Boolean'];
  operationRegistry: Scalars['Boolean'];
  /** The price of every seat */
  pricePerSeatInUsdCents?: Maybe<Scalars['Int']>;
  /** The price of subscribing to this plan with a quantity of 1 (currently always the case) */
  pricePerUnitInUsdCents: Scalars['Int'];
  /** Whether the plan is accessible by all users in QueryRoot.allPlans, QueryRoot.plan, or AccountMutation.setPlan */
  public: Scalars['Boolean'];
  ranges: Array<Scalars['String']>;
  schemaValidation: Scalars['Boolean'];
  tier: BillingPlanTierV2;
  traces: Scalars['Boolean'];
  userRoles: Scalars['Boolean'];
  webhooks: Scalars['Boolean'];
};

export type BillingSubscription = {
  __typename?: 'BillingSubscription';
  activatedAt: Scalars['Timestamp'];
  addons: Array<BillingSubscriptionAddon>;
  autoRenew: Scalars['Boolean'];
  /** The price of the subscription when ignoring add-ons (such as seats), ie quantity * pricePerUnitInUsdCents */
  basePriceInUsdCents: Scalars['Long'];
  canceledAt?: Maybe<Scalars['Timestamp']>;
  currentPeriodEndsAt: Scalars['Timestamp'];
  currentPeriodStartedAt: Scalars['Timestamp'];
  expiresAt?: Maybe<Scalars['Timestamp']>;
  plan: BillingPlan;
  /** The price of every seat */
  pricePerSeatInUsdCents?: Maybe<Scalars['Int']>;
  /** The price of every unit in the subscription (hence multiplied by quantity to get to the basePriceInUsdCents) */
  pricePerUnitInUsdCents: Scalars['Int'];
  quantity: Scalars['Int'];
  /** Total price of the subscription when it next renews, including add-ons (such as seats) */
  renewalTotalPriceInUsdCents: Scalars['Long'];
  state: SubscriptionState;
  /** Total price of the subscription, including add-ons (such as seats) */
  totalPriceInUsdCents: Scalars['Long'];
  /**
   * When this subscription's trial period expires (if it is a trial). Not the same as the
   * subscription's Recurly expiration).
   */
  trialExpiresAt?: Maybe<Scalars['Timestamp']>;
  uuid: Scalars['ID'];
};

export type BillingSubscriptionAddon = {
  __typename?: 'BillingSubscriptionAddon';
  id: Scalars['ID'];
  pricePerUnitInUsdCents: Scalars['Int'];
  quantity: Scalars['Int'];
};

export type Build = {
  __typename?: 'Build';
  input: BuildInput;
  result?: Maybe<BuildResult>;
};

export type BuildError = {
  __typename?: 'BuildError';
  code?: Maybe<Scalars['String']>;
  locations: Array<SourceLocation>;
  message: Scalars['String'];
};

export type BuildFailure = {
  __typename?: 'BuildFailure';
  errorMessages: Array<BuildError>;
};

export type BuildInput = CompositionBuildInput | FilterBuildInput;

export type BuildResult = BuildFailure | BuildSuccess;

export type BuildSuccess = {
  __typename?: 'BuildSuccess';
  coreSchema: CoreSchema;
};

export enum CacheScope {
  Private = 'PRIVATE',
  Public = 'PUBLIC',
  Unknown = 'UNKNOWN',
  Unrecognized = 'UNRECOGNIZED'
}

export type Change = {
  __typename?: 'Change';
  affectedQueries?: Maybe<Array<AffectedQuery>>;
  /** Target arg of change made. */
  argNode?: Maybe<NamedIntrospectionArg>;
  /** Indication of the category of the change (e.g. addition, removal, edit). */
  category: ChangeCategory;
  /**
   * Node related to the top level node that was changed, such as a field in an object,
   * a value in an enum or the object of an interface
   */
  childNode?: Maybe<NamedIntrospectionValue>;
  /** Indication of the kind of target and action of the change, e.g. 'TYPE_REMOVED'. */
  code: Scalars['String'];
  /** Explanation of both the target of the change and how it was changed. */
  description: Scalars['String'];
  /** Top level node affected by the change */
  parentNode?: Maybe<NamedIntrospectionType>;
  /** Indication of the success of the overall change, either failure, warning, or notice. */
  severity: ChangeSeverity;
  /**
   * Indication of the success of the overall change, either failure, warning, or notice.
   * @deprecated use severity instead
   */
  type: ChangeType;
};

/**
 * Defines a set of categories that a schema change
 * can be grouped by.
 */
export enum ChangeCategory {
  Addition = 'ADDITION',
  Deprecation = 'DEPRECATION',
  Edit = 'EDIT',
  Removal = 'REMOVAL'
}

/**
 * These schema change codes represent all of the possible changes that can
 * occur during the schema diff algorithm.
 */
export enum ChangeCode {
  /** Type of the argument was changed. */
  ArgChangedType = 'ARG_CHANGED_TYPE',
  /** Argument was changed from nullable to non-nullable. */
  ArgChangedTypeOptionalToRequired = 'ARG_CHANGED_TYPE_OPTIONAL_TO_REQUIRED',
  /** Default value added or changed for the argument. */
  ArgDefaultValueChange = 'ARG_DEFAULT_VALUE_CHANGE',
  /** Description was added, removed, or updated for argument. */
  ArgDescriptionChange = 'ARG_DESCRIPTION_CHANGE',
  /** Argument to a field was removed. */
  ArgRemoved = 'ARG_REMOVED',
  /** Argument to the directive was removed. */
  DirectiveArgRemoved = 'DIRECTIVE_ARG_REMOVED',
  /** Location of the directive was removed. */
  DirectiveLocationRemoved = 'DIRECTIVE_LOCATION_REMOVED',
  /** Directive was removed. */
  DirectiveRemoved = 'DIRECTIVE_REMOVED',
  /** Repeatable flag was removed for directive. */
  DirectiveRepeatableRemoved = 'DIRECTIVE_REPEATABLE_REMOVED',
  /** Enum was deprecated. */
  EnumDeprecated = 'ENUM_DEPRECATED',
  /** Reason for enum deprecation changed. */
  EnumDeprecatedReasonChange = 'ENUM_DEPRECATED_REASON_CHANGE',
  /** Enum deprecation was removed. */
  EnumDeprecationRemoved = 'ENUM_DEPRECATION_REMOVED',
  /** Description was added, removed, or updated for enum value. */
  EnumValueDescriptionChange = 'ENUM_VALUE_DESCRIPTION_CHANGE',
  /** Field was added to the type. */
  FieldAdded = 'FIELD_ADDED',
  /** Return type for the field was changed. */
  FieldChangedType = 'FIELD_CHANGED_TYPE',
  /** Field was deprecated. */
  FieldDeprecated = 'FIELD_DEPRECATED',
  /** Reason for field deprecation changed. */
  FieldDeprecatedReasonChange = 'FIELD_DEPRECATED_REASON_CHANGE',
  /** Field deprecation removed. */
  FieldDeprecationRemoved = 'FIELD_DEPRECATION_REMOVED',
  /** Description was added, removed, or updated for field. */
  FieldDescriptionChange = 'FIELD_DESCRIPTION_CHANGE',
  /** Type of the field in the input object was changed. */
  FieldOnInputObjectChangedType = 'FIELD_ON_INPUT_OBJECT_CHANGED_TYPE',
  /** Field was removed from the type. */
  FieldRemoved = 'FIELD_REMOVED',
  /** Field was removed from the input object. */
  FieldRemovedFromInputObject = 'FIELD_REMOVED_FROM_INPUT_OBJECT',
  /** Non-nullable field was added to the input object. */
  NonNullableFieldAddedToInputObject = 'NON_NULLABLE_FIELD_ADDED_TO_INPUT_OBJECT',
  /** Nullable field was added to the input type. */
  NullableFieldAddedToInputObject = 'NULLABLE_FIELD_ADDED_TO_INPUT_OBJECT',
  /** Nullable argument was added to the field. */
  OptionalArgAdded = 'OPTIONAL_ARG_ADDED',
  /** Non-nullable argument was added to the field. */
  RequiredArgAdded = 'REQUIRED_ARG_ADDED',
  /** Non-nullable argument added to directive. */
  RequiredDirectiveArgAdded = 'REQUIRED_DIRECTIVE_ARG_ADDED',
  /** Type was added to the schema. */
  TypeAdded = 'TYPE_ADDED',
  /** Type now implements the interface. */
  TypeAddedToInterface = 'TYPE_ADDED_TO_INTERFACE',
  /** A new value was added to the enum. */
  TypeAddedToUnion = 'TYPE_ADDED_TO_UNION',
  /**
   * Type was changed from one kind to another.
   * Ex: scalar to object or enum to union.
   */
  TypeChangedKind = 'TYPE_CHANGED_KIND',
  /** Description was added, removed, or updated for type. */
  TypeDescriptionChange = 'TYPE_DESCRIPTION_CHANGE',
  /** Type (object or scalar) was removed from the schema. */
  TypeRemoved = 'TYPE_REMOVED',
  /** Type no longer implements the interface. */
  TypeRemovedFromInterface = 'TYPE_REMOVED_FROM_INTERFACE',
  /** Type is no longer included in the union. */
  TypeRemovedFromUnion = 'TYPE_REMOVED_FROM_UNION',
  /** A new value was added to the enum. */
  ValueAddedToEnum = 'VALUE_ADDED_TO_ENUM',
  /** Value was removed from the enum. */
  ValueRemovedFromEnum = 'VALUE_REMOVED_FROM_ENUM'
}

/**
 * Represents the tuple of static information
 * about a particular kind of schema change.
 */
export type ChangeDefinition = {
  __typename?: 'ChangeDefinition';
  category: ChangeCategory;
  code: ChangeCode;
  defaultSeverity: ChangeSeverity;
};

/** Info about a change in the context of an operation it affects */
export type ChangeOnOperation = {
  __typename?: 'ChangeOnOperation';
  /** Human-readable explanation of the impact of this change on the operation */
  impact?: Maybe<Scalars['String']>;
  /** The semantic info about this change, i.e. info about the change that doesn't depend on the operation */
  semanticChange: SemanticChange;
};

export enum ChangeSeverity {
  Failure = 'FAILURE',
  Notice = 'NOTICE'
}

/**
 * Summary of the changes for a schema diff, computed by placing the changes into categories and then
 * counting the size of each category. This categorization can be done in different ways, and
 * accordingly there are multiple fields here for each type of categorization.
 *
 * Note that if an object or interface field is added/removed, there won't be any addition/removal
 * changes generated for its arguments or @deprecated usages. If an enum type is added/removed, there
 * will be addition/removal changes generated for its values, but not for those values' @deprecated
 * usages. Description changes won't be generated for a schema element if that element (or an
 * ancestor) was added/removed.
 */
export type ChangeSummary = {
  __typename?: 'ChangeSummary';
  /** Counts for changes to fields of objects, input objects, and interfaces. */
  field: FieldChangeSummaryCounts;
  /** Counts for all changes. */
  total: TotalChangeSummaryCounts;
  /**
   * Counts for changes to non-field aspects of objects, input objects, and interfaces,
   * and all aspects of enums, unions, and scalars.
   */
  type: TypeChangeSummaryCounts;
};

export enum ChangeType {
  Failure = 'FAILURE',
  Notice = 'NOTICE'
}

export type ChangelogLaunchResult = {
  __typename?: 'ChangelogLaunchResult';
  createdAt: Scalars['Timestamp'];
  schemaTagID: Scalars['ID'];
};

/** Destination for notifications */
export type Channel = {
  id: Scalars['ID'];
  name: Scalars['String'];
  subscriptions: Array<ChannelSubscription>;
};

export type ChannelSubscription = {
  channels: Array<Channel>;
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  variant?: Maybe<Scalars['String']>;
};

export type CheckConfiguration = {
  __typename?: 'CheckConfiguration';
  /** Time when check configuration was created */
  createdAt: Scalars['Timestamp'];
  /** Clients to ignore during validation */
  excludedClients: Array<ClientFilter>;
  /** Operations to ignore during validation */
  excludedOperations: Array<ExcludedOperation>;
  /** Graph that this check configuration belongs to */
  graphID: Scalars['ID'];
  /** ID of the check configuration */
  id: Scalars['ID'];
  /** Default configuration to include operations on the base variant. */
  includeBaseVariant: Scalars['Boolean'];
  /** Variant overrides for validation */
  includedVariants: Array<Scalars['String']>;
  /** Minimum number of requests within the window for an operation to be considered. */
  operationCountThreshold: Scalars['Int'];
  /**
   * Number of requests within the window for an operation to be considered, relative to
   * total request count. Expected values are between 0 and 0.05 (minimum 5% of
   * total request volume)
   */
  operationCountThresholdPercentage: Scalars['Float'];
  /**
   * Only check operations from the last <timeRangeSeconds> seconds.
   * The default is 7 days (604,800 seconds).
   */
  timeRangeSeconds: Scalars['Long'];
  /** Time when check configuration was last updated */
  updatedAt: Scalars['Timestamp'];
  /** Identity of the last user to update the check configuration */
  updatedBy?: Maybe<Identity>;
};

/** Filter options available when listing checks. */
export type CheckFilterInput = {
  authors?: InputMaybe<Array<Scalars['String']>>;
  branches?: InputMaybe<Array<Scalars['String']>>;
  status?: InputMaybe<CheckFilterInputStatusOption>;
  subgraphs?: InputMaybe<Array<Scalars['String']>>;
};

/** Options for filtering CheckWorkflows by status */
export enum CheckFilterInputStatusOption {
  Failed = 'FAILED',
  Passed = 'PASSED',
  Pending = 'PENDING'
}

export type CheckPartialSchemaResult = {
  __typename?: 'CheckPartialSchemaResult';
  /** Result of traffic validation. This will be null if composition validation was unsuccessful. */
  checkSchemaResult?: Maybe<CheckSchemaResult>;
  /** Result of composition validation run before the schema check. */
  compositionValidationResult: CompositionValidationResult;
  /** Workflow associated with the composition validation. */
  workflow?: Maybe<CheckWorkflow>;
};

export type CheckSchemaResult = {
  __typename?: 'CheckSchemaResult';
  /** Schema diff and affected operations generated by the schema check */
  diffToPrevious: SchemaDiff;
  /** ID of the operations check that was created */
  operationsCheckID: Scalars['ID'];
  /** Generated url to view schema diff in Engine */
  targetUrl?: Maybe<Scalars['String']>;
  /** Workflow associated with this check result */
  workflow?: Maybe<CheckWorkflow>;
};

export type CheckWorkflow = {
  __typename?: 'CheckWorkflow';
  /**
   * The variant provided as a base to check against.  Only the differences from the
   * base schema will be tested in operations checks.
   */
  baseVariant?: Maybe<GraphVariant>;
  completedAt?: Maybe<Scalars['Timestamp']>;
  createdAt: Scalars['Timestamp'];
  /** Contextual parameters supplied by the runtime environment where the check was run. */
  gitContext?: Maybe<GitContext>;
  id: Scalars['ID'];
  /** The name of the implementing service that was responsible for triggering the validation. */
  implementingServiceName?: Maybe<Scalars['String']>;
  /** If this check is triggered for an sdl fetched using introspection, this is the endpoint where that schema was being served. */
  introspectionEndpoint?: Maybe<Scalars['String']>;
  /** Only true if the check was triggered from Sandbox Checks page. */
  isSandboxCheck: Scalars['Boolean'];
  /** If this check was created by rerunning, the original check that was rerun. */
  rerunOf?: Maybe<CheckWorkflow>;
  /** Checks created by re-running this check, most recent first. */
  reruns?: Maybe<Array<CheckWorkflow>>;
  startedAt?: Maybe<Scalars['Timestamp']>;
  /** Overall status of the workflow, based on the underlying task statuses. */
  status: CheckWorkflowStatus;
  /** The set of check tasks associated with this workflow, e.g. OperationsCheck, GraphComposition, etc. */
  tasks: Array<CheckWorkflowTask>;
  /** Configuration of validation at the time the check was run. */
  validationConfig?: Maybe<SchemaDiffValidationConfig>;
};


export type CheckWorkflowRerunsArgs = {
  limit?: Scalars['Int'];
};

export type CheckWorkflowMutation = {
  __typename?: 'CheckWorkflowMutation';
  /** Re-run a check workflow using the current configuration. A new workflow is created and returned. */
  rerun?: Maybe<CheckWorkflowRerunResult>;
};

export type CheckWorkflowRerunResult = {
  __typename?: 'CheckWorkflowRerunResult';
  /** Check workflow created by re-running. */
  result?: Maybe<CheckWorkflow>;
  /** Check workflow that was rerun. */
  source?: Maybe<CheckWorkflow>;
};

export enum CheckWorkflowStatus {
  Failed = 'FAILED',
  Passed = 'PASSED',
  Pending = 'PENDING'
}

export type CheckWorkflowTask = {
  completedAt?: Maybe<Scalars['Timestamp']>;
  createdAt: Scalars['Timestamp'];
  id: Scalars['ID'];
  status: CheckWorkflowTaskStatus;
  /** The workflow that this task belongs to. */
  workflow: CheckWorkflow;
};

export enum CheckWorkflowTaskStatus {
  Blocked = 'BLOCKED',
  Failed = 'FAILED',
  Passed = 'PASSED',
  Pending = 'PENDING'
}

/** Client filter configuration for a graph. */
export type ClientFilter = {
  __typename?: 'ClientFilter';
  /** name of the client set by the user and reported alongside metrics */
  name?: Maybe<Scalars['String']>;
  /** version of the client set by the user and reported alongside metrics */
  version?: Maybe<Scalars['String']>;
};

/**
 * Options to filter by client reference ID, client name, and client version.
 * If passing client version, make sure to either provide a client reference ID or client name.
 */
export type ClientFilterInput = {
  /** name of the client set by the user and reported alongside metrics */
  name?: InputMaybe<Scalars['String']>;
  /** version of the client set by the user and reported alongside metrics */
  version?: InputMaybe<Scalars['String']>;
};

/** Filter options to exclude by client reference ID, client name, and client version. */
export type ClientInfoFilter = {
  name?: InputMaybe<Scalars['String']>;
  /** Ignored */
  referenceID?: InputMaybe<Scalars['ID']>;
  version?: InputMaybe<Scalars['String']>;
};

/** Filter options to exclude clients. Used as an output type for SchemaDiffValidationConfig. */
export type ClientInfoFilterOutput = {
  __typename?: 'ClientInfoFilterOutput';
  name?: Maybe<Scalars['String']>;
  version?: Maybe<Scalars['String']>;
};

export enum ComparisonOperator {
  Equals = 'EQUALS',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEqualTo = 'GREATER_THAN_OR_EQUAL_TO',
  LessThan = 'LESS_THAN',
  LessThanOrEqualTo = 'LESS_THAN_OR_EQUAL_TO',
  NotEquals = 'NOT_EQUALS',
  Unrecognized = 'UNRECOGNIZED'
}

/** Metadata about the result of composition run in the cloud, combined with removing an implementing service */
export type CompositionAndRemoveResult = {
  __typename?: 'CompositionAndRemoveResult';
  /** The produced composition config. Will be null if there are any errors */
  compositionConfig?: Maybe<CompositionConfig>;
  /** Whether the removed implementing service existed. */
  didExist: Scalars['Boolean'];
  /**
   * List of errors during composition. Errors mean that Apollo was unable to compose the
   * graph's implementing services into a GraphQL schema. This partial schema should not be
   * published to the implementing service if there were any errors encountered.
   */
  errors: Array<Maybe<SchemaCompositionError>>;
  /** ID that points to the results of composition. */
  graphCompositionID: Scalars['String'];
  /** List of subgraphs that are included in this composition. */
  subgraphConfigs: Array<SubgraphConfig>;
  /** Whether the gateway link was updated, or would have been for dry runs. */
  updatedGateway: Scalars['Boolean'];
};

/** Metadata about the result of composition run in the cloud, combined with implementing service upsert */
export type CompositionAndUpsertResult = {
  __typename?: 'CompositionAndUpsertResult';
  /** The produced composition config. Will be null if there are any errors */
  compositionConfig?: Maybe<CompositionConfig>;
  /**
   * List of errors during composition. Errors mean that Apollo was unable to compose the
   * graph's implementing services into a GraphQL schema. This partial schema should not be
   * published to the implementing service if there were any errors encountered
   */
  errors: Array<Maybe<SchemaCompositionError>>;
  /** ID that points to the results of composition. */
  graphCompositionID: Scalars['String'];
  /** List of subgraphs that are included in this composition. */
  subgraphConfigs: Array<SubgraphConfig>;
  /** Whether the gateway link was updated. */
  updatedGateway: Scalars['Boolean'];
  /** Whether an implementingService was created as part of this mutation */
  wasCreated: Scalars['Boolean'];
  /** Whether an implementingService was updated as part of this mutation */
  wasUpdated: Scalars['Boolean'];
};

export type CompositionBuildInput = {
  __typename?: 'CompositionBuildInput';
  subgraphs: Array<Subgraph>;
  version?: Maybe<Scalars['String']>;
};

export type CompositionCheckTask = CheckWorkflowTask & {
  __typename?: 'CompositionCheckTask';
  completedAt?: Maybe<Scalars['Timestamp']>;
  createdAt: Scalars['Timestamp'];
  id: Scalars['ID'];
  /** The result of the composition. */
  result?: Maybe<CompositionResult>;
  status: CheckWorkflowTaskStatus;
  workflow: CheckWorkflow;
};

/** The composition config exposed to the gateway */
export type CompositionConfig = {
  __typename?: 'CompositionConfig';
  /**
   * List of GCS links for implementing services that comprise a composed graph. Is empty if tag/inaccessible is enabled.
   * @deprecated Soon we will stop writing to GCS locations
   */
  implementingServiceLocations: Array<ImplementingServiceLocation>;
  /** Hash of the composed schema */
  schemaHash: Scalars['String'];
};

/** Metadata about the result of composition run in the cloud */
export type CompositionPublishResult = CompositionResult & {
  __typename?: 'CompositionPublishResult';
  /** The produced composition config. Will be null if there are any errors */
  compositionConfig?: Maybe<CompositionConfig>;
  /**
   * Supergraph SDL generated by composition (this is not the CSDL, that is a deprecated format).
   * @deprecated Use supergraphSdl instead
   */
  csdl?: Maybe<Scalars['GraphQLDocument']>;
  /**
   * List of errors during composition. Errors mean that Apollo was unable to compose the
   * graph's implementing services into a GraphQL schema. This partial schema should not be
   * published to the implementing service if there were any errors encountered
   */
  errors: Array<SchemaCompositionError>;
  /** ID that points to the results of this composition. */
  graphCompositionID: Scalars['ID'];
  /** List of subgraphs that are included in this composition. */
  subgraphConfigs: Array<SubgraphConfig>;
  /** Supergraph SDL generated by composition. */
  supergraphSdl?: Maybe<Scalars['GraphQLDocument']>;
  /** Whether the gateway link was updated. */
  updatedGateway: Scalars['Boolean'];
  webhookNotificationBody?: Maybe<Scalars['String']>;
};

/** Result of a composition, either as the result of a composition validation or a publish. */
export type CompositionResult = {
  /**
   * Supergraph SDL generated by composition (this is not the CSDL, that is a deprecated format).
   * @deprecated Use supergraphSdl instead
   */
  csdl?: Maybe<Scalars['GraphQLDocument']>;
  /**
   * List of errors during composition. Errors mean that Apollo was unable to compose the
   * graph's implementing services into a GraphQL schema. This partial schema should not be
   * published to the implementing service if there were any errors encountered
   */
  errors: Array<SchemaCompositionError>;
  /** ID that points to the results of this composition. */
  graphCompositionID: Scalars['ID'];
  /** List of subgraphs that are included in this composition. */
  subgraphConfigs: Array<SubgraphConfig>;
  /** Supergraph SDL generated by composition. */
  supergraphSdl?: Maybe<Scalars['GraphQLDocument']>;
};

export type CompositionStatusSubscription = ChannelSubscription & {
  __typename?: 'CompositionStatusSubscription';
  channels: Array<Channel>;
  createdAt: Scalars['Timestamp'];
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  lastUpdatedAt: Scalars['Timestamp'];
  variant?: Maybe<Scalars['String']>;
};

/** The composition config exposed to the gateway */
export type CompositionValidationDetails = {
  __typename?: 'CompositionValidationDetails';
  /** List of implementing service partial schemas that comprised the graph composed during validation */
  implementingServices: Array<FederatedImplementingServicePartialSchema>;
  /** Hash of the composed schema */
  schemaHash?: Maybe<Scalars['String']>;
};

/** Metadata about the result of compositions validation run in the cloud */
export type CompositionValidationResult = CompositionResult & {
  __typename?: 'CompositionValidationResult';
  /** Describes whether composition succeeded. */
  compositionSuccess: Scalars['Boolean'];
  /**
   * Akin to a composition config, represents the partial schemas and implementing services that were used
   * in running composition. Will be null if any errors are encountered. Also may contain a schema hash if
   * one could be computed, which can be used for schema validation.
   */
  compositionValidationDetails?: Maybe<CompositionValidationDetails>;
  /**
   * Supergraph SDL generated by composition (this is not the CSDL, that is a deprecated format).
   * @deprecated Use supergraphSdl instead
   */
  csdl?: Maybe<Scalars['GraphQLDocument']>;
  /**
   * List of errors during composition. Errors mean that Apollo was unable to compose the
   * graph's implementing services into a GraphQL schema. This partial schema should not be
   * published to the implementing service if there were any errors encountered
   */
  errors: Array<SchemaCompositionError>;
  /** ID that points to the results of this composition. */
  graphCompositionID: Scalars['ID'];
  /** The implementing service that was responsible for triggering the validation */
  proposedImplementingService: FederatedImplementingServicePartialSchema;
  /** List of subgraphs that are included in this composition. */
  subgraphConfigs: Array<SubgraphConfig>;
  /** Supergraph SDL generated by composition. */
  supergraphSdl?: Maybe<Scalars['GraphQLDocument']>;
  /** If created as part of a check workflow, the associated workflow task. */
  workflowTask?: Maybe<CompositionCheckTask>;
};

export enum ContractVariantFailedStep {
  AddDirectiveDefinitionsIfNotPresent = 'ADD_DIRECTIVE_DEFINITIONS_IF_NOT_PRESENT',
  DirectiveDefinitionLocationAugmenting = 'DIRECTIVE_DEFINITION_LOCATION_AUGMENTING',
  EmptyObjectAndInterfaceMasking = 'EMPTY_OBJECT_AND_INTERFACE_MASKING',
  EmptyUnionMasking = 'EMPTY_UNION_MASKING',
  InputValidation = 'INPUT_VALIDATION',
  Parsing = 'PARSING',
  ParsingTagDirectives = 'PARSING_TAG_DIRECTIVES',
  PartialInterfaceMasking = 'PARTIAL_INTERFACE_MASKING',
  SchemaRetrieval = 'SCHEMA_RETRIEVAL',
  TagInheriting = 'TAG_INHERITING',
  TagMatching = 'TAG_MATCHING',
  ToApiSchema = 'TO_API_SCHEMA',
  ToFilterSchema = 'TO_FILTER_SCHEMA',
  Unknown = 'UNKNOWN',
  VersionCheck = 'VERSION_CHECK'
}

export type ContractVariantPreviewErrors = {
  __typename?: 'ContractVariantPreviewErrors';
  errorMessages: Array<Scalars['String']>;
  failedStep: ContractVariantFailedStep;
};

export type ContractVariantPreviewResult = ContractVariantPreviewErrors | ContractVariantPreviewSuccess;

export type ContractVariantPreviewSuccess = {
  __typename?: 'ContractVariantPreviewSuccess';
  allTags: Array<Scalars['String']>;
  baseApiSchema: Scalars['String'];
  baseCoreSchema: Scalars['String'];
  contractApiSchema: Scalars['String'];
  contractCoreSchema: Scalars['String'];
};

export type ContractVariantUpsertErrors = {
  __typename?: 'ContractVariantUpsertErrors';
  errorMessages: Array<Scalars['String']>;
};

export type ContractVariantUpsertResult = ContractVariantUpsertErrors | ContractVariantUpsertSuccess;

export type ContractVariantUpsertSuccess = {
  __typename?: 'ContractVariantUpsertSuccess';
  contractVariant: GraphVariant;
};

export type CoreSchema = {
  __typename?: 'CoreSchema';
  apiDocument: Scalars['GraphQLDocument'];
  coreDocument: Scalars['GraphQLDocument'];
  coreHash: Scalars['String'];
};

export type CreateOperationCollectionResult = OperationCollection | ValidationError;

export type CronExecution = {
  __typename?: 'CronExecution';
  completedAt?: Maybe<Scalars['Timestamp']>;
  failure?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  job: CronJob;
  resolvedAt?: Maybe<Scalars['Timestamp']>;
  resolvedBy?: Maybe<Actor>;
  schedule: Scalars['String'];
  startedAt: Scalars['Timestamp'];
};

export type CronJob = {
  __typename?: 'CronJob';
  group: Scalars['String'];
  name: Scalars['String'];
  recentExecutions: Array<CronExecution>;
};


export type CronJobRecentExecutionsArgs = {
  n?: InputMaybe<Scalars['Int']>;
};

export enum DatadogApiRegion {
  Eu = 'EU',
  Eu1 = 'EU1',
  Us = 'US',
  Us1 = 'US1',
  Us1Fed = 'US1FED',
  Us3 = 'US3',
  Us5 = 'US5'
}

export type DatadogMetricsConfig = {
  __typename?: 'DatadogMetricsConfig';
  apiKey: Scalars['String'];
  apiRegion: DatadogApiRegion;
  enabled: Scalars['Boolean'];
  legacyMetricNames: Scalars['Boolean'];
};

export type DeleteOperationCollectionSuccess = {
  __typename?: 'DeleteOperationCollectionSuccess';
  variants: Array<GraphVariant>;
};

export type DeleteSchemaTagResult = {
  __typename?: 'DeleteSchemaTagResult';
  deleted: Scalars['Boolean'];
  deletedSubscriptionIDs: Array<Scalars['ID']>;
};

export enum DeletionTargetType {
  Account = 'ACCOUNT',
  User = 'USER'
}

/** Support for a single directive on a graph variant */
export type DirectiveSupportStatus = {
  __typename?: 'DirectiveSupportStatus';
  /** whether the directive is supported on the current graph variant */
  enabled: Scalars['Boolean'];
  /** name of the directive */
  name: Scalars['String'];
};

export type DurationHistogram = {
  __typename?: 'DurationHistogram';
  averageDurationMs?: Maybe<Scalars['Float']>;
  buckets: Array<DurationHistogramBucket>;
  durationMs?: Maybe<Scalars['Float']>;
  /** Counts per durationBucket, where sequences of zeroes are replaced with the negative of their size */
  sparseBuckets: Array<Scalars['Long']>;
  totalCount: Scalars['Long'];
  totalDurationMs: Scalars['Float'];
};


export type DurationHistogramDurationMsArgs = {
  percentile: Scalars['Float'];
};

export type DurationHistogramBucket = {
  __typename?: 'DurationHistogramBucket';
  count: Scalars['Long'];
  index: Scalars['Int'];
  rangeBeginMs: Scalars['Float'];
  rangeEndMs: Scalars['Float'];
};

export type EdgeServerInfo = {
  /** A randomly generated UUID, immutable for the lifetime of the edge server runtime. */
  bootId: Scalars['String'];
  /** A unique identifier for the executable GraphQL served by the edge server. length must be <= 64 characters. */
  executableSchemaId: Scalars['String'];
  /** The graph variant, defaults to 'current' */
  graphVariant?: Scalars['String'];
  /** The version of the edge server reporting agent, e.g. apollo-server-2.8, graphql-java-3.1, etc. length must be <= 256 characters. */
  libraryVersion?: InputMaybe<Scalars['String']>;
  /** The infra environment in which this edge server is running, e.g. localhost, Kubernetes, AWS Lambda, Google CloudRun, AWS ECS, etc. length must be <= 256 characters. */
  platform?: InputMaybe<Scalars['String']>;
  /** The runtime in which the edge server is running, e.g. node 12.03, zulu8.46.0.19-ca-jdk8.0.252-macosx_x64, etc. length must be <= 256 characters. */
  runtimeVersion?: InputMaybe<Scalars['String']>;
  /** If available, an identifier for the edge server instance, such that when restarting this instance it will have the same serverId, with a different bootId. For example, in Kubernetes this might be the pod name. Length must be <= 256 characters. */
  serverId?: InputMaybe<Scalars['String']>;
  /** An identifier used to distinguish the version (from the user's perspective) of the edge server's code itself. For instance, the git sha of the server's repository or the docker sha of the associated image this server runs with. Length must be <= 256 characters. */
  userVersion?: InputMaybe<Scalars['String']>;
};

/** Columns of EdgeServerInfos. */
export enum EdgeServerInfosColumn {
  BootId = 'BOOT_ID',
  ExecutableSchemaId = 'EXECUTABLE_SCHEMA_ID',
  LibraryVersion = 'LIBRARY_VERSION',
  Platform = 'PLATFORM',
  RuntimeVersion = 'RUNTIME_VERSION',
  SchemaTag = 'SCHEMA_TAG',
  ServerId = 'SERVER_ID',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  UserVersion = 'USER_VERSION'
}

export type EdgeServerInfosDimensions = {
  __typename?: 'EdgeServerInfosDimensions';
  bootId?: Maybe<Scalars['ID']>;
  executableSchemaId?: Maybe<Scalars['ID']>;
  libraryVersion?: Maybe<Scalars['String']>;
  platform?: Maybe<Scalars['String']>;
  runtimeVersion?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serverId?: Maybe<Scalars['ID']>;
  serviceId?: Maybe<Scalars['ID']>;
  userVersion?: Maybe<Scalars['String']>;
};

/** Filter for data in EdgeServerInfos. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type EdgeServerInfosFilter = {
  and?: InputMaybe<Array<EdgeServerInfosFilter>>;
  /** Selects rows whose bootId dimension equals the given value if not null. To query for the null value, use {in: {bootId: [null]}} instead. */
  bootId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose executableSchemaId dimension equals the given value if not null. To query for the null value, use {in: {executableSchemaId: [null]}} instead. */
  executableSchemaId?: InputMaybe<Scalars['ID']>;
  in?: InputMaybe<EdgeServerInfosFilterIn>;
  /** Selects rows whose libraryVersion dimension equals the given value if not null. To query for the null value, use {in: {libraryVersion: [null]}} instead. */
  libraryVersion?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<EdgeServerInfosFilter>;
  or?: InputMaybe<Array<EdgeServerInfosFilter>>;
  /** Selects rows whose platform dimension equals the given value if not null. To query for the null value, use {in: {platform: [null]}} instead. */
  platform?: InputMaybe<Scalars['String']>;
  /** Selects rows whose runtimeVersion dimension equals the given value if not null. To query for the null value, use {in: {runtimeVersion: [null]}} instead. */
  runtimeVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serverId dimension equals the given value if not null. To query for the null value, use {in: {serverId: [null]}} instead. */
  serverId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose userVersion dimension equals the given value if not null. To query for the null value, use {in: {userVersion: [null]}} instead. */
  userVersion?: InputMaybe<Scalars['String']>;
};

/** Filter for data in EdgeServerInfos. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type EdgeServerInfosFilterIn = {
  /** Selects rows whose bootId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  bootId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose executableSchemaId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  executableSchemaId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose libraryVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  libraryVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose platform dimension is in the given list. A null value in the list means a row with null for that dimension. */
  platform?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose runtimeVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  runtimeVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serverId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serverId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose userVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  userVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type EdgeServerInfosOrderBySpec = {
  column: EdgeServerInfosColumn;
  direction: Ordering;
};

export type EdgeServerInfosRecord = {
  __typename?: 'EdgeServerInfosRecord';
  /** Dimensions of EdgeServerInfos that can be grouped by. */
  groupBy: EdgeServerInfosDimensions;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export enum EmailCategory {
  Educational = 'EDUCATIONAL'
}

export type EmailPreferences = {
  __typename?: 'EmailPreferences';
  email: Scalars['String'];
  subscriptions: Array<EmailCategory>;
  unsubscribedFromAll: Scalars['Boolean'];
};

export type Error = {
  message: Scalars['String'];
};

/** Columns of ErrorStats. */
export enum ErrorStatsColumn {
  AccountId = 'ACCOUNT_ID',
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  ErrorsCount = 'ERRORS_COUNT',
  Path = 'PATH',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  RequestsWithErrorsCount = 'REQUESTS_WITH_ERRORS_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP'
}

export type ErrorStatsDimensions = {
  __typename?: 'ErrorStatsDimensions';
  accountId?: Maybe<Scalars['ID']>;
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in ErrorStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ErrorStatsFilter = {
  /** Selects rows whose accountId dimension equals the given value if not null. To query for the null value, use {in: {accountId: [null]}} instead. */
  accountId?: InputMaybe<Scalars['ID']>;
  and?: InputMaybe<Array<ErrorStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<ErrorStatsFilterIn>;
  not?: InputMaybe<ErrorStatsFilter>;
  or?: InputMaybe<Array<ErrorStatsFilter>>;
  /** Selects rows whose path dimension equals the given value if not null. To query for the null value, use {in: {path: [null]}} instead. */
  path?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in ErrorStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ErrorStatsFilterIn = {
  /** Selects rows whose accountId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  accountId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose path dimension is in the given list. A null value in the list means a row with null for that dimension. */
  path?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type ErrorStatsMetrics = {
  __typename?: 'ErrorStatsMetrics';
  errorsCount: Scalars['Long'];
  requestsWithErrorsCount: Scalars['Long'];
};

export type ErrorStatsOrderBySpec = {
  column: ErrorStatsColumn;
  direction: Ordering;
};

export type ErrorStatsRecord = {
  __typename?: 'ErrorStatsRecord';
  /** Dimensions of ErrorStats that can be grouped by. */
  groupBy: ErrorStatsDimensions;
  /** Metrics of ErrorStats that can be aggregated over. */
  metrics: ErrorStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/**  Input parameters for run explorer operation event. */
export enum EventEnum {
  ClickCheckList = 'CLICK_CHECK_LIST',
  ClickGoToGraphSettings = 'CLICK_GO_TO_GRAPH_SETTINGS',
  RunExplorerOperation = 'RUN_EXPLORER_OPERATION'
}

/** Excluded operation for a graph. */
export type ExcludedOperation = {
  __typename?: 'ExcludedOperation';
  /** Operation ID to exclude from schema check. */
  ID: Scalars['ID'];
};

/** Option to filter by operation ID. */
export type ExcludedOperationInput = {
  /** Operation ID to exclude from schema check. */
  ID: Scalars['ID'];
};

export type FeatureIntros = {
  __typename?: 'FeatureIntros';
  devGraph: Scalars['Boolean'];
  federatedGraph: Scalars['Boolean'];
  freeConsumerSeats: Scalars['Boolean'];
};

/** Feature Intros Input Type */
export type FeatureIntrosInput = {
  devGraph?: InputMaybe<Scalars['Boolean']>;
  federatedGraph?: InputMaybe<Scalars['Boolean']>;
  freeConsumerSeats?: InputMaybe<Scalars['Boolean']>;
};

export type FederatedImplementingService = {
  __typename?: 'FederatedImplementingService';
  /**
   * An implementing service could have multiple inactive partial schemas that were previously uploaded
   * activePartialSchema returns the one that is designated to be used for composition for a given graph-variant
   */
  activePartialSchema: PartialSchema;
  /** Timestamp of when this implementing service was created */
  createdAt: Scalars['Timestamp'];
  /**
   * Identifies which graph this implementing service belongs to.
   * Formerly known as "service_id"
   */
  graphID: Scalars['String'];
  /**
   * Specifies which variant of a graph this implementing service belongs to".
   * Formerly known as "tag"
   */
  graphVariant: Scalars['String'];
  /** Name of the implementing service */
  name: Scalars['String'];
  /**
   * A way to capture some customer-specific way of tracking which version / edition
   * of the ImplementingService this is. Typically a Git SHA or docker image ID.
   */
  revision: Scalars['String'];
  /** Timestamp for when this implementing service was updated */
  updatedAt: Scalars['Timestamp'];
  /** URL of the graphql endpoint of the implementing service */
  url?: Maybe<Scalars['String']>;
};

/** A minimal representation of a federated implementing service, using only a name and partial schema SDL */
export type FederatedImplementingServicePartialSchema = {
  __typename?: 'FederatedImplementingServicePartialSchema';
  /** The name of the implementing service */
  name: Scalars['String'];
  /** The partial schema of the implementing service */
  sdl: Scalars['String'];
};

/** List of federated implementing services that compose a graph */
export type FederatedImplementingServices = {
  __typename?: 'FederatedImplementingServices';
  services: Array<FederatedImplementingService>;
};

export type FieldChangeSummaryCounts = {
  __typename?: 'FieldChangeSummaryCounts';
  /** Number of changes that are additions of fields to object and interface types. */
  additions: Scalars['Int'];
  /**
   * Number of changes that are field edits. This includes fields changing type and any field
   * deprecation and description changes, but also includes any argument changes and any input object
   * field changes.
   */
  edits: Scalars['Int'];
  /** Number of changes that are removals of fields from object and interface types. */
  removals: Scalars['Int'];
};

/** Columns of FieldLatencies. */
export enum FieldLatenciesColumn {
  FieldHistogram = 'FIELD_HISTOGRAM',
  FieldName = 'FIELD_NAME',
  ParentType = 'PARENT_TYPE',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP'
}

export type FieldLatenciesDimensions = {
  __typename?: 'FieldLatenciesDimensions';
  field?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  parentType?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in FieldLatencies. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type FieldLatenciesFilter = {
  and?: InputMaybe<Array<FieldLatenciesFilter>>;
  /** Selects rows whose fieldName dimension equals the given value if not null. To query for the null value, use {in: {fieldName: [null]}} instead. */
  fieldName?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<FieldLatenciesFilterIn>;
  not?: InputMaybe<FieldLatenciesFilter>;
  or?: InputMaybe<Array<FieldLatenciesFilter>>;
  /** Selects rows whose parentType dimension equals the given value if not null. To query for the null value, use {in: {parentType: [null]}} instead. */
  parentType?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in FieldLatencies. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type FieldLatenciesFilterIn = {
  /** Selects rows whose fieldName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fieldName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose parentType dimension is in the given list. A null value in the list means a row with null for that dimension. */
  parentType?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type FieldLatenciesMetrics = {
  __typename?: 'FieldLatenciesMetrics';
  fieldHistogram: DurationHistogram;
};

export type FieldLatenciesOrderBySpec = {
  column: FieldLatenciesColumn;
  direction: Ordering;
};

export type FieldLatenciesRecord = {
  __typename?: 'FieldLatenciesRecord';
  /** Dimensions of FieldLatencies that can be grouped by. */
  groupBy: FieldLatenciesDimensions;
  /** Metrics of FieldLatencies that can be aggregated over. */
  metrics: FieldLatenciesMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of FieldUsage. */
export enum FieldUsageColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  EstimatedExecutionCount = 'ESTIMATED_EXECUTION_COUNT',
  ExecutionCount = 'EXECUTION_COUNT',
  Field = 'FIELD',
  FieldName = 'FIELD_NAME',
  ParentType = 'PARENT_TYPE',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  ReferencingOperationCount = 'REFERENCING_OPERATION_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP'
}

export type FieldUsageDimensions = {
  __typename?: 'FieldUsageDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  field?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  parentType?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in FieldUsage. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type FieldUsageFilter = {
  and?: InputMaybe<Array<FieldUsageFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose field dimension equals the given value if not null. To query for the null value, use {in: {field: [null]}} instead. */
  field?: InputMaybe<Scalars['String']>;
  /** Selects rows whose fieldName dimension equals the given value if not null. To query for the null value, use {in: {fieldName: [null]}} instead. */
  fieldName?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<FieldUsageFilterIn>;
  not?: InputMaybe<FieldUsageFilter>;
  or?: InputMaybe<Array<FieldUsageFilter>>;
  /** Selects rows whose parentType dimension equals the given value if not null. To query for the null value, use {in: {parentType: [null]}} instead. */
  parentType?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in FieldUsage. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type FieldUsageFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose field dimension is in the given list. A null value in the list means a row with null for that dimension. */
  field?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose fieldName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fieldName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose parentType dimension is in the given list. A null value in the list means a row with null for that dimension. */
  parentType?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type FieldUsageMetrics = {
  __typename?: 'FieldUsageMetrics';
  estimatedExecutionCount: Scalars['Long'];
  executionCount: Scalars['Long'];
  referencingOperationCount: Scalars['Long'];
};

export type FieldUsageOrderBySpec = {
  column: FieldUsageColumn;
  direction: Ordering;
};

export type FieldUsageRecord = {
  __typename?: 'FieldUsageRecord';
  /** Dimensions of FieldUsage that can be grouped by. */
  groupBy: FieldUsageDimensions;
  /** Metrics of FieldUsage that can be aggregated over. */
  metrics: FieldUsageMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type FilterBuildInput = {
  __typename?: 'FilterBuildInput';
  filterConfig: FilterConfig;
  schemaHash: Scalars['String'];
};

export type FilterConfig = {
  __typename?: 'FilterConfig';
  exclude: Array<Scalars['String']>;
  include: Array<Scalars['String']>;
};

export type FilterConfigInput = {
  exclude: Array<Scalars['String']>;
  include: Array<Scalars['String']>;
};

export type GitContext = {
  __typename?: 'GitContext';
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['ID']>;
  commitUrl?: Maybe<Scalars['String']>;
  committer?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  remoteHost?: Maybe<GitRemoteHost>;
  remoteUrl?: Maybe<Scalars['String']>;
};

/** This is stored with a schema when it is uploaded */
export type GitContextInput = {
  branch?: InputMaybe<Scalars['String']>;
  commit?: InputMaybe<Scalars['ID']>;
  committer?: InputMaybe<Scalars['String']>;
  message?: InputMaybe<Scalars['String']>;
  remoteUrl?: InputMaybe<Scalars['String']>;
};

export enum GitRemoteHost {
  Bitbucket = 'BITBUCKET',
  Github = 'GITHUB',
  Gitlab = 'GITLAB'
}

export type GlobalExperimentalFeatures = {
  __typename?: 'GlobalExperimentalFeatures';
  operationsCollections: Scalars['Boolean'];
  sandboxesFullRelease: Scalars['Boolean'];
  sandboxesPreview: Scalars['Boolean'];
  sandboxesSchemaChecksPage: Scalars['Boolean'];
  sandboxesSchemaDiffPage: Scalars['Boolean'];
};

export type GraphApiKey = ApiKey & {
  __typename?: 'GraphApiKey';
  createdAt: Scalars['Timestamp'];
  createdBy?: Maybe<Identity>;
  id: Scalars['ID'];
  keyName?: Maybe<Scalars['String']>;
  role: UserPermission;
  token: Scalars['String'];
};

/** A union of all combinations that can comprise the implementingServices for a Service */
export type GraphImplementors = FederatedImplementingServices | NonFederatedImplementingService;

/** A variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariant = {
  __typename?: 'GraphVariant';
  /** As new schema tags keep getting published, activeSchemaPublish refers to the latest. */
  activeSchemaPublish?: Maybe<SchemaTag>;
  /** The version of composition currently in use */
  compositionVersion: Scalars['String'];
  /** Filter configuration used to create the contract schema */
  contractFilterConfig?: Maybe<FilterConfig>;
  /** Explorer setting for default headers for a graph */
  defaultHeaders?: Maybe<Scalars['String']>;
  derivedVariantCount: Scalars['Int'];
  /** Graph the variant belongs to */
  graph: Service;
  /** Graph ID of the variant. Prefer using graph { id } when feasible. */
  graphId: Scalars['String'];
  /** Global identifier for the graph variant, in the form `graph@variant`. */
  id: Scalars['ID'];
  /** Represents whether this variant is a Contract. */
  isContract: Scalars['Boolean'];
  /** Is this variant one of the current user's favorite variants? */
  isFavoriteOfCurrentUser: Scalars['Boolean'];
  /** If the variant has a composition */
  isFederated: Scalars['Boolean'];
  /** If the variant is protected */
  isProtected: Scalars['Boolean'];
  isPublic: Scalars['Boolean'];
  /** Represents whether this variant should be listed in the public variants directory. This can only be true if the variant is also public. */
  isPubliclyListed: Scalars['Boolean'];
  /** Represents whether Apollo has verified the authenticity of this public variant. This can only be true if the variant is also public. */
  isVerified: Scalars['Boolean'];
  latestLaunch?: Maybe<Launch>;
  launch?: Maybe<Launch>;
  launchHistory: Array<Launch>;
  links?: Maybe<Array<LinkInfo>>;
  /** Name of the variant, like `variant`. */
  name: Scalars['String'];
  operationCollections: Array<OperationCollection>;
  /** Which permissions the current user has for interacting with this variant */
  permissions: GraphVariantPermissions;
  /** Explorer setting for preflight script to run before the actual GraphQL operations is run. */
  preflightScript?: Maybe<Scalars['String']>;
  readme?: Maybe<Readme>;
  /** Registry stats for this particular graph variant */
  registryStatsWindow?: Maybe<RegistryStatsWindow>;
  /** The total number of requests for this variant in the last 24 hours */
  requestsInLastDay?: Maybe<Scalars['Long']>;
  /** If the graphql endpoint is set up to accept cookies */
  sendCookies?: Maybe<Scalars['Boolean']>;
  sourceVariant?: Maybe<GraphVariant>;
  /** URL where the graph subscription can be queried. */
  subscriptionUrl?: Maybe<Scalars['String']>;
  /** A list of supported directives */
  supportedDirectives?: Maybe<Array<DirectiveSupportStatus>>;
  /** URL where the graph can be queried. */
  url?: Maybe<Scalars['String']>;
  /** The last instant that usage information (e.g. operation stat, client stats) was reported for this variant */
  usageLastReportedAt?: Maybe<Scalars['Timestamp']>;
};


/** A variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantLaunchArgs = {
  id: Scalars['ID'];
};


/** A variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantLaunchHistoryArgs = {
  limit?: Scalars['Int'];
};


/** A variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantRegistryStatsWindowArgs = {
  from: Scalars['Timestamp'];
  resolution?: InputMaybe<Resolution>;
  to?: InputMaybe<Scalars['Timestamp']>;
};

export type GraphVariantLookup = GraphVariant | InvalidRefFormat;

/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutation = {
  __typename?: 'GraphVariantMutation';
  addLinkToVariant: GraphVariant;
  configureComposition?: Maybe<GraphVariant>;
  /** @deprecated Use configureComposition instead */
  enableTagAndInaccessible?: Maybe<GraphVariant>;
  /** Graph ID of the variant */
  graphId: Scalars['String'];
  /** Global identifier for the graph variant, in the form `graph@variant`. */
  id: Scalars['ID'];
  /** Name of the variant, like `variant`. */
  name: Scalars['String'];
  relaunch: RelaunchResult;
  removeLinkFromVariant: GraphVariant;
  setIsFavoriteOfCurrentUser: GraphVariant;
  updateDefaultHeaders?: Maybe<GraphVariant>;
  updateIsProtected?: Maybe<GraphVariant>;
  updatePreflightScript?: Maybe<GraphVariant>;
  updateSendCookies?: Maybe<GraphVariant>;
  updateSubscriptionURL?: Maybe<GraphVariant>;
  updateURL?: Maybe<GraphVariant>;
  updateVariantIsPublic?: Maybe<GraphVariant>;
  updateVariantIsPubliclyListed?: Maybe<GraphVariant>;
  updateVariantIsVerified?: Maybe<GraphVariant>;
  updateVariantReadme?: Maybe<GraphVariant>;
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationAddLinkToVariantArgs = {
  title?: InputMaybe<Scalars['String']>;
  type: LinkInfoType;
  url: Scalars['String'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationConfigureCompositionArgs = {
  enableTagAndInaccessible?: InputMaybe<Scalars['Boolean']>;
  version?: InputMaybe<Scalars['String']>;
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationEnableTagAndInaccessibleArgs = {
  enabled: Scalars['Boolean'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationRemoveLinkFromVariantArgs = {
  linkInfoId: Scalars['ID'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationSetIsFavoriteOfCurrentUserArgs = {
  favorite: Scalars['Boolean'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateDefaultHeadersArgs = {
  defaultHeaders?: InputMaybe<Scalars['String']>;
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateIsProtectedArgs = {
  isProtected: Scalars['Boolean'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdatePreflightScriptArgs = {
  preflightScript?: InputMaybe<Scalars['String']>;
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateSendCookiesArgs = {
  sendCookies: Scalars['Boolean'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateSubscriptionUrlArgs = {
  subscriptionUrl?: InputMaybe<Scalars['String']>;
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateUrlArgs = {
  url?: InputMaybe<Scalars['String']>;
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateVariantIsPublicArgs = {
  isPublic: Scalars['Boolean'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateVariantIsPubliclyListedArgs = {
  isPubliclyListed: Scalars['Boolean'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateVariantIsVerifiedArgs = {
  isVerified: Scalars['Boolean'];
};


/** Modifies a variant of a graph, also called a schema tag in parts of our product. */
export type GraphVariantMutationUpdateVariantReadmeArgs = {
  readme: Scalars['String'];
};

/** A map from permission String to boolean that the current user is allowed for the root graph variant */
export type GraphVariantPermissions = {
  __typename?: 'GraphVariantPermissions';
  canManageBuildConfig: Scalars['Boolean'];
  canManageExplorerSettings: Scalars['Boolean'];
  canPushSchemas: Scalars['Boolean'];
  canQueryBuildConfig: Scalars['Boolean'];
  /**
   * Whether the current user can access the schema for this variant. This will be anded with
   * the ServiceRoles.canQuerySchemas, this will be true when the service schema permission is
   * false for Services with public variants
   */
  canQuerySchemas: Scalars['Boolean'];
  canUpdateVariantLinkInfo: Scalars['Boolean'];
  canUpdateVariantReadme: Scalars['Boolean'];
};

export enum HttpMethod {
  Connect = 'CONNECT',
  Delete = 'DELETE',
  Get = 'GET',
  Head = 'HEAD',
  Options = 'OPTIONS',
  Patch = 'PATCH',
  Post = 'POST',
  Put = 'PUT',
  Trace = 'TRACE',
  Unknown = 'UNKNOWN',
  Unrecognized = 'UNRECOGNIZED'
}

export type HistoricQueryParameters = {
  /** A list of clients to filter out during validation. */
  excludedClients?: InputMaybe<Array<ClientInfoFilter>>;
  from?: InputMaybe<Scalars['Timestamp']>;
  /** A list of operation IDs to filter out during validation. */
  ignoredOperations?: InputMaybe<Array<Scalars['ID']>>;
  /**
   * A list of variants to include in the validation. If no variants are provided
   * then this defaults to the "current" variant along with the base variant. The
   * base variant indicates the schema that generates diff and marks the metrics that
   * are checked for broken queries. We union this base variant with the untagged values('',
   * same as null inside of `in`, and 'current') in this metrics fetch. This strategy
   * supports users who have not tagged their metrics or schema.
   */
  includedVariants?: InputMaybe<Array<Scalars['String']>>;
  /** Minimum number of requests within the window for a query to be considered. */
  queryCountThreshold?: InputMaybe<Scalars['Int']>;
  /**
   * Number of requests within the window for a query to be considered, relative to
   * total request count. Expected values are between 0 and 0.05 (minimum 5% of total
   * request volume)
   */
  queryCountThresholdPercentage?: InputMaybe<Scalars['Float']>;
  to?: InputMaybe<Scalars['Timestamp']>;
};

export type Identity = {
  asActor: Actor;
  id: Scalars['ID'];
  name: Scalars['String'];
};

/** An actor's identity and info about the client they used to perform the action */
export type IdentityAndClientInfo = {
  __typename?: 'IdentityAndClientInfo';
  /** The clientName given to Apollo Cloud when the actor performed the action */
  clientName?: Maybe<Scalars['String']>;
  /** The clientVersion given to Apollo Cloud when the actor performed the action */
  clientVersion?: Maybe<Scalars['String']>;
  /** Identity info about the actor */
  identity?: Maybe<Identity>;
};

export type IdentityMutation = ServiceMutation | UserMutation;

export type IgnoreOperationsInChecksResult = {
  __typename?: 'IgnoreOperationsInChecksResult';
  graph: Service;
};

/** The location of the implementing service config file in storage */
export type ImplementingServiceLocation = {
  __typename?: 'ImplementingServiceLocation';
  /** The name of the implementing service */
  name: Scalars['String'];
  /** The path in storage to access the implementing service config file */
  path: Scalars['String'];
};

export type InternalAdminUser = {
  __typename?: 'InternalAdminUser';
  role: InternalMdgAdminRole;
  userID: Scalars['String'];
};

export type InternalIdentity = Identity & {
  __typename?: 'InternalIdentity';
  accounts: Array<Account>;
  asActor: Actor;
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
};

export enum InternalMdgAdminRole {
  InternalMdgReadOnly = 'INTERNAL_MDG_READ_ONLY',
  InternalMdgSales = 'INTERNAL_MDG_SALES',
  InternalMdgSuperAdmin = 'INTERNAL_MDG_SUPER_ADMIN',
  InternalMdgSupport = 'INTERNAL_MDG_SUPPORT'
}

export type IntrospectionDirective = {
  __typename?: 'IntrospectionDirective';
  args: Array<IntrospectionInputValue>;
  description?: Maybe<Scalars['String']>;
  locations: Array<IntrospectionDirectiveLocation>;
  name: Scalars['String'];
};

export type IntrospectionDirectiveInput = {
  args: Array<IntrospectionInputValueInput>;
  description?: InputMaybe<Scalars['String']>;
  isRepeatable?: InputMaybe<Scalars['Boolean']>;
  locations: Array<IntrospectionDirectiveLocation>;
  name: Scalars['String'];
};

/** __DirectiveLocation introspection type */
export enum IntrospectionDirectiveLocation {
  /** Location adjacent to an argument definition. */
  ArgumentDefinition = 'ARGUMENT_DEFINITION',
  /** Location adjacent to an enum definition. */
  Enum = 'ENUM',
  /** Location adjacent to an enum value definition. */
  EnumValue = 'ENUM_VALUE',
  /** Location adjacent to a field. */
  Field = 'FIELD',
  /** Location adjacent to a field definition. */
  FieldDefinition = 'FIELD_DEFINITION',
  /** Location adjacent to a fragment definition. */
  FragmentDefinition = 'FRAGMENT_DEFINITION',
  /** Location adjacent to a fragment spread. */
  FragmentSpread = 'FRAGMENT_SPREAD',
  /** Location adjacent to an inline fragment. */
  InlineFragment = 'INLINE_FRAGMENT',
  /** Location adjacent to an input object field definition. */
  InputFieldDefinition = 'INPUT_FIELD_DEFINITION',
  /** Location adjacent to an input object type definition. */
  InputObject = 'INPUT_OBJECT',
  /** Location adjacent to an interface definition. */
  Interface = 'INTERFACE',
  /** Location adjacent to a mutation operation. */
  Mutation = 'MUTATION',
  /** Location adjacent to an object type definition. */
  Object = 'OBJECT',
  /** Location adjacent to a query operation. */
  Query = 'QUERY',
  /** Location adjacent to a scalar definition. */
  Scalar = 'SCALAR',
  /** Location adjacent to a schema definition. */
  Schema = 'SCHEMA',
  /** Location adjacent to a subscription operation. */
  Subscription = 'SUBSCRIPTION',
  /** Location adjacent to a union definition. */
  Union = 'UNION',
  /** Location adjacent to a variable definition. */
  VariableDefinition = 'VARIABLE_DEFINITION'
}

/** Values associated with introspection result for an enum value */
export type IntrospectionEnumValue = {
  __typename?: 'IntrospectionEnumValue';
  /** @deprecated Use deprecationReason instead */
  depreactionReason?: Maybe<Scalars['String']>;
  deprecationReason?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  isDeprecated: Scalars['Boolean'];
  name: Scalars['String'];
};

/** __EnumValue introspection type */
export type IntrospectionEnumValueInput = {
  deprecationReason?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isDeprecated: Scalars['Boolean'];
  name: Scalars['String'];
};

/** Values associated with introspection result for field */
export type IntrospectionField = {
  __typename?: 'IntrospectionField';
  args: Array<IntrospectionInputValue>;
  deprecationReason?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  isDeprecated: Scalars['Boolean'];
  name: Scalars['String'];
  type: IntrospectionType;
};

/** __Field introspection type */
export type IntrospectionFieldInput = {
  args: Array<IntrospectionInputValueInput>;
  deprecationReason?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isDeprecated: Scalars['Boolean'];
  name: Scalars['String'];
  type: IntrospectionTypeInput;
};

/** Values associated with introspection result for an input field */
export type IntrospectionInputValue = {
  __typename?: 'IntrospectionInputValue';
  defaultValue?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  type: IntrospectionType;
};

/** __Value introspection type */
export type IntrospectionInputValueInput = {
  defaultValue?: InputMaybe<Scalars['String']>;
  deprecationReason?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  isDeprecated?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
  type: IntrospectionTypeInput;
};

export type IntrospectionSchema = {
  __typename?: 'IntrospectionSchema';
  directives: Array<IntrospectionDirective>;
  mutationType?: Maybe<IntrospectionType>;
  queryType: IntrospectionType;
  subscriptionType?: Maybe<IntrospectionType>;
  types: Array<IntrospectionType>;
};


export type IntrospectionSchemaTypesArgs = {
  filter?: InputMaybe<TypeFilterConfig>;
};

/** __Schema introspection type */
export type IntrospectionSchemaInput = {
  description?: InputMaybe<Scalars['String']>;
  directives: Array<IntrospectionDirectiveInput>;
  mutationType?: InputMaybe<IntrospectionTypeRefInput>;
  queryType: IntrospectionTypeRefInput;
  subscriptionType?: InputMaybe<IntrospectionTypeRefInput>;
  types?: InputMaybe<Array<IntrospectionTypeInput>>;
};

/** Object containing all possible values for an introspectionType */
export type IntrospectionType = {
  __typename?: 'IntrospectionType';
  /** the base kind of the type this references, ignoring lists and nullability */
  baseKind?: Maybe<IntrospectionTypeKind>;
  description?: Maybe<Scalars['String']>;
  enumValues?: Maybe<Array<IntrospectionEnumValue>>;
  fields?: Maybe<Array<IntrospectionField>>;
  inputFields?: Maybe<Array<IntrospectionInputValue>>;
  interfaces?: Maybe<Array<IntrospectionType>>;
  kind?: Maybe<IntrospectionTypeKind>;
  name?: Maybe<Scalars['String']>;
  ofType?: Maybe<IntrospectionType>;
  possibleTypes?: Maybe<Array<IntrospectionType>>;
  /** printed representation of type, including nested nullability and list ofTypes */
  printed: Scalars['String'];
};


/** Object containing all possible values for an introspectionType */
export type IntrospectionTypeEnumValuesArgs = {
  includeDeprecated?: InputMaybe<Scalars['Boolean']>;
};

/** __Type introspection type */
export type IntrospectionTypeInput = {
  description?: InputMaybe<Scalars['String']>;
  enumValues?: InputMaybe<Array<IntrospectionEnumValueInput>>;
  fields?: InputMaybe<Array<IntrospectionFieldInput>>;
  inputFields?: InputMaybe<Array<IntrospectionInputValueInput>>;
  interfaces?: InputMaybe<Array<IntrospectionTypeInput>>;
  kind: IntrospectionTypeKind;
  name?: InputMaybe<Scalars['String']>;
  ofType?: InputMaybe<IntrospectionTypeInput>;
  possibleTypes?: InputMaybe<Array<IntrospectionTypeInput>>;
  specifiedByUrl?: InputMaybe<Scalars['String']>;
};

export enum IntrospectionTypeKind {
  /** Indicates this type is an enum. 'enumValues' is a valid field. */
  Enum = 'ENUM',
  /** Indicates this type is an input object. 'inputFields' is a valid field. */
  InputObject = 'INPUT_OBJECT',
  /**
   * Indicates this type is an interface. 'fields' and 'possibleTypes' are valid
   * fields
   */
  Interface = 'INTERFACE',
  /** Indicates this type is a list. 'ofType' is a valid field. */
  List = 'LIST',
  /** Indicates this type is a non-null. 'ofType' is a valid field. */
  NonNull = 'NON_NULL',
  /** Indicates this type is an object. 'fields' and 'interfaces' are valid fields. */
  Object = 'OBJECT',
  /** Indicates this type is a scalar. */
  Scalar = 'SCALAR',
  /** Indicates this type is a union. 'possibleTypes' is a valid field. */
  Union = 'UNION'
}

/** Shallow __Type introspection type */
export type IntrospectionTypeRefInput = {
  kind?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

export type InvalidOperation = {
  __typename?: 'InvalidOperation';
  errors?: Maybe<Array<OperationValidationError>>;
  signature: Scalars['ID'];
};

export type InvalidRefFormat = Error & {
  __typename?: 'InvalidRefFormat';
  message: Scalars['String'];
};

export type InvalidTarget = Error & {
  __typename?: 'InvalidTarget';
  message: Scalars['String'];
};

export type Invoice = {
  __typename?: 'Invoice';
  closedAt?: Maybe<Scalars['Timestamp']>;
  collectionMethod?: Maybe<Scalars['String']>;
  createdAt: Scalars['Timestamp'];
  invoiceNumber: Scalars['Int'];
  state: InvoiceState;
  totalInCents: Scalars['Int'];
  updatedAt: Scalars['Timestamp'];
  uuid: Scalars['ID'];
};

export enum InvoiceState {
  Collected = 'COLLECTED',
  Failed = 'FAILED',
  Open = 'OPEN',
  PastDue = 'PAST_DUE',
  Unknown = 'UNKNOWN'
}

export type Launch = {
  __typename?: 'Launch';
  approvedAt?: Maybe<Scalars['Timestamp']>;
  build?: Maybe<Build>;
  buildInput: BuildInput;
  completedAt?: Maybe<Scalars['Timestamp']>;
  createdAt: Scalars['Timestamp'];
  downstreamLaunches: Array<Launch>;
  id: Scalars['ID'];
  isAvailable?: Maybe<Scalars['Boolean']>;
  isCompleted?: Maybe<Scalars['Boolean']>;
  isPublished?: Maybe<Scalars['Boolean']>;
  isTarget?: Maybe<Scalars['Boolean']>;
  latestSequenceStep?: Maybe<LaunchSequenceStep>;
  results: Array<LaunchResult>;
  schemaTag?: Maybe<SchemaTag>;
  sequence: Array<LaunchSequenceStep>;
  shortenedID: Scalars['String'];
  status: LaunchStatus;
  subgraphChanges?: Maybe<Array<SubgraphChange>>;
  supersededAt?: Maybe<Scalars['Timestamp']>;
  supersededBy?: Maybe<Launch>;
  upstreamLaunch?: Maybe<Launch>;
};

/** more result types will be supported in the future */
export type LaunchResult = ChangelogLaunchResult;

export type LaunchSequenceBuildStep = {
  __typename?: 'LaunchSequenceBuildStep';
  completedAt?: Maybe<Scalars['Timestamp']>;
  startedAt?: Maybe<Scalars['Timestamp']>;
};

export type LaunchSequenceCheckStep = {
  __typename?: 'LaunchSequenceCheckStep';
  completedAt?: Maybe<Scalars['Timestamp']>;
  startedAt?: Maybe<Scalars['Timestamp']>;
};

export type LaunchSequenceCompletedStep = {
  __typename?: 'LaunchSequenceCompletedStep';
  completedAt?: Maybe<Scalars['Timestamp']>;
};

export type LaunchSequenceInitiatedStep = {
  __typename?: 'LaunchSequenceInitiatedStep';
  startedAt?: Maybe<Scalars['Timestamp']>;
};

export type LaunchSequencePublishStep = {
  __typename?: 'LaunchSequencePublishStep';
  completedAt?: Maybe<Scalars['Timestamp']>;
  startedAt?: Maybe<Scalars['Timestamp']>;
};

export type LaunchSequenceStep = LaunchSequenceBuildStep | LaunchSequenceCheckStep | LaunchSequenceCompletedStep | LaunchSequenceInitiatedStep | LaunchSequencePublishStep | LaunchSequenceSupersededStep;

export type LaunchSequenceSupersededStep = {
  __typename?: 'LaunchSequenceSupersededStep';
  completedAt?: Maybe<Scalars['Timestamp']>;
};

export enum LaunchStatus {
  LaunchCompleted = 'LAUNCH_COMPLETED',
  LaunchFailed = 'LAUNCH_FAILED',
  LaunchInitiated = 'LAUNCH_INITIATED'
}

export type LinkInfo = {
  __typename?: 'LinkInfo';
  createdAt: Scalars['Timestamp'];
  id: Scalars['ID'];
  title?: Maybe<Scalars['String']>;
  type: LinkInfoType;
  url: Scalars['String'];
};

export enum LinkInfoType {
  DeveloperPortal = 'DEVELOPER_PORTAL',
  Other = 'OTHER',
  Repository = 'REPOSITORY'
}

export type MarkChangesForOperationAsSafeResult = {
  __typename?: 'MarkChangesForOperationAsSafeResult';
  /**
   * Nice to have for the frontend since the Apollo cache is already watching for AffectedQuery to update.
   * This might return null if no behavior changes were found for the affected operation ID.
   * This is a weird situation that should never happen.
   */
  affectedOperation?: Maybe<AffectedQuery>;
  message: Scalars['String'];
  success: Scalars['Boolean'];
};

export type MediaUploadInfo = {
  __typename?: 'MediaUploadInfo';
  csrfToken: Scalars['String'];
  maxContentLength: Scalars['Int'];
  url: Scalars['String'];
};

export type Mutation = {
  __typename?: 'Mutation';
  account?: Maybe<AccountMutation>;
  createOperationCollection: CreateOperationCollectionResult;
  /**
   * Finalize a password reset with a token included in the E-mail link,
   * returns the corresponding login email when successful
   */
  finalizePasswordReset?: Maybe<Scalars['String']>;
  /** Join an account with a token */
  joinAccount?: Maybe<Account>;
  me?: Maybe<IdentityMutation>;
  newAccount?: Maybe<Account>;
  newService?: Maybe<Service>;
  operationCollection?: Maybe<OperationCollectionMutation>;
  /** Refresh all plans from third-party billing service */
  plansRefreshBilling?: Maybe<Scalars['Void']>;
  /** Report a running GraphQL server's schema. */
  reportSchema?: Maybe<ReportSchemaResult>;
  /** Ask for a user's password to be reset by E-mail */
  resetPassword?: Maybe<Scalars['Void']>;
  resolveAllInternalCronExecutions?: Maybe<Scalars['Void']>;
  resolveInternalCronExecution?: Maybe<CronExecution>;
  service?: Maybe<ServiceMutation>;
  /** Set the subscriptions for a given email */
  setSubscriptions?: Maybe<EmailPreferences>;
  /** Set the studio settings for the current user */
  setUserSettings?: Maybe<UserSettings>;
  signUp?: Maybe<User>;
  /** This is called by the form shown to users after they delete their user or organization account. */
  submitPostDeletionFeedback?: Maybe<Scalars['Void']>;
  /** Mutation for basic engagement tracking in studio */
  track?: Maybe<Scalars['Void']>;
  /** Unsubscribe a given email from all emails */
  unsubscribeFromAll?: Maybe<EmailPreferences>;
  user?: Maybe<UserMutation>;
};


export type MutationAccountArgs = {
  id: Scalars['ID'];
};


export type MutationCreateOperationCollectionArgs = {
  description?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  variantRefs?: InputMaybe<Array<Scalars['ID']>>;
};


export type MutationFinalizePasswordResetArgs = {
  newPassword: Scalars['String'];
  resetToken: Scalars['String'];
};


export type MutationJoinAccountArgs = {
  accountId: Scalars['ID'];
  joinToken: Scalars['String'];
};


export type MutationNewAccountArgs = {
  companyUrl?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type MutationNewServiceArgs = {
  accountId: Scalars['ID'];
  description?: InputMaybe<Scalars['String']>;
  hiddenFromUninvitedNonAdminAccountMembers?: Scalars['Boolean'];
  id: Scalars['ID'];
  isDev?: Scalars['Boolean'];
  name?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};


export type MutationOperationCollectionArgs = {
  id: Scalars['ID'];
};


export type MutationReportSchemaArgs = {
  coreSchema?: InputMaybe<Scalars['String']>;
  report: SchemaReport;
};


export type MutationResetPasswordArgs = {
  email: Scalars['String'];
};


export type MutationResolveAllInternalCronExecutionsArgs = {
  group?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};


export type MutationResolveInternalCronExecutionArgs = {
  id: Scalars['ID'];
};


export type MutationServiceArgs = {
  id: Scalars['ID'];
};


export type MutationSetSubscriptionsArgs = {
  email: Scalars['String'];
  subscriptions: Array<EmailCategory>;
  token: Scalars['String'];
};


export type MutationSetUserSettingsArgs = {
  newSettings?: InputMaybe<UserSettingsInput>;
};


export type MutationSignUpArgs = {
  email: Scalars['String'];
  fullName: Scalars['String'];
  password: Scalars['String'];
  referrer?: InputMaybe<Scalars['String']>;
  trackingGoogleClientId?: InputMaybe<Scalars['String']>;
  trackingMarketoClientId?: InputMaybe<Scalars['String']>;
  userSegment?: InputMaybe<UserSegment>;
  utmCampaign?: InputMaybe<Scalars['String']>;
  utmMedium?: InputMaybe<Scalars['String']>;
  utmSource?: InputMaybe<Scalars['String']>;
};


export type MutationSubmitPostDeletionFeedbackArgs = {
  feedback: Scalars['String'];
  targetIdentifier: Scalars['ID'];
  targetType: DeletionTargetType;
};


export type MutationTrackArgs = {
  event: EventEnum;
  graphID: Scalars['String'];
  graphVariant?: Scalars['String'];
};


export type MutationUnsubscribeFromAllArgs = {
  email: Scalars['String'];
  token: Scalars['String'];
};


export type MutationUserArgs = {
  id: Scalars['ID'];
};

export type NamedIntrospectionArg = {
  __typename?: 'NamedIntrospectionArg';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

export type NamedIntrospectionArgNoDescription = {
  __typename?: 'NamedIntrospectionArgNoDescription';
  name?: Maybe<Scalars['String']>;
};

/**
 * The shared fields for a named introspection type. Currently this is returned for the
 * top level value affected by a change. In the future, we may update this
 * type to be an interface, which is extended by the more specific types:
 * scalar, object, input object, union, interface, and enum
 *
 * For an in-depth look at where these types come from, see:
 * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/659eb50d3/types/graphql/utilities/introspectionQuery.d.ts#L31-L37
 */
export type NamedIntrospectionType = {
  __typename?: 'NamedIntrospectionType';
  description?: Maybe<Scalars['String']>;
  kind?: Maybe<IntrospectionTypeKind>;
  name?: Maybe<Scalars['String']>;
};

export type NamedIntrospectionTypeNoDescription = {
  __typename?: 'NamedIntrospectionTypeNoDescription';
  name?: Maybe<Scalars['String']>;
};

/**
 * Introspection values that can be children of other types for changes, such
 * as input fields, objects in interfaces, enum values. In the future, this
 * value could become an interface to allow fields specific to the types
 * returned.
 */
export type NamedIntrospectionValue = {
  __typename?: 'NamedIntrospectionValue';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  printedType?: Maybe<Scalars['String']>;
};

export type NamedIntrospectionValueNoDescription = {
  __typename?: 'NamedIntrospectionValueNoDescription';
  name?: Maybe<Scalars['String']>;
  printedType?: Maybe<Scalars['String']>;
};

/** A non-federated service for a monolithic graph */
export type NonFederatedImplementingService = {
  __typename?: 'NonFederatedImplementingService';
  /** Timestamp of when this implementing service was created */
  createdAt: Scalars['Timestamp'];
  /**
   * Identifies which graph this non-implementing service belongs to.
   * Formerly known as "service_id"
   */
  graphID: Scalars['String'];
  /**
   * Specifies which variant of a graph this implementing service belongs to".
   * Formerly known as "tag"
   */
  graphVariant: Scalars['String'];
};

export type NotFoundError = Error & {
  __typename?: 'NotFoundError';
  message: Scalars['String'];
};

export type OdysseyCertification = {
  __typename?: 'OdysseyCertification';
  certificationId: Scalars['String'];
  earnedAt: Scalars['Timestamp'];
  id: Scalars['ID'];
  owner?: Maybe<OdysseyCertificationOwner>;
};

export type OdysseyCertificationOwner = {
  __typename?: 'OdysseyCertificationOwner';
  fullName: Scalars['String'];
  id: Scalars['ID'];
};

export type OdysseyCourse = {
  __typename?: 'OdysseyCourse';
  completedAt?: Maybe<Scalars['Timestamp']>;
  enrolledAt?: Maybe<Scalars['Timestamp']>;
  id: Scalars['ID'];
};

export type OdysseyCourseInput = {
  completedAt?: InputMaybe<Scalars['Timestamp']>;
  courseId: Scalars['String'];
};

export type OdysseyTask = {
  __typename?: 'OdysseyTask';
  completedAt?: Maybe<Scalars['Timestamp']>;
  id: Scalars['ID'];
  value?: Maybe<Scalars['String']>;
};

export type OdysseyTaskInput = {
  completedAt?: InputMaybe<Scalars['Timestamp']>;
  taskId: Scalars['String'];
  value?: InputMaybe<Scalars['String']>;
};

export type Operation = {
  __typename?: 'Operation';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  signature?: Maybe<Scalars['String']>;
  truncated: Scalars['Boolean'];
};

export type OperationAcceptedChange = {
  __typename?: 'OperationAcceptedChange';
  acceptedAt: Scalars['Timestamp'];
  acceptedBy: Identity;
  change: StoredApprovedChange;
  checkID: Scalars['ID'];
  graphID: Scalars['ID'];
  id: Scalars['ID'];
  operationID: Scalars['String'];
};

/** Columns of OperationCheckStats. */
export enum OperationCheckStatsColumn {
  CachedRequestsCount = 'CACHED_REQUESTS_COUNT',
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  UncachedRequestsCount = 'UNCACHED_REQUESTS_COUNT'
}

export type OperationCheckStatsDimensions = {
  __typename?: 'OperationCheckStatsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in OperationCheckStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type OperationCheckStatsFilter = {
  and?: InputMaybe<Array<OperationCheckStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<OperationCheckStatsFilterIn>;
  not?: InputMaybe<OperationCheckStatsFilter>;
  or?: InputMaybe<Array<OperationCheckStatsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in OperationCheckStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type OperationCheckStatsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type OperationCheckStatsMetrics = {
  __typename?: 'OperationCheckStatsMetrics';
  cachedRequestsCount: Scalars['Long'];
  uncachedRequestsCount: Scalars['Long'];
};

export type OperationCheckStatsOrderBySpec = {
  column: OperationCheckStatsColumn;
  direction: Ordering;
};

export type OperationCheckStatsRecord = {
  __typename?: 'OperationCheckStatsRecord';
  /** Dimensions of OperationCheckStats that can be grouped by. */
  groupBy: OperationCheckStatsDimensions;
  /** Metrics of OperationCheckStats that can be aggregated over. */
  metrics: OperationCheckStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type OperationCollection = {
  __typename?: 'OperationCollection';
  createdAt: Scalars['Timestamp'];
  createdBy?: Maybe<Identity>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  lastUpdatedAt: Scalars['Timestamp'];
  lastUpdatedBy?: Maybe<Identity>;
  name: Scalars['String'];
  operation?: Maybe<OperationCollectionEntryResult>;
  operations: Array<OperationCollectionEntry>;
  variants: Array<GraphVariant>;
};


export type OperationCollectionOperationArgs = {
  id: Scalars['ID'];
};

export type OperationCollectionEntry = {
  __typename?: 'OperationCollectionEntry';
  collection: OperationCollection;
  createdAt: Scalars['Timestamp'];
  createdBy?: Maybe<Identity>;
  currentOperationRevision: OperationCollectionEntryState;
  id: Scalars['ID'];
  lastUpdatedAt: Scalars['Timestamp'];
  lastUpdatedBy?: Maybe<Identity>;
  name: Scalars['String'];
};

export type OperationCollectionEntryMutation = {
  __typename?: 'OperationCollectionEntryMutation';
  updateValues?: Maybe<UpdateOperationCollectionEntryResult>;
};


export type OperationCollectionEntryMutationUpdateValuesArgs = {
  operationInput: OperationCollectionEntryStateInput;
};

export type OperationCollectionEntryResult = NotFoundError | OperationCollectionEntry;

export type OperationCollectionEntryState = {
  __typename?: 'OperationCollectionEntryState';
  body: Scalars['String'];
  createdAt: Scalars['Timestamp'];
  createdBy?: Maybe<Identity>;
  headers?: Maybe<Array<OperationHeader>>;
  variables?: Maybe<Scalars['String']>;
};

export type OperationCollectionEntryStateInput = {
  body: Scalars['String'];
  headers?: InputMaybe<Array<OperationHeaderInput>>;
  /**  I'm assuming this is non null */
  variables?: InputMaybe<Scalars['String']>;
};

export type OperationCollectionMutation = {
  __typename?: 'OperationCollectionMutation';
  addOperation?: Maybe<AddOperationCollectionEntryResult>;
  addToVariant: AddOperationCollectionToVariantResult;
  delete?: Maybe<DeleteOperationCollectionSuccess>;
  deleteOperation?: Maybe<OperationCollection>;
  operation?: Maybe<OperationCollectionEntryMutation>;
  removeFromVariant: RemoveOperationCollectionFromVariantResult;
  updateDescription?: Maybe<UpdateOperationCollectionResult>;
  updateName?: Maybe<UpdateOperationCollectionResult>;
};


export type OperationCollectionMutationAddOperationArgs = {
  operationInput: OperationCollectionEntryStateInput;
};


export type OperationCollectionMutationAddToVariantArgs = {
  variantRef: Scalars['ID'];
};


export type OperationCollectionMutationDeleteOperationArgs = {
  id: Scalars['ID'];
};


export type OperationCollectionMutationOperationArgs = {
  id: Scalars['ID'];
};


export type OperationCollectionMutationRemoveFromVariantArgs = {
  variantRef: Scalars['ID'];
};


export type OperationCollectionMutationUpdateDescriptionArgs = {
  description?: InputMaybe<Scalars['String']>;
};


export type OperationCollectionMutationUpdateNameArgs = {
  name: Scalars['String'];
};

export type OperationCollectionResult = NotFoundError | OperationCollection;

export type OperationDocument = {
  __typename?: 'OperationDocument';
  /** Operation document body */
  body: Scalars['String'];
  /** Operation name */
  name?: Maybe<Scalars['String']>;
};

export type OperationDocumentInput = {
  /** Operation document body */
  body: Scalars['String'];
  /** Operation name */
  name?: InputMaybe<Scalars['String']>;
};

export type OperationHeader = {
  __typename?: 'OperationHeader';
  name: Scalars['String'];
  value: Scalars['String'];
};

export type OperationHeaderInput = {
  name: Scalars['String'];
  value: Scalars['String'];
};

export type OperationValidationError = {
  __typename?: 'OperationValidationError';
  message: Scalars['String'];
};

export type OperationsCheckResult = {
  __typename?: 'OperationsCheckResult';
  /** Operations affected by all changes in diff */
  affectedQueries?: Maybe<Array<AffectedQuery>>;
  /** Summary/counts for all changes in diff */
  changeSummary: ChangeSummary;
  /** List of schema changes with associated affected clients and operations */
  changes: Array<Change>;
  /** Indication of the success of the change, either failure, warning, or notice. */
  checkSeverity: ChangeSeverity;
  /** The variant that was used as a base to check against */
  checkedVariant: GraphVariant;
  createdAt: Scalars['Timestamp'];
  id: Scalars['ID'];
  /** Number of affected query operations that are neither marked as SAFE or IGNORED */
  numberOfAffectedOperations: Scalars['Int'];
  /** Number of operations that were validated during schema diff */
  numberOfCheckedOperations: Scalars['Int'];
  workflowTask: OperationsCheckTask;
};

export type OperationsCheckTask = CheckWorkflowTask & {
  __typename?: 'OperationsCheckTask';
  completedAt?: Maybe<Scalars['Timestamp']>;
  createdAt: Scalars['Timestamp'];
  id: Scalars['ID'];
  /** The result of the check. */
  result?: Maybe<OperationsCheckResult>;
  status: CheckWorkflowTaskStatus;
  workflow: CheckWorkflow;
};

export enum Ordering {
  Ascending = 'ASCENDING',
  Descending = 'DESCENDING'
}

/** A reusable invite link for an organization. */
export type OrganizationInviteLink = {
  __typename?: 'OrganizationInviteLink';
  createdAt: Scalars['Timestamp'];
  /** A joinToken that can be passed to Mutation.joinAccount to join the organization. */
  joinToken: Scalars['String'];
  /** The role that the user will receive if they join the organization with this link. */
  role: UserPermission;
};

export type OrganizationSso = {
  __typename?: 'OrganizationSSO';
  defaultRole: UserPermission;
  idpid: Scalars['ID'];
  provider: OrganizationSsoProvider;
};

export enum OrganizationSsoProvider {
  Pingone = 'PINGONE'
}

/** PagerDuty notification channel */
export type PagerDutyChannel = Channel & {
  __typename?: 'PagerDutyChannel';
  id: Scalars['ID'];
  name: Scalars['String'];
  routingKey: Scalars['String'];
  subscriptions: Array<ChannelSubscription>;
};

/** PagerDuty notification channel parameters */
export type PagerDutyChannelInput = {
  name?: InputMaybe<Scalars['String']>;
  routingKey: Scalars['String'];
};

/** Schema for an implementing service with associated metadata */
export type PartialSchema = {
  __typename?: 'PartialSchema';
  /** Timestamp for when the partial schema was created */
  createdAt: Scalars['Timestamp'];
  /** If this sdl is currently actively composed in the gateway, this is true */
  isLive: Scalars['Boolean'];
  /** The enriched sdl of a partial schema */
  sdl: Scalars['String'];
  /** The path of deep storage to find the raw enriched partial schema file */
  sdlPath: Scalars['String'];
};

/**
 * Input for registering a partial schema to an implementing service.
 * One of the fields must be specified (validated server-side).
 *
 * If a new partialSchemaSDL is passed in, this operation will store it before
 * creating the association.
 *
 * If both the sdl and hash are specified, an error will be thrown if the provided
 * hash doesn't match our hash of the sdl contents. If the sdl field is specified,
 * the hash does not need to be and will be computed server-side.
 */
export type PartialSchemaInput = {
  /**
   * Hash of the partial schema to associate; error is thrown if only the hash is
   * specified and the hash has not been seen before
   */
  hash?: InputMaybe<Scalars['String']>;
  /**
   * Contents of the partial schema in SDL syntax, but may reference types
   * that aren't defined in this document
   */
  sdl?: InputMaybe<Scalars['String']>;
};

export type PermissionError = Error & {
  __typename?: 'PermissionError';
  message: Scalars['String'];
};

export type PromoteSchemaError = {
  __typename?: 'PromoteSchemaError';
  code: PromoteSchemaErrorCode;
  message: Scalars['String'];
};

export enum PromoteSchemaErrorCode {
  CannotPromoteSchemaForFederatedGraph = 'CANNOT_PROMOTE_SCHEMA_FOR_FEDERATED_GRAPH'
}

export type PromoteSchemaResponse = {
  __typename?: 'PromoteSchemaResponse';
  code: PromoteSchemaResponseCode;
  tag: SchemaTag;
};

export enum PromoteSchemaResponseCode {
  NoChangesDetected = 'NO_CHANGES_DETECTED',
  PromotionSuccess = 'PROMOTION_SUCCESS'
}

export type PromoteSchemaResponseOrError = PromoteSchemaError | PromoteSchemaResponse;

export type Protobuf = {
  __typename?: 'Protobuf';
  json?: Maybe<Scalars['String']>;
  object?: Maybe<Scalars['Object']>;
  raw: Scalars['Blob'];
  text: Scalars['String'];
};

export type Query = {
  __typename?: 'Query';
  /** Account by ID */
  account?: Maybe<Account>;
  /** Whether an account ID is available for mutation{newAccount(id:)} */
  accountIDAvailable: Scalars['Boolean'];
  /** All accounts */
  allAccounts?: Maybe<Array<Account>>;
  /** All available plans */
  allPlans: Array<BillingPlan>;
  /** All services */
  allServices?: Maybe<Array<Service>>;
  /** All timezones with their offsets from UTC */
  allTimezoneOffsets: Array<TimezoneOffset>;
  /** All users */
  allUsers?: Maybe<Array<User>>;
  /** Look up a plan by ID */
  billingPlan?: Maybe<BillingPlanV2>;
  /** All available plans */
  billingPlans: Array<BillingPlanV2>;
  /** If this is true, the user is an Apollo administrator who can ignore restrictions based purely on billing plan. */
  canBypassPlanRestrictions: Scalars['Boolean'];
  diffSchemas: Array<Change>;
  /** Get the unsubscribe settings for a given email. */
  emailPreferences?: Maybe<EmailPreferences>;
  experimentalFeatures: GlobalExperimentalFeatures;
  frontendUrlRoot: Scalars['String'];
  internalActiveCronJobs: Array<CronJob>;
  internalAdminUsers?: Maybe<Array<InternalAdminUser>>;
  internalUnresolvedCronExecutionFailures: Array<CronExecution>;
  /** Current identity, null if not authenticated */
  me?: Maybe<Identity>;
  odysseyCertification?: Maybe<OdysseyCertification>;
  operationCollection: OperationCollectionResult;
  /** Look up a plan by ID */
  plan?: Maybe<BillingPlan>;
  /** A list of public variants that have been selected to be shown on our Graph Directory. */
  publiclyListedVariants?: Maybe<Array<GraphVariant>>;
  /** Service by ID */
  service?: Maybe<Service>;
  /** Query statistics across all services. For admins only; normal users must go through AccountsStatsWindow or ServiceStatsWindow. */
  stats: StatsWindow;
  /** Get the studio settings for the current user */
  studioSettings?: Maybe<UserSettings>;
  /** The plan started by AccountMutation.startTeamSubscription */
  teamBillingPlan: BillingPlanV2;
  /** The plan started by AccountMutation.startTeamSubscription */
  teamPlan: BillingPlan;
  /** The plan started by AccountMutation.startTrial */
  trialBillingPlan: BillingPlanV2;
  /** The plan started by AccountMutation.startTrial */
  trialPlan: BillingPlan;
  /** User by ID */
  user?: Maybe<User>;
  /**
   * Access a variant by reference of the form `graphID@variantName`, or `graphID` for the default `current` variant.
   * Returns null when the graph or variant do not exist, or when the graph cannot be accessed.
   * Note that we can return more types implementing Error in the future.
   */
  variant?: Maybe<GraphVariantLookup>;
};


export type QueryAccountArgs = {
  id: Scalars['ID'];
};


export type QueryAccountIdAvailableArgs = {
  id: Scalars['ID'];
};


export type QueryAllAccountsArgs = {
  search?: InputMaybe<Scalars['String']>;
  tier?: InputMaybe<BillingPlanTier>;
};


export type QueryAllServicesArgs = {
  search?: InputMaybe<Scalars['String']>;
};


export type QueryAllUsersArgs = {
  search?: InputMaybe<Scalars['String']>;
};


export type QueryBillingPlanArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryDiffSchemasArgs = {
  baseSchema: Scalars['String'];
  nextSchema: Scalars['String'];
};


export type QueryEmailPreferencesArgs = {
  email: Scalars['String'];
  token: Scalars['String'];
};


export type QueryOdysseyCertificationArgs = {
  id: Scalars['ID'];
};


export type QueryOperationCollectionArgs = {
  id: Scalars['ID'];
};


export type QueryPlanArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryServiceArgs = {
  id: Scalars['ID'];
};


export type QueryStatsArgs = {
  from: Scalars['Timestamp'];
  resolution?: InputMaybe<Resolution>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type QueryTeamBillingPlanArgs = {
  billingPeriod: BillingPeriod;
};


export type QueryTeamPlanArgs = {
  billingPeriod: BillingPeriod;
};


export type QueryUserArgs = {
  id: Scalars['ID'];
};


export type QueryVariantArgs = {
  ref: Scalars['ID'];
};

/** query documents to validate against */
export type QueryDocumentInput = {
  document?: InputMaybe<Scalars['String']>;
};

/** Columns of QueryStats. */
export enum QueryStatsColumn {
  AccountId = 'ACCOUNT_ID',
  CachedHistogram = 'CACHED_HISTOGRAM',
  CachedRequestsCount = 'CACHED_REQUESTS_COUNT',
  CacheTtlHistogram = 'CACHE_TTL_HISTOGRAM',
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  ForbiddenOperationCount = 'FORBIDDEN_OPERATION_COUNT',
  FromEngineproxy = 'FROM_ENGINEPROXY',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  RegisteredOperationCount = 'REGISTERED_OPERATION_COUNT',
  RequestsWithErrorsCount = 'REQUESTS_WITH_ERRORS_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  UncachedHistogram = 'UNCACHED_HISTOGRAM',
  UncachedRequestsCount = 'UNCACHED_REQUESTS_COUNT'
}

export type QueryStatsDimensions = {
  __typename?: 'QueryStatsDimensions';
  accountId?: Maybe<Scalars['ID']>;
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  fromEngineproxy?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  querySignature?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in QueryStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type QueryStatsFilter = {
  /** Selects rows whose accountId dimension equals the given value if not null. To query for the null value, use {in: {accountId: [null]}} instead. */
  accountId?: InputMaybe<Scalars['ID']>;
  and?: InputMaybe<Array<QueryStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose fromEngineproxy dimension equals the given value if not null. To query for the null value, use {in: {fromEngineproxy: [null]}} instead. */
  fromEngineproxy?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<QueryStatsFilterIn>;
  not?: InputMaybe<QueryStatsFilter>;
  or?: InputMaybe<Array<QueryStatsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in QueryStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type QueryStatsFilterIn = {
  /** Selects rows whose accountId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  accountId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose fromEngineproxy dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fromEngineproxy?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type QueryStatsMetrics = {
  __typename?: 'QueryStatsMetrics';
  cacheTtlHistogram: DurationHistogram;
  cachedHistogram: DurationHistogram;
  cachedRequestsCount: Scalars['Long'];
  forbiddenOperationCount: Scalars['Long'];
  registeredOperationCount: Scalars['Long'];
  requestsWithErrorsCount: Scalars['Long'];
  totalLatencyHistogram: DurationHistogram;
  totalRequestCount: Scalars['Long'];
  uncachedHistogram: DurationHistogram;
  uncachedRequestsCount: Scalars['Long'];
};

export type QueryStatsOrderBySpec = {
  column: QueryStatsColumn;
  direction: Ordering;
};

export type QueryStatsRecord = {
  __typename?: 'QueryStatsRecord';
  /** Dimensions of QueryStats that can be grouped by. */
  groupBy: QueryStatsDimensions;
  /** Metrics of QueryStats that can be aggregated over. */
  metrics: QueryStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Query Trigger */
export type QueryTrigger = ChannelSubscription & {
  __typename?: 'QueryTrigger';
  channels: Array<Channel>;
  comparisonOperator: ComparisonOperator;
  enabled: Scalars['Boolean'];
  excludedOperationNames: Array<Scalars['String']>;
  id: Scalars['ID'];
  metric: QueryTriggerMetric;
  operationNames: Array<Scalars['String']>;
  percentile?: Maybe<Scalars['Float']>;
  scope: QueryTriggerScope;
  serviceId: Scalars['String'];
  state: QueryTriggerState;
  threshold: Scalars['Float'];
  variant?: Maybe<Scalars['String']>;
  window: QueryTriggerWindow;
};

/** Query trigger */
export type QueryTriggerInput = {
  channelIds?: InputMaybe<Array<Scalars['String']>>;
  comparisonOperator: ComparisonOperator;
  enabled?: InputMaybe<Scalars['Boolean']>;
  excludedOperationNames?: InputMaybe<Array<Scalars['String']>>;
  metric: QueryTriggerMetric;
  operationNames?: InputMaybe<Array<Scalars['String']>>;
  percentile?: InputMaybe<Scalars['Float']>;
  scope?: InputMaybe<QueryTriggerScope>;
  threshold: Scalars['Float'];
  variant?: InputMaybe<Scalars['String']>;
  window: QueryTriggerWindow;
};

export enum QueryTriggerMetric {
  /** Number of requests within the window that resulted in an error. Ignores `percentile`. */
  ErrorCount = 'ERROR_COUNT',
  /** Number of error requests divided by total number of requests. Ignores `percentile`. */
  ErrorPercentage = 'ERROR_PERCENTAGE',
  /** Number of requests within the window. Ignores `percentile`. */
  RequestCount = 'REQUEST_COUNT',
  /** Request latency in ms. Requires `percentile`. */
  RequestServiceTime = 'REQUEST_SERVICE_TIME'
}

export enum QueryTriggerScope {
  All = 'ALL',
  Any = 'ANY',
  Unrecognized = 'UNRECOGNIZED'
}

/** Query trigger state */
export type QueryTriggerState = {
  __typename?: 'QueryTriggerState';
  evaluatedAt: Scalars['Timestamp'];
  lastTriggeredAt?: Maybe<Scalars['Timestamp']>;
  operations: Array<QueryTriggerStateOperation>;
  triggered: Scalars['Boolean'];
};

export type QueryTriggerStateOperation = {
  __typename?: 'QueryTriggerStateOperation';
  count: Scalars['Long'];
  operation: Scalars['String'];
  triggered: Scalars['Boolean'];
  value: Scalars['Float'];
};

export enum QueryTriggerWindow {
  FifteenMinutes = 'FIFTEEN_MINUTES',
  FiveMinutes = 'FIVE_MINUTES',
  OneMinute = 'ONE_MINUTE',
  Unrecognized = 'UNRECOGNIZED'
}

export type Readme = {
  __typename?: 'Readme';
  content: Scalars['String'];
  id: Scalars['ID'];
  lastUpdatedAt: Scalars['Timestamp'];
  lastUpdatedBy?: Maybe<Identity>;
};

export type RegisterOperationsMutationResponse = {
  __typename?: 'RegisterOperationsMutationResponse';
  invalidOperations?: Maybe<Array<InvalidOperation>>;
  newOperations?: Maybe<Array<RegisteredOperation>>;
  registrationSuccess: Scalars['Boolean'];
};

export type RegisteredClientIdentityInput = {
  identifier: Scalars['String'];
  name: Scalars['String'];
  version?: InputMaybe<Scalars['String']>;
};

export type RegisteredOperation = {
  __typename?: 'RegisteredOperation';
  signature: Scalars['ID'];
};

export type RegisteredOperationInput = {
  document?: InputMaybe<Scalars['String']>;
  metadata?: InputMaybe<RegisteredOperationMetadataInput>;
  signature: Scalars['ID'];
};

export type RegisteredOperationMetadataInput = {
  /** This will be used to link existing records in Engine to a new ID. */
  engineSignature?: InputMaybe<Scalars['String']>;
};

export type RegistryApiKey = {
  __typename?: 'RegistryApiKey';
  keyName?: Maybe<Scalars['String']>;
  token: Scalars['String'];
};

export type RegistryStatsWindow = {
  __typename?: 'RegistryStatsWindow';
  schemaCheckStats: Array<AccountChecksStatsRecord>;
  schemaPublishStats: Array<AccountPublishesStatsRecord>;
};

export type RegistrySubscription = ChannelSubscription & {
  __typename?: 'RegistrySubscription';
  channel?: Maybe<Channel>;
  /** @deprecated Use channels list instead */
  channels: Array<Channel>;
  createdAt: Scalars['Timestamp'];
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  lastUpdatedAt: Scalars['Timestamp'];
  options: SubscriptionOptions;
  variant?: Maybe<Scalars['String']>;
};

export type RelaunchComplete = {
  __typename?: 'RelaunchComplete';
  latestLaunch: Launch;
  updated: Scalars['Boolean'];
};

export type RelaunchError = {
  __typename?: 'RelaunchError';
  message: Scalars['String'];
};

export type RelaunchResult = RelaunchComplete | RelaunchError;

export type RemoveOperationCollectionFromVariantResult = GraphVariant | NotFoundError | ValidationError;

export type ReportSchemaError = ReportSchemaResult & {
  __typename?: 'ReportSchemaError';
  code: ReportSchemaErrorCode;
  inSeconds: Scalars['Int'];
  message: Scalars['String'];
  withCoreSchema: Scalars['Boolean'];
};

export enum ReportSchemaErrorCode {
  BootIdIsNotValidUuid = 'BOOT_ID_IS_NOT_VALID_UUID',
  BootIdIsRequired = 'BOOT_ID_IS_REQUIRED',
  CoreSchemaHashIsNotSchemaSha256 = 'CORE_SCHEMA_HASH_IS_NOT_SCHEMA_SHA256',
  CoreSchemaHashIsRequired = 'CORE_SCHEMA_HASH_IS_REQUIRED',
  CoreSchemaHashIsTooLong = 'CORE_SCHEMA_HASH_IS_TOO_LONG',
  ExecutableSchemaIdIsNotSchemaSha256 = 'EXECUTABLE_SCHEMA_ID_IS_NOT_SCHEMA_SHA256',
  ExecutableSchemaIdIsRequired = 'EXECUTABLE_SCHEMA_ID_IS_REQUIRED',
  ExecutableSchemaIdIsTooLong = 'EXECUTABLE_SCHEMA_ID_IS_TOO_LONG',
  GraphRefInvalidFormat = 'GRAPH_REF_INVALID_FORMAT',
  GraphRefIsRequired = 'GRAPH_REF_IS_REQUIRED',
  GraphVariantDoesNotMatchRegex = 'GRAPH_VARIANT_DOES_NOT_MATCH_REGEX',
  GraphVariantIsRequired = 'GRAPH_VARIANT_IS_REQUIRED',
  LibraryVersionIsTooLong = 'LIBRARY_VERSION_IS_TOO_LONG',
  PlatformIsTooLong = 'PLATFORM_IS_TOO_LONG',
  RuntimeVersionIsTooLong = 'RUNTIME_VERSION_IS_TOO_LONG',
  SchemaIsNotParsable = 'SCHEMA_IS_NOT_PARSABLE',
  SchemaIsNotValid = 'SCHEMA_IS_NOT_VALID',
  ServerIdIsTooLong = 'SERVER_ID_IS_TOO_LONG',
  UserVersionIsTooLong = 'USER_VERSION_IS_TOO_LONG'
}

export type ReportSchemaResponse = ReportSchemaResult & {
  __typename?: 'ReportSchemaResponse';
  inSeconds: Scalars['Int'];
  withCoreSchema: Scalars['Boolean'];
};

export type ReportSchemaResult = {
  inSeconds: Scalars['Int'];
  withCoreSchema: Scalars['Boolean'];
};

export type ReportServerInfoError = ReportServerInfoResult & {
  __typename?: 'ReportServerInfoError';
  code: ReportSchemaErrorCode;
  inSeconds: Scalars['Int'];
  message: Scalars['String'];
  withExecutableSchema: Scalars['Boolean'];
};

export type ReportServerInfoResponse = ReportServerInfoResult & {
  __typename?: 'ReportServerInfoResponse';
  inSeconds: Scalars['Int'];
  withExecutableSchema: Scalars['Boolean'];
};

export type ReportServerInfoResult = {
  inSeconds: Scalars['Int'];
  withExecutableSchema: Scalars['Boolean'];
};

export enum Resolution {
  R1D = 'R1D',
  R1H = 'R1H',
  R1M = 'R1M',
  R5M = 'R5M',
  R6H = 'R6H',
  R15M = 'R15M'
}

export enum ResponseHints {
  None = 'NONE',
  SampleResponses = 'SAMPLE_RESPONSES',
  Subgraphs = 'SUBGRAPHS',
  Timings = 'TIMINGS',
  TraceTimings = 'TRACE_TIMINGS'
}

export type RoleOverride = {
  __typename?: 'RoleOverride';
  graph: Service;
  lastUpdatedAt: Scalars['Timestamp'];
  role: UserPermission;
  user: User;
};

export type ScheduledSummary = ChannelSubscription & {
  __typename?: 'ScheduledSummary';
  /** @deprecated Use channels list instead */
  channel?: Maybe<Channel>;
  channels: Array<Channel>;
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  timezone: Scalars['String'];
  variant: Scalars['String'];
};

export type Schema = {
  __typename?: 'Schema';
  createTemporaryURL?: Maybe<TemporaryUrl>;
  createdAt: Scalars['Timestamp'];
  document: Scalars['GraphQLDocument'];
  /** The number of fields; this includes user defined fields only, excluding built-in types and fields */
  fieldCount: Scalars['Int'];
  gitContext?: Maybe<GitContext>;
  hash: Scalars['ID'];
  introspection: IntrospectionSchema;
  /** The number of types; this includes user defined types only, excluding built-in types */
  typeCount: Scalars['Int'];
};


export type SchemaCreateTemporaryUrlArgs = {
  expiresInSeconds?: Scalars['Int'];
};

/** Represents an error from running schema composition on a list of service definitions. */
export type SchemaCompositionError = {
  __typename?: 'SchemaCompositionError';
  code?: Maybe<Scalars['String']>;
  locations: Array<Maybe<SourceLocation>>;
  message: Scalars['String'];
};

export type SchemaDiff = {
  __typename?: 'SchemaDiff';
  /**
   * Clients affected by all changes in diff
   * @deprecated Unsupported.
   */
  affectedClients?: Maybe<Array<AffectedClient>>;
  /** Operations affected by all changes in diff */
  affectedQueries?: Maybe<Array<AffectedQuery>>;
  /** Summary/counts for all changes in diff */
  changeSummary: ChangeSummary;
  /** List of schema changes with associated affected clients and operations */
  changes: Array<Change>;
  /** Number of affected query operations that are neither marked as SAFE or IGNORED */
  numberOfAffectedOperations: Scalars['Int'];
  /** Number of operations that were validated during schema diff */
  numberOfCheckedOperations?: Maybe<Scalars['Int']>;
  /** Indication of the success of the change, either failure, warning, or notice. */
  severity: ChangeSeverity;
  /** The tag against which this diff was created */
  tag?: Maybe<Scalars['String']>;
  /** @deprecated use severity instead */
  type: ChangeType;
  /** Configuration of validation */
  validationConfig?: Maybe<SchemaDiffValidationConfig>;
};

export type SchemaDiffValidationConfig = {
  __typename?: 'SchemaDiffValidationConfig';
  /** Clients to ignore during validation. */
  excludedClients?: Maybe<Array<ClientInfoFilterOutput>>;
  /**
   * delta in seconds from current time that determines the start of the window
   * for reported metrics included in a schema diff. A day window from the present
   * day would have a `from` value of -86400. In rare cases, this could be an ISO
   * timestamp if the user passed one in on diff creation
   */
  from?: Maybe<Scalars['Timestamp']>;
  /** Operation IDs to ignore during validation. */
  ignoredOperations?: Maybe<Array<Scalars['ID']>>;
  /** Variants to include during validation. */
  includedVariants?: Maybe<Array<Scalars['String']>>;
  /** Minimum number of requests within the window for a query to be considered. */
  queryCountThreshold?: Maybe<Scalars['Int']>;
  /**
   * Number of requests within the window for a query to be considered, relative to
   * total request count. Expected values are between 0 and 0.05 (minimum 5% of
   * total request volume)
   */
  queryCountThresholdPercentage?: Maybe<Scalars['Float']>;
  /**
   * delta in seconds from current time that determines the end of the
   * window for reported metrics included in a schema diff. A day window
   * from the present day would have a `to` value of -0. In rare
   * cases, this could be an ISO timestamp if the user passed one in on diff
   * creation
   */
  to?: Maybe<Scalars['Timestamp']>;
};

export type SchemaPublishSubscription = ChannelSubscription & {
  __typename?: 'SchemaPublishSubscription';
  channels: Array<Channel>;
  createdAt: Scalars['Timestamp'];
  enabled: Scalars['Boolean'];
  id: Scalars['ID'];
  lastUpdatedAt: Scalars['Timestamp'];
  variant?: Maybe<Scalars['String']>;
};

export type SchemaReport = {
  /** A randomly generated UUID, immutable for the lifetime of the edge server runtime. */
  bootId: Scalars['String'];
  /** The hex SHA256 hash of the schema being reported. Note that for a GraphQL server with a core schema, this should be the core schema, not the API schema. */
  coreSchemaHash: Scalars['String'];
  /** The graph ref (eg, 'id@variant') */
  graphRef: Scalars['String'];
  /** The version of the edge server reporting agent, e.g. apollo-server-2.8, graphql-java-3.1, etc. length must be <= 256 characters. */
  libraryVersion?: InputMaybe<Scalars['String']>;
  /** The infra environment in which this edge server is running, e.g. localhost, Kubernetes, AWS Lambda, Google CloudRun, AWS ECS, etc. length must be <= 256 characters. */
  platform?: InputMaybe<Scalars['String']>;
  /** The runtime in which the edge server is running, e.g. node 12.03, zulu8.46.0.19-ca-jdk8.0.252-macosx_x64, etc. length must be <= 256 characters. */
  runtimeVersion?: InputMaybe<Scalars['String']>;
  /** If available, an identifier for the edge server instance, such that when restarting this instance it will have the same serverId, with a different bootId. For example, in Kubernetes this might be the pod name. Length must be <= 256 characters. */
  serverId?: InputMaybe<Scalars['String']>;
  /** An identifier used to distinguish the version (from the user's perspective) of the edge server's code itself. For instance, the git sha of the server's repository or the docker sha of the associated image this server runs with. Length must be <= 256 characters. */
  userVersion?: InputMaybe<Scalars['String']>;
};

export type SchemaTag = {
  __typename?: 'SchemaTag';
  /** The composition result that corresponds to this schema repo tag, if it exists. */
  compositionResult?: Maybe<CompositionResult>;
  createdAt: Scalars['Timestamp'];
  diffToPrevious?: Maybe<SchemaDiff>;
  gitContext?: Maybe<GitContext>;
  /**
   * List of previously uploaded SchemaTags under the same tag name, starting with
   * the selected published schema record. Sorted in reverse chronological order
   * by creation date (newest publish first).
   *
   * Note: This does not include the history of checked schemas
   */
  history: Array<SchemaTag>;
  /**
   * Number of tagged schemas created under the same tag name.
   * Also represents the maximum size of the history's limit argument.
   */
  historyLength: Scalars['Int'];
  /**
   * Number of schemas tagged prior to this one under the same tag name, its position
   * in the tag history.
   */
  historyOrder: Scalars['Int'];
  /**
   * The identifier for this particular schema tag, which may be either a particular
   * run of a check or a specific publish. This ID can be used alongside `schemaTagByID`
   * in order to look up a particular entry.
   */
  id: Scalars['ID'];
  /**
   * Indicates this schema is "published" meaning that our users correspond this schema
   * with a long-running or permanent initiative. Published schemas appear in the UI
   * when exploring a service's schemas, and typically refer to either active environments
   * with metrics (e.g. "staging") or git branches that are constantly used as a base
   * (e.g. "main"). If this field is not found, the schema is "private" to Engine
   * and is uploaded but not promoted to published yet. The other benefit is this makes
   * for nice UX around publishing events
   */
  publishedAt: Scalars['Timestamp'];
  /**
   * The Identity that published this schema and their client info, or null if this isn't
   * a publish. Sub-fields may be null if they weren't recorded.
   */
  publishedBy?: Maybe<IdentityAndClientInfo>;
  /**
   * Indicates the schemaTag of the schema's original upload, null if this is the
   * first upload of the schema.
   */
  reversionFrom?: Maybe<SchemaTag>;
  schema: Schema;
  slackNotificationBody?: Maybe<Scalars['String']>;
  /** @deprecated Please use variant { name } instead */
  tag: Scalars['String'];
  /** The graph variant this schema tag belongs to. */
  variant: GraphVariant;
  webhookNotificationBody: Scalars['String'];
};


export type SchemaTagHistoryArgs = {
  includeUnchanged?: Scalars['Boolean'];
  limit?: Scalars['Int'];
  offset?: InputMaybe<Scalars['Int']>;
};


export type SchemaTagSlackNotificationBodyArgs = {
  graphDisplayName: Scalars['String'];
};

/** How many seats of the given types does an organization have (regardless of plan type)? */
export type Seats = {
  __typename?: 'Seats';
  /** How many members that are free in this organization. */
  free: Scalars['Int'];
  /** How many members that are not free in this organization. */
  fullPrice: Scalars['Int'];
};

export type SemanticChange = {
  __typename?: 'SemanticChange';
  /** Target arg of change made. */
  argNode?: Maybe<NamedIntrospectionArg>;
  /**
   * Node related to the top level node that was changed, such as a field in an object,
   * a value in an enum or the object of an interface
   */
  childNode?: Maybe<NamedIntrospectionValue>;
  /** Semantic metadata about the type of change */
  definition: ChangeDefinition;
  /** Top level node affected by the change */
  parentNode?: Maybe<NamedIntrospectionType>;
};

export type Service = Identity & {
  __typename?: 'Service';
  account?: Maybe<Account>;
  accountId?: Maybe<Scalars['ID']>;
  apiKeys?: Maybe<Array<GraphApiKey>>;
  asActor: Actor;
  /**
   * Get an URL to which an avatar image can be uploaded. Client uploads by sending a PUT request
   * with the image data to MediaUploadInfo.url. Client SHOULD set the "Content-Type" header to the
   * browser-inferred MIME type, and SHOULD set the "x-apollo-content-filename" header to the
   * filename, if such information is available. Client MUST set the "x-apollo-csrf-token" header to
   * MediaUploadInfo.csrfToken.
   */
  avatarUpload?: Maybe<AvatarUploadResult>;
  /**
   * Get an image URL for the service's avatar. Note that CORS is not enabled for these URLs. The size
   * argument is used for bandwidth reduction, and should be the size of the image as displayed in the
   * application. Apollo's media server will downscale larger images to at least the requested size,
   * but this will not happen for third-party media servers.
   */
  avatarUrl?: Maybe<Scalars['String']>;
  /** Get available notification endpoints */
  channels?: Maybe<Array<Channel>>;
  /** Get check configuration for this graph. */
  checkConfiguration?: Maybe<CheckConfiguration>;
  /** Get a check workflow for this graph by its ID */
  checkWorkflow?: Maybe<CheckWorkflow>;
  /** Get check workflows for this graph ordered by creation time, most recent first. */
  checkWorkflows: Array<CheckWorkflow>;
  /**
   * List of options available for filtering checks for this graph by author.
   * If a filter is passed, constrains results to match the filter.
   */
  checksAuthorOptions: Array<Scalars['String']>;
  /**
   * List of options available for filtering checks for this graph by branch.
   * If a filter is passed, constrains results to match the filter.
   */
  checksBranchOptions: Array<Scalars['String']>;
  /**
   * List of options available for filtering checks for this graph by subgraph name.
   * If a filter is passed, constrains results to match the filter.
   */
  checksSubgraphOptions: Array<Scalars['String']>;
  /** Given a graphCompositionID, return the results of composition. This can represent either a validation or a publish. */
  compositionResultById?: Maybe<CompositionResult>;
  createdAt: Scalars['Timestamp'];
  createdBy?: Maybe<Identity>;
  datadogMetricsConfig?: Maybe<DatadogMetricsConfig>;
  deletedAt?: Maybe<Scalars['Timestamp']>;
  description?: Maybe<Scalars['String']>;
  devGraphOwner?: Maybe<User>;
  /** Get a GraphQL document by hash */
  document?: Maybe<Scalars['GraphQLDocument']>;
  /**
   * When this is true, this graph will be hidden from non-admin members of the org who haven't been explicitly assigned a
   * role on this graph.
   */
  hiddenFromUninvitedNonAdminAccountMembers: Scalars['Boolean'];
  id: Scalars['ID'];
  /**
   * List of implementing services that comprise a graph. A non-federated graph should have a single implementing service.
   * Set includeDeleted to see deleted implementing services.
   */
  implementingServices?: Maybe<GraphImplementors>;
  lastReportedAt?: Maybe<Scalars['Timestamp']>;
  /** Current identity, null if not authenticated. */
  me?: Maybe<Identity>;
  /**
   * This returns the composition result that was most recently published to the graph.
   * Only identities that canQuerySchemas and canQueryImplementingServices have access
   * to this field
   */
  mostRecentCompositionPublish?: Maybe<CompositionPublishResult>;
  myRole?: Maybe<UserPermission>;
  /** @deprecated Use Service.title */
  name: Scalars['String'];
  operation?: Maybe<Operation>;
  /** Gets the operations and their approved changes for this graph, checkID, and operationID. */
  operationsAcceptedChanges: Array<OperationAcceptedChange>;
  /** Get an operations check result for a specific check ID */
  operationsCheck?: Maybe<OperationsCheckResult>;
  /** Get query triggers for a given variant. If variant is null all the triggers for this service will be gotten. */
  queryTriggers?: Maybe<Array<QueryTrigger>>;
  readme?: Maybe<Readme>;
  /** Registry specific stats for this graph. */
  registryStatsWindow?: Maybe<RegistryStatsWindow>;
  /**
   * Whether registry subscriptions (with any options) are enabled. If variant is not passed, returns true if configuration is present for any variant
   * @deprecated This field will be removed
   */
  registrySubscriptionsEnabled: Scalars['Boolean'];
  reportingEnabled: Scalars['Boolean'];
  /** The list of members that can access this graph, accounting for graph role overrides */
  roleOverrides?: Maybe<Array<RoleOverride>>;
  /** Which permissions the current user has for interacting with this service */
  roles?: Maybe<ServiceRoles>;
  scheduledSummaries: Array<ScheduledSummary>;
  /** Get a schema by hash OR current tag */
  schema?: Maybe<Schema>;
  /** Get the schema tag */
  schemaTag?: Maybe<SchemaTag>;
  schemaTagById?: Maybe<SchemaTag>;
  /**
   * Get schema tags, with optional filtering to a set of tags. Always sorted by creation
   * date in reverse chronological order.
   */
  schemaTags?: Maybe<Array<SchemaTag>>;
  /** @deprecated use Service.statsWindow instead */
  stats: ServiceStatsWindow;
  statsWindow?: Maybe<ServiceStatsWindow>;
  /** Generate a test schema publish notification body */
  testSchemaPublishBody: Scalars['String'];
  title: Scalars['String'];
  trace?: Maybe<Trace>;
  traceStorageEnabled: Scalars['Boolean'];
  /** A particular variant (sometimes called "tag") of the graph, often representing a live traffic environment (such as "prod"). Each variant can represent a specific URL or destination to query at, analytics, and its own schema history. */
  variant?: Maybe<GraphVariant>;
  /** The list of variants that exist for this graph */
  variants: Array<GraphVariant>;
};


export type ServiceAvatarUrlArgs = {
  size?: Scalars['Int'];
};


export type ServiceChannelsArgs = {
  channelIds?: InputMaybe<Array<Scalars['ID']>>;
};


export type ServiceCheckWorkflowArgs = {
  id: Scalars['ID'];
};


export type ServiceCheckWorkflowsArgs = {
  filter?: InputMaybe<CheckFilterInput>;
  limit?: Scalars['Int'];
};


export type ServiceChecksAuthorOptionsArgs = {
  filter?: InputMaybe<CheckFilterInput>;
};


export type ServiceChecksBranchOptionsArgs = {
  filter?: InputMaybe<CheckFilterInput>;
};


export type ServiceChecksSubgraphOptionsArgs = {
  filter?: InputMaybe<CheckFilterInput>;
};


export type ServiceCompositionResultByIdArgs = {
  id: Scalars['ID'];
};


export type ServiceDocumentArgs = {
  hash?: InputMaybe<Scalars['SHA256']>;
};


export type ServiceImplementingServicesArgs = {
  graphVariant: Scalars['String'];
  includeDeleted?: InputMaybe<Scalars['Boolean']>;
};


export type ServiceLastReportedAtArgs = {
  graphVariant?: InputMaybe<Scalars['String']>;
};


export type ServiceMostRecentCompositionPublishArgs = {
  graphVariant: Scalars['String'];
};


export type ServiceOperationArgs = {
  id: Scalars['ID'];
};


export type ServiceOperationsAcceptedChangesArgs = {
  checkID: Scalars['ID'];
  operationID: Scalars['String'];
};


export type ServiceOperationsCheckArgs = {
  checkID: Scalars['ID'];
};


export type ServiceQueryTriggersArgs = {
  graphVariant?: InputMaybe<Scalars['String']>;
  operationNames?: InputMaybe<Array<Scalars['String']>>;
};


export type ServiceRegistryStatsWindowArgs = {
  from: Scalars['Timestamp'];
  resolution?: InputMaybe<Resolution>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type ServiceRegistrySubscriptionsEnabledArgs = {
  graphVariant?: InputMaybe<Scalars['String']>;
};


export type ServiceSchemaArgs = {
  hash?: InputMaybe<Scalars['ID']>;
  tag?: InputMaybe<Scalars['String']>;
};


export type ServiceSchemaTagArgs = {
  tag: Scalars['String'];
};


export type ServiceSchemaTagByIdArgs = {
  id: Scalars['ID'];
};


export type ServiceSchemaTagsArgs = {
  tags?: InputMaybe<Array<Scalars['String']>>;
};


export type ServiceStatsArgs = {
  from: Scalars['Timestamp'];
  resolution?: InputMaybe<Resolution>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type ServiceStatsWindowArgs = {
  from: Scalars['Timestamp'];
  resolution?: InputMaybe<Resolution>;
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type ServiceTestSchemaPublishBodyArgs = {
  variant: Scalars['String'];
};


export type ServiceTraceArgs = {
  id: Scalars['ID'];
};


export type ServiceVariantArgs = {
  name: Scalars['String'];
};

/** Columns of ServiceEdgeServerInfos. */
export enum ServiceEdgeServerInfosColumn {
  BootId = 'BOOT_ID',
  ExecutableSchemaId = 'EXECUTABLE_SCHEMA_ID',
  LibraryVersion = 'LIBRARY_VERSION',
  Platform = 'PLATFORM',
  RuntimeVersion = 'RUNTIME_VERSION',
  SchemaTag = 'SCHEMA_TAG',
  ServerId = 'SERVER_ID',
  Timestamp = 'TIMESTAMP',
  UserVersion = 'USER_VERSION'
}

export type ServiceEdgeServerInfosDimensions = {
  __typename?: 'ServiceEdgeServerInfosDimensions';
  bootId?: Maybe<Scalars['ID']>;
  executableSchemaId?: Maybe<Scalars['ID']>;
  libraryVersion?: Maybe<Scalars['String']>;
  platform?: Maybe<Scalars['String']>;
  runtimeVersion?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serverId?: Maybe<Scalars['ID']>;
  userVersion?: Maybe<Scalars['String']>;
};

/** Filter for data in ServiceEdgeServerInfos. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ServiceEdgeServerInfosFilter = {
  and?: InputMaybe<Array<ServiceEdgeServerInfosFilter>>;
  /** Selects rows whose bootId dimension equals the given value if not null. To query for the null value, use {in: {bootId: [null]}} instead. */
  bootId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose executableSchemaId dimension equals the given value if not null. To query for the null value, use {in: {executableSchemaId: [null]}} instead. */
  executableSchemaId?: InputMaybe<Scalars['ID']>;
  in?: InputMaybe<ServiceEdgeServerInfosFilterIn>;
  /** Selects rows whose libraryVersion dimension equals the given value if not null. To query for the null value, use {in: {libraryVersion: [null]}} instead. */
  libraryVersion?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<ServiceEdgeServerInfosFilter>;
  or?: InputMaybe<Array<ServiceEdgeServerInfosFilter>>;
  /** Selects rows whose platform dimension equals the given value if not null. To query for the null value, use {in: {platform: [null]}} instead. */
  platform?: InputMaybe<Scalars['String']>;
  /** Selects rows whose runtimeVersion dimension equals the given value if not null. To query for the null value, use {in: {runtimeVersion: [null]}} instead. */
  runtimeVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serverId dimension equals the given value if not null. To query for the null value, use {in: {serverId: [null]}} instead. */
  serverId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose userVersion dimension equals the given value if not null. To query for the null value, use {in: {userVersion: [null]}} instead. */
  userVersion?: InputMaybe<Scalars['String']>;
};

/** Filter for data in ServiceEdgeServerInfos. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ServiceEdgeServerInfosFilterIn = {
  /** Selects rows whose bootId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  bootId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose executableSchemaId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  executableSchemaId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose libraryVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  libraryVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose platform dimension is in the given list. A null value in the list means a row with null for that dimension. */
  platform?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose runtimeVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  runtimeVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serverId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serverId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose userVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  userVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ServiceEdgeServerInfosOrderBySpec = {
  column: ServiceEdgeServerInfosColumn;
  direction: Ordering;
};

export type ServiceEdgeServerInfosRecord = {
  __typename?: 'ServiceEdgeServerInfosRecord';
  /** Dimensions of ServiceEdgeServerInfos that can be grouped by. */
  groupBy: ServiceEdgeServerInfosDimensions;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of ServiceErrorStats. */
export enum ServiceErrorStatsColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  ErrorsCount = 'ERRORS_COUNT',
  Path = 'PATH',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  RequestsWithErrorsCount = 'REQUESTS_WITH_ERRORS_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  Timestamp = 'TIMESTAMP'
}

export type ServiceErrorStatsDimensions = {
  __typename?: 'ServiceErrorStatsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
};

/** Filter for data in ServiceErrorStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ServiceErrorStatsFilter = {
  and?: InputMaybe<Array<ServiceErrorStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<ServiceErrorStatsFilterIn>;
  not?: InputMaybe<ServiceErrorStatsFilter>;
  or?: InputMaybe<Array<ServiceErrorStatsFilter>>;
  /** Selects rows whose path dimension equals the given value if not null. To query for the null value, use {in: {path: [null]}} instead. */
  path?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
};

/** Filter for data in ServiceErrorStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ServiceErrorStatsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose path dimension is in the given list. A null value in the list means a row with null for that dimension. */
  path?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ServiceErrorStatsMetrics = {
  __typename?: 'ServiceErrorStatsMetrics';
  errorsCount: Scalars['Long'];
  requestsWithErrorsCount: Scalars['Long'];
};

export type ServiceErrorStatsOrderBySpec = {
  column: ServiceErrorStatsColumn;
  direction: Ordering;
};

export type ServiceErrorStatsRecord = {
  __typename?: 'ServiceErrorStatsRecord';
  /** Dimensions of ServiceErrorStats that can be grouped by. */
  groupBy: ServiceErrorStatsDimensions;
  /** Metrics of ServiceErrorStats that can be aggregated over. */
  metrics: ServiceErrorStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of ServiceFieldLatencies. */
export enum ServiceFieldLatenciesColumn {
  FieldHistogram = 'FIELD_HISTOGRAM',
  FieldName = 'FIELD_NAME',
  ParentType = 'PARENT_TYPE',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  Timestamp = 'TIMESTAMP'
}

export type ServiceFieldLatenciesDimensions = {
  __typename?: 'ServiceFieldLatenciesDimensions';
  field?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  parentType?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
};

/** Filter for data in ServiceFieldLatencies. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ServiceFieldLatenciesFilter = {
  and?: InputMaybe<Array<ServiceFieldLatenciesFilter>>;
  /** Selects rows whose fieldName dimension equals the given value if not null. To query for the null value, use {in: {fieldName: [null]}} instead. */
  fieldName?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<ServiceFieldLatenciesFilterIn>;
  not?: InputMaybe<ServiceFieldLatenciesFilter>;
  or?: InputMaybe<Array<ServiceFieldLatenciesFilter>>;
  /** Selects rows whose parentType dimension equals the given value if not null. To query for the null value, use {in: {parentType: [null]}} instead. */
  parentType?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
};

/** Filter for data in ServiceFieldLatencies. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ServiceFieldLatenciesFilterIn = {
  /** Selects rows whose fieldName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fieldName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose parentType dimension is in the given list. A null value in the list means a row with null for that dimension. */
  parentType?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ServiceFieldLatenciesMetrics = {
  __typename?: 'ServiceFieldLatenciesMetrics';
  fieldHistogram: DurationHistogram;
};

export type ServiceFieldLatenciesOrderBySpec = {
  column: ServiceFieldLatenciesColumn;
  direction: Ordering;
};

export type ServiceFieldLatenciesRecord = {
  __typename?: 'ServiceFieldLatenciesRecord';
  /** Dimensions of ServiceFieldLatencies that can be grouped by. */
  groupBy: ServiceFieldLatenciesDimensions;
  /** Metrics of ServiceFieldLatencies that can be aggregated over. */
  metrics: ServiceFieldLatenciesMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of ServiceFieldUsage. */
export enum ServiceFieldUsageColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  EstimatedExecutionCount = 'ESTIMATED_EXECUTION_COUNT',
  ExecutionCount = 'EXECUTION_COUNT',
  Field = 'FIELD',
  FieldName = 'FIELD_NAME',
  ParentType = 'PARENT_TYPE',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  ReferencingOperationCount = 'REFERENCING_OPERATION_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  Timestamp = 'TIMESTAMP'
}

export type ServiceFieldUsageDimensions = {
  __typename?: 'ServiceFieldUsageDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  field?: Maybe<Scalars['String']>;
  fieldName?: Maybe<Scalars['String']>;
  parentType?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
};

/** Filter for data in ServiceFieldUsage. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ServiceFieldUsageFilter = {
  and?: InputMaybe<Array<ServiceFieldUsageFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose field dimension equals the given value if not null. To query for the null value, use {in: {field: [null]}} instead. */
  field?: InputMaybe<Scalars['String']>;
  /** Selects rows whose fieldName dimension equals the given value if not null. To query for the null value, use {in: {fieldName: [null]}} instead. */
  fieldName?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<ServiceFieldUsageFilterIn>;
  not?: InputMaybe<ServiceFieldUsageFilter>;
  or?: InputMaybe<Array<ServiceFieldUsageFilter>>;
  /** Selects rows whose parentType dimension equals the given value if not null. To query for the null value, use {in: {parentType: [null]}} instead. */
  parentType?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
};

/** Filter for data in ServiceFieldUsage. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ServiceFieldUsageFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose field dimension is in the given list. A null value in the list means a row with null for that dimension. */
  field?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose fieldName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fieldName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose parentType dimension is in the given list. A null value in the list means a row with null for that dimension. */
  parentType?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ServiceFieldUsageMetrics = {
  __typename?: 'ServiceFieldUsageMetrics';
  estimatedExecutionCount: Scalars['Long'];
  executionCount: Scalars['Long'];
  referencingOperationCount: Scalars['Long'];
};

export type ServiceFieldUsageOrderBySpec = {
  column: ServiceFieldUsageColumn;
  direction: Ordering;
};

export type ServiceFieldUsageRecord = {
  __typename?: 'ServiceFieldUsageRecord';
  /** Dimensions of ServiceFieldUsage that can be grouped by. */
  groupBy: ServiceFieldUsageDimensions;
  /** Metrics of ServiceFieldUsage that can be aggregated over. */
  metrics: ServiceFieldUsageMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type ServiceMutation = {
  __typename?: 'ServiceMutation';
  /**
   * Compose an implementing service's partial schema, diff the composed schema, validate traffic against that schema,
   * and store the result so the details can be viewed by users in the UI.
   * This mutation will not mark the schema as "published".
   */
  checkPartialSchema: CheckPartialSchemaResult;
  /**
   * Checks a proposed schema against the schema that has been published to
   * a particular tag, using metrics that have been published to the base tag.
   * Callers can set the historicParameters directly, which will be used if
   * provided. If useMaximumRetention is provided, but historicParameters is not,
   * then validation will use the maximum retention the graph has access to.
   * If neither historicParameters nor useMaximumRetention is provided, the
   * default time range of one week (7 days) will be used.
   */
  checkSchema: CheckSchemaResult;
  /** Make changes to a check workflow. */
  checkWorkflow?: Maybe<CheckWorkflowMutation>;
  createCompositionStatusSubscription: SchemaPublishSubscription;
  createSchemaPublishSubscription: SchemaPublishSubscription;
  /** Soft delete a graph. Data associated with the graph is not permanently deleted; Apollo support can undo. */
  delete?: Maybe<Scalars['Void']>;
  /** Delete the service's avatar. Requires Service.roles.canUpdateAvatar to be true. */
  deleteAvatar?: Maybe<AvatarDeleteError>;
  /** Delete an existing channel */
  deleteChannel: Scalars['Boolean'];
  /** Delete an existing query trigger */
  deleteQueryTrigger: Scalars['Boolean'];
  /** Deletes this service's current subscriptions specific to the ID, returns true if it existed */
  deleteRegistrySubscription: Scalars['Boolean'];
  /**
   * Deletes this service's current registry subscription(s) specific to its graph variant,
   * returns a list of subscription IDs that were deleted.
   */
  deleteRegistrySubscriptions: Array<Scalars['ID']>;
  deleteScheduledSummary: Scalars['Boolean'];
  deleteSchemaTag: DeleteSchemaTagResult;
  /** Given a UTC timestamp, delete all traces associated with this Service, on that corresponding day. If a timestamp to is provided, deletes all days inclusive. */
  deleteTraces?: Maybe<Scalars['Void']>;
  disableDatadogForwardingLegacyMetricNames?: Maybe<Service>;
  /** Hard delete a graph and all data associated with it. Its ID cannot be reused. */
  hardDelete?: Maybe<Scalars['Void']>;
  /** @deprecated Use service.id */
  id: Scalars['ID'];
  /**
   * Ignore an operation in future checks;
   * changes affecting it will be tracked,
   * but won't affect the outcome of the check.
   * Returns true if the operation is newly ignored,
   * false if it already was.
   */
  ignoreOperationsInChecks?: Maybe<IgnoreOperationsInChecksResult>;
  /**
   * Mark the changeset that affects an operation in a given check instance as safe.
   * Note that only operations marked as behavior changes are allowed to be marked as safe.
   */
  markChangesForOperationAsSafe: MarkChangesForOperationAsSafeResult;
  newKey: GraphApiKey;
  /** Adds an override to the given users permission for this graph */
  overrideUserPermission?: Maybe<Service>;
  /** Returns a preview of the Core and API schema contracts derived from a source variant and a set of filter configurations */
  previewContractVariant: ContractVariantPreviewResult;
  /** Promote the schema with the given SHA-256 hash to active for the given variant/tag. */
  promoteSchema: PromoteSchemaResponseOrError;
  registerOperationsWithResponse?: Maybe<RegisterOperationsMutationResponse>;
  removeImplementingServiceAndTriggerComposition: CompositionAndRemoveResult;
  removeKey?: Maybe<Scalars['Void']>;
  renameKey?: Maybe<GraphApiKey>;
  /** @deprecated use Mutation.reportSchema instead */
  reportServerInfo?: Maybe<ReportServerInfoResult>;
  service: Service;
  /**
   * Store a given schema document. This schema will be attached to the graph but
   * not be associated with any variant. On success, returns the schema hash.
   */
  storeSchemaDocument: StoreSchemaResponseOrError;
  /** Test Slack notification channel */
  testSlackChannel?: Maybe<Scalars['Void']>;
  testSubscriptionForChannel: Scalars['String'];
  transfer?: Maybe<Service>;
  triggerRepublish?: Maybe<Scalars['Void']>;
  undelete?: Maybe<Service>;
  /**
   * Revert the effects of ignoreOperation.
   * Returns true if the operation is no longer ignored,
   * false if it wasn't.
   */
  unignoreOperationsInChecks?: Maybe<UnignoreOperationsInChecksResult>;
  /** Unmark changes for an operation as safe. */
  unmarkChangesForOperationAsSafe: MarkChangesForOperationAsSafeResult;
  /** Update schema check configuration for a graph. */
  updateCheckConfiguration: CheckConfiguration;
  updateDatadogMetricsConfig?: Maybe<DatadogMetricsConfig>;
  updateDescription?: Maybe<Service>;
  /** Update hiddenFromUninvitedNonAdminAccountMembers */
  updateHiddenFromUninvitedNonAdminAccountMembers?: Maybe<Service>;
  updateReadme?: Maybe<Service>;
  updateTitle?: Maybe<Service>;
  uploadSchema?: Maybe<UploadSchemaMutationResponse>;
  upsertChannel?: Maybe<Channel>;
  /** Creates a contract schema from a source variant and a set of filter configurations */
  upsertContractVariant: ContractVariantUpsertResult;
  upsertImplementingServiceAndTriggerComposition?: Maybe<CompositionAndUpsertResult>;
  /** Create/update PagerDuty notification channel */
  upsertPagerDutyChannel?: Maybe<PagerDutyChannel>;
  upsertQueryTrigger?: Maybe<QueryTrigger>;
  /** Create or update a subscription for a service. */
  upsertRegistrySubscription: RegistrySubscription;
  upsertScheduledSummary?: Maybe<ScheduledSummary>;
  /** Create/update Slack notification channel */
  upsertSlackChannel?: Maybe<SlackChannel>;
  upsertWebhookChannel?: Maybe<WebhookChannel>;
  validateOperations: ValidateOperationsResult;
  /**
   * This mutation will not result in any changes to the implementing service
   * Run composition with the Implementing Service's partial schema replaced with the one provided
   * in the mutation's input. Store the composed schema, return the hash of the composed schema,
   * and any warnings and errors pertaining to composition.
   * This mutation will not run validation against operations.
   */
  validatePartialSchemaOfImplementingServiceAgainstGraph: CompositionValidationResult;
  /** Make changes to a graph variant. */
  variant?: Maybe<GraphVariantMutation>;
};


export type ServiceMutationCheckPartialSchemaArgs = {
  frontend?: InputMaybe<Scalars['String']>;
  gitContext?: InputMaybe<GitContextInput>;
  graphVariant: Scalars['String'];
  historicParameters?: InputMaybe<HistoricQueryParameters>;
  implementingServiceName: Scalars['String'];
  partialSchema: PartialSchemaInput;
  useMaximumRetention?: InputMaybe<Scalars['Boolean']>;
};


export type ServiceMutationCheckSchemaArgs = {
  baseSchemaTag?: InputMaybe<Scalars['String']>;
  frontend?: InputMaybe<Scalars['String']>;
  gitContext?: InputMaybe<GitContextInput>;
  historicParameters?: InputMaybe<HistoricQueryParameters>;
  introspectionEndpoint?: InputMaybe<Scalars['String']>;
  isSandboxCheck?: Scalars['Boolean'];
  proposedSchema?: InputMaybe<IntrospectionSchemaInput>;
  proposedSchemaDocument?: InputMaybe<Scalars['String']>;
  proposedSchemaHash?: InputMaybe<Scalars['String']>;
  useMaximumRetention?: InputMaybe<Scalars['Boolean']>;
};


export type ServiceMutationCheckWorkflowArgs = {
  id: Scalars['ID'];
};


export type ServiceMutationCreateCompositionStatusSubscriptionArgs = {
  channelID: Scalars['ID'];
  variant: Scalars['String'];
};


export type ServiceMutationCreateSchemaPublishSubscriptionArgs = {
  channelID: Scalars['ID'];
  variant: Scalars['String'];
};


export type ServiceMutationDeleteChannelArgs = {
  id: Scalars['ID'];
};


export type ServiceMutationDeleteQueryTriggerArgs = {
  id: Scalars['ID'];
};


export type ServiceMutationDeleteRegistrySubscriptionArgs = {
  id: Scalars['ID'];
};


export type ServiceMutationDeleteRegistrySubscriptionsArgs = {
  variant: Scalars['String'];
};


export type ServiceMutationDeleteScheduledSummaryArgs = {
  id: Scalars['ID'];
};


export type ServiceMutationDeleteSchemaTagArgs = {
  tag: Scalars['String'];
};


export type ServiceMutationDeleteTracesArgs = {
  from: Scalars['Timestamp'];
  to?: InputMaybe<Scalars['Timestamp']>;
};


export type ServiceMutationIgnoreOperationsInChecksArgs = {
  ids: Array<Scalars['ID']>;
};


export type ServiceMutationMarkChangesForOperationAsSafeArgs = {
  checkID: Scalars['ID'];
  operationID: Scalars['ID'];
};


export type ServiceMutationNewKeyArgs = {
  keyName?: InputMaybe<Scalars['String']>;
  role?: UserPermission;
};


export type ServiceMutationOverrideUserPermissionArgs = {
  permission?: InputMaybe<UserPermission>;
  userID: Scalars['ID'];
};


export type ServiceMutationPreviewContractVariantArgs = {
  filterConfig: FilterConfigInput;
  sourceVariant: Scalars['String'];
};


export type ServiceMutationPromoteSchemaArgs = {
  graphVariant: Scalars['String'];
  historicParameters?: InputMaybe<HistoricQueryParameters>;
  overrideComposedSchema?: Scalars['Boolean'];
  sha256: Scalars['SHA256'];
};


export type ServiceMutationRegisterOperationsWithResponseArgs = {
  clientIdentity?: InputMaybe<RegisteredClientIdentityInput>;
  gitContext?: InputMaybe<GitContextInput>;
  graphVariant?: Scalars['String'];
  manifestVersion?: InputMaybe<Scalars['Int']>;
  operations: Array<RegisteredOperationInput>;
};


export type ServiceMutationRemoveImplementingServiceAndTriggerCompositionArgs = {
  dryRun?: Scalars['Boolean'];
  graphVariant: Scalars['String'];
  name: Scalars['String'];
};


export type ServiceMutationRemoveKeyArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type ServiceMutationRenameKeyArgs = {
  id: Scalars['ID'];
  newKeyName?: InputMaybe<Scalars['String']>;
};


export type ServiceMutationReportServerInfoArgs = {
  executableSchema?: InputMaybe<Scalars['String']>;
  info: EdgeServerInfo;
};


export type ServiceMutationStoreSchemaDocumentArgs = {
  schemaDocument: Scalars['String'];
};


export type ServiceMutationTestSlackChannelArgs = {
  id: Scalars['ID'];
  notification: SlackNotificationInput;
};


export type ServiceMutationTestSubscriptionForChannelArgs = {
  channelID: Scalars['ID'];
  subscriptionID: Scalars['ID'];
};


export type ServiceMutationTransferArgs = {
  to: Scalars['String'];
};


export type ServiceMutationTriggerRepublishArgs = {
  graphVariant: Scalars['String'];
};


export type ServiceMutationUnignoreOperationsInChecksArgs = {
  ids: Array<Scalars['ID']>;
};


export type ServiceMutationUnmarkChangesForOperationAsSafeArgs = {
  checkID: Scalars['ID'];
  operationID: Scalars['ID'];
};


export type ServiceMutationUpdateCheckConfigurationArgs = {
  excludedClients?: InputMaybe<Array<ClientFilterInput>>;
  excludedOperations?: InputMaybe<Array<ExcludedOperationInput>>;
  includeBaseVariant?: InputMaybe<Scalars['Boolean']>;
  includedVariants?: InputMaybe<Array<Scalars['String']>>;
  operationCountThreshold?: InputMaybe<Scalars['Int']>;
  operationCountThresholdPercentage?: InputMaybe<Scalars['Float']>;
  timeRangeSeconds?: InputMaybe<Scalars['Long']>;
};


export type ServiceMutationUpdateDatadogMetricsConfigArgs = {
  apiKey?: InputMaybe<Scalars['String']>;
  apiRegion?: InputMaybe<DatadogApiRegion>;
  enabled?: InputMaybe<Scalars['Boolean']>;
};


export type ServiceMutationUpdateDescriptionArgs = {
  description: Scalars['String'];
};


export type ServiceMutationUpdateHiddenFromUninvitedNonAdminAccountMembersArgs = {
  hiddenFromUninvitedNonAdminAccountMembers: Scalars['Boolean'];
};


export type ServiceMutationUpdateReadmeArgs = {
  readme: Scalars['String'];
};


export type ServiceMutationUpdateTitleArgs = {
  title: Scalars['String'];
};


export type ServiceMutationUploadSchemaArgs = {
  errorOnBadRequest?: Scalars['Boolean'];
  gitContext?: InputMaybe<GitContextInput>;
  historicParameters?: InputMaybe<HistoricQueryParameters>;
  overrideComposedSchema?: Scalars['Boolean'];
  schema?: InputMaybe<IntrospectionSchemaInput>;
  schemaDocument?: InputMaybe<Scalars['String']>;
  tag: Scalars['String'];
};


export type ServiceMutationUpsertChannelArgs = {
  id?: InputMaybe<Scalars['ID']>;
  pagerDutyChannel?: InputMaybe<PagerDutyChannelInput>;
  slackChannel?: InputMaybe<SlackChannelInput>;
  webhookChannel?: InputMaybe<WebhookChannelInput>;
};


export type ServiceMutationUpsertContractVariantArgs = {
  contractVariantName: Scalars['String'];
  filterConfig: FilterConfigInput;
  initiateLaunch?: Scalars['Boolean'];
  sourceVariant: Scalars['String'];
};


export type ServiceMutationUpsertImplementingServiceAndTriggerCompositionArgs = {
  activePartialSchema: PartialSchemaInput;
  gitContext?: InputMaybe<GitContextInput>;
  graphVariant: Scalars['String'];
  name: Scalars['String'];
  revision: Scalars['String'];
  url?: InputMaybe<Scalars['String']>;
};


export type ServiceMutationUpsertPagerDutyChannelArgs = {
  channel: PagerDutyChannelInput;
  id?: InputMaybe<Scalars['ID']>;
};


export type ServiceMutationUpsertQueryTriggerArgs = {
  id?: InputMaybe<Scalars['ID']>;
  trigger: QueryTriggerInput;
};


export type ServiceMutationUpsertRegistrySubscriptionArgs = {
  channelID?: InputMaybe<Scalars['ID']>;
  id?: InputMaybe<Scalars['ID']>;
  options?: InputMaybe<SubscriptionOptionsInput>;
  variant?: InputMaybe<Scalars['String']>;
};


export type ServiceMutationUpsertScheduledSummaryArgs = {
  channelID?: InputMaybe<Scalars['ID']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['ID']>;
  tag?: InputMaybe<Scalars['String']>;
  timezone?: InputMaybe<Scalars['String']>;
  variant?: InputMaybe<Scalars['String']>;
};


export type ServiceMutationUpsertSlackChannelArgs = {
  channel: SlackChannelInput;
  id?: InputMaybe<Scalars['ID']>;
};


export type ServiceMutationUpsertWebhookChannelArgs = {
  id?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  secretToken?: InputMaybe<Scalars['String']>;
  url: Scalars['String'];
};


export type ServiceMutationValidateOperationsArgs = {
  gitContext?: InputMaybe<GitContextInput>;
  operations: Array<OperationDocumentInput>;
  tag?: InputMaybe<Scalars['String']>;
};


export type ServiceMutationValidatePartialSchemaOfImplementingServiceAgainstGraphArgs = {
  graphVariant: Scalars['String'];
  implementingServiceName: Scalars['String'];
  partialSchema: PartialSchemaInput;
};


export type ServiceMutationVariantArgs = {
  name: Scalars['String'];
};

/** Columns of ServiceOperationCheckStats. */
export enum ServiceOperationCheckStatsColumn {
  CachedRequestsCount = 'CACHED_REQUESTS_COUNT',
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaTag = 'SCHEMA_TAG',
  Timestamp = 'TIMESTAMP',
  UncachedRequestsCount = 'UNCACHED_REQUESTS_COUNT'
}

export type ServiceOperationCheckStatsDimensions = {
  __typename?: 'ServiceOperationCheckStatsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
};

/** Filter for data in ServiceOperationCheckStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ServiceOperationCheckStatsFilter = {
  and?: InputMaybe<Array<ServiceOperationCheckStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<ServiceOperationCheckStatsFilterIn>;
  not?: InputMaybe<ServiceOperationCheckStatsFilter>;
  or?: InputMaybe<Array<ServiceOperationCheckStatsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
};

/** Filter for data in ServiceOperationCheckStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ServiceOperationCheckStatsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ServiceOperationCheckStatsMetrics = {
  __typename?: 'ServiceOperationCheckStatsMetrics';
  cachedRequestsCount: Scalars['Long'];
  uncachedRequestsCount: Scalars['Long'];
};

export type ServiceOperationCheckStatsOrderBySpec = {
  column: ServiceOperationCheckStatsColumn;
  direction: Ordering;
};

export type ServiceOperationCheckStatsRecord = {
  __typename?: 'ServiceOperationCheckStatsRecord';
  /** Dimensions of ServiceOperationCheckStats that can be grouped by. */
  groupBy: ServiceOperationCheckStatsDimensions;
  /** Metrics of ServiceOperationCheckStats that can be aggregated over. */
  metrics: ServiceOperationCheckStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of ServiceQueryStats. */
export enum ServiceQueryStatsColumn {
  CachedHistogram = 'CACHED_HISTOGRAM',
  CachedRequestsCount = 'CACHED_REQUESTS_COUNT',
  CacheTtlHistogram = 'CACHE_TTL_HISTOGRAM',
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  ForbiddenOperationCount = 'FORBIDDEN_OPERATION_COUNT',
  FromEngineproxy = 'FROM_ENGINEPROXY',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  RegisteredOperationCount = 'REGISTERED_OPERATION_COUNT',
  RequestsWithErrorsCount = 'REQUESTS_WITH_ERRORS_COUNT',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  Timestamp = 'TIMESTAMP',
  UncachedHistogram = 'UNCACHED_HISTOGRAM',
  UncachedRequestsCount = 'UNCACHED_REQUESTS_COUNT'
}

export type ServiceQueryStatsDimensions = {
  __typename?: 'ServiceQueryStatsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  fromEngineproxy?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  querySignature?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
};

/** Filter for data in ServiceQueryStats. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ServiceQueryStatsFilter = {
  and?: InputMaybe<Array<ServiceQueryStatsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose fromEngineproxy dimension equals the given value if not null. To query for the null value, use {in: {fromEngineproxy: [null]}} instead. */
  fromEngineproxy?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<ServiceQueryStatsFilterIn>;
  not?: InputMaybe<ServiceQueryStatsFilter>;
  or?: InputMaybe<Array<ServiceQueryStatsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
};

/** Filter for data in ServiceQueryStats. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ServiceQueryStatsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose fromEngineproxy dimension is in the given list. A null value in the list means a row with null for that dimension. */
  fromEngineproxy?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

export type ServiceQueryStatsMetrics = {
  __typename?: 'ServiceQueryStatsMetrics';
  cacheTtlHistogram: DurationHistogram;
  cachedHistogram: DurationHistogram;
  cachedRequestsCount: Scalars['Long'];
  forbiddenOperationCount: Scalars['Long'];
  registeredOperationCount: Scalars['Long'];
  requestsWithErrorsCount: Scalars['Long'];
  totalLatencyHistogram: DurationHistogram;
  totalRequestCount: Scalars['Long'];
  uncachedHistogram: DurationHistogram;
  uncachedRequestsCount: Scalars['Long'];
};

export type ServiceQueryStatsOrderBySpec = {
  column: ServiceQueryStatsColumn;
  direction: Ordering;
};

export type ServiceQueryStatsRecord = {
  __typename?: 'ServiceQueryStatsRecord';
  /** Dimensions of ServiceQueryStats that can be grouped by. */
  groupBy: ServiceQueryStatsDimensions;
  /** Metrics of ServiceQueryStats that can be aggregated over. */
  metrics: ServiceQueryStatsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** A map from role (permission) String to boolean that the current user is allowed for the root service */
export type ServiceRoles = {
  __typename?: 'ServiceRoles';
  canCheckSchemas: Scalars['Boolean'];
  canCreateVariants: Scalars['Boolean'];
  canDelete: Scalars['Boolean'];
  canManageAccess: Scalars['Boolean'];
  canManageBuildConfig: Scalars['Boolean'];
  canManageIntegrations: Scalars['Boolean'];
  canManageKeys: Scalars['Boolean'];
  canManageVariants: Scalars['Boolean'];
  canQueryBuildConfig: Scalars['Boolean'];
  canQueryCheckConfiguration: Scalars['Boolean'];
  canQueryDeletedImplementingServices: Scalars['Boolean'];
  canQueryImplementingServices: Scalars['Boolean'];
  canQueryIntegrations: Scalars['Boolean'];
  canQueryPrivateInfo: Scalars['Boolean'];
  canQueryPublicInfo: Scalars['Boolean'];
  canQueryReadmeAuthor: Scalars['Boolean'];
  canQueryRoleOverrides: Scalars['Boolean'];
  canQuerySchemas: Scalars['Boolean'];
  canQueryStats: Scalars['Boolean'];
  canQueryTokens: Scalars['Boolean'];
  canQueryTraces: Scalars['Boolean'];
  canRegisterOperations: Scalars['Boolean'];
  canStoreSchemasWithoutVariant: Scalars['Boolean'];
  canUndelete: Scalars['Boolean'];
  canUpdateAvatar: Scalars['Boolean'];
  canUpdateDescription: Scalars['Boolean'];
  canUpdateTitle: Scalars['Boolean'];
  /** @deprecated Replaced with canQueryTraces and canQueryStats */
  canVisualizeStats: Scalars['Boolean'];
  canWriteCheckConfiguration: Scalars['Boolean'];
  /** @deprecated Never worked, not replaced */
  canWriteTraces: Scalars['Boolean'];
};

/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindow = {
  __typename?: 'ServiceStatsWindow';
  edgeServerInfos: Array<ServiceEdgeServerInfosRecord>;
  errorStats: Array<ServiceErrorStatsRecord>;
  fieldLatencies: Array<ServiceFieldLatenciesRecord>;
  fieldStats: Array<ServiceFieldLatenciesRecord>;
  fieldUsage: Array<ServiceFieldUsageRecord>;
  operationCheckStats: Array<ServiceOperationCheckStatsRecord>;
  queryStats: Array<ServiceQueryStatsRecord>;
  /** From field rounded down to the nearest resolution. */
  roundedDownFrom: Scalars['Timestamp'];
  /** To field rounded up to the nearest resolution. */
  roundedUpTo: Scalars['Timestamp'];
  tracePathErrorsRefs: Array<ServiceTracePathErrorsRefsRecord>;
  traceRefs: Array<ServiceTraceRefsRecord>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowEdgeServerInfosArgs = {
  filter?: InputMaybe<ServiceEdgeServerInfosFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceEdgeServerInfosOrderBySpec>>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowErrorStatsArgs = {
  filter?: InputMaybe<ServiceErrorStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceErrorStatsOrderBySpec>>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowFieldLatenciesArgs = {
  filter?: InputMaybe<ServiceFieldLatenciesFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceFieldLatenciesOrderBySpec>>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowFieldStatsArgs = {
  filter?: InputMaybe<ServiceFieldLatenciesFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceFieldLatenciesOrderBySpec>>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowFieldUsageArgs = {
  filter?: InputMaybe<ServiceFieldUsageFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceFieldUsageOrderBySpec>>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowOperationCheckStatsArgs = {
  filter?: InputMaybe<ServiceOperationCheckStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceOperationCheckStatsOrderBySpec>>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowQueryStatsArgs = {
  filter?: InputMaybe<ServiceQueryStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceQueryStatsOrderBySpec>>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowTracePathErrorsRefsArgs = {
  filter?: InputMaybe<ServiceTracePathErrorsRefsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceTracePathErrorsRefsOrderBySpec>>;
};


/** A time window with a specified granularity over a given service. */
export type ServiceStatsWindowTraceRefsArgs = {
  filter?: InputMaybe<ServiceTraceRefsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ServiceTraceRefsOrderBySpec>>;
};

/** Columns of ServiceTracePathErrorsRefs. */
export enum ServiceTracePathErrorsRefsColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  DurationBucket = 'DURATION_BUCKET',
  ErrorsCountInPath = 'ERRORS_COUNT_IN_PATH',
  ErrorsCountInTrace = 'ERRORS_COUNT_IN_TRACE',
  ErrorMessage = 'ERROR_MESSAGE',
  Path = 'PATH',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  Timestamp = 'TIMESTAMP',
  TraceHttpStatusCode = 'TRACE_HTTP_STATUS_CODE',
  TraceId = 'TRACE_ID',
  TraceSizeBytes = 'TRACE_SIZE_BYTES',
  TraceStartsAt = 'TRACE_STARTS_AT'
}

export type ServiceTracePathErrorsRefsDimensions = {
  __typename?: 'ServiceTracePathErrorsRefsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  durationBucket?: Maybe<Scalars['Int']>;
  errorMessage?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  traceHttpStatusCode?: Maybe<Scalars['Int']>;
  traceId?: Maybe<Scalars['ID']>;
  traceStartsAt?: Maybe<Scalars['Timestamp']>;
};

/** Filter for data in ServiceTracePathErrorsRefs. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ServiceTracePathErrorsRefsFilter = {
  and?: InputMaybe<Array<ServiceTracePathErrorsRefsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose durationBucket dimension equals the given value if not null. To query for the null value, use {in: {durationBucket: [null]}} instead. */
  durationBucket?: InputMaybe<Scalars['Int']>;
  /** Selects rows whose errorMessage dimension equals the given value if not null. To query for the null value, use {in: {errorMessage: [null]}} instead. */
  errorMessage?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<ServiceTracePathErrorsRefsFilterIn>;
  not?: InputMaybe<ServiceTracePathErrorsRefsFilter>;
  or?: InputMaybe<Array<ServiceTracePathErrorsRefsFilter>>;
  /** Selects rows whose path dimension equals the given value if not null. To query for the null value, use {in: {path: [null]}} instead. */
  path?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose traceHttpStatusCode dimension equals the given value if not null. To query for the null value, use {in: {traceHttpStatusCode: [null]}} instead. */
  traceHttpStatusCode?: InputMaybe<Scalars['Int']>;
  /** Selects rows whose traceId dimension equals the given value if not null. To query for the null value, use {in: {traceId: [null]}} instead. */
  traceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in ServiceTracePathErrorsRefs. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ServiceTracePathErrorsRefsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose durationBucket dimension is in the given list. A null value in the list means a row with null for that dimension. */
  durationBucket?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose errorMessage dimension is in the given list. A null value in the list means a row with null for that dimension. */
  errorMessage?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose path dimension is in the given list. A null value in the list means a row with null for that dimension. */
  path?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose traceHttpStatusCode dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceHttpStatusCode?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose traceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type ServiceTracePathErrorsRefsMetrics = {
  __typename?: 'ServiceTracePathErrorsRefsMetrics';
  errorsCountInPath: Scalars['Long'];
  errorsCountInTrace: Scalars['Long'];
  traceSizeBytes: Scalars['Long'];
};

export type ServiceTracePathErrorsRefsOrderBySpec = {
  column: ServiceTracePathErrorsRefsColumn;
  direction: Ordering;
};

export type ServiceTracePathErrorsRefsRecord = {
  __typename?: 'ServiceTracePathErrorsRefsRecord';
  /** Dimensions of ServiceTracePathErrorsRefs that can be grouped by. */
  groupBy: ServiceTracePathErrorsRefsDimensions;
  /** Metrics of ServiceTracePathErrorsRefs that can be aggregated over. */
  metrics: ServiceTracePathErrorsRefsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of ServiceTraceRefs. */
export enum ServiceTraceRefsColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  DurationBucket = 'DURATION_BUCKET',
  DurationNs = 'DURATION_NS',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  Timestamp = 'TIMESTAMP',
  TraceId = 'TRACE_ID',
  TraceSizeBytes = 'TRACE_SIZE_BYTES'
}

export type ServiceTraceRefsDimensions = {
  __typename?: 'ServiceTraceRefsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  durationBucket?: Maybe<Scalars['Int']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  querySignature?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  traceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in ServiceTraceRefs. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type ServiceTraceRefsFilter = {
  and?: InputMaybe<Array<ServiceTraceRefsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose durationBucket dimension equals the given value if not null. To query for the null value, use {in: {durationBucket: [null]}} instead. */
  durationBucket?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<ServiceTraceRefsFilterIn>;
  not?: InputMaybe<ServiceTraceRefsFilter>;
  or?: InputMaybe<Array<ServiceTraceRefsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose traceId dimension equals the given value if not null. To query for the null value, use {in: {traceId: [null]}} instead. */
  traceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in ServiceTraceRefs. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type ServiceTraceRefsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose durationBucket dimension is in the given list. A null value in the list means a row with null for that dimension. */
  durationBucket?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose traceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type ServiceTraceRefsMetrics = {
  __typename?: 'ServiceTraceRefsMetrics';
  durationNs: Scalars['Long'];
  traceSizeBytes: Scalars['Long'];
};

export type ServiceTraceRefsOrderBySpec = {
  column: ServiceTraceRefsColumn;
  direction: Ordering;
};

export type ServiceTraceRefsRecord = {
  __typename?: 'ServiceTraceRefsRecord';
  /** Dimensions of ServiceTraceRefs that can be grouped by. */
  groupBy: ServiceTraceRefsDimensions;
  /** Metrics of ServiceTraceRefs that can be aggregated over. */
  metrics: ServiceTraceRefsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Slack notification channel */
export type SlackChannel = Channel & {
  __typename?: 'SlackChannel';
  id: Scalars['ID'];
  name: Scalars['String'];
  subscriptions: Array<ChannelSubscription>;
  url: Scalars['String'];
};

/** Slack notification channel parameters */
export type SlackChannelInput = {
  name?: InputMaybe<Scalars['String']>;
  url: Scalars['String'];
};

export type SlackNotificationField = {
  key: Scalars['String'];
  value: Scalars['String'];
};

/** Slack notification message */
export type SlackNotificationInput = {
  color?: InputMaybe<Scalars['String']>;
  fallback: Scalars['String'];
  fields?: InputMaybe<Array<SlackNotificationField>>;
  iconUrl?: InputMaybe<Scalars['String']>;
  text?: InputMaybe<Scalars['String']>;
  timestamp?: InputMaybe<Scalars['Timestamp']>;
  title?: InputMaybe<Scalars['String']>;
  titleLink?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
};

export type SourceLocation = {
  __typename?: 'SourceLocation';
  column: Scalars['Int'];
  line: Scalars['Int'];
};

/** A time window with a specified granularity. */
export type StatsWindow = {
  __typename?: 'StatsWindow';
  edgeServerInfos: Array<EdgeServerInfosRecord>;
  errorStats: Array<ErrorStatsRecord>;
  fieldLatencies: Array<FieldLatenciesRecord>;
  fieldUsage: Array<FieldUsageRecord>;
  operationCheckStats: Array<OperationCheckStatsRecord>;
  queryStats: Array<QueryStatsRecord>;
  /** From field rounded down to the nearest resolution. */
  roundedDownFrom: Scalars['Timestamp'];
  /** To field rounded up to the nearest resolution. */
  roundedUpTo: Scalars['Timestamp'];
  tracePathErrorsRefs: Array<TracePathErrorsRefsRecord>;
  traceRefs: Array<TraceRefsRecord>;
};


/** A time window with a specified granularity. */
export type StatsWindowEdgeServerInfosArgs = {
  filter?: InputMaybe<EdgeServerInfosFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EdgeServerInfosOrderBySpec>>;
};


/** A time window with a specified granularity. */
export type StatsWindowErrorStatsArgs = {
  filter?: InputMaybe<ErrorStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ErrorStatsOrderBySpec>>;
};


/** A time window with a specified granularity. */
export type StatsWindowFieldLatenciesArgs = {
  filter?: InputMaybe<FieldLatenciesFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FieldLatenciesOrderBySpec>>;
};


/** A time window with a specified granularity. */
export type StatsWindowFieldUsageArgs = {
  filter?: InputMaybe<FieldUsageFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FieldUsageOrderBySpec>>;
};


/** A time window with a specified granularity. */
export type StatsWindowOperationCheckStatsArgs = {
  filter?: InputMaybe<OperationCheckStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OperationCheckStatsOrderBySpec>>;
};


/** A time window with a specified granularity. */
export type StatsWindowQueryStatsArgs = {
  filter?: InputMaybe<QueryStatsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<QueryStatsOrderBySpec>>;
};


/** A time window with a specified granularity. */
export type StatsWindowTracePathErrorsRefsArgs = {
  filter?: InputMaybe<TracePathErrorsRefsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TracePathErrorsRefsOrderBySpec>>;
};


/** A time window with a specified granularity. */
export type StatsWindowTraceRefsArgs = {
  filter?: InputMaybe<TraceRefsFilter>;
  limit?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TraceRefsOrderBySpec>>;
};

export type StoreSchemaError = {
  __typename?: 'StoreSchemaError';
  code: StoreSchemaErrorCode;
  message: Scalars['String'];
};

export enum StoreSchemaErrorCode {
  SchemaIsNotParsable = 'SCHEMA_IS_NOT_PARSABLE',
  SchemaIsNotValid = 'SCHEMA_IS_NOT_VALID'
}

export type StoreSchemaResponse = {
  __typename?: 'StoreSchemaResponse';
  sha256: Scalars['SHA256'];
};

export type StoreSchemaResponseOrError = StoreSchemaError | StoreSchemaResponse;

export type StoredApprovedChange = {
  __typename?: 'StoredApprovedChange';
  argNode?: Maybe<NamedIntrospectionArgNoDescription>;
  childNode?: Maybe<NamedIntrospectionValueNoDescription>;
  code: ChangeCode;
  parentNode?: Maybe<NamedIntrospectionTypeNoDescription>;
};

export type StringToString = {
  __typename?: 'StringToString';
  key: Scalars['String'];
  value: Scalars['String'];
};

export type StringToStringInput = {
  key: Scalars['String'];
  value: Scalars['String'];
};

export type Subgraph = {
  __typename?: 'Subgraph';
  hash: Scalars['String'];
  name: Scalars['String'];
  routingURL: Scalars['String'];
};

export type SubgraphChange = {
  __typename?: 'SubgraphChange';
  name: Scalars['ID'];
  type: SubgraphChangeType;
};

export enum SubgraphChangeType {
  Addition = 'ADDITION',
  Deletion = 'DELETION',
  Modification = 'MODIFICATION'
}

export type SubgraphConfig = {
  __typename?: 'SubgraphConfig';
  id: Scalars['ID'];
  name: Scalars['String'];
  schemaHash: Scalars['String'];
  sdl: Scalars['String'];
  url: Scalars['String'];
};

export type SubscriptionOptions = {
  __typename?: 'SubscriptionOptions';
  /** Enables notifications for schema updates */
  schemaUpdates: Scalars['Boolean'];
};

export type SubscriptionOptionsInput = {
  /** Enables notifications for schema updates */
  schemaUpdates: Scalars['Boolean'];
};

export enum SubscriptionState {
  Active = 'ACTIVE',
  Canceled = 'CANCELED',
  Expired = 'EXPIRED',
  Future = 'FUTURE',
  PastDue = 'PAST_DUE',
  Paused = 'PAUSED',
  Pending = 'PENDING',
  Unknown = 'UNKNOWN'
}

export type TemporaryUrl = {
  __typename?: 'TemporaryURL';
  url: Scalars['String'];
};

export enum ThemeName {
  Dark = 'DARK',
  Light = 'LIGHT'
}

export enum TicketPriority {
  P0 = 'P0',
  P1 = 'P1',
  P2 = 'P2',
  P3 = 'P3'
}

export enum TicketStatus {
  Closed = 'CLOSED',
  Hold = 'HOLD',
  New = 'NEW',
  Open = 'OPEN',
  Pending = 'PENDING',
  Solved = 'SOLVED'
}

export type TimezoneOffset = {
  __typename?: 'TimezoneOffset';
  minutesOffsetFromUTC: Scalars['Int'];
  zoneID: Scalars['String'];
};

export type TotalChangeSummaryCounts = {
  __typename?: 'TotalChangeSummaryCounts';
  /**
   * Number of changes that are additions. This includes adding types, adding fields to object, input
   * object, and interface types, adding values to enums, adding members to interfaces and unions, and
   * adding arguments.
   */
  additions: Scalars['Int'];
  /** Number of changes that are new usages of the @deprecated directive. */
  deprecations: Scalars['Int'];
  /**
   * Number of changes that are edits. This includes types changing kind, fields and arguments
   * changing type, arguments changing default value, and any description changes. This also includes
   * edits to @deprecated reason strings.
   */
  edits: Scalars['Int'];
  /**
   * Number of changes that are removals. This includes removing types, removing fields from object,
   * input object, and interface types, removing values from enums, removing members from interfaces
   * and unions, and removing arguments. This also includes removing @deprecated usages.
   */
  removals: Scalars['Int'];
};

export type Trace = {
  __typename?: 'Trace';
  cacheMaxAgeMs?: Maybe<Scalars['Float']>;
  cacheScope?: Maybe<CacheScope>;
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  durationMs: Scalars['Float'];
  endTime: Scalars['Timestamp'];
  http?: Maybe<TraceHttp>;
  id: Scalars['ID'];
  operationName?: Maybe<Scalars['String']>;
  protobuf: Protobuf;
  root: TraceNode;
  signature: Scalars['String'];
  startTime: Scalars['Timestamp'];
  variablesJSON: Array<StringToString>;
};

export type TraceError = {
  __typename?: 'TraceError';
  json: Scalars['String'];
  locations: Array<TraceSourceLocation>;
  message: Scalars['String'];
  timestamp?: Maybe<Scalars['Timestamp']>;
};

export type TraceHttp = {
  __typename?: 'TraceHTTP';
  host?: Maybe<Scalars['String']>;
  method: HttpMethod;
  path?: Maybe<Scalars['String']>;
  protocol?: Maybe<Scalars['String']>;
  requestHeaders: Array<StringToString>;
  responseHeaders: Array<StringToString>;
  secure: Scalars['Boolean'];
  statusCode: Scalars['Int'];
};

export type TraceNode = {
  __typename?: 'TraceNode';
  cacheMaxAgeMs?: Maybe<Scalars['Float']>;
  cacheScope?: Maybe<CacheScope>;
  children: Array<TraceNode>;
  childrenIds: Array<Scalars['ID']>;
  descendants: Array<TraceNode>;
  descendantsIds: Array<Scalars['ID']>;
  endTime: Scalars['Timestamp'];
  errors: Array<TraceError>;
  id: Scalars['ID'];
  key?: Maybe<Scalars['StringOrInt']>;
  originalFieldName?: Maybe<Scalars['String']>;
  parent: Scalars['ID'];
  parentId?: Maybe<Scalars['ID']>;
  path: Array<Scalars['String']>;
  startTime: Scalars['Timestamp'];
  type?: Maybe<Scalars['String']>;
};

/** Columns of TracePathErrorsRefs. */
export enum TracePathErrorsRefsColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  DurationBucket = 'DURATION_BUCKET',
  ErrorsCountInPath = 'ERRORS_COUNT_IN_PATH',
  ErrorsCountInTrace = 'ERRORS_COUNT_IN_TRACE',
  ErrorMessage = 'ERROR_MESSAGE',
  Path = 'PATH',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  TraceHttpStatusCode = 'TRACE_HTTP_STATUS_CODE',
  TraceId = 'TRACE_ID',
  TraceSizeBytes = 'TRACE_SIZE_BYTES',
  TraceStartsAt = 'TRACE_STARTS_AT'
}

export type TracePathErrorsRefsDimensions = {
  __typename?: 'TracePathErrorsRefsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  durationBucket?: Maybe<Scalars['Int']>;
  errorMessage?: Maybe<Scalars['String']>;
  /** If metrics were collected from a federated service, this field will be prefixed with `service:<SERVICE_NAME>.` */
  path?: Maybe<Scalars['String']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
  traceHttpStatusCode?: Maybe<Scalars['Int']>;
  traceId?: Maybe<Scalars['ID']>;
  traceStartsAt?: Maybe<Scalars['Timestamp']>;
};

/** Filter for data in TracePathErrorsRefs. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type TracePathErrorsRefsFilter = {
  and?: InputMaybe<Array<TracePathErrorsRefsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose durationBucket dimension equals the given value if not null. To query for the null value, use {in: {durationBucket: [null]}} instead. */
  durationBucket?: InputMaybe<Scalars['Int']>;
  /** Selects rows whose errorMessage dimension equals the given value if not null. To query for the null value, use {in: {errorMessage: [null]}} instead. */
  errorMessage?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<TracePathErrorsRefsFilterIn>;
  not?: InputMaybe<TracePathErrorsRefsFilter>;
  or?: InputMaybe<Array<TracePathErrorsRefsFilter>>;
  /** Selects rows whose path dimension equals the given value if not null. To query for the null value, use {in: {path: [null]}} instead. */
  path?: InputMaybe<Scalars['String']>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose traceHttpStatusCode dimension equals the given value if not null. To query for the null value, use {in: {traceHttpStatusCode: [null]}} instead. */
  traceHttpStatusCode?: InputMaybe<Scalars['Int']>;
  /** Selects rows whose traceId dimension equals the given value if not null. To query for the null value, use {in: {traceId: [null]}} instead. */
  traceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in TracePathErrorsRefs. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type TracePathErrorsRefsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose durationBucket dimension is in the given list. A null value in the list means a row with null for that dimension. */
  durationBucket?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose errorMessage dimension is in the given list. A null value in the list means a row with null for that dimension. */
  errorMessage?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose path dimension is in the given list. A null value in the list means a row with null for that dimension. */
  path?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose traceHttpStatusCode dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceHttpStatusCode?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose traceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type TracePathErrorsRefsMetrics = {
  __typename?: 'TracePathErrorsRefsMetrics';
  errorsCountInPath: Scalars['Long'];
  errorsCountInTrace: Scalars['Long'];
  traceSizeBytes: Scalars['Long'];
};

export type TracePathErrorsRefsOrderBySpec = {
  column: TracePathErrorsRefsColumn;
  direction: Ordering;
};

export type TracePathErrorsRefsRecord = {
  __typename?: 'TracePathErrorsRefsRecord';
  /** Dimensions of TracePathErrorsRefs that can be grouped by. */
  groupBy: TracePathErrorsRefsDimensions;
  /** Metrics of TracePathErrorsRefs that can be aggregated over. */
  metrics: TracePathErrorsRefsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

/** Columns of TraceRefs. */
export enum TraceRefsColumn {
  ClientName = 'CLIENT_NAME',
  ClientVersion = 'CLIENT_VERSION',
  DurationBucket = 'DURATION_BUCKET',
  DurationNs = 'DURATION_NS',
  QueryId = 'QUERY_ID',
  QueryName = 'QUERY_NAME',
  SchemaHash = 'SCHEMA_HASH',
  SchemaTag = 'SCHEMA_TAG',
  ServiceId = 'SERVICE_ID',
  Timestamp = 'TIMESTAMP',
  TraceId = 'TRACE_ID',
  TraceSizeBytes = 'TRACE_SIZE_BYTES'
}

export type TraceRefsDimensions = {
  __typename?: 'TraceRefsDimensions';
  clientName?: Maybe<Scalars['String']>;
  clientVersion?: Maybe<Scalars['String']>;
  durationBucket?: Maybe<Scalars['Int']>;
  queryId?: Maybe<Scalars['ID']>;
  queryName?: Maybe<Scalars['String']>;
  querySignature?: Maybe<Scalars['String']>;
  schemaHash?: Maybe<Scalars['String']>;
  schemaTag?: Maybe<Scalars['String']>;
  serviceId?: Maybe<Scalars['ID']>;
  traceId?: Maybe<Scalars['ID']>;
};

/** Filter for data in TraceRefs. Fields with dimension names represent equality checks. All fields are implicitly ANDed together. */
export type TraceRefsFilter = {
  and?: InputMaybe<Array<TraceRefsFilter>>;
  /** Selects rows whose clientName dimension equals the given value if not null. To query for the null value, use {in: {clientName: [null]}} instead. */
  clientName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose clientVersion dimension equals the given value if not null. To query for the null value, use {in: {clientVersion: [null]}} instead. */
  clientVersion?: InputMaybe<Scalars['String']>;
  /** Selects rows whose durationBucket dimension equals the given value if not null. To query for the null value, use {in: {durationBucket: [null]}} instead. */
  durationBucket?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<TraceRefsFilterIn>;
  not?: InputMaybe<TraceRefsFilter>;
  or?: InputMaybe<Array<TraceRefsFilter>>;
  /** Selects rows whose queryId dimension equals the given value if not null. To query for the null value, use {in: {queryId: [null]}} instead. */
  queryId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose queryName dimension equals the given value if not null. To query for the null value, use {in: {queryName: [null]}} instead. */
  queryName?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaHash dimension equals the given value if not null. To query for the null value, use {in: {schemaHash: [null]}} instead. */
  schemaHash?: InputMaybe<Scalars['String']>;
  /** Selects rows whose schemaTag dimension equals the given value if not null. To query for the null value, use {in: {schemaTag: [null]}} instead. */
  schemaTag?: InputMaybe<Scalars['String']>;
  /** Selects rows whose serviceId dimension equals the given value if not null. To query for the null value, use {in: {serviceId: [null]}} instead. */
  serviceId?: InputMaybe<Scalars['ID']>;
  /** Selects rows whose traceId dimension equals the given value if not null. To query for the null value, use {in: {traceId: [null]}} instead. */
  traceId?: InputMaybe<Scalars['ID']>;
};

/** Filter for data in TraceRefs. Fields match if the corresponding dimension's value is in the given list. All fields are implicitly ANDed together. */
export type TraceRefsFilterIn = {
  /** Selects rows whose clientName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose clientVersion dimension is in the given list. A null value in the list means a row with null for that dimension. */
  clientVersion?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose durationBucket dimension is in the given list. A null value in the list means a row with null for that dimension. */
  durationBucket?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Selects rows whose queryId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose queryName dimension is in the given list. A null value in the list means a row with null for that dimension. */
  queryName?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaHash dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaHash?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose schemaTag dimension is in the given list. A null value in the list means a row with null for that dimension. */
  schemaTag?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Selects rows whose serviceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  serviceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Selects rows whose traceId dimension is in the given list. A null value in the list means a row with null for that dimension. */
  traceId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
};

export type TraceRefsMetrics = {
  __typename?: 'TraceRefsMetrics';
  durationNs: Scalars['Long'];
  traceSizeBytes: Scalars['Long'];
};

export type TraceRefsOrderBySpec = {
  column: TraceRefsColumn;
  direction: Ordering;
};

export type TraceRefsRecord = {
  __typename?: 'TraceRefsRecord';
  /** Dimensions of TraceRefs that can be grouped by. */
  groupBy: TraceRefsDimensions;
  /** Metrics of TraceRefs that can be aggregated over. */
  metrics: TraceRefsMetrics;
  /** Starting segment timestamp. */
  timestamp: Scalars['Timestamp'];
};

export type TraceSourceLocation = {
  __typename?: 'TraceSourceLocation';
  column: Scalars['Int'];
  line: Scalars['Int'];
};

export type TypeChangeSummaryCounts = {
  __typename?: 'TypeChangeSummaryCounts';
  /** Number of changes that are additions of types. */
  additions: Scalars['Int'];
  /**
   * Number of changes that are edits. This includes types changing kind and any type description
   * changes, but also includes adding/removing values from enums, adding/removing members from
   * interfaces and unions, and any enum value deprecation and description changes.
   */
  edits: Scalars['Int'];
  /** Number of changes that are removals of types. */
  removals: Scalars['Int'];
};

/**
 * the TypeFilterConfig is used to isolate
 * types, and subsequent fields, through
 * various configuration settings.
 *
 * It defaults to filter towards user defined
 * types only
 */
export type TypeFilterConfig = {
  /** include abstract types (interfaces and unions) */
  includeAbstractTypes?: InputMaybe<Scalars['Boolean']>;
  /** include built in scalars (i.e. Boolean, Int, etc) */
  includeBuiltInTypes?: InputMaybe<Scalars['Boolean']>;
  /** include reserved introspection types (i.e. __Type) */
  includeIntrospectionTypes?: InputMaybe<Scalars['Boolean']>;
};

export type Uri = {
  __typename?: 'URI';
  /** A GCS URI */
  gcs: Scalars['String'];
};

export type UnignoreOperationsInChecksResult = {
  __typename?: 'UnignoreOperationsInChecksResult';
  graph: Service;
};

export type UpdateOperationCollectionEntryResult = OperationCollectionEntry | ValidationError;

export type UpdateOperationCollectionResult = OperationCollection | ValidationError;

export type UploadSchemaMutationResponse = {
  __typename?: 'UploadSchemaMutationResponse';
  code: Scalars['String'];
  message: Scalars['String'];
  success: Scalars['Boolean'];
  tag?: Maybe<SchemaTag>;
};

export type User = Identity & {
  __typename?: 'User';
  acceptedPrivacyPolicyAt?: Maybe<Scalars['Timestamp']>;
  /** @deprecated Replaced with User.memberships.account */
  accounts: Array<Account>;
  apiKeys: Array<UserApiKey>;
  asActor: Actor;
  /**
   * Get an URL to which an avatar image can be uploaded. Client uploads by sending a PUT request
   * with the image data to MediaUploadInfo.url. Client SHOULD set the "Content-Type" header to the
   * browser-inferred MIME type, and SHOULD set the "x-apollo-content-filename" header to the
   * filename, if such information is available. Client MUST set the "x-apollo-csrf-token" header to
   * MediaUploadInfo.csrfToken.
   */
  avatarUpload?: Maybe<AvatarUploadResult>;
  /**
   * Get an image URL for the user's avatar. Note that CORS is not enabled for these URLs. The size
   * argument is used for bandwidth reduction, and should be the size of the image as displayed in the
   * application. Apollo's media server will downscale larger images to at least the requested size,
   * but this will not happen for third-party media servers.
   */
  avatarUrl?: Maybe<Scalars['String']>;
  betaFeaturesOn: Scalars['Boolean'];
  canUpdateAvatar: Scalars['Boolean'];
  canUpdateEmail: Scalars['Boolean'];
  canUpdateFullName: Scalars['Boolean'];
  createdAt: Scalars['Timestamp'];
  email?: Maybe<Scalars['String']>;
  emailModifiedAt?: Maybe<Scalars['Timestamp']>;
  emailVerified: Scalars['Boolean'];
  experimentalFeatures: UserExperimentalFeatures;
  featureIntros?: Maybe<FeatureIntros>;
  fullName: Scalars['String'];
  /** The user's GitHub username, if they log in via GitHub. May be null even for GitHub users in some edge cases. */
  githubUsername?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /**
   * This role is reserved exclusively for internal MDG employees, and it controls what access they may have to other
   * organizations. Only admins are allowed to see this field.
   */
  internalAdminRole?: Maybe<InternalMdgAdminRole>;
  /** Last time any API token from this user was used against AGM services */
  lastAuthenticatedAt?: Maybe<Scalars['Timestamp']>;
  logoutAfterIdleMs?: Maybe<Scalars['Int']>;
  memberships: Array<UserMembership>;
  name: Scalars['String'];
  odysseyCertifications?: Maybe<Array<OdysseyCertification>>;
  odysseyCourses?: Maybe<Array<OdysseyCourse>>;
  odysseyTasks?: Maybe<Array<OdysseyTask>>;
  synchronized: Scalars['Boolean'];
  /** List of Zendesk tickets this user has submitted */
  tickets?: Maybe<Array<ZendeskTicket>>;
  type: UserType;
};


export type UserApiKeysArgs = {
  includeCookies?: InputMaybe<Scalars['Boolean']>;
};


export type UserAvatarUrlArgs = {
  size?: Scalars['Int'];
};

export type UserApiKey = ApiKey & {
  __typename?: 'UserApiKey';
  id: Scalars['ID'];
  keyName?: Maybe<Scalars['String']>;
  token: Scalars['String'];
};

export type UserExperimentalFeatures = {
  __typename?: 'UserExperimentalFeatures';
  exampleFeature: Scalars['Boolean'];
};

export type UserMembership = {
  __typename?: 'UserMembership';
  account: Account;
  createdAt: Scalars['Timestamp'];
  permission: UserPermission;
  user: User;
};

export type UserMutation = {
  __typename?: 'UserMutation';
  acceptPrivacyPolicy?: Maybe<Scalars['Void']>;
  /** Change the user's password */
  changePassword?: Maybe<Scalars['Void']>;
  createOdysseyCertification?: Maybe<OdysseyCertification>;
  createOdysseyCourses?: Maybe<Array<OdysseyCourse>>;
  createOdysseyTasks?: Maybe<Array<OdysseyTask>>;
  /** Delete the user's avatar. Requires User.canUpdateAvatar to be true. */
  deleteAvatar?: Maybe<AvatarDeleteError>;
  /** Hard deletes the associated user. Throws an error otherwise with reason included. */
  hardDelete?: Maybe<Scalars['Void']>;
  /** Create a new API key for this user. Must take in a name for this key. */
  newKey: UserApiKey;
  /**
   * Create a new API key for this user if there are no current API keys.
   * If an API key already exists, this will return one at random and not create a new one.
   */
  provisionKey?: Maybe<ApiKeyProvision>;
  /** Refresh information about the user from its upstream service (eg list of organizations from GitHub) */
  refresh?: Maybe<User>;
  /** Removes the given key from this user. Can be used to remove either a web cookie or a user API key. */
  removeKey?: Maybe<Scalars['Void']>;
  /** Renames the given key to the new key name. */
  renameKey?: Maybe<UserApiKey>;
  resendVerificationEmail?: Maybe<Scalars['Void']>;
  setOdysseyCourse?: Maybe<OdysseyCourse>;
  setOdysseyTask?: Maybe<OdysseyTask>;
  /** Submit a zendesk ticket for this user */
  submitZendeskTicket?: Maybe<ZendeskTicket>;
  /** Update information about a user; all arguments are optional */
  update?: Maybe<User>;
  /** Updates this users' preference concerning opting into beta features. */
  updateBetaFeaturesOn?: Maybe<User>;
  /** Update the status of a feature for this. For example, if you want to hide an introductory popup. */
  updateFeatureIntros?: Maybe<User>;
  /**
   * Update user to have the given internal mdg admin role.
   * It is necessary to be an MDG_INTERNAL_SUPER_ADMIN to perform update.
   * Additionally, upserting a null value explicitly revokes this user's
   * admin status.
   */
  updateRole?: Maybe<User>;
  user: User;
  verifyEmail?: Maybe<User>;
};


export type UserMutationChangePasswordArgs = {
  newPassword: Scalars['String'];
  previousPassword: Scalars['String'];
};


export type UserMutationCreateOdysseyCertificationArgs = {
  certificationId: Scalars['String'];
};


export type UserMutationCreateOdysseyCoursesArgs = {
  courses: Array<OdysseyCourseInput>;
};


export type UserMutationCreateOdysseyTasksArgs = {
  tasks: Array<OdysseyTaskInput>;
};


export type UserMutationNewKeyArgs = {
  keyName: Scalars['String'];
};


export type UserMutationProvisionKeyArgs = {
  keyName?: Scalars['String'];
};


export type UserMutationRemoveKeyArgs = {
  id: Scalars['ID'];
};


export type UserMutationRenameKeyArgs = {
  id: Scalars['ID'];
  newKeyName?: InputMaybe<Scalars['String']>;
};


export type UserMutationSetOdysseyCourseArgs = {
  course: OdysseyCourseInput;
};


export type UserMutationSetOdysseyTaskArgs = {
  task: OdysseyTaskInput;
};


export type UserMutationSubmitZendeskTicketArgs = {
  collaborators?: InputMaybe<Array<Scalars['String']>>;
  email: Scalars['String'];
  ticket: ZendeskTicketInput;
};


export type UserMutationUpdateArgs = {
  email?: InputMaybe<Scalars['String']>;
  fullName?: InputMaybe<Scalars['String']>;
  referrer?: InputMaybe<Scalars['String']>;
  trackingGoogleClientId?: InputMaybe<Scalars['String']>;
  trackingMarketoClientId?: InputMaybe<Scalars['String']>;
  userSegment?: InputMaybe<UserSegment>;
  utmCampaign?: InputMaybe<Scalars['String']>;
  utmMedium?: InputMaybe<Scalars['String']>;
  utmSource?: InputMaybe<Scalars['String']>;
};


export type UserMutationUpdateBetaFeaturesOnArgs = {
  betaFeaturesOn: Scalars['Boolean'];
};


export type UserMutationUpdateFeatureIntrosArgs = {
  newFeatureIntros?: InputMaybe<FeatureIntrosInput>;
};


export type UserMutationUpdateRoleArgs = {
  newRole?: InputMaybe<InternalMdgAdminRole>;
};


export type UserMutationVerifyEmailArgs = {
  token: Scalars['String'];
};

export enum UserPermission {
  BillingManager = 'BILLING_MANAGER',
  Consumer = 'CONSUMER',
  Contributor = 'CONTRIBUTOR',
  GraphAdmin = 'GRAPH_ADMIN',
  LegacyGraphKey = 'LEGACY_GRAPH_KEY',
  Observer = 'OBSERVER',
  OrgAdmin = 'ORG_ADMIN'
}

export enum UserSegment {
  JoinMyTeam = 'JOIN_MY_TEAM',
  LocalDevelopment = 'LOCAL_DEVELOPMENT',
  NotSpecified = 'NOT_SPECIFIED',
  ProductionGraphs = 'PRODUCTION_GRAPHS',
  Sandbox = 'SANDBOX',
  TryTeam = 'TRY_TEAM'
}

export type UserSettings = {
  __typename?: 'UserSettings';
  appNavCollapsed: Scalars['Boolean'];
  autoManageVariables: Scalars['Boolean'];
  id: Scalars['String'];
  mockingResponses: Scalars['Boolean'];
  preflightScriptEnabled: Scalars['Boolean'];
  responseHints: ResponseHints;
  tableMode: Scalars['Boolean'];
  themeName: ThemeName;
};

/** Explorer user settings input */
export type UserSettingsInput = {
  appNavCollapsed?: InputMaybe<Scalars['Boolean']>;
  autoManageVariables?: InputMaybe<Scalars['Boolean']>;
  mockingResponses?: InputMaybe<Scalars['Boolean']>;
  preflightScriptEnabled?: InputMaybe<Scalars['Boolean']>;
  responseHints?: InputMaybe<ResponseHints>;
  tableMode?: InputMaybe<Scalars['Boolean']>;
  themeName?: InputMaybe<ThemeName>;
};

export enum UserType {
  Apollo = 'APOLLO',
  Github = 'GITHUB',
  Sso = 'SSO'
}

export type ValidateOperationsResult = {
  __typename?: 'ValidateOperationsResult';
  validationResults: Array<ValidationResult>;
};

export type ValidationError = Error & {
  __typename?: 'ValidationError';
  message: Scalars['String'];
};

export enum ValidationErrorCode {
  DeprecatedField = 'DEPRECATED_FIELD',
  InvalidOperation = 'INVALID_OPERATION',
  NonParseableDocument = 'NON_PARSEABLE_DOCUMENT'
}

export enum ValidationErrorType {
  Failure = 'FAILURE',
  Invalid = 'INVALID',
  Warning = 'WARNING'
}

/**
 * Represents a single validation error, with information relating to the error
 * and its respective operation
 */
export type ValidationResult = {
  __typename?: 'ValidationResult';
  /** The validation result's error code */
  code: ValidationErrorCode;
  /** Description of the validation error */
  description: Scalars['String'];
  /** The operation related to this validation result */
  operation: OperationDocument;
  /** The type of validation error thrown - warning, failure, or invalid. */
  type: ValidationErrorType;
};

/** Webhook notification channel */
export type WebhookChannel = Channel & {
  __typename?: 'WebhookChannel';
  id: Scalars['ID'];
  name: Scalars['String'];
  secretToken?: Maybe<Scalars['String']>;
  subscriptions: Array<ChannelSubscription>;
  url: Scalars['String'];
};

/** PagerDuty notification channel parameters */
export type WebhookChannelInput = {
  name?: InputMaybe<Scalars['String']>;
  secretToken?: InputMaybe<Scalars['String']>;
  url: Scalars['String'];
};

export type ZendeskTicket = {
  __typename?: 'ZendeskTicket';
  createdAt: Scalars['Timestamp'];
  description: Scalars['String'];
  graph?: Maybe<Service>;
  id: Scalars['Int'];
  organization?: Maybe<Account>;
  priority: TicketPriority;
  status?: Maybe<TicketStatus>;
  subject: Scalars['String'];
  user?: Maybe<User>;
};

/** Zendesk ticket input */
export type ZendeskTicketInput = {
  description: Scalars['String'];
  graphId?: InputMaybe<Scalars['String']>;
  organizationId?: InputMaybe<Scalars['String']>;
  priority: TicketPriority;
  subject: Scalars['String'];
};

export type SchemaReportMutationVariables = Exact<{
  report: SchemaReport;
  coreSchema?: InputMaybe<Scalars['String']>;
}>;


export type SchemaReportMutation = { __typename?: 'Mutation', reportSchema?: { __typename: 'ReportSchemaError', message: string, code: ReportSchemaErrorCode } | { __typename: 'ReportSchemaResponse', inSeconds: number, withCoreSchema: boolean } | null | undefined };
Ÿ,/dist/esm/incrementalDeliveryPolyfill.js.map≈ì{"version":3,"file":"incrementalDeliveryPolyfill.js","sourceRoot":"","sources":["../../src/incrementalDeliveryPolyfill.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAgD,MAAM,SAAS,CAAC;AA+EhF,IAAI,uCAAuC,GAO3B,SAAS,CAAC;AAE1B,KAAK,UAAU,kBAAkB;IAC/B,IAAI,uCAAuC,KAAK,SAAS,EAAE;QACzD,OAAO;KACR;IACD,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,CAAC;IACxC,IAAI,kCAAkC,IAAI,OAAO,EAAE;QACjD,uCAAuC,GAAI,OAAe;aACvD,gCAAgC,CAAC;KACrC;SAAM;QACL,uCAAuC,GAAG,IAAI,CAAC;KAChD;AACH,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,oBAAoB,CACxC,IAAmB;IAEnB,MAAM,kBAAkB,EAAE,CAAC;IAC3B,IAAI,uCAAuC,EAAE;QAC3C,OAAO,uCAAuC,CAAC,IAAI,CAAC,CAAC;KACtD;IACD,OAAO,OAAO,CAAC,IAAI,CAAC,CAAC;AACvB,CAAC"}Ÿ:/dist/esm/externalTypes/incrementalDeliveryPolyfill.js.mapƒ¶{"version":3,"file":"incrementalDeliveryPolyfill.js","sourceRoot":"","sources":["../../../src/externalTypes/incrementalDeliveryPolyfill.ts"],"names":[],"mappings":""}Ÿ@/dist/esm/plugin/usageReporting/operationDerivedDataCache.js.map≈Á{"version":3,"file":"operationDerivedDataCache.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/operationDerivedDataCache.ts"],"names":[],"mappings":"AAEA,OAAO,QAAQ,MAAM,WAAW,CAAC;AAOjC,MAAM,UAAU,+BAA+B,CAAC,EAC9C,MAAM,GAGP;IACC,IAAI,QAAc,CAAC;IACnB,IAAI,aAAa,GAAG,CAAC,CAAC;IACtB,OAAO,IAAI,QAAQ,CAA+B;QAEhD,eAAe,CAAC,GAAG;YACjB,OAAO,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC;QACxD,CAAC;QASD,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE;QAC7B,OAAO;YAEL,aAAa,EAAE,CAAC;YAGhB,IAAI,CAAC,QAAQ,IAAI,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,QAAQ,CAAC,OAAO,EAAE,GAAG,KAAK,EAAE;gBAElE,QAAQ,GAAG,IAAI,IAAI,EAAE,CAAC;gBACtB,MAAM,CAAC,IAAI,CACT;oBACE,iEAAiE;oBACjE,cAAc,aAAa,qBAAqB;oBAChD,gFAAgF;oBAChF,gEAAgE;oBAChE,wCAAwC;iBACzC,CAAC,IAAI,CAAC,EAAE,CAAC,CACX,CAAC;gBAGF,aAAa,GAAG,CAAC,CAAC;aACnB;QACH,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AAED,MAAM,UAAU,4BAA4B,CAC1C,SAAiB,EACjB,aAAqB;IAErB,OAAO,GAAG,SAAS,GAAG,aAAa,IAAI,GAAG,GAAG,aAAa,EAAE,CAAC;AAC/D,CAAC"}≤/dist/esm/index.jsƒØexport { ApolloServer } from './ApolloServer.js';
export { HeaderMap } from './utils/HeaderMap.js';
export * from './externalTypes/index.js';
//# sourceMappingURL=index.js.mapŸ(/dist/esm/utils/computeCoreSchemaHash.jsƒÿimport { createHash } from '@apollo/utils.createhash';
export function computeCoreSchemaHash(schema) {
    return createHash('sha256').update(schema).digest('hex');
}
//# sourceMappingURL=computeCoreSchemaHash.js.mapΩ/dist/esm/express4/index.d.ts≈eimport type { WithRequired } from '@apollo/utils.withrequired';
import type express from 'express';
import type { ApolloServer } from '../index.js';
import type { BaseContext, ContextFunction } from '../externalTypes/index.js';
export interface ExpressContextFunctionArgument {
    req: express.Request;
    res: express.Response;
}
export interface ExpressMiddlewareOptions<TContext extends BaseContext> {
    context?: ContextFunction<[ExpressContextFunctionArgument], TContext>;
}
export declare function expressMiddleware(server: ApolloServer<BaseContext>, options?: ExpressMiddlewareOptions<BaseContext>): express.RequestHandler;
export declare function expressMiddleware<TContext extends BaseContext>(server: ApolloServer<TContext>, options: WithRequired<ExpressMiddlewareOptions<TContext>, 'context'>): express.RequestHandler;
//# sourceMappingURL=index.d.ts.map≥/src/preventCsrf.ts≈ﬂimport MIMEType from 'whatwg-mimetype';
import { BadRequestError } from './internalErrorClasses.js';
import type { HeaderMap } from './utils/HeaderMap.js';

// Our recommended set of CSRF prevention headers. Operations that do not
// provide a content-type such as `application/json` (in practice, this
// means GET operations) must include at least one of these headers.
// Apollo Client Web's default behavior is to always sends a
// `content-type` even for `GET`, and Apollo iOS and Apollo Kotlin always
// send `x-apollo-operation-name`. So if you set
// `csrfPreventionRequestHeaders: true` then any `GET` operation from these
// three client projects and any `POST` operation at all should work
// successfully; if you need `GET`s from another kind of client to work,
// just add `apollo-require-preflight: true` to their requests.
export const recommendedCsrfPreventionRequestHeaders = [
  'x-apollo-operation-name',
  'apollo-require-preflight',
];

// See https://fetch.spec.whatwg.org/#cors-safelisted-request-header
const NON_PREFLIGHTED_CONTENT_TYPES = [
  'application/x-www-form-urlencoded',
  'multipart/form-data',
  'text/plain',
];

// We don't want random websites to be able to execute actual GraphQL operations
// from a user's browser unless our CORS policy supports it. It's not good
// enough just to ensure that the browser can't read the response from the
// operation; we also want to prevent CSRF, where the attacker can cause side
// effects with an operation or can measure the timing of a read operation. Our
// goal is to ensure that we don't run the context function or execute the
// GraphQL operation until the browser has evaluated the CORS policy, which
// means we want all operations to be pre-flighted. We can do that by only
// processing operations that have at least one header set that appears to be
// manually set by the JS code rather than by the browser automatically.
//
// POST requests generally have a content-type `application/json`, which is
// sufficient to trigger preflighting. So we take extra care with requests that
// specify no content-type or that specify one of the three non-preflighted
// content types. For those operations, we require (if this feature is enabled)
// one of a set of specific headers to be set. By ensuring that every operation
// either has a custom content-type or sets one of these headers, we know we
// won't execute operations at the request of origins who our CORS policy will
// block.
export function preventCsrf(
  headers: HeaderMap,
  csrfPreventionRequestHeaders: string[],
) {
  const contentType = headers.get('content-type');

  // We have to worry about CSRF if it looks like this may have been a
  // non-preflighted request. If we see a content-type header that is not one of
  // the three CORS-safelisted MIME types (see
  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header) then we know
  // it was preflighted and we don't have to worry.
  if (contentType !== undefined) {
    const contentTypeParsed = MIMEType.parse(contentType);
    if (contentTypeParsed === null) {
      // If we got null, then parsing the content-type failed... which is
      // actually *ok* because that would lead to a preflight. (For example, the
      // header is empty, or doesn't have a slash, or has bad characters.) The
      // scary CSRF case is only if there's *not* an error. So it is actually
      // fine for us to just `return` here. (That said, it would also be
      // reasonable to reject such requests with provided yet unparsable
      // Content-Type here.)
      return;
    }
    if (!NON_PREFLIGHTED_CONTENT_TYPES.includes(contentTypeParsed.essence)) {
      // We managed to parse a MIME type that was not one of the
      // CORS-safelisted ones. (Probably application/json!) That means that if
      // the client is a browser, the browser must have applied CORS
      // preflighting and we don't have to worry about CSRF.
      return;
    }
  }

  // Either there was no content-type, or the content-type parsed properly as
  // one of the three CORS-safelisted values. Let's look for another header that
  // (if this was a browser) must have been set by the user's code and would
  // have caused a preflight.
  if (
    csrfPreventionRequestHeaders.some((header) => {
      const value = headers.get(header);
      return value !== undefined && value.length > 0;
    })
  ) {
    return;
  }

  throw new BadRequestError(
    `This operation has been blocked as a potential Cross-Site Request Forgery ` +
      `(CSRF). Please either specify a 'content-type' header (with a type that ` +
      `is not one of ${NON_PREFLIGHTED_CONTENT_TYPES.join(', ')}) or provide ` +
      `a non-empty value for one of the following headers: ${csrfPreventionRequestHeaders.join(
        ', ',
      )}\n`,
  );
}
ŸE/dist/esm/plugin/usageReporting/defaultSendOperationsAsTrace.d.ts.map≈ {"version":3,"file":"defaultSendOperationsAsTrace.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/defaultSendOperationsAsTrace.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AAI9D,wBAAgB,4BAA4B,YA2B3B,KAAK,kBAAkB,MAAM,KAAG,OAAO,CAyBvD"}Ÿ!/src/plugin/cacheControl/index.ts≈E‹import type { ApolloServerPlugin } from '../../externalTypes/index.js';
import {
  DirectiveNode,
  getNamedType,
  GraphQLCompositeType,
  GraphQLField,
  isCompositeType,
  isInterfaceType,
  isObjectType,
  responsePathAsArray,
} from 'graphql';
import { newCachePolicy } from '../../cachePolicy.js';
import { internalPlugin } from '../../internalPlugin.js';
import LRUCache from 'lru-cache';
import type {
  CacheHint,
  CacheScope,
  GraphQLResolveInfoWithCacheControl,
} from '@apollo/cache-control-types';

/**
 * CacheAnnotation represents the contents of a `@cacheControl` directive.
 * (`inheritMaxAge` is part of this interface and not CacheHint, because
 * `inheritMaxAge` isn't a contributing piece of a cache policy: it just means
 * to not apply default values in some contexts.)
 */
interface CacheAnnotation extends CacheHint {
  inheritMaxAge?: true;
}

export interface ApolloServerPluginCacheControlOptions {
  /**
   * All root fields and fields returning objects or interfaces have this value
   * for `maxAge` unless they set a cache hint with a non-undefined `maxAge`
   * using `@cacheControl` or `setCacheHint`. The default is 0, which means "not
   * cacheable". (That is: if you don't set `defaultMaxAge`, then every root
   * field in your operation and every field with sub-fields must have a cache
   * hint or the overall operation will not be cacheable.)
   */
  defaultMaxAge?: number;
  /**
   * Determines whether to set the `Cache-Control` HTTP header. If true (the
   * default), the header is written on all responses (with a value of
   * `no-store` for non-cacheable responses). If `'if-cacheable'`, the header is
   * only written for cacheable responses. If false, the header is never
   * written. A response is cacheable if its overall cache policy has a non-zero
   * `maxAge`, and the body is a single result rather than an incremental
   * delivery response, and the body contains no errors.
   */
  calculateHttpHeaders?: boolean | 'if-cacheable';
  // For testing only.
  __testing__cacheHints?: Map<string, CacheHint>;
}

export function ApolloServerPluginCacheControl(
  options: ApolloServerPluginCacheControlOptions = Object.create(null),
): ApolloServerPlugin {
  let typeAnnotationCache: LRUCache<GraphQLCompositeType, CacheAnnotation>;

  let fieldAnnotationCache: LRUCache<
    GraphQLField<unknown, unknown>,
    CacheAnnotation
  >;

  return internalPlugin({
    __internal_plugin_id__: 'CacheControl',
    __is_disabled_plugin__: false,

    async serverWillStart({ schema }) {
      // Set the size of the caches to be equal to the number of composite types
      // and fields in the schema respectively. This generally means that the
      // cache will always have room for all the cache hints in the active
      // schema but we won't have a memory leak as schemas are replaced in a
      // gateway. (Once we're comfortable breaking compatibility with
      // versions of Gateway older than 0.35.0, we should also run this code
      // from a schemaDidLoadOrUpdate instead of serverWillStart. Using
      // schemaDidLoadOrUpdate throws when combined with old gateways.)
      typeAnnotationCache = new LRUCache<GraphQLCompositeType, CacheAnnotation>(
        {
          max: Object.values(schema.getTypeMap()).filter(isCompositeType)
            .length,
        },
      );

      fieldAnnotationCache = new LRUCache<
        GraphQLField<unknown, unknown>,
        CacheAnnotation
      >({
        max:
          Object.values(schema.getTypeMap())
            .filter(isObjectType)
            .flatMap((t) => Object.values(t.getFields())).length +
          Object.values(schema.getTypeMap())
            .filter(isInterfaceType)
            .flatMap((t) => Object.values(t.getFields())).length,
      });

      return undefined;
    },

    async requestDidStart(requestContext) {
      function memoizedCacheAnnotationFromType(
        t: GraphQLCompositeType,
      ): CacheAnnotation {
        const existing = typeAnnotationCache.get(t);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromType(t);
        typeAnnotationCache.set(t, annotation);
        return annotation;
      }

      function memoizedCacheAnnotationFromField(
        field: GraphQLField<unknown, unknown>,
      ): CacheAnnotation {
        const existing = fieldAnnotationCache.get(field);
        if (existing) {
          return existing;
        }
        const annotation = cacheAnnotationFromField(field);
        fieldAnnotationCache.set(field, annotation);
        return annotation;
      }

      const defaultMaxAge: number = options.defaultMaxAge ?? 0;
      const calculateHttpHeaders = options.calculateHttpHeaders ?? true;
      const { __testing__cacheHints } = options;

      return {
        async executionDidStart() {
          // Did something set the overall cache policy before we've even
          // started? If so, consider that as an override and don't touch it.
          // Just put set up fake `info.cacheControl` objects and otherwise
          // don't track cache policy.
          //
          // (This doesn't happen in practice using the core plugins: the main
          // use case for restricting overallCachePolicy outside of this plugin
          // is apollo-server-plugin-response-cache, but when it sets the policy
          // we never get to execution at all.)
          if (isRestricted(requestContext.overallCachePolicy)) {
            // This is "fake" in the sense that it never actually affects
            // requestContext.overallCachePolicy.
            const fakeFieldPolicy = newCachePolicy();
            return {
              willResolveField({ info }) {
                // This `as` is "safe" in the sense that this is the statement
                // that makes a GraphQLResolveInfo into a
                // GraphQLResolveInfoWithCacheControl.
                (info as GraphQLResolveInfoWithCacheControl).cacheControl = {
                  setCacheHint: (dynamicHint: CacheHint) => {
                    fakeFieldPolicy.replace(dynamicHint);
                  },
                  cacheHint: fakeFieldPolicy,
                  cacheHintFromType: memoizedCacheAnnotationFromType,
                };
              },
            };
          }

          return {
            willResolveField({ info }) {
              const fieldPolicy = newCachePolicy();

              let inheritMaxAge = false;

              // If this field's resolver returns an object/interface/union
              // (maybe wrapped in list/non-null), look for hints on that return
              // type.
              const targetType = getNamedType(info.returnType);
              if (isCompositeType(targetType)) {
                const typeAnnotation =
                  memoizedCacheAnnotationFromType(targetType);
                fieldPolicy.replace(typeAnnotation);
                inheritMaxAge = !!typeAnnotation.inheritMaxAge;
              }

              // Look for hints on the field itself (on its parent type), taking
              // precedence over previously calculated hints.
              const fieldAnnotation = memoizedCacheAnnotationFromField(
                info.parentType.getFields()[info.fieldName],
              );

              // Note that specifying `@cacheControl(inheritMaxAge: true)` on a
              // field whose return type defines a `maxAge` gives precedence to
              // the type's `maxAge`. (Perhaps this should be some sort of
              // error.)
              if (
                fieldAnnotation.inheritMaxAge &&
                fieldPolicy.maxAge === undefined
              ) {
                inheritMaxAge = true;
                // Handle `@cacheControl(inheritMaxAge: true, scope: PRIVATE)`.
                // (We ignore any specified `maxAge`; perhaps it should be some
                // sort of error.)
                if (fieldAnnotation.scope) {
                  fieldPolicy.replace({ scope: fieldAnnotation.scope });
                }
              } else {
                fieldPolicy.replace(fieldAnnotation);
              }

              // This `as` is "safe" in the sense that this is the statement
              // that makes a GraphQLResolveInfo into a
              // GraphQLResolveInfoWithCacheControl.
              (info as GraphQLResolveInfoWithCacheControl).cacheControl = {
                setCacheHint: (dynamicHint: CacheHint) => {
                  fieldPolicy.replace(dynamicHint);
                },
                cacheHint: fieldPolicy,
                cacheHintFromType: memoizedCacheAnnotationFromType,
              };

              // When the resolver is done, call restrict once. By calling
              // restrict after the resolver instead of before, we don't need to
              // "undo" the effect on overallCachePolicy of a static hint that
              // gets refined by a dynamic hint.
              return () => {
                // If this field returns a composite type or is a root field and
                // we haven't seen an explicit maxAge hint, set the maxAge to 0
                // (uncached) or the default if specified in the constructor.
                // (Non-object fields by default are assumed to inherit their
                // cacheability from their parents. But on the other hand, while
                // root non-object fields can get explicit hints from their
                // definition on the Query/Mutation object, if that doesn't
                // exist then there's no parent field that would assign the
                // default maxAge, so we do it here.)
                //
                // You can disable this on a non-root field by writing
                // `@cacheControl(inheritMaxAge: true)` on it. If you do this,
                // then its children will be treated like root paths, since
                // there is no parent maxAge to inherit.
                //
                // We do this in the end hook so that dynamic cache control
                // prevents it from happening (eg,
                // `info.cacheControl.cacheHint.restrict({maxAge: 60})` should
                // work rather than doing nothing because we've already set the
                // max age to the default of 0). This also lets resolvers assume
                // any hint in `info.cacheControl.cacheHint` was explicitly set.
                if (
                  fieldPolicy.maxAge === undefined &&
                  ((isCompositeType(targetType) && !inheritMaxAge) ||
                    !info.path.prev)
                ) {
                  fieldPolicy.restrict({ maxAge: defaultMaxAge });
                }

                if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                  const path = responsePathAsArray(info.path).join('.');
                  if (__testing__cacheHints.has(path)) {
                    throw Error(
                      "shouldn't happen: addHint should only be called once per path",
                    );
                  }
                  __testing__cacheHints.set(path, {
                    maxAge: fieldPolicy.maxAge,
                    scope: fieldPolicy.scope,
                  });
                }
                requestContext.overallCachePolicy.restrict(fieldPolicy);
              };
            },
          };
        },

        async willSendResponse(requestContext) {
          // This hook is just for setting response headers, so make sure that
          // hasn't been disabled.
          if (!calculateHttpHeaders) {
            return;
          }

          const { response, overallCachePolicy } = requestContext;

          // Look to see if something has already set the cache-control header.
          // This could be a different plugin... or it could be this very plugin
          // operating on a different operation in the same batched HTTP
          // request.
          const existingCacheControlHeader = parseExistingCacheControlHeader(
            response.http.headers.get('cache-control'),
          );

          // If the header contains something other than a value that this
          // plugin sets, then we leave it alone. We don't want to mangle
          // something important that you set! That said, it's probably best to
          // have only one piece of code that writes to a given header, so you
          // should probably set `calculateHttpHeaders: false` on this plugin.
          if (existingCacheControlHeader.kind === 'unparsable') {
            return;
          }

          const cachePolicy = newCachePolicy();
          cachePolicy.replace(overallCachePolicy);
          if (existingCacheControlHeader.kind === 'parsable-and-cacheable') {
            cachePolicy.restrict(existingCacheControlHeader.hint);
          }
          const policyIfCacheable = cachePolicy.policyIfCacheable();

          if (
            // This code path is only for if we believe it is cacheable.
            policyIfCacheable &&
            // Either there wasn't a cache-control header already, or we've
            // already incorporated it into policyIfCacheable. (If we couldn't
            // parse it, that means some other plugin or mechanism set the
            // header. This is confusing, so we just don't make any more
            // changes. You should probably set `calculateHttpHeaders` to false
            // in that case and only set the header from one place.)
            existingCacheControlHeader.kind !== 'uncacheable' &&
            // At least for now, we don't set cache-control headers for
            // incremental delivery responses, since we don't know if a later
            // part of the execution will affect the cache policy (perhaps
            // dynamically). (Note that willSendResponse is called when the
            // initial payload is sent, not the final payload.)
            response.body.kind === 'single' &&
            !response.body.singleResult.errors
          ) {
            response.http.headers.set(
              'cache-control',
              `max-age=${
                policyIfCacheable.maxAge
              }, ${policyIfCacheable.scope.toLowerCase()}`,
            );
          } else if (calculateHttpHeaders !== 'if-cacheable') {
            // The response is not cacheable, so make sure it doesn't get
            // cached. This is especially important for GET requests, because
            // browsers and other agents cache many GET requests by default.
            // (But if some other plugin set the header to a value that this
            // plugin does not produce, we don't do anything.)
            response.http.headers.set(
              'cache-control',
              CACHE_CONTROL_HEADER_UNCACHEABLE,
            );
          }
        },
      };
    },
  });
}

const CACHE_CONTROL_HEADER_CACHEABLE_REGEXP =
  /^max-age=(\d+), (public|private)$/;
const CACHE_CONTROL_HEADER_UNCACHEABLE = 'no-store';

type ExistingCacheControlHeader =
  | { kind: 'no-header' }
  | { kind: 'uncacheable' }
  | { kind: 'parsable-and-cacheable'; hint: CacheHint }
  | { kind: 'unparsable' };

function parseExistingCacheControlHeader(
  header: string | undefined,
): ExistingCacheControlHeader {
  if (!header) {
    return { kind: 'no-header' };
  }
  if (header === CACHE_CONTROL_HEADER_UNCACHEABLE) {
    return { kind: 'uncacheable' };
  }
  const match = CACHE_CONTROL_HEADER_CACHEABLE_REGEXP.exec(header);
  if (!match) {
    return { kind: 'unparsable' };
  }
  return {
    kind: 'parsable-and-cacheable',
    hint: {
      maxAge: +match[1],
      scope: match[2] === 'public' ? 'PUBLIC' : 'PRIVATE',
    },
  };
}

function cacheAnnotationFromDirectives(
  directives: ReadonlyArray<DirectiveNode> | undefined,
): CacheAnnotation | undefined {
  if (!directives) return undefined;

  const cacheControlDirective = directives.find(
    (directive) => directive.name.value === 'cacheControl',
  );
  if (!cacheControlDirective) return undefined;

  if (!cacheControlDirective.arguments) return undefined;

  const maxAgeArgument = cacheControlDirective.arguments.find(
    (argument) => argument.name.value === 'maxAge',
  );
  const scopeArgument = cacheControlDirective.arguments.find(
    (argument) => argument.name.value === 'scope',
  );
  const inheritMaxAgeArgument = cacheControlDirective.arguments.find(
    (argument) => argument.name.value === 'inheritMaxAge',
  );

  const scopeString =
    scopeArgument?.value?.kind === 'EnumValue'
      ? scopeArgument.value.value
      : undefined;

  const scope: CacheScope | undefined =
    scopeString === 'PUBLIC' || scopeString === 'PRIVATE'
      ? scopeString
      : undefined;

  if (
    inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&
    inheritMaxAgeArgument.value.value
  ) {
    // We ignore maxAge if it is also specified.
    return { inheritMaxAge: true, scope };
  }

  return {
    maxAge:
      maxAgeArgument?.value?.kind === 'IntValue'
        ? parseInt(maxAgeArgument.value.value)
        : undefined,
    scope,
  };
}

function cacheAnnotationFromType(t: GraphQLCompositeType): CacheAnnotation {
  if (t.astNode) {
    const hint = cacheAnnotationFromDirectives(t.astNode.directives);
    if (hint) {
      return hint;
    }
  }
  if (t.extensionASTNodes) {
    for (const node of t.extensionASTNodes) {
      const hint = cacheAnnotationFromDirectives(node.directives);
      if (hint) {
        return hint;
      }
    }
  }
  return {};
}

function cacheAnnotationFromField(
  field: GraphQLField<unknown, unknown>,
): CacheAnnotation {
  if (field.astNode) {
    const hint = cacheAnnotationFromDirectives(field.astNode.directives);
    if (hint) {
      return hint;
    }
  }
  return {};
}

function isRestricted(hint: CacheHint) {
  return hint.maxAge !== undefined || hint.scope !== undefined;
}
∏/dist/esm/index.d.ts.mapƒ÷{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACjD,OAAO,EAAE,SAAS,EAAE,MAAM,sBAAsB,CAAC;AAEjD,cAAc,0BAA0B,CAAC"}ø/dist/cjs/internalPlugin.js.map≈{"version":3,"file":"internalPlugin.js","sourceRoot":"","sources":["../../src/internalPlugin.ts"],"names":[],"mappings":";;;AAqBA,SAAgB,cAAc,CAC5B,CAAuC;IAEvC,OAAO,CAAC,CAAC;AACX,CAAC;AAJD,wCAIC;AASD,SAAgB,gBAAgB,CAC9B,MAAoC;IAIpC,OAAO,wBAAwB,IAAI,MAAM,CAAC;AAC5C,CAAC;AAND,4CAMC"}Ÿ-/dist/esm/plugin/usageReporting/plugin.js.map≈<—{"version":3,"file":"plugin.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/plugin.ts"],"names":[],"mappings":"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"}Ÿ'/dist/esm/internalErrorClasses.d.ts.map≈‘{"version":3,"file":"internalErrorClasses.d.ts","sourceRoot":"","sources":["../../src/internalErrorClasses.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,mBAAmB,EAAE,MAAM,SAAS,CAAC;AAC5D,OAAO,EAAE,qBAAqB,EAAE,MAAM,mBAAmB,CAAC;AAO1D,cAAM,oBAAqB,SAAQ,YAAY;gBAE3C,OAAO,EAAE,MAAM,EACf,IAAI,EAAE,qBAAqB,EAC3B,OAAO,CAAC,EAAE,mBAAmB;CAQhC;AAED,qBAAa,WAAY,SAAQ,oBAAoB;gBACvC,YAAY,EAAE,YAAY;CAQvC;AAED,qBAAa,eAAgB,SAAQ,oBAAoB;gBAC3C,YAAY,EAAE,YAAY;CAcvC;AAcD,qBAAa,2BAA4B,SAAQ,oBAAoB;;CAQpE;AAED,qBAAa,+BAAgC,SAAQ,oBAAoB;;CAYxE;AAED,qBAAa,cAAe,SAAQ,oBAAoB;gBAC1C,YAAY,EAAE,YAAY;CAOvC;AAED,qBAAa,wBAAyB,SAAQ,oBAAoB;gBACpD,YAAY,EAAE,YAAY;CAcvC;AAED,qBAAa,eAAgB,SAAQ,oBAAoB;gBAC3C,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,mBAAmB;CAQ3D"}Ω/src/externalTypes/context.ts≈ë// The default `contextValue` is an empty object. Generics related to the
// context type of `ApolloServer` should `extends BasedContext` as we do
// throughout this repository.
export type BaseContext = {};

// Integration authors should use this type for typing their own user-provided
// context function. See the express middleware for a usage example.
export type ContextFunction<
  TIntegrationSpecificArgs extends any[],
  TContext extends BaseContext = BaseContext,
> = (...integrationContext: TIntegrationSpecificArgs) => Promise<TContext>;

// This is used in `executeHTTPGraphQLRequest` so that that function can apply
// consistent error handling if it throws. Web framework integrations typically
// pass a function which passes integration-specific parameters to a
// user-provided `ContextFunction`.
export type ContextThunk<TContext extends BaseContext = BaseContext> =
  () => Promise<TContext>;
Ÿ./src/plugin/usageReporting/iterateOverTrace.ts≈Wimport type { Trace } from '@apollo/usage-reporting-protobuf';

/**
 * Iterates over the entire trace, calling `f` on each Trace.Node found. It
 * looks under the "root" node as well as any inside the query plan. If any `f`
 * returns true, it stops walking the tree.
 *
 * Each call to `f` will receive an object that implements ResponseNamePath. If
 * `includePath` is true, `f` can call `toArray()` on it to convert the
 * linked-list representation to an array of the response name (field name)
 * nodes that you navigate to get to the node (including a "service:subgraph"
 * top-level node if this is a federated trace). Note that we don't add anything
 * to the path for index (list element) nodes. This is because the only use case
 * we have (error path statistics) does not care about list indexes (it's not
 * that interesting to know that sometimes an error was at foo.3.bar and
 * sometimes foo.5.bar, vs just generally foo.bar).
 *
 * If `includePath` is false, we don't bother to build up the linked lists, and
 * calling `toArray()` will throw.
 */
export function iterateOverTrace(
  trace: Trace,
  f: (node: Trace.INode, path: ResponseNamePath) => boolean,
  includePath: boolean,
) {
  const rootPath = includePath
    ? new RootCollectingPathsResponseNamePath()
    : notCollectingPathsResponseNamePath;
  if (trace.root) {
    if (iterateOverTraceNode(trace.root, rootPath, f)) return;
  }

  if (trace.queryPlan) {
    if (iterateOverQueryPlan(trace.queryPlan, rootPath, f)) return;
  }
}

// Helper for iterateOverTrace; returns true to stop the overall walk.
function iterateOverQueryPlan(
  node: Trace.IQueryPlanNode,
  rootPath: ResponseNamePath,
  f: (node: Trace.INode, path: ResponseNamePath) => boolean,
): boolean {
  if (!node) return false;

  if (node.fetch?.trace?.root && node.fetch.serviceName) {
    return iterateOverTraceNode(
      node.fetch.trace.root,
      rootPath.child(`service:${node.fetch.serviceName}`),
      f,
    );
  }
  if (node.flatten?.node) {
    return iterateOverQueryPlan(node.flatten.node, rootPath, f);
  }
  if (node.parallel?.nodes) {
    // We want to stop as soon as some call returns true, which happens to be
    // exactly what 'some' does.
    return node.parallel.nodes.some((node) =>
      iterateOverQueryPlan(node, rootPath, f),
    );
  }
  if (node.sequence?.nodes) {
    // We want to stop as soon as some call returns true, which happens to be
    // exactly what 'some' does.
    return node.sequence.nodes.some((node) =>
      iterateOverQueryPlan(node, rootPath, f),
    );
  }

  return false;
}

// Helper for iterateOverTrace; returns true to stop the overall walk.
function iterateOverTraceNode(
  node: Trace.INode,
  path: ResponseNamePath,
  f: (node: Trace.INode, path: ResponseNamePath) => boolean,
): boolean {
  // Invoke the function; if it returns true, don't descend and tell callers to
  // stop walking.
  if (f(node, path)) {
    return true;
  }

  return (
    // We want to stop as soon as some call returns true, which happens to be
    // exactly what 'some' does.
    node.child?.some((child) => {
      const childPath = child.responseName
        ? path.child(child.responseName)
        : path;
      return iterateOverTraceNode(child, childPath, f);
    }) ?? false
  );
}

export interface ResponseNamePath {
  toArray(): string[];
  child(responseName: string): ResponseNamePath;
}

const notCollectingPathsResponseNamePath: ResponseNamePath = {
  toArray() {
    throw Error('not collecting paths!');
  },
  child() {
    return this;
  },
};

type CollectingPathsResponseNamePath =
  | RootCollectingPathsResponseNamePath
  | ChildCollectingPathsResponseNamePath;
class RootCollectingPathsResponseNamePath implements ResponseNamePath {
  toArray() {
    return [];
  }
  child(responseName: string) {
    return new ChildCollectingPathsResponseNamePath(responseName, this);
  }
}
class ChildCollectingPathsResponseNamePath implements ResponseNamePath {
  constructor(
    readonly responseName: string,
    readonly prev: CollectingPathsResponseNamePath,
  ) {}
  toArray() {
    const out = [];
    let curr: CollectingPathsResponseNamePath = this;
    while (curr instanceof ChildCollectingPathsResponseNamePath) {
      out.push(curr.responseName);
      curr = curr.prev;
    }
    return out.reverse();
  }
  child(responseName: string) {
    return new ChildCollectingPathsResponseNamePath(responseName, this);
  }
}
ª/dist/esm/errors/index.d.ts≈∂export declare enum ApolloServerErrorCode {
    INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR",
    GRAPHQL_PARSE_FAILED = "GRAPHQL_PARSE_FAILED",
    GRAPHQL_VALIDATION_FAILED = "GRAPHQL_VALIDATION_FAILED",
    PERSISTED_QUERY_NOT_FOUND = "PERSISTED_QUERY_NOT_FOUND",
    PERSISTED_QUERY_NOT_SUPPORTED = "PERSISTED_QUERY_NOT_SUPPORTED",
    BAD_USER_INPUT = "BAD_USER_INPUT",
    OPERATION_RESOLUTION_FAILURE = "OPERATION_RESOLUTION_FAILURE",
    BAD_REQUEST = "BAD_REQUEST"
}
export declare enum ApolloServerValidationErrorCode {
    INTROSPECTION_DISABLED = "INTROSPECTION_DISABLED"
}
export declare function unwrapResolverError(error: unknown): unknown;
//# sourceMappingURL=index.d.ts.mapŸ4/dist/esm/plugin/schemaReporting/schemaReporter.d.ts≈∂import type { Logger } from '@apollo/utils.logger';
import type { SchemaReport, ReportSchemaResponse } from './generated/operations';
import type { Fetcher } from '@apollo/utils.fetcher';
export declare const schemaReportGql = "mutation SchemaReport($report: SchemaReport!, $coreSchema: String) {\n  reportSchema(report: $report, coreSchema: $coreSchema) {\n    __typename\n    ... on ReportSchemaError {\n      message\n      code\n    }\n    ... on ReportSchemaResponse {\n      inSeconds\n      withCoreSchema\n    }\n  }\n}\n";
export declare class SchemaReporter {
    private readonly schemaReport;
    private readonly coreSchema;
    private readonly endpointUrl;
    private readonly logger;
    private readonly initialReportingDelayInMs;
    private readonly fallbackReportingDelayInMs;
    private readonly fetcher;
    private isStopped;
    private pollTimer?;
    private readonly headers;
    constructor(options: {
        schemaReport: SchemaReport;
        coreSchema: string;
        apiKey: string;
        endpointUrl: string | undefined;
        logger: Logger;
        initialReportingDelayInMs: number;
        fallbackReportingDelayInMs: number;
        fetcher?: Fetcher;
    });
    stopped(): boolean;
    start(): void;
    stop(): void;
    private sendOneReportAndScheduleNext;
    reportSchema(withCoreSchema: boolean): Promise<ReportSchemaResponse | null>;
    private apolloQuery;
}
//# sourceMappingURL=schemaReporter.d.ts.mapŸ"/dist/esm/requestPipeline.d.ts.map≈y{"version":3,"file":"requestPipeline.d.ts","sourceRoot":"","sources":["../../src/requestPipeline.ts"],"names":[],"mappings":"AA6BA,OAAO,KAAK,EACV,qBAAqB,EAUrB,WAAW,EACX,eAAe,EAEhB,MAAM,0BAA0B,CAAC;AAWlC,OAAO,KAAK,EACV,YAAY,EACZ,qBAAqB,EACrB,iBAAiB,EAClB,MAAM,mBAAmB,CAAC;AAa3B,eAAO,MAAM,gBAAgB,SAAS,CAAC;AAMvC,aAAK,OAAO,CAAC,CAAC,IAAI;IAAE,CAAC,UAAU,CAAC,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;CAAE,CAAC;AA8BrD,wBAAsB,qBAAqB,CAAC,QAAQ,SAAS,WAAW,EACtE,iBAAiB,EAAE,iBAAiB,EACpC,MAAM,EAAE,YAAY,CAAC,QAAQ,CAAC,EAC9B,SAAS,EAAE,qBAAqB,CAAC,QAAQ,CAAC,EAC1C,cAAc,EAAE,OAAO,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC,GACvD,OAAO,CAAC,eAAe,CAAC,CAuiB1B"}Ÿ(/dist/esm/plugin/usageReporting/index.jsƒaexport { ApolloServerPluginUsageReporting } from './plugin.js';
//# sourceMappingURL=index.js.mapø/dist/esm/externalTypes/http.jsƒ+export {};
//# sourceMappingURL=http.js.mapŸ /dist/esm/requestPipeline.js.map≈-Ô{"version":3,"file":"requestPipeline.js","sourceRoot":"","sources":["../../src/requestPipeline.ts"],"names":[],"mappings":"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"}Ÿ)/dist/esm/plugin/schemaIsFederated.js.map≈c{"version":3,"file":"schemaIsFederated.js","sourceRoot":"","sources":["../../../src/plugin/schemaIsFederated.ts"],"names":[],"mappings":"AAAA,OAAO,EAAiB,YAAY,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AAkBpE,MAAM,UAAU,iBAAiB,CAAC,MAAqB;IACrD,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAC/C,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,EAAE;QAC9B,OAAO,KAAK,CAAC;KACd;IACD,MAAM,QAAQ,GAAG,WAAW,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC;IAC7C,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,KAAK,CAAC;KACd;IACD,MAAM,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC;IACnC,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,EAAE;QAC/B,OAAO,KAAK,CAAC;KACd;IACD,OAAO,YAAY,CAAC,IAAI,IAAI,QAAQ,CAAC;AACvC,CAAC"}Ÿ(/dist/cjs/plugin/traceTreeBuilder.js.map≈–{"version":3,"file":"traceTreeBuilder.js","sourceRoot":"","sources":["../../../src/plugin/traceTreeBuilder.ts"],"names":[],"mappings":"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"}Ÿ)/dist/cjs/plugin/inlineTrace/index.js.map≈h{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/inlineTrace/index.ts"],"names":[],"mappings":"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"}Ÿ&/dist/esm/externalTypes/index.d.ts.map≈T{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/externalTypes/index.ts"],"names":[],"mappings":"AAMA,YAAY,EAAE,WAAW,EAAE,eAAe,EAAE,YAAY,EAAE,MAAM,cAAc,CAAC;AAC/E,YAAY,EAAE,cAAc,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AACpE,YAAY,EACV,kBAAkB,EAClB,mBAAmB,EACnB,eAAe,GAChB,MAAM,WAAW,CAAC;AACnB,YAAY,EACV,kBAAkB,EAClB,0BAA0B,EAC1B,+BAA+B,EAC/B,sBAAsB,EACtB,qCAAqC,EACrC,qCAAqC,EACrC,mCAAmC,EACnC,sCAAsC,EACtC,oBAAoB,EACpB,qBAAqB,EACrB,oBAAoB,EACpB,WAAW,GACZ,MAAM,cAAc,CAAC;AACtB,YAAY,EACV,qBAAqB,EACrB,qBAAqB,EACrB,uCAAuC,EACvC,wCAAwC,EACxC,qCAAqC,EACrC,sCAAsC,EACtC,oCAAoC,EACpC,yCAAyC,EACzC,uCAAuC,EACvC,qCAAqC,GACtC,MAAM,sBAAsB,CAAC;AAC9B,YAAY,EACV,aAAa,EACb,iBAAiB,EACjB,YAAY,EACZ,qBAAqB,EACrB,qBAAqB,EACrB,mBAAmB,GACpB,MAAM,kBAAkB,CAAC;AAE1B,YAAY,EACV,6DAA6D,EAC7D,gEAAgE,EAChE,6CAA6C,EAC7C,kDAAkD,EAClD,mDAAmD,GACpD,MAAM,kCAAkC,CAAC"}Ÿ-/dist/cjs/plugin/drainHttpServer/index.js.map≈¥{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/drainHttpServer/index.ts"],"names":[],"mappings":";;;AAEA,iDAAyC;AAuBzC,SAAgB,iCAAiC,CAC/C,OAAiD;IAEjD,MAAM,OAAO,GAAG,IAAI,sBAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAChD,OAAO;QACL,KAAK,CAAC,eAAe;YACnB,OAAO;gBACL,KAAK,CAAC,WAAW;oBACf,MAAM,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,qBAAqB,IAAI,KAAM,CAAC,CAAC;gBAC9D,CAAC;aACF,CAAC;QACJ,CAAC;KACF,CAAC;AACJ,CAAC;AAbD,8EAaC"}Ÿ#/plugin/usageReporting/package.json≈{
  "name": "@apollo/server/plugin/usageReporting",
  "type": "module",
  "main": "../../dist/cjs/plugin/usageReporting/index.js",
  "module": "../../dist/esm/plugin/usageReporting/index.js",
  "types": "../../dist/esm/plugin/usageReporting/index.d.ts",
  "sideEffects": false
}
Ÿ-/dist/esm/plugin/landingPage/default/index.js≈èimport { getEmbeddedExplorerHTML, getEmbeddedSandboxHTML, } from './getEmbeddedHTML.js';
export function ApolloServerPluginLandingPageLocalDefault(options = {}) {
    const { version, __internal_apolloStudioEnv__, ...rest } = {
        embed: true,
        ...options,
    };
    return ApolloServerPluginLandingPageDefault(version, {
        isProd: false,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest,
    });
}
export function ApolloServerPluginLandingPageProductionDefault(options = {}) {
    const { version, __internal_apolloStudioEnv__, ...rest } = options;
    return ApolloServerPluginLandingPageDefault(version, {
        isProd: true,
        apolloStudioEnv: __internal_apolloStudioEnv__,
        ...rest,
    });
}
function encodeConfig(config) {
    return JSON.stringify(encodeURIComponent(JSON.stringify(config)));
}
const getNonEmbeddedLandingPageHTML = (version, config) => {
    const encodedConfig = encodeConfig(config);
    return `
 <div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>The full landing page cannot be loaded; it appears that you might be offline.</p>
</div>
<script>window.landingPage = ${encodedConfig};</script>
<script src="https://apollo-server-landing-page.cdn.apollographql.com/${version}/static/js/main.js"></script>`;
};
function ApolloServerPluginLandingPageDefault(maybeVersion, config) {
    const version = maybeVersion ?? '_latest';
    return {
        __internal_installed_implicitly__: false,
        async serverWillStart() {
            return {
                async renderLandingPage() {
                    const html = `
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Apollo server landing page" />
    <link
      rel="apple-touch-icon"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/assets/favicon.png"
    />
    <link
      rel="manifest"
      href="https://apollo-server-landing-page.cdn.apollographql.com/${version}/manifest.json"
    />
    <title>Apollo Server</title>
  </head>
  <body style="margin: 0; overflow-x: hidden; overflow-y: hidden">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="react-root">
      <style>
        .fallback {
          opacity: 0;
          animation: fadeIn 1s 1s;
          animation-iteration-count: 1;
          animation-fill-mode: forwards;
          padding: 1em;
        }
        @keyframes fadeIn {
          0% {opacity:0;}
          100% {opacity:1; }
        }
      </style>
    ${config.embed
                        ? 'graphRef' in config && config.graphRef
                            ? getEmbeddedExplorerHTML(version, config)
                            : getEmbeddedSandboxHTML(version, config)
                        : getNonEmbeddedLandingPageHTML(version, config)}
    </div>
  </body>
</html>
          `;
                    return { html };
                },
            };
        },
    };
}
//# sourceMappingURL=index.js.mapπ/dist/esm/ApolloServer.js≈kRimport { isNodeLike } from '@apollo/utils.isnodelike';
import { makeExecutableSchema } from '@graphql-tools/schema';
import resolvable from '@josephg/resolvable';
import { assertValidSchema, GraphQLError, print, } from 'graphql';
import { InMemoryLRUCache, PrefixingKeyValueCache, } from '@apollo/utils.keyvaluecache';
import loglevel from 'loglevel';
import Negotiator from 'negotiator';
import * as uuid from 'uuid';
import { newCachePolicy } from './cachePolicy.js';
import { determineApolloConfig } from './determineApolloConfig.js';
import { ensureError, ensureGraphQLError, normalizeAndFormatErrors, } from './errorNormalize.js';
import { ApolloServerErrorCode, ApolloServerValidationErrorCode, } from './errors/index.js';
import { runPotentiallyBatchedHttpQuery } from './httpBatching.js';
import { pluginIsInternal } from './internalPlugin.js';
import { preventCsrf, recommendedCsrfPreventionRequestHeaders, } from './preventCsrf.js';
import { APQ_CACHE_PREFIX, processGraphQLRequest } from './requestPipeline.js';
import { newHTTPGraphQLHead, prettyJSONStringify } from './runHttpQuery.js';
import { SchemaManager } from './utils/schemaManager.js';
import { isDefined } from './utils/isDefined.js';
import { UnreachableCaseError } from './utils/UnreachableCaseError.js';
import { HeaderMap } from './utils/HeaderMap.js';
const NoIntrospection = (context) => ({
    Field(node) {
        if (node.name.value === '__schema' || node.name.value === '__type') {
            context.reportError(new GraphQLError('GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production', {
                nodes: [node],
                extensions: {
                    validationErrorCode: ApolloServerValidationErrorCode.INTROSPECTION_DISABLED,
                },
            }));
        }
    },
});
function defaultLogger() {
    const loglevelLogger = loglevel.getLogger('apollo-server');
    loglevelLogger.setLevel(loglevel.levels.INFO);
    return loglevelLogger;
}
export class ApolloServer {
    constructor(config) {
        const nodeEnv = config.nodeEnv ?? process.env.NODE_ENV ?? '';
        this.logger = config.logger ?? defaultLogger();
        const apolloConfig = determineApolloConfig(config.apollo);
        const isDev = nodeEnv !== 'production';
        const state = config.gateway
            ?
                {
                    phase: 'initialized',
                    schemaManager: new SchemaManager({
                        gateway: config.gateway,
                        apolloConfig,
                        schemaDerivedDataProvider: (schema) => ApolloServer.generateSchemaDerivedData(schema, config.documentStore),
                        logger: this.logger,
                    }),
                }
            :
                {
                    phase: 'initialized',
                    schemaManager: new SchemaManager({
                        apiSchema: ApolloServer.constructSchema(config),
                        schemaDerivedDataProvider: (schema) => ApolloServer.generateSchemaDerivedData(schema, config.documentStore),
                        logger: this.logger,
                    }),
                };
        const introspectionEnabled = config.introspection ?? isDev;
        this.cache = config.cache ?? new InMemoryLRUCache();
        this.internals = {
            formatError: config.formatError,
            rootValue: config.rootValue,
            validationRules: [
                ...(config.validationRules ?? []),
                ...(introspectionEnabled ? [] : [NoIntrospection]),
            ],
            fieldResolver: config.fieldResolver,
            includeStacktraceInErrorResponses: config.includeStacktraceInErrorResponses ??
                (nodeEnv !== 'production' && nodeEnv !== 'test'),
            persistedQueries: config.persistedQueries === false
                ? undefined
                : {
                    ...config.persistedQueries,
                    cache: new PrefixingKeyValueCache(config.persistedQueries?.cache ?? this.cache, APQ_CACHE_PREFIX),
                },
            nodeEnv,
            allowBatchedHttpRequests: config.allowBatchedHttpRequests ?? false,
            apolloConfig,
            plugins: config.plugins ?? [],
            parseOptions: config.parseOptions ?? {},
            state,
            stopOnTerminationSignals: config.stopOnTerminationSignals,
            gatewayExecutor: null,
            csrfPreventionRequestHeaders: config.csrfPrevention === true || config.csrfPrevention === undefined
                ? recommendedCsrfPreventionRequestHeaders
                : config.csrfPrevention === false
                    ? null
                    : config.csrfPrevention.requestHeaders ??
                        recommendedCsrfPreventionRequestHeaders,
            __testing_incrementalExecutionResults: config.__testing_incrementalExecutionResults,
        };
    }
    async start() {
        return await this._start(false);
    }
    startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests() {
        this._start(true).catch((e) => this.logStartupError(e));
    }
    async _start(startedInBackground) {
        if (this.internals.state.phase !== 'initialized') {
            throw new Error(`You should only call 'start()' or ` +
                `'startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests()' ` +
                `once on your ApolloServer.`);
        }
        const schemaManager = this.internals.state.schemaManager;
        const barrier = resolvable();
        this.internals.state = {
            phase: 'starting',
            barrier,
            schemaManager,
            startedInBackground,
        };
        try {
            await this.addDefaultPlugins();
            const toDispose = [];
            const executor = await schemaManager.start();
            if (executor) {
                this.internals.gatewayExecutor = executor;
            }
            toDispose.push(async () => {
                await schemaManager.stop();
            });
            const schemaDerivedData = schemaManager.getSchemaDerivedData();
            const service = {
                logger: this.logger,
                cache: this.cache,
                schema: schemaDerivedData.schema,
                apollo: this.internals.apolloConfig,
                startedInBackground,
            };
            const taggedServerListeners = (await Promise.all(this.internals.plugins.map(async (plugin) => ({
                serverListener: plugin.serverWillStart && (await plugin.serverWillStart(service)),
                installedImplicitly: isImplicitlyInstallablePlugin(plugin) &&
                    plugin.__internal_installed_implicitly__,
            })))).filter((maybeTaggedServerListener) => typeof maybeTaggedServerListener.serverListener === 'object');
            taggedServerListeners.forEach(({ serverListener: { schemaDidLoadOrUpdate } }) => {
                if (schemaDidLoadOrUpdate) {
                    schemaManager.onSchemaLoadOrUpdate(schemaDidLoadOrUpdate);
                }
            });
            const serverWillStops = taggedServerListeners
                .map((l) => l.serverListener.serverWillStop)
                .filter(isDefined);
            if (serverWillStops.length) {
                toDispose.push(async () => {
                    await Promise.all(serverWillStops.map((serverWillStop) => serverWillStop()));
                });
            }
            const drainServerCallbacks = taggedServerListeners
                .map((l) => l.serverListener.drainServer)
                .filter(isDefined);
            const drainServers = drainServerCallbacks.length
                ? async () => {
                    await Promise.all(drainServerCallbacks.map((drainServer) => drainServer()));
                }
                : null;
            let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
            if (taggedServerListenersWithRenderLandingPage.length > 1) {
                taggedServerListenersWithRenderLandingPage =
                    taggedServerListenersWithRenderLandingPage.filter((l) => !l.installedImplicitly);
            }
            let landingPage = null;
            if (taggedServerListenersWithRenderLandingPage.length > 1) {
                throw Error('Only one plugin can implement renderLandingPage.');
            }
            else if (taggedServerListenersWithRenderLandingPage.length) {
                landingPage = await taggedServerListenersWithRenderLandingPage[0]
                    .serverListener.renderLandingPage();
            }
            const toDisposeLast = this.maybeRegisterTerminationSignalHandlers(['SIGINT', 'SIGTERM'], startedInBackground);
            this.internals.state = {
                phase: 'started',
                schemaManager,
                drainServers,
                landingPage,
                toDispose,
                toDisposeLast,
            };
        }
        catch (maybeError) {
            const error = ensureError(maybeError);
            try {
                await Promise.all(this.internals.plugins.map(async (plugin) => plugin.startupDidFail?.({ error })));
            }
            catch (pluginError) {
                this.logger.error(`startupDidFail hook threw: ${pluginError}`);
            }
            this.internals.state = {
                phase: 'failed to start',
                error,
            };
            throw error;
        }
        finally {
            barrier.resolve();
        }
    }
    maybeRegisterTerminationSignalHandlers(signals, startedInBackground) {
        const toDisposeLast = [];
        if (this.internals.stopOnTerminationSignals === false ||
            (this.internals.stopOnTerminationSignals === undefined &&
                !(isNodeLike &&
                    this.internals.nodeEnv !== 'test' &&
                    !startedInBackground))) {
            return toDisposeLast;
        }
        let receivedSignal = false;
        const signalHandler = async (signal) => {
            if (receivedSignal) {
                return;
            }
            receivedSignal = true;
            try {
                await this.stop();
            }
            catch (e) {
                this.logger.error(`stop() threw during ${signal} shutdown`);
                this.logger.error(e);
                process.exit(1);
            }
            process.kill(process.pid, signal);
        };
        signals.forEach((signal) => {
            process.on(signal, signalHandler);
            toDisposeLast.push(async () => {
                process.removeListener(signal, signalHandler);
            });
        });
        return toDisposeLast;
    }
    async _ensureStarted() {
        while (true) {
            switch (this.internals.state.phase) {
                case 'initialized':
                    throw new Error('You need to call `server.start()` before using your Apollo Server.');
                case 'starting':
                    await this.internals.state.barrier;
                    break;
                case 'failed to start':
                    this.logStartupError(this.internals.state.error);
                    throw new Error('This data graph is missing a valid configuration. More details may be available in the server logs.');
                case 'started':
                case 'draining':
                    return this.internals.state;
                case 'stopping':
                case 'stopped':
                    this.logger.warn('A GraphQL operation was received during server shutdown. The ' +
                        'operation will fail. Consider draining the HTTP server on shutdown; ' +
                        'see https://go.apollo.dev/s/drain for details.');
                    throw new Error(`Cannot execute GraphQL operations ${this.internals.state.phase === 'stopping'
                        ? 'while the server is stopping'
                        : 'after the server has stopped'}.'`);
                default:
                    throw new UnreachableCaseError(this.internals.state);
            }
        }
    }
    assertStarted(expressionForError) {
        if (this.internals.state.phase !== 'started' &&
            this.internals.state.phase !== 'draining' &&
            !(this.internals.state.phase === 'starting' &&
                this.internals.state.startedInBackground)) {
            throw new Error('You must `await server.start()` before calling `' +
                expressionForError +
                '`');
        }
    }
    logStartupError(err) {
        this.logger.error('An error occurred during Apollo Server startup. All GraphQL requests ' +
            'will now fail. The startup error was: ' +
            (err?.message || err));
    }
    static constructSchema(config) {
        if (config.schema) {
            return config.schema;
        }
        const { typeDefs, resolvers } = config;
        const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];
        return makeExecutableSchema({
            typeDefs: augmentedTypeDefs,
            resolvers,
        });
    }
    static generateSchemaDerivedData(schema, providedUnprefixedDocumentStore) {
        assertValidSchema(schema);
        return {
            schema,
            documentStore: providedUnprefixedDocumentStore === undefined
                ? new InMemoryLRUCache()
                : providedUnprefixedDocumentStore === null
                    ? null
                    : new PrefixingKeyValueCache(providedUnprefixedDocumentStore, `${uuid.v4()}:`),
        };
    }
    async stop() {
        switch (this.internals.state.phase) {
            case 'initialized':
            case 'starting':
            case 'failed to start':
                throw Error('apolloServer.stop() should only be called after `await apolloServer.start()` has succeeded');
            case 'stopped':
                if (this.internals.state.stopError) {
                    throw this.internals.state.stopError;
                }
                return;
            case 'stopping':
            case 'draining': {
                await this.internals.state.barrier;
                const state = this.internals.state;
                if (state.phase !== 'stopped') {
                    throw Error(`Surprising post-stopping state ${state.phase}`);
                }
                if (state.stopError) {
                    throw state.stopError;
                }
                return;
            }
            case 'started':
                break;
            default:
                throw new UnreachableCaseError(this.internals.state);
        }
        const barrier = resolvable();
        const { schemaManager, drainServers, landingPage, toDispose, toDisposeLast, } = this.internals.state;
        this.internals.state = {
            phase: 'draining',
            barrier,
            schemaManager,
            landingPage,
        };
        try {
            await drainServers?.();
            this.internals.state = { phase: 'stopping', barrier };
            await Promise.all([...toDispose].map((dispose) => dispose()));
            await Promise.all([...toDisposeLast].map((dispose) => dispose()));
        }
        catch (stopError) {
            this.internals.state = {
                phase: 'stopped',
                stopError: stopError,
            };
            barrier.resolve();
            throw stopError;
        }
        this.internals.state = { phase: 'stopped', stopError: null };
    }
    async addDefaultPlugins() {
        const { plugins, apolloConfig, nodeEnv } = this.internals;
        const isDev = nodeEnv !== 'production';
        const alreadyHavePluginWithInternalId = (id) => plugins.some((p) => pluginIsInternal(p) && p.__internal_plugin_id__ === id);
        const pluginsByInternalID = new Map();
        for (const p of plugins) {
            if (pluginIsInternal(p)) {
                const id = p.__internal_plugin_id__;
                if (!pluginsByInternalID.has(id)) {
                    pluginsByInternalID.set(id, {
                        sawDisabled: false,
                        sawNonDisabled: false,
                    });
                }
                const seen = pluginsByInternalID.get(id);
                if (p.__is_disabled_plugin__) {
                    seen.sawDisabled = true;
                }
                else {
                    seen.sawNonDisabled = true;
                }
                if (seen.sawDisabled && seen.sawNonDisabled) {
                    throw new Error(`You have tried to install both ApolloServerPlugin${id} and ` +
                        `ApolloServerPlugin${id}Disabled in your server. Please choose ` +
                        `whether or not you want to disable the feature and install the ` +
                        `appropriate plugin for your use case.`);
                }
            }
        }
        {
            if (!alreadyHavePluginWithInternalId('CacheControl')) {
                const { ApolloServerPluginCacheControl } = await import('./plugin/cacheControl/index.js');
                plugins.push(ApolloServerPluginCacheControl());
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('UsageReporting');
            if (!alreadyHavePlugin && apolloConfig.key) {
                if (apolloConfig.graphRef) {
                    const { ApolloServerPluginUsageReporting } = await import('./plugin/usageReporting/index.js');
                    plugins.unshift(ApolloServerPluginUsageReporting());
                }
                else {
                    this.logger.warn('You have specified an Apollo key but have not specified a graph ref; usage ' +
                        'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +
                        'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +
                        'warning, install `ApolloServerPluginUsageReportingDisabled`.');
                }
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('SchemaReporting');
            const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';
            if (!alreadyHavePlugin && enabledViaEnvVar) {
                if (apolloConfig.key) {
                    const { ApolloServerPluginSchemaReporting } = await import('./plugin/schemaReporting/index.js');
                    plugins.push(ApolloServerPluginSchemaReporting());
                }
                else {
                    throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING " +
                        'environment variable to true, but you also need to provide your ' +
                        'Apollo API key, via the APOLLO_KEY environment ' +
                        'variable or via `new ApolloServer({apollo: {key})');
                }
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');
            if (!alreadyHavePlugin) {
                const { ApolloServerPluginInlineTrace } = await import('./plugin/inlineTrace/index.js');
                plugins.push(ApolloServerPluginInlineTrace({ __onlyIfSchemaIsFederated: true }));
            }
        }
        const alreadyHavePlugin = alreadyHavePluginWithInternalId('LandingPageDisabled');
        if (!alreadyHavePlugin) {
            const { ApolloServerPluginLandingPageLocalDefault, ApolloServerPluginLandingPageProductionDefault, } = await import('./plugin/landingPage/default/index.js');
            const plugin = isDev
                ? ApolloServerPluginLandingPageLocalDefault()
                : ApolloServerPluginLandingPageProductionDefault();
            if (!isImplicitlyInstallablePlugin(plugin)) {
                throw Error('default landing page plugin should be implicitly installable?');
            }
            plugin.__internal_installed_implicitly__ = true;
            plugins.push(plugin);
        }
    }
    addPlugin(plugin) {
        if (this.internals.state.phase !== 'initialized') {
            throw new Error("Can't add plugins after the server has started");
        }
        this.internals.plugins.push(plugin);
    }
    async executeHTTPGraphQLRequest({ httpGraphQLRequest, context, }) {
        try {
            let runningServerState;
            try {
                runningServerState = await this._ensureStarted();
            }
            catch (error) {
                return this.errorResponse(error, httpGraphQLRequest);
            }
            if (runningServerState.landingPage &&
                this.prefersHTML(httpGraphQLRequest)) {
                return {
                    headers: new HeaderMap([['content-type', 'text/html']]),
                    body: {
                        kind: 'complete',
                        string: runningServerState.landingPage.html,
                    },
                };
            }
            if (this.internals.csrfPreventionRequestHeaders) {
                preventCsrf(httpGraphQLRequest.headers, this.internals.csrfPreventionRequestHeaders);
            }
            let contextValue;
            try {
                contextValue = await context();
            }
            catch (maybeError) {
                const error = ensureError(maybeError);
                try {
                    await Promise.all(this.internals.plugins.map(async (plugin) => plugin.contextCreationDidFail?.({
                        error,
                    })));
                }
                catch (pluginError) {
                    this.logger.error(`contextCreationDidFail hook threw: ${pluginError}`);
                }
                return this.errorResponse(ensureGraphQLError(error, 'Context creation failed: '), httpGraphQLRequest);
            }
            return await runPotentiallyBatchedHttpQuery(this, httpGraphQLRequest, contextValue, runningServerState.schemaManager.getSchemaDerivedData(), this.internals);
        }
        catch (maybeError_) {
            const maybeError = maybeError_;
            if (maybeError instanceof GraphQLError &&
                maybeError.extensions.code === ApolloServerErrorCode.BAD_REQUEST) {
                try {
                    await Promise.all(this.internals.plugins.map(async (plugin) => plugin.invalidRequestWasReceived?.({ error: maybeError })));
                }
                catch (pluginError) {
                    this.logger.error(`invalidRequestWasReceived hook threw: ${pluginError}`);
                }
            }
            return this.errorResponse(maybeError, httpGraphQLRequest);
        }
    }
    errorResponse(error, requestHead) {
        const { formattedErrors, httpFromErrors } = normalizeAndFormatErrors([error], {
            includeStacktraceInErrorResponses: this.internals.includeStacktraceInErrorResponses,
            formatError: this.internals.formatError,
        });
        return {
            status: httpFromErrors.status ?? 500,
            headers: new HeaderMap([
                ...httpFromErrors.headers,
                [
                    'content-type',
                    chooseContentTypeForSingleResultResponse(requestHead) ??
                        MEDIA_TYPES.APPLICATION_JSON,
                ],
            ]),
            body: {
                kind: 'complete',
                string: prettyJSONStringify({
                    errors: formattedErrors,
                }),
            },
        };
    }
    prefersHTML(request) {
        const acceptHeader = request.headers.get('accept');
        return (request.method === 'GET' &&
            !!acceptHeader &&
            new Negotiator({
                headers: { accept: acceptHeader },
            }).mediaType([
                MEDIA_TYPES.APPLICATION_JSON,
                MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,
                MEDIA_TYPES.MULTIPART_MIXED_EXPERIMENTAL,
                MEDIA_TYPES.MULTIPART_MIXED_NO_DEFER_SPEC,
                MEDIA_TYPES.TEXT_HTML,
            ]) === MEDIA_TYPES.TEXT_HTML);
    }
    async executeOperation(request, options = {}) {
        if (this.internals.state.phase === 'initialized') {
            await this.start();
        }
        const schemaDerivedData = (await this._ensureStarted()).schemaManager.getSchemaDerivedData();
        const graphQLRequest = {
            ...request,
            query: request.query && typeof request.query !== 'string'
                ? print(request.query)
                : request.query,
        };
        const response = await internalExecuteOperation({
            server: this,
            graphQLRequest,
            internals: this.internals,
            schemaDerivedData,
            sharedResponseHTTPGraphQLHead: null,
        }, options);
        return response;
    }
}
export async function internalExecuteOperation({ server, graphQLRequest, internals, schemaDerivedData, sharedResponseHTTPGraphQLHead, }, options) {
    const requestContext = {
        logger: server.logger,
        cache: server.cache,
        schema: schemaDerivedData.schema,
        request: graphQLRequest,
        response: {
            http: sharedResponseHTTPGraphQLHead ?? newHTTPGraphQLHead(),
        },
        contextValue: cloneObject(options?.contextValue ?? {}),
        metrics: {},
        overallCachePolicy: newCachePolicy(),
        requestIsBatched: sharedResponseHTTPGraphQLHead !== null,
    };
    try {
        return await processGraphQLRequest(schemaDerivedData, server, internals, requestContext);
    }
    catch (maybeError) {
        const error = ensureError(maybeError);
        await Promise.all(internals.plugins.map(async (plugin) => plugin.unexpectedErrorProcessingRequest?.({
            requestContext,
            error,
        })));
        server.logger.error(`Unexpected error processing request: ${error}`);
        throw new Error('Internal server error');
    }
}
export function isImplicitlyInstallablePlugin(p) {
    return '__internal_installed_implicitly__' in p;
}
export const MEDIA_TYPES = {
    APPLICATION_JSON: 'application/json; charset=utf-8',
    APPLICATION_GRAPHQL_RESPONSE_JSON: 'application/graphql-response+json; charset=utf-8',
    MULTIPART_MIXED_NO_DEFER_SPEC: 'multipart/mixed',
    MULTIPART_MIXED_EXPERIMENTAL: 'multipart/mixed; deferSpec=20220824',
    TEXT_HTML: 'text/html',
};
export function chooseContentTypeForSingleResultResponse(head) {
    const acceptHeader = head.headers.get('accept');
    if (!acceptHeader) {
        return MEDIA_TYPES.APPLICATION_JSON;
    }
    else {
        const preferred = new Negotiator({
            headers: { accept: head.headers.get('accept') },
        }).mediaType([
            MEDIA_TYPES.APPLICATION_JSON,
            MEDIA_TYPES.APPLICATION_GRAPHQL_RESPONSE_JSON,
        ]);
        if (preferred) {
            return preferred;
        }
        else {
            return null;
        }
    }
}
function cloneObject(object) {
    return Object.assign(Object.create(Object.getPrototypeOf(object)), object);
}
//# sourceMappingURL=ApolloServer.js.mapŸ5/dist/esm/plugin/usageReporting/traceDetails.d.ts.map≈É{"version":3,"file":"traceDetails.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/traceDetails.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AACzD,OAAO,KAAK,EAAE,oBAAoB,EAAE,MAAM,cAAc,CAAC;AASzD,wBAAgB,gBAAgB,CAC9B,SAAS,EAAE,MAAM,CAAC,MAAM,EAAE,GAAG,CAAC,EAC9B,kBAAkB,CAAC,EAAE,oBAAoB,EACzC,eAAe,CAAC,EAAE,MAAM,GACvB,KAAK,CAAC,OAAO,CA0Df"}Ÿ%/dist/esm/externalTypes/http.d.ts.map≈h{"version":3,"file":"http.d.ts","sourceRoot":"","sources":["../../../src/externalTypes/http.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,EAAE,SAAS,EAAE,MAAM,uBAAuB,CAAC;AAEvD,MAAM,WAAW,kBAAkB;IAEjC,MAAM,EAAE,MAAM,CAAC;IAGf,OAAO,EAAE,SAAS,CAAC;IAQnB,MAAM,EAAE,MAAM,CAAC;IAGf,IAAI,EAAE,OAAO,CAAC;CACf;AAED,MAAM,WAAW,eAAe;IAC9B,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,OAAO,EAAE,SAAS,CAAC;CACpB;AAQD,oBAAY,uBAAuB,GAC/B;IAAE,IAAI,EAAE,UAAU,CAAC;IAAC,MAAM,EAAE,MAAM,CAAA;CAAE,GACpC;IAAE,IAAI,EAAE,SAAS,CAAC;IAAC,aAAa,EAAE,qBAAqB,CAAC,MAAM,CAAC,CAAA;CAAE,CAAC;AAEtE,oBAAY,mBAAmB,GAAG,eAAe,GAAG;IAClD,IAAI,EAAE,uBAAuB,CAAC;CAC/B,CAAC"}Ÿ*/dist/esm/externalTypes/requestPipeline.jsƒ6export {};
//# sourceMappingURL=requestPipeline.js.mapŸ,/dist/cjs/plugin/usageReporting/stats.js.map≈ ﬂ{"version":3,"file":"stats.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/stats.ts"],"names":[],"mappings":"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"}Ÿ1/dist/esm/plugin/usageReporting/traceDetails.d.ts≈<import { Trace } from '@apollo/usage-reporting-protobuf';
import type { VariableValueOptions } from './options.js';
export declare function makeTraceDetails(variables: Record<string, any>, sendVariableValues?: VariableValueOptions, operationString?: string): Trace.Details;
//# sourceMappingURL=traceDetails.d.ts.map≤/dist/cjs/index.js≈Ó"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HeaderMap = exports.ApolloServer = void 0;
var ApolloServer_js_1 = require("./ApolloServer.js");
Object.defineProperty(exports, "ApolloServer", { enumerable: true, get: function () { return ApolloServer_js_1.ApolloServer; } });
var HeaderMap_js_1 = require("./utils/HeaderMap.js");
Object.defineProperty(exports, "HeaderMap", { enumerable: true, get: function () { return HeaderMap_js_1.HeaderMap; } });
__exportStar(require("./externalTypes/index.js"), exports);
//# sourceMappingURL=index.js.mapŸ!/dist/cjs/internalErrorClasses.js≈N"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BadRequestError = exports.OperationResolutionError = exports.UserInputError = exports.PersistedQueryNotSupportedError = exports.PersistedQueryNotFoundError = exports.ValidationError = exports.SyntaxError = void 0;
const graphql_1 = require("graphql");
const index_js_1 = require("./errors/index.js");
const runHttpQuery_js_1 = require("./runHttpQuery.js");
const HeaderMap_js_1 = require("./utils/HeaderMap.js");
class GraphQLErrorWithCode extends graphql_1.GraphQLError {
    constructor(message, code, options) {
        super(message, {
            ...options,
            extensions: { ...options?.extensions, code },
        });
        this.name = this.constructor.name;
    }
}
class SyntaxError extends GraphQLErrorWithCode {
    constructor(graphqlError) {
        super(graphqlError.message, index_js_1.ApolloServerErrorCode.GRAPHQL_PARSE_FAILED, {
            source: graphqlError.source,
            positions: graphqlError.positions,
            extensions: { http: (0, runHttpQuery_js_1.newHTTPGraphQLHead)(400), ...graphqlError.extensions },
            originalError: graphqlError,
        });
    }
}
exports.SyntaxError = SyntaxError;
class ValidationError extends GraphQLErrorWithCode {
    constructor(graphqlError) {
        super(graphqlError.message, index_js_1.ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED, {
            nodes: graphqlError.nodes,
            extensions: {
                http: (0, runHttpQuery_js_1.newHTTPGraphQLHead)(400),
                ...graphqlError.extensions,
            },
            originalError: graphqlError.originalError ?? graphqlError,
        });
    }
}
exports.ValidationError = ValidationError;
const getPersistedQueryErrorHttp = () => ({
    status: 200,
    headers: new HeaderMap_js_1.HeaderMap([
        ['cache-control', 'private, no-cache, must-revalidate'],
    ]),
});
class PersistedQueryNotFoundError extends GraphQLErrorWithCode {
    constructor() {
        super('PersistedQueryNotFound', index_js_1.ApolloServerErrorCode.PERSISTED_QUERY_NOT_FOUND, { extensions: { http: getPersistedQueryErrorHttp() } });
    }
}
exports.PersistedQueryNotFoundError = PersistedQueryNotFoundError;
class PersistedQueryNotSupportedError extends GraphQLErrorWithCode {
    constructor() {
        super('PersistedQueryNotSupported', index_js_1.ApolloServerErrorCode.PERSISTED_QUERY_NOT_SUPPORTED, { extensions: { http: getPersistedQueryErrorHttp() } });
    }
}
exports.PersistedQueryNotSupportedError = PersistedQueryNotSupportedError;
class UserInputError extends GraphQLErrorWithCode {
    constructor(graphqlError) {
        super(graphqlError.message, index_js_1.ApolloServerErrorCode.BAD_USER_INPUT, {
            nodes: graphqlError.nodes,
            originalError: graphqlError.originalError ?? graphqlError,
            extensions: graphqlError.extensions,
        });
    }
}
exports.UserInputError = UserInputError;
class OperationResolutionError extends GraphQLErrorWithCode {
    constructor(graphqlError) {
        super(graphqlError.message, index_js_1.ApolloServerErrorCode.OPERATION_RESOLUTION_FAILURE, {
            nodes: graphqlError.nodes,
            originalError: graphqlError.originalError ?? graphqlError,
            extensions: {
                http: (0, runHttpQuery_js_1.newHTTPGraphQLHead)(400),
                ...graphqlError.extensions,
            },
        });
    }
}
exports.OperationResolutionError = OperationResolutionError;
class BadRequestError extends GraphQLErrorWithCode {
    constructor(message, options) {
        super(message, index_js_1.ApolloServerErrorCode.BAD_REQUEST, {
            ...options,
            extensions: { http: (0, runHttpQuery_js_1.newHTTPGraphQLHead)(400), ...options?.extensions },
        });
    }
}
exports.BadRequestError = BadRequestError;
//# sourceMappingURL=internalErrorClasses.js.map∑/src/requestPipeline.ts≈]Óimport { createHash } from '@apollo/utils.createhash';
import {
  specifiedRules,
  getOperationAST,
  GraphQLError,
  validate,
  parse,
  Kind,
  ExecutionResult,
} from 'graphql';
import {
  symbolExecutionDispatcherWillResolveField,
  enablePluginsForSchemaResolvers,
  symbolUserFieldResolver,
} from './utils/schemaInstrumentation.js';
import {
  PersistedQueryNotSupportedError,
  PersistedQueryNotFoundError,
  UserInputError,
  BadRequestError,
  ValidationError,
  SyntaxError,
  OperationResolutionError,
} from './internalErrorClasses.js';
import {
  ensureError,
  normalizeAndFormatErrors,
  ensureGraphQLError,
} from './errorNormalize.js';
import type {
  GraphQLRequestContext,
  GraphQLRequestContextDidResolveSource,
  GraphQLRequestContextExecutionDidStart,
  GraphQLRequestContextResponseForOperation,
  GraphQLRequestContextDidResolveOperation,
  GraphQLRequestContextParsingDidStart,
  GraphQLRequestContextValidationDidStart,
  GraphQLRequestContextWillSendResponse,
  GraphQLRequestContextDidEncounterErrors,
  GraphQLRequestExecutionListener,
  BaseContext,
  GraphQLResponse,
  GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,
} from './externalTypes/index.js';

import {
  invokeDidStartHook,
  invokeHooksUntilDefinedAndNonNull,
  invokeSyncDidStartHook,
} from './utils/invokeHooks.js';

import { makeGatewayGraphQLRequestContext } from './utils/makeGatewayGraphQLRequestContext.js';

import { mergeHTTPGraphQLHead, newHTTPGraphQLHead } from './runHttpQuery.js';
import type {
  ApolloServer,
  ApolloServerInternals,
  SchemaDerivedData,
} from './ApolloServer.js';
import { isDefined } from './utils/isDefined.js';
import type {
  GraphQLRequestContextDidEncounterSubsequentErrors,
  GraphQLRequestContextWillSendSubsequentPayload,
} from './externalTypes/requestPipeline.js';
import {
  executeIncrementally,
  GraphQLExperimentalInitialIncrementalExecutionResult,
  GraphQLExperimentalSubsequentIncrementalExecutionResult,
} from './incrementalDeliveryPolyfill.js';
import { HeaderMap } from './utils/HeaderMap.js';

export const APQ_CACHE_PREFIX = 'apq:';

function computeQueryHash(query: string) {
  return createHash('sha256').update(query).digest('hex');
}

type Mutable<T> = { -readonly [P in keyof T]: T[P] };

function isBadUserInputGraphQLError(error: GraphQLError): boolean {
  return (
    error.nodes?.length === 1 &&
    error.nodes[0].kind === Kind.VARIABLE_DEFINITION &&
    (error.message.startsWith(
      `Variable "$${error.nodes[0].variable.name.value}" got invalid value `,
    ) ||
      error.message.startsWith(
        `Variable "$${error.nodes[0].variable.name.value}" of required type `,
      ) ||
      error.message.startsWith(
        `Variable "$${error.nodes[0].variable.name.value}" of non-null type `,
      ))
  );
}

// This is "semi-formatted" because the initial result has not yet been
// formatted but the subsequent results "have been" --- in the sense that they
// are an async iterable that will format them as they come in.
type SemiFormattedExecuteIncrementallyResults =
  | {
      singleResult: ExecutionResult;
    }
  | {
      initialResult: GraphQLExperimentalInitialIncrementalExecutionResult;
      subsequentResults: AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult>;
    };

export async function processGraphQLRequest<TContext extends BaseContext>(
  schemaDerivedData: SchemaDerivedData,
  server: ApolloServer<TContext>,
  internals: ApolloServerInternals<TContext>,
  requestContext: Mutable<GraphQLRequestContext<TContext>>,
): Promise<GraphQLResponse> {
  const requestListeners = (
    await Promise.all(
      internals.plugins.map((p) => p.requestDidStart?.(requestContext)),
    )
  ).filter(isDefined);

  const request = requestContext.request;

  let { query, extensions } = request;

  let queryHash: string;

  requestContext.metrics.persistedQueryHit = false;
  requestContext.metrics.persistedQueryRegister = false;

  if (extensions?.persistedQuery) {
    // It looks like we've received a persisted query. Check if we
    // support them.
    if (!internals.persistedQueries) {
      return await sendErrorResponse([new PersistedQueryNotSupportedError()]);
    } else if (extensions.persistedQuery.version !== 1) {
      return await sendErrorResponse([
        new GraphQLError('Unsupported persisted query version', {
          extensions: { http: newHTTPGraphQLHead(400) },
        }),
      ]);
    }

    queryHash = extensions.persistedQuery.sha256Hash;

    if (query === undefined) {
      query = await internals.persistedQueries.cache.get(queryHash);
      if (query) {
        requestContext.metrics.persistedQueryHit = true;
      } else {
        return await sendErrorResponse([new PersistedQueryNotFoundError()]);
      }
    } else {
      const computedQueryHash = computeQueryHash(query);

      // The provided hash must exactly match the SHA-256 hash of
      // the query string. This prevents hash hijacking, where a
      // new and potentially malicious query is associated with
      // an existing hash.
      if (queryHash !== computedQueryHash) {
        return await sendErrorResponse([
          new GraphQLError('provided sha does not match query', {
            extensions: { http: newHTTPGraphQLHead(400) },
          }),
        ]);
      }

      // We won't write to the persisted query cache until later.
      // Deferring the writing gives plugins the ability to "win" from use of
      // the cache, but also have their say in whether or not the cache is
      // written to (by interrupting the request with an error).
      requestContext.metrics.persistedQueryRegister = true;
    }
  } else if (query) {
    queryHash = computeQueryHash(query);
  } else {
    return await sendErrorResponse([
      new BadRequestError(
        'GraphQL operations must contain a non-empty `query` or a `persistedQuery` extension.',
      ),
    ]);
  }

  requestContext.queryHash = queryHash;
  requestContext.source = query;

  // Let the plugins know that we now have a STRING of what we hope will
  // parse and validate into a document we can execute on.  Unless we have
  // retrieved this from our APQ cache, there's no guarantee that it is
  // syntactically correct, so this string should not be trusted as a valid
  // document until after it's parsed and validated.
  await Promise.all(
    requestListeners.map((l) =>
      l.didResolveSource?.(
        requestContext as GraphQLRequestContextDidResolveSource<TContext>,
      ),
    ),
  );

  // If we're configured with a document store (by default, we are), we'll
  // utilize the operation's hash to lookup the AST from the previously
  // parsed-and-validated operation.  Failure to retrieve anything from the
  // cache just means we're committed to doing the parsing and validation.
  if (schemaDerivedData.documentStore) {
    try {
      requestContext.document = await schemaDerivedData.documentStore.get(
        queryHash,
      );
    } catch (err: unknown) {
      server.logger.warn(
        'An error occurred while attempting to read from the documentStore. ' +
          ensureError(err).message,
      );
    }
  }

  // If we still don't have a document, we'll need to parse and validate it.
  // With success, we'll attempt to save it into the store for future use.
  if (!requestContext.document) {
    const parsingDidEnd = await invokeDidStartHook(
      requestListeners,
      async (l) =>
        l.parsingDidStart?.(
          requestContext as GraphQLRequestContextParsingDidStart<TContext>,
        ),
    );

    try {
      requestContext.document = parse(query, internals.parseOptions);
    } catch (syntaxMaybeError: unknown) {
      const error = ensureError(syntaxMaybeError);
      await parsingDidEnd(error);
      return await sendErrorResponse([
        new SyntaxError(ensureGraphQLError(error)),
      ]);
    }
    await parsingDidEnd();

    const validationDidEnd = await invokeDidStartHook(
      requestListeners,
      async (l) =>
        l.validationDidStart?.(
          requestContext as GraphQLRequestContextValidationDidStart<TContext>,
        ),
    );

    const validationErrors = validate(
      schemaDerivedData.schema,
      requestContext.document,
      [...specifiedRules, ...internals.validationRules],
    );

    if (validationErrors.length === 0) {
      await validationDidEnd();
    } else {
      await validationDidEnd(validationErrors);
      return await sendErrorResponse(
        validationErrors.map((error) => new ValidationError(error)),
      );
    }

    if (schemaDerivedData.documentStore) {
      // The underlying cache store behind the `documentStore` returns a
      // `Promise` which is resolved (or rejected), eventually, based on the
      // success or failure (respectively) of the cache save attempt.  While
      // it's certainly possible to `await` this `Promise`, we don't care about
      // whether or not it's successful at this point.  We'll instead proceed
      // to serve the rest of the request and just hope that this works out.
      // If it doesn't work, the next request will have another opportunity to
      // try again.  Errors will surface as warnings, as appropriate.
      //
      // While it shouldn't normally be necessary to wrap this `Promise` in a
      // `Promise.resolve` invocation, it seems that the underlying cache store
      // is returning a non-native `Promise` (e.g. Bluebird, etc.).
      Promise.resolve(
        schemaDerivedData.documentStore.set(queryHash, requestContext.document),
      ).catch((err) =>
        server.logger.warn(
          'Could not store validated document. ' + err?.message || err,
        ),
      );
    }
  }

  // TODO: If we want to guarantee an operation has been set when invoking
  // `willExecuteOperation` and executionDidStart`, we need to throw an
  // error here and not leave this to `buildExecutionContext` in
  // `graphql-js`.
  const operation = getOperationAST(
    requestContext.document,
    request.operationName,
  );

  requestContext.operation = operation || undefined;
  // We'll set `operationName` to `null` for anonymous operations.
  requestContext.operationName = operation?.name?.value || null;

  // Special case: GET operations should only be queries (not mutations). We
  // want to throw a particular HTTP error in that case. (This matters because
  // it's generally how HTTP requests should work, and additionally it makes us
  // less vulnerable to mutations running over CSRF, if you turn off our CSRF
  // prevention feature.)
  if (
    request.http?.method === 'GET' &&
    operation?.operation &&
    operation.operation !== 'query'
  ) {
    return await sendErrorResponse([
      new BadRequestError(
        `GET requests only support query operations, not ${operation.operation} operations`,
        {
          extensions: {
            http: { status: 405, headers: new HeaderMap([['allow', 'POST']]) },
          },
        },
      ),
    ]);
  }

  try {
    await Promise.all(
      requestListeners.map((l) =>
        l.didResolveOperation?.(
          requestContext as GraphQLRequestContextDidResolveOperation<TContext>,
        ),
      ),
    );
  } catch (err: unknown) {
    // Note that we explicitly document throwing `GraphQLError`s from
    // `didResolveOperation` as a good way to do validation that depends on the
    // validated operation and the request context. (It will have status 500 by
    // default.)
    return await sendErrorResponse([ensureGraphQLError(err)]);
  }

  // Now that we've gone through the pre-execution phases of the request
  // pipeline, and given plugins appropriate ability to object (by throwing
  // an error) and not actually write, we'll write to the cache if it was
  // determined earlier in the request pipeline that we should do so.
  if (
    requestContext.metrics.persistedQueryRegister &&
    internals.persistedQueries
  ) {
    // While it shouldn't normally be necessary to wrap this `Promise` in a
    // `Promise.resolve` invocation, it seems that the underlying cache store
    // is returning a non-native `Promise` (e.g. Bluebird, etc.).
    const ttl = internals.persistedQueries?.ttl;
    Promise.resolve(
      internals.persistedQueries.cache.set(
        queryHash,
        query,
        // Explicitly checking for `undefined` which means "not set" vs 0 or
        // null which means "no TTL".
        ttl !== undefined
          ? { ttl: internals.persistedQueries?.ttl }
          : undefined,
      ),
    ).catch(server.logger.warn);
  }

  const responseFromPlugin = await invokeHooksUntilDefinedAndNonNull(
    requestListeners,
    async (l) =>
      await l.responseForOperation?.(
        requestContext as GraphQLRequestContextResponseForOperation<TContext>,
      ),
  );
  if (responseFromPlugin !== null) {
    requestContext.response.body = responseFromPlugin.body;
    mergeHTTPGraphQLHead(requestContext.response.http, responseFromPlugin.http);
  } else {
    const executionListeners = (
      await Promise.all(
        requestListeners.map((l) =>
          l.executionDidStart?.(
            requestContext as GraphQLRequestContextExecutionDidStart<TContext>,
          ),
        ),
      )
    ).filter(isDefined);
    executionListeners.reverse();

    if (executionListeners.some((l) => l.willResolveField)) {
      // Create a callback that will trigger the execution dispatcher's
      // `willResolveField` hook.  We will attach this to the context on a
      // symbol so it can be invoked by our `wrapField` method during execution.
      const invokeWillResolveField: GraphQLRequestExecutionListener<TContext>['willResolveField'] =
        (...args) =>
          invokeSyncDidStartHook(executionListeners, (l) =>
            l.willResolveField?.(...args),
          );

      Object.defineProperty(
        requestContext.contextValue,
        symbolExecutionDispatcherWillResolveField,
        { value: invokeWillResolveField },
      );

      // If the user has provided a custom field resolver, we will attach
      // it to the context so we can still invoke it after we've wrapped the
      // fields with `wrapField` within `enablePluginsForSchemaResolvers` of
      // the `schemaInstrumentation` module.
      if (internals.fieldResolver) {
        Object.defineProperty(
          requestContext.contextValue,
          symbolUserFieldResolver,
          {
            value: internals.fieldResolver,
          },
        );
      }

      // If the schema is already enabled, this is a no-op.  Otherwise, the
      // schema will be augmented so it is able to invoke willResolveField. Note
      // that if we never see a plugin with willResolveField then we will never
      // need to instrument the schema, which might be a small performance gain.
      // (For example, this can happen if you pass `fieldLevelInstrumentation:
      // () => false` to the usage reporting plugin and disable the cache
      // control plugin. We can consider changing the cache control plugin to
      // have a "static cache control only" mode that doesn't use
      // willResolveField too if this proves to be helpful in practice.)
      enablePluginsForSchemaResolvers(schemaDerivedData.schema);
    }

    try {
      const fullResult = await execute(
        requestContext as GraphQLRequestContextExecutionDidStart<TContext>,
      );
      const result =
        'singleResult' in fullResult
          ? fullResult.singleResult
          : fullResult.initialResult;

      // If we don't have an operation, there's no reason to go further. We know
      // `result` will consist of one error (returned by `graphql-js`'s
      // `buildExecutionContext`).
      if (!requestContext.operation) {
        if (!result.errors?.length) {
          throw new Error(
            'Unexpected error: Apollo Server did not resolve an operation but execute did not return errors',
          );
        }
        throw new OperationResolutionError(result.errors[0]);
      }

      // The first thing that execution does is coerce the request's variables
      // to the types declared in the operation, which can lead to errors if
      // they are of the wrong type. It also makes sure that all non-null
      // variables are required and get non-null values. If any of these things
      // lead to errors, we change them into UserInputError so that their code
      // doesn't end up being INTERNAL_SERVER_ERROR, since these are client
      // errors.
      //
      // This is hacky! Hopefully graphql-js will give us a way to separate
      // variable resolution from execution later; see
      // https://github.com/graphql/graphql-js/issues/3169
      const resultErrors = result.errors?.map((e) => {
        if (isBadUserInputGraphQLError(e)) {
          return new UserInputError(e);
        }
        return e;
      });

      if (resultErrors) {
        await didEncounterErrors(resultErrors);
      }

      const { formattedErrors, httpFromErrors } = resultErrors
        ? formatErrors(resultErrors)
        : { formattedErrors: undefined, httpFromErrors: newHTTPGraphQLHead() };
      mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);

      if ('singleResult' in fullResult) {
        requestContext.response.body = {
          kind: 'single',
          singleResult: {
            ...result,
            errors: formattedErrors,
          },
        };
      } else {
        requestContext.response.body = {
          kind: 'incremental',
          initialResult: {
            ...fullResult.initialResult,
            errors: formattedErrors,
          },
          subsequentResults: fullResult.subsequentResults,
        };
      }
    } catch (executionMaybeError: unknown) {
      const executionError = ensureError(executionMaybeError);
      await Promise.all(
        executionListeners.map((l) => l.executionDidEnd?.(executionError)),
      );

      return await sendErrorResponse([ensureGraphQLError(executionError)]);
    }

    await Promise.all(executionListeners.map((l) => l.executionDidEnd?.()));
  }

  await invokeWillSendResponse();
  if (!requestContext.response.body) {
    throw Error('got to end of processGraphQLRequest without setting body?');
  }
  return requestContext.response as GraphQLResponse; // cast checked on previous line

  async function execute(
    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,
  ): Promise<SemiFormattedExecuteIncrementallyResults> {
    const { request, document } = requestContext;

    if (internals.__testing_incrementalExecutionResults) {
      return internals.__testing_incrementalExecutionResults;
    } else if (internals.gatewayExecutor) {
      const result = await internals.gatewayExecutor(
        makeGatewayGraphQLRequestContext(requestContext, server, internals),
      );
      return { singleResult: result };
    } else {
      const resultOrResults = await executeIncrementally({
        schema: schemaDerivedData.schema,
        document,
        rootValue:
          typeof internals.rootValue === 'function'
            ? internals.rootValue(document)
            : internals.rootValue,
        contextValue: requestContext.contextValue,
        variableValues: request.variables,
        operationName: request.operationName,
        fieldResolver: internals.fieldResolver,
      });
      if ('initialResult' in resultOrResults) {
        return {
          initialResult: resultOrResults.initialResult,
          subsequentResults: formatErrorsInSubsequentResults(
            resultOrResults.subsequentResults,
          ),
        };
      } else {
        return { singleResult: resultOrResults };
      }
    }
  }

  async function* formatErrorsInSubsequentResults(
    results: AsyncIterable<GraphQLExperimentalSubsequentIncrementalExecutionResult>,
  ): AsyncIterable<GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult> {
    for await (const result of results) {
      const payload: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult =
        result.incremental
          ? {
              ...result,
              incremental: await seriesAsyncMap(
                result.incremental,
                async (incrementalResult) => {
                  const { errors } = incrementalResult;
                  if (errors) {
                    await Promise.all(
                      requestListeners.map((l) =>
                        l.didEncounterSubsequentErrors?.(
                          requestContext as GraphQLRequestContextDidEncounterSubsequentErrors<TContext>,
                          errors,
                        ),
                      ),
                    );

                    return {
                      ...incrementalResult,
                      // Note that any `http` extensions in errors have no
                      // effect, because we've already sent the status code
                      // and response headers.
                      errors: formatErrors(errors).formattedErrors,
                    };
                  }
                  return incrementalResult;
                },
              ),
            }
          : result;

      // Invoke hook, which is allowed to mutate payload if it really wants to.
      await Promise.all(
        requestListeners.map((l) =>
          l.willSendSubsequentPayload?.(
            requestContext as GraphQLRequestContextWillSendSubsequentPayload<TContext>,
            payload,
          ),
        ),
      );

      yield payload;
    }
  }

  async function invokeWillSendResponse() {
    await Promise.all(
      requestListeners.map((l) =>
        l.willSendResponse?.(
          requestContext as GraphQLRequestContextWillSendResponse<TContext>,
        ),
      ),
    );
  }

  // Note that we ensure that all calls to didEncounterErrors are followed by
  // calls to willSendResponse. (The usage reporting plugin depends on this.)
  async function didEncounterErrors(errors: ReadonlyArray<GraphQLError>) {
    requestContext.errors = errors;

    return await Promise.all(
      requestListeners.map((l) =>
        l.didEncounterErrors?.(
          requestContext as GraphQLRequestContextDidEncounterErrors<TContext>,
        ),
      ),
    );
  }

  // This function "sends" a response that contains errors and no data (not even
  // `data: null`) because the pipeline does not make it to a successful
  // `execute` call. (It is *not* called for execution that happens to return
  // some errors.) In this case "send" means "update requestContext.response and
  // invoke willSendResponse hooks".
  //
  // If any errors have `extensions.http` set, it sets the response's status code
  // and errors from them.
  //
  // Then, if the HTTP status code is not yet set, it sets it to 500.
  async function sendErrorResponse(
    errors: ReadonlyArray<GraphQLError>,
  ): Promise<GraphQLResponse> {
    await didEncounterErrors(errors);

    const { formattedErrors, httpFromErrors } = formatErrors(errors);

    requestContext.response.body = {
      kind: 'single',
      singleResult: {
        errors: formattedErrors,
      },
    };

    mergeHTTPGraphQLHead(requestContext.response.http, httpFromErrors);

    if (!requestContext.response.http.status) {
      requestContext.response.http.status = 500;
    }

    await invokeWillSendResponse();

    // cast safe because we assigned to `body` above
    return requestContext.response as GraphQLResponse;
  }

  function formatErrors(
    errors: ReadonlyArray<GraphQLError>,
  ): ReturnType<typeof normalizeAndFormatErrors> {
    return normalizeAndFormatErrors(errors, {
      formatError: internals.formatError,
      includeStacktraceInErrorResponses:
        internals.includeStacktraceInErrorResponses,
    });
  }
}

async function seriesAsyncMap<T, U>(
  ts: readonly T[],
  fn: (value: T) => Promise<U>,
): Promise<U[]> {
  const us: U[] = [];
  for (const t of ts) {
    const u = await fn(t);
    us.push(u);
  }
  return us;
}
Ÿ3/dist/cjs/plugin/usageReporting/iterateOverTrace.js≈	¶"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterateOverTrace = void 0;
function iterateOverTrace(trace, f, includePath) {
    const rootPath = includePath
        ? new RootCollectingPathsResponseNamePath()
        : notCollectingPathsResponseNamePath;
    if (trace.root) {
        if (iterateOverTraceNode(trace.root, rootPath, f))
            return;
    }
    if (trace.queryPlan) {
        if (iterateOverQueryPlan(trace.queryPlan, rootPath, f))
            return;
    }
}
exports.iterateOverTrace = iterateOverTrace;
function iterateOverQueryPlan(node, rootPath, f) {
    if (!node)
        return false;
    if (node.fetch?.trace?.root && node.fetch.serviceName) {
        return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);
    }
    if (node.flatten?.node) {
        return iterateOverQueryPlan(node.flatten.node, rootPath, f);
    }
    if (node.parallel?.nodes) {
        return node.parallel.nodes.some((node) => iterateOverQueryPlan(node, rootPath, f));
    }
    if (node.sequence?.nodes) {
        return node.sequence.nodes.some((node) => iterateOverQueryPlan(node, rootPath, f));
    }
    return false;
}
function iterateOverTraceNode(node, path, f) {
    if (f(node, path)) {
        return true;
    }
    return (node.child?.some((child) => {
        const childPath = child.responseName
            ? path.child(child.responseName)
            : path;
        return iterateOverTraceNode(child, childPath, f);
    }) ?? false);
}
const notCollectingPathsResponseNamePath = {
    toArray() {
        throw Error('not collecting paths!');
    },
    child() {
        return this;
    },
};
class RootCollectingPathsResponseNamePath {
    toArray() {
        return [];
    }
    child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
    }
}
class ChildCollectingPathsResponseNamePath {
    constructor(responseName, prev) {
        this.responseName = responseName;
        this.prev = prev;
    }
    toArray() {
        const out = [];
        let curr = this;
        while (curr instanceof ChildCollectingPathsResponseNamePath) {
            out.push(curr.responseName);
            curr = curr.prev;
        }
        return out.reverse();
    }
    child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
    }
}
//# sourceMappingURL=iterateOverTrace.js.map∏/src/standalone/index.ts≈
Àimport type { WithRequired } from '@apollo/utils.withrequired';
import bodyParser from 'body-parser'; // note that importing 'json' directly doesn't work in ESM
import cors from 'cors';
import express from 'express';
import http, { IncomingMessage, ServerResponse } from 'http';
import type { ListenOptions } from 'net';
import type { ApolloServer } from '../ApolloServer.js';
import { expressMiddleware } from '../express4/index.js';
import type { BaseContext, ContextFunction } from '../externalTypes/index.js';
import { ApolloServerPluginDrainHttpServer } from '../plugin/drainHttpServer/index.js';
import { urlForHttpServer } from '../utils/urlForHttpServer.js';

// Note that while we do use express and expressMiddleware to implement the
// standalone server, this is an internal implementation detail. We could
// rewrite this to have no dependencies other than the core http package.
// Because of this, our TypeScript types encourage users to only use
// functionality of `req` and `res` that are part of the core http
// implementations rather than the Express-specific subclasses; if you need
// typesafe access to Express-specific properties, just use expressMiddleware
// directly.
export interface StandaloneServerContextFunctionArgument {
  req: IncomingMessage;
  res: ServerResponse;
}

export interface StartStandaloneServerOptions<TContext extends BaseContext> {
  context?: ContextFunction<
    [StandaloneServerContextFunctionArgument],
    TContext
  >;
}

export async function startStandaloneServer(
  server: ApolloServer<BaseContext>,
  options?: StartStandaloneServerOptions<BaseContext> & {
    listen?: ListenOptions;
  },
): Promise<{ url: string }>;
export async function startStandaloneServer<TContext extends BaseContext>(
  server: ApolloServer<TContext>,
  options: WithRequired<StartStandaloneServerOptions<TContext>, 'context'> & {
    listen?: ListenOptions;
  },
): Promise<{ url: string }>;
export async function startStandaloneServer<TContext extends BaseContext>(
  server: ApolloServer<TContext>,
  options?: StartStandaloneServerOptions<TContext> & { listen?: ListenOptions },
): Promise<{ url: string }> {
  const app: express.Express = express();
  const httpServer: http.Server = http.createServer(app);

  server.addPlugin(
    ApolloServerPluginDrainHttpServer({ httpServer: httpServer }),
  );

  await server.start();

  const context = options?.context ?? (async () => ({} as TContext));
  app.use(cors(), bodyParser.json(), expressMiddleware(server, { context }));

  const listenOptions = options?.listen ?? { port: 4000 };
  // Wait for server to start listening
  await new Promise<void>((resolve) => {
    httpServer.listen(listenOptions, resolve);
  });

  return { url: urlForHttpServer(httpServer) };
}
Ÿ8/dist/cjs/plugin/usageReporting/durationHistogram.js.map≈	{"version":3,"file":"durationHistogram.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/durationHistogram.ts"],"names":[],"mappings":"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"}Ÿ(/plugin/landingPage/default/package.json≈4{
  "name": "@apollo/server/plugin/landingPage/default",
  "type": "module",
  "main": "../../../dist/cjs/plugin/landingPage/default/index.js",
  "module": "../../../dist/esm/plugin/landingPage/default/index.js",
  "types": "../../../dist/esm/plugin/landingPage/default/index.d.ts",
  "sideEffects": false
}
Ÿ5/dist/esm/plugin/usageReporting/iterateOverTrace.d.ts≈nimport type { Trace } from '@apollo/usage-reporting-protobuf';
export declare function iterateOverTrace(trace: Trace, f: (node: Trace.INode, path: ResponseNamePath) => boolean, includePath: boolean): void;
export interface ResponseNamePath {
    toArray(): string[];
    child(responseName: string): ResponseNamePath;
}
//# sourceMappingURL=iterateOverTrace.d.ts.mapΩ/dist/cjs/runHttpQuery.js.map≈{"version":3,"file":"runHttpQuery.js","sourceRoot":"","sources":["../../src/runHttpQuery.ts"],"names":[],"mappings":"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"}Ÿ'/dist/esm/generated/packageVersion.d.tsƒ[export declare const packageVersion = "4.1.1";
//# sourceMappingURL=packageVersion.d.ts.mapŸ*/dist/esm/plugin/usageReporting/options.jsƒ.export {};
//# sourceMappingURL=options.js.mapŸ!/dist/cjs/standalone/index.js.map≈–{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/standalone/index.ts"],"names":[],"mappings":";;;;;;AACA,8DAAqC;AACrC,gDAAwB;AACxB,sDAA8B;AAC9B,gDAA6D;AAG7D,mDAAyD;AAEzD,iEAAuF;AACvF,sEAAgE;AAkCzD,KAAK,UAAU,qBAAqB,CACzC,MAA8B,EAC9B,OAA6E;IAE7E,MAAM,GAAG,GAAoB,IAAA,iBAAO,GAAE,CAAC;IACvC,MAAM,UAAU,GAAgB,cAAI,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;IAEvD,MAAM,CAAC,SAAS,CACd,IAAA,4CAAiC,EAAC,EAAE,UAAU,EAAE,UAAU,EAAE,CAAC,CAC9D,CAAC;IAEF,MAAM,MAAM,CAAC,KAAK,EAAE,CAAC;IAErB,MAAM,OAAO,GAAG,OAAO,EAAE,OAAO,IAAI,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC,EAAe,CAAA,CAAC,CAAC;IACnE,GAAG,CAAC,GAAG,CAAC,IAAA,cAAI,GAAE,EAAE,qBAAU,CAAC,IAAI,EAAE,EAAE,IAAA,4BAAiB,EAAC,MAAM,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;IAE3E,MAAM,aAAa,GAAG,OAAO,EAAE,MAAM,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;IAExD,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,EAAE;QAClC,UAAU,CAAC,MAAM,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;IAEH,OAAO,EAAE,GAAG,EAAE,IAAA,sCAAgB,EAAC,UAAU,CAAC,EAAE,CAAC;AAC/C,CAAC;AAvBD,sDAuBC"}Ÿ#/dist/cjs/externalTypes/http.js.mapƒx{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../src/externalTypes/http.ts"],"names":[],"mappings":""}≠/package.json≈∂{
  "name": "@apollo/server",
  "version": "4.1.1",
  "description": "Core engine for Apollo GraphQL server",
  "type": "module",
  "main": "dist/cjs/index.js",
  "module": "dist/esm/index.js",
  "types": "dist/esm/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/esm/index.d.ts",
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js"
    },
    "./errors": {
      "types": "./dist/esm/errors/index.d.ts",
      "import": "./dist/esm/errors/index.js",
      "require": "./dist/cjs/errors/index.js"
    },
    "./express4": {
      "types": "./dist/esm/express4/index.d.ts",
      "import": "./dist/esm/express4/index.js",
      "require": "./dist/cjs/express4/index.js"
    },
    "./standalone": {
      "types": "./dist/esm/standalone/index.d.ts",
      "import": "./dist/esm/standalone/index.js",
      "require": "./dist/cjs/standalone/index.js"
    },
    "./plugin/cacheControl": {
      "types": "./dist/esm/plugin/cacheControl/index.d.ts",
      "import": "./dist/esm/plugin/cacheControl/index.js",
      "require": "./dist/cjs/plugin/cacheControl/index.js"
    },
    "./plugin/disabled": {
      "types": "./dist/esm/plugin/disabled/index.d.ts",
      "import": "./dist/esm/plugin/disabled/index.js",
      "require": "./dist/cjs/plugin/disabled/index.js"
    },
    "./plugin/drainHttpServer": {
      "types": "./dist/esm/plugin/drainHttpServer/index.d.ts",
      "import": "./dist/esm/plugin/drainHttpServer/index.js",
      "require": "./dist/cjs/plugin/drainHttpServer/index.js"
    },
    "./plugin/inlineTrace": {
      "types": "./dist/esm/plugin/inlineTrace/index.d.ts",
      "import": "./dist/esm/plugin/inlineTrace/index.js",
      "require": "./dist/cjs/plugin/inlineTrace/index.js"
    },
    "./plugin/landingPage/default": {
      "types": "./dist/esm/plugin/landingPage/default/index.d.ts",
      "import": "./dist/esm/plugin/landingPage/default/index.js",
      "require": "./dist/cjs/plugin/landingPage/default/index.js"
    },
    "./plugin/schemaReporting": {
      "types": "./dist/esm/plugin/schemaReporting/index.d.ts",
      "import": "./dist/esm/plugin/schemaReporting/index.js",
      "require": "./dist/cjs/plugin/schemaReporting/index.js"
    },
    "./plugin/usageReporting": {
      "types": "./dist/esm/plugin/usageReporting/index.d.ts",
      "import": "./dist/esm/plugin/usageReporting/index.js",
      "require": "./dist/cjs/plugin/usageReporting/index.js"
    }
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/apollographql/apollo-server",
    "directory": "packages/server"
  },
  "keywords": [
    "GraphQL",
    "Apollo",
    "Server",
    "Javascript"
  ],
  "author": "Apollo <packages@apollographql.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/apollographql/apollo-server/issues"
  },
  "homepage": "https://github.com/apollographql/apollo-server#readme",
  "engines": {
    "node": ">=14.16.0"
  },
  "dependencies": {
    "@apollo/cache-control-types": "^1.0.2",
    "@apollo/server-gateway-interface": "^1.0.5",
    "@apollo/usage-reporting-protobuf": "^4.0.0",
    "@apollo/utils.createhash": "^1.1.0",
    "@apollo/utils.fetcher": "^1.0.0",
    "@apollo/utils.isnodelike": "^1.1.0",
    "@apollo/utils.keyvaluecache": "^1.0.1",
    "@apollo/utils.logger": "^1.0.0",
    "@apollo/utils.usagereporting": "^1.0.0",
    "@apollo/utils.withrequired": "^1.0.0",
    "@graphql-tools/schema": "^9.0.0",
    "@josephg/resolvable": "^1.0.0",
    "@types/express-serve-static-core": "^4.17.30",
    "@types/express": "^4.17.13",
    "@types/node-fetch": "^2.6.1",
    "async-retry": "^1.2.1",
    "body-parser": "^1.20.0",
    "cors": "^2.8.5",
    "express": "^4.17.1",
    "loglevel": "^1.6.8",
    "lru-cache": "^7.10.1",
    "negotiator": "^0.6.3",
    "node-abort-controller": "^3.0.1",
    "node-fetch": "^2.6.7",
    "uuid": "^9.0.0",
    "whatwg-mimetype": "^3.0.0"
  },
  "peerDependencies": {
    "graphql": "^16.6.0"
  },
  "volta": {
    "extends": "../../package.json"
  }
}
Ÿ'/dist/esm/utils/urlForHttpServer.js.map≈‰{"version":3,"file":"urlForHttpServer.js","sourceRoot":"","sources":["../../../src/utils/urlForHttpServer.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,KAAK,CAAC;AAE7B,MAAM,UAAU,gBAAgB,CAAC,UAAkB;IACjD,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,UAAU,CAAC,OAAO,EAAiB,CAAC;IAO9D,MAAM,QAAQ,GAAG,OAAO,KAAK,EAAE,IAAI,OAAO,KAAK,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,OAAO,CAAC;IAE5E,OAAO,MAAM,CAAC;QACZ,QAAQ,EAAE,MAAM;QAChB,QAAQ;QACR,IAAI;QACJ,QAAQ,EAAE,GAAG;KACd,CAAC,CAAC;AACL,CAAC"}Ÿ./dist/esm/plugin/usageReporting/stats.d.ts.map≈
≤{"version":3,"file":"stats.d.ts","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/stats.ts"],"names":[],"mappings":"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"}Ÿ&/dist/cjs/plugin/cacheControl/index.js≈)Á"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApolloServerPluginCacheControl = void 0;
const graphql_1 = require("graphql");
const cachePolicy_js_1 = require("../../cachePolicy.js");
const internalPlugin_js_1 = require("../../internalPlugin.js");
const lru_cache_1 = __importDefault(require("lru-cache"));
function ApolloServerPluginCacheControl(options = Object.create(null)) {
    let typeAnnotationCache;
    let fieldAnnotationCache;
    return (0, internalPlugin_js_1.internalPlugin)({
        __internal_plugin_id__: 'CacheControl',
        __is_disabled_plugin__: false,
        async serverWillStart({ schema }) {
            typeAnnotationCache = new lru_cache_1.default({
                max: Object.values(schema.getTypeMap()).filter(graphql_1.isCompositeType)
                    .length,
            });
            fieldAnnotationCache = new lru_cache_1.default({
                max: Object.values(schema.getTypeMap())
                    .filter(graphql_1.isObjectType)
                    .flatMap((t) => Object.values(t.getFields())).length +
                    Object.values(schema.getTypeMap())
                        .filter(graphql_1.isInterfaceType)
                        .flatMap((t) => Object.values(t.getFields())).length,
            });
            return undefined;
        },
        async requestDidStart(requestContext) {
            function memoizedCacheAnnotationFromType(t) {
                const existing = typeAnnotationCache.get(t);
                if (existing) {
                    return existing;
                }
                const annotation = cacheAnnotationFromType(t);
                typeAnnotationCache.set(t, annotation);
                return annotation;
            }
            function memoizedCacheAnnotationFromField(field) {
                const existing = fieldAnnotationCache.get(field);
                if (existing) {
                    return existing;
                }
                const annotation = cacheAnnotationFromField(field);
                fieldAnnotationCache.set(field, annotation);
                return annotation;
            }
            const defaultMaxAge = options.defaultMaxAge ?? 0;
            const calculateHttpHeaders = options.calculateHttpHeaders ?? true;
            const { __testing__cacheHints } = options;
            return {
                async executionDidStart() {
                    if (isRestricted(requestContext.overallCachePolicy)) {
                        const fakeFieldPolicy = (0, cachePolicy_js_1.newCachePolicy)();
                        return {
                            willResolveField({ info }) {
                                info.cacheControl = {
                                    setCacheHint: (dynamicHint) => {
                                        fakeFieldPolicy.replace(dynamicHint);
                                    },
                                    cacheHint: fakeFieldPolicy,
                                    cacheHintFromType: memoizedCacheAnnotationFromType,
                                };
                            },
                        };
                    }
                    return {
                        willResolveField({ info }) {
                            const fieldPolicy = (0, cachePolicy_js_1.newCachePolicy)();
                            let inheritMaxAge = false;
                            const targetType = (0, graphql_1.getNamedType)(info.returnType);
                            if ((0, graphql_1.isCompositeType)(targetType)) {
                                const typeAnnotation = memoizedCacheAnnotationFromType(targetType);
                                fieldPolicy.replace(typeAnnotation);
                                inheritMaxAge = !!typeAnnotation.inheritMaxAge;
                            }
                            const fieldAnnotation = memoizedCacheAnnotationFromField(info.parentType.getFields()[info.fieldName]);
                            if (fieldAnnotation.inheritMaxAge &&
                                fieldPolicy.maxAge === undefined) {
                                inheritMaxAge = true;
                                if (fieldAnnotation.scope) {
                                    fieldPolicy.replace({ scope: fieldAnnotation.scope });
                                }
                            }
                            else {
                                fieldPolicy.replace(fieldAnnotation);
                            }
                            info.cacheControl = {
                                setCacheHint: (dynamicHint) => {
                                    fieldPolicy.replace(dynamicHint);
                                },
                                cacheHint: fieldPolicy,
                                cacheHintFromType: memoizedCacheAnnotationFromType,
                            };
                            return () => {
                                if (fieldPolicy.maxAge === undefined &&
                                    (((0, graphql_1.isCompositeType)(targetType) && !inheritMaxAge) ||
                                        !info.path.prev)) {
                                    fieldPolicy.restrict({ maxAge: defaultMaxAge });
                                }
                                if (__testing__cacheHints && isRestricted(fieldPolicy)) {
                                    const path = (0, graphql_1.responsePathAsArray)(info.path).join('.');
                                    if (__testing__cacheHints.has(path)) {
                                        throw Error("shouldn't happen: addHint should only be called once per path");
                                    }
                                    __testing__cacheHints.set(path, {
                                        maxAge: fieldPolicy.maxAge,
                                        scope: fieldPolicy.scope,
                                    });
                                }
                                requestContext.overallCachePolicy.restrict(fieldPolicy);
                            };
                        },
                    };
                },
                async willSendResponse(requestContext) {
                    if (!calculateHttpHeaders) {
                        return;
                    }
                    const { response, overallCachePolicy } = requestContext;
                    const existingCacheControlHeader = parseExistingCacheControlHeader(response.http.headers.get('cache-control'));
                    if (existingCacheControlHeader.kind === 'unparsable') {
                        return;
                    }
                    const cachePolicy = (0, cachePolicy_js_1.newCachePolicy)();
                    cachePolicy.replace(overallCachePolicy);
                    if (existingCacheControlHeader.kind === 'parsable-and-cacheable') {
                        cachePolicy.restrict(existingCacheControlHeader.hint);
                    }
                    const policyIfCacheable = cachePolicy.policyIfCacheable();
                    if (policyIfCacheable &&
                        existingCacheControlHeader.kind !== 'uncacheable' &&
                        response.body.kind === 'single' &&
                        !response.body.singleResult.errors) {
                        response.http.headers.set('cache-control', `max-age=${policyIfCacheable.maxAge}, ${policyIfCacheable.scope.toLowerCase()}`);
                    }
                    else if (calculateHttpHeaders !== 'if-cacheable') {
                        response.http.headers.set('cache-control', CACHE_CONTROL_HEADER_UNCACHEABLE);
                    }
                },
            };
        },
    });
}
exports.ApolloServerPluginCacheControl = ApolloServerPluginCacheControl;
const CACHE_CONTROL_HEADER_CACHEABLE_REGEXP = /^max-age=(\d+), (public|private)$/;
const CACHE_CONTROL_HEADER_UNCACHEABLE = 'no-store';
function parseExistingCacheControlHeader(header) {
    if (!header) {
        return { kind: 'no-header' };
    }
    if (header === CACHE_CONTROL_HEADER_UNCACHEABLE) {
        return { kind: 'uncacheable' };
    }
    const match = CACHE_CONTROL_HEADER_CACHEABLE_REGEXP.exec(header);
    if (!match) {
        return { kind: 'unparsable' };
    }
    return {
        kind: 'parsable-and-cacheable',
        hint: {
            maxAge: +match[1],
            scope: match[2] === 'public' ? 'PUBLIC' : 'PRIVATE',
        },
    };
}
function cacheAnnotationFromDirectives(directives) {
    if (!directives)
        return undefined;
    const cacheControlDirective = directives.find((directive) => directive.name.value === 'cacheControl');
    if (!cacheControlDirective)
        return undefined;
    if (!cacheControlDirective.arguments)
        return undefined;
    const maxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'maxAge');
    const scopeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'scope');
    const inheritMaxAgeArgument = cacheControlDirective.arguments.find((argument) => argument.name.value === 'inheritMaxAge');
    const scopeString = scopeArgument?.value?.kind === 'EnumValue'
        ? scopeArgument.value.value
        : undefined;
    const scope = scopeString === 'PUBLIC' || scopeString === 'PRIVATE'
        ? scopeString
        : undefined;
    if (inheritMaxAgeArgument?.value?.kind === 'BooleanValue' &&
        inheritMaxAgeArgument.value.value) {
        return { inheritMaxAge: true, scope };
    }
    return {
        maxAge: maxAgeArgument?.value?.kind === 'IntValue'
            ? parseInt(maxAgeArgument.value.value)
            : undefined,
        scope,
    };
}
function cacheAnnotationFromType(t) {
    if (t.astNode) {
        const hint = cacheAnnotationFromDirectives(t.astNode.directives);
        if (hint) {
            return hint;
        }
    }
    if (t.extensionASTNodes) {
        for (const node of t.extensionASTNodes) {
            const hint = cacheAnnotationFromDirectives(node.directives);
            if (hint) {
                return hint;
            }
        }
    }
    return {};
}
function cacheAnnotationFromField(field) {
    if (field.astNode) {
        const hint = cacheAnnotationFromDirectives(field.astNode.directives);
        if (hint) {
            return hint;
        }
    }
    return {};
}
function isRestricted(hint) {
    return hint.maxAge !== undefined || hint.scope !== undefined;
}
//# sourceMappingURL=index.js.mapŸ#/dist/esm/externalTypes/http.js.mapƒx{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../src/externalTypes/http.ts"],"names":[],"mappings":""}Ÿ%/dist/cjs/internalErrorClasses.js.map≈	M{"version":3,"file":"internalErrorClasses.js","sourceRoot":"","sources":["../../src/internalErrorClasses.ts"],"names":[],"mappings":"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"}Ÿ)/dist/esm/plugin/drainHttpServer/index.js≈≠import { Stopper } from './stoppable.js';
export function ApolloServerPluginDrainHttpServer(options) {
    const stopper = new Stopper(options.httpServer);
    return {
        async serverWillStart() {
            return {
                async drainServer() {
                    await stopper.stop(options.stopGracePeriodMillis ?? 10000);
                },
            };
        },
    };
}
//# sourceMappingURL=index.js.mapŸ0/dist/esm/externalTypes/requestPipeline.d.ts.map≈
H{"version":3,"file":"requestPipeline.d.ts","sourceRoot":"","sources":["../../../src/externalTypes/requestPipeline.ts"],"names":[],"mappings":"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"}Ÿ,/dist/esm/utils/schemaInstrumentation.js.map≈
{"version":3,"file":"schemaInstrumentation.js","sourceRoot":"","sources":["../../../src/utils/schemaInstrumentation.ts"],"names":[],"mappings":"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"}Ÿ3/dist/esm/plugin/landingPage/default/index.d.ts.map≈ß{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../../src/plugin/landingPage/default/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EACV,kBAAkB,EAEnB,MAAM,iCAAiC,CAAC;AAEzC,OAAO,KAAK,EACV,gDAAgD,EAChD,qDAAqD,EAEtD,MAAM,YAAY,CAAC;AAMpB,YAAY,EACV,gDAAgD,EAChD,qDAAqD,GACtD,CAAC;AAEF,wBAAgB,yCAAyC,CACvD,OAAO,GAAE,gDAAqD,GAC7D,kBAAkB,CAWpB;AAED,wBAAgB,8CAA8C,CAC5D,OAAO,GAAE,qDAA0D,GAClE,kBAAkB,CAOpB"}Ÿ9/dist/esm/utils/makeGatewayGraphQLRequestContext.d.ts.map≈{"version":3,"file":"makeGatewayGraphQLRequestContext.d.ts","sourceRoot":"","sources":["../../../src/utils/makeGatewayGraphQLRequestContext.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAEV,4BAA4B,EAG7B,MAAM,kCAAkC,CAAC;AAE1C,OAAO,KAAK,EAAE,YAAY,EAAE,qBAAqB,EAAE,MAAM,iBAAiB,CAAC;AAC3E,OAAO,KAAK,EACV,WAAW,EACX,sCAAsC,EACvC,MAAM,kBAAkB,CAAC;AAyE1B,wBAAgB,gCAAgC,CAAC,QAAQ,SAAS,WAAW,EAC3E,iBAAiB,EAAE,sCAAsC,CAAC,QAAQ,CAAC,EACnE,MAAM,EAAE,YAAY,CAAC,QAAQ,CAAC,EAC9B,SAAS,EAAE,qBAAqB,CAAC,QAAQ,CAAC,GACzC,4BAA4B,CAqE9B"}ª/dist/esm/runHttpQuery.d.ts≈import type { BaseContext, HTTPGraphQLHead, HTTPGraphQLRequest, HTTPGraphQLResponse } from './externalTypes/index.js';
import { ApolloServer, ApolloServerInternals, SchemaDerivedData } from './ApolloServer.js';
import { FormattedExecutionResult } from 'graphql';
export declare function runHttpQuery<TContext extends BaseContext>({ server, httpRequest, contextValue, schemaDerivedData, internals, sharedResponseHTTPGraphQLHead, }: {
    server: ApolloServer<TContext>;
    httpRequest: HTTPGraphQLRequest;
    contextValue: TContext;
    schemaDerivedData: SchemaDerivedData;
    internals: ApolloServerInternals<TContext>;
    sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;
}): Promise<HTTPGraphQLResponse>;
export declare function prettyJSONStringify(value: FormattedExecutionResult): string;
export declare function newHTTPGraphQLHead(status?: number): HTTPGraphQLHead;
export declare function mergeHTTPGraphQLHead(target: HTTPGraphQLHead, source: HTTPGraphQLHead): void;
//# sourceMappingURL=runHttpQuery.d.ts.mapŸ /dist/esm/utils/invokeHooks.d.ts≈declare type AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;
declare type SyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => void;
export declare function invokeDidStartHook<T, TEndHookArgs extends unknown[]>(targets: T[], hook: (t: T) => Promise<AsyncDidEndHook<TEndHookArgs> | undefined | void>): Promise<AsyncDidEndHook<TEndHookArgs>>;
export declare function invokeSyncDidStartHook<T, TEndHookArgs extends unknown[]>(targets: T[], hook: (t: T) => SyncDidEndHook<TEndHookArgs> | undefined | void): SyncDidEndHook<TEndHookArgs>;
export declare function invokeHooksUntilDefinedAndNonNull<T, TOut>(targets: T[], hook: (t: T) => Promise<TOut | null | undefined>): Promise<TOut | null>;
export {};
//# sourceMappingURL=invokeHooks.d.ts.mapŸ)/dist/cjs/plugin/schemaIsFederated.js.map≈R{"version":3,"file":"schemaIsFederated.js","sourceRoot":"","sources":["../../../src/plugin/schemaIsFederated.ts"],"names":[],"mappings":";;;AAAA,qCAAoE;AAkBpE,SAAgB,iBAAiB,CAAC,MAAqB;IACrD,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAC/C,IAAI,CAAC,IAAA,sBAAY,EAAC,WAAW,CAAC,EAAE;QAC9B,OAAO,KAAK,CAAC;KACd;IACD,MAAM,QAAQ,GAAG,WAAW,CAAC,SAAS,EAAE,CAAC,GAAG,CAAC;IAC7C,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,KAAK,CAAC;KACd;IACD,MAAM,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC;IACnC,IAAI,CAAC,IAAA,sBAAY,EAAC,YAAY,CAAC,EAAE;QAC/B,OAAO,KAAK,CAAC;KACd;IACD,OAAO,YAAY,CAAC,IAAI,IAAI,QAAQ,CAAC;AACvC,CAAC;AAdD,8CAcC"}Ÿ)/dist/cjs/plugin/usageReporting/plugin.js≈fU"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeHTTPRequestHeaders = exports.ApolloServerPluginUsageReporting = void 0;
const usage_reporting_protobuf_1 = require("@apollo/usage-reporting-protobuf");
const utils_usagereporting_1 = require("@apollo/utils.usagereporting");
const async_retry_1 = __importDefault(require("async-retry"));
const graphql_1 = require("graphql");
const node_abort_controller_1 = require("node-abort-controller");
const node_fetch_1 = __importDefault(require("node-fetch"));
const os_1 = __importDefault(require("os"));
const util_1 = require("util");
const zlib_1 = require("zlib");
const internalPlugin_js_1 = require("../../internalPlugin.js");
const traceTreeBuilder_js_1 = require("../traceTreeBuilder.js");
const defaultSendOperationsAsTrace_js_1 = require("./defaultSendOperationsAsTrace.js");
const operationDerivedDataCache_js_1 = require("./operationDerivedDataCache.js");
const stats_js_1 = require("./stats.js");
const traceDetails_js_1 = require("./traceDetails.js");
const packageVersion_js_1 = require("../../generated/packageVersion.js");
const computeCoreSchemaHash_js_1 = require("../../utils/computeCoreSchemaHash.js");
const gzipPromise = (0, util_1.promisify)(zlib_1.gzip);
const reportHeaderDefaults = {
    hostname: os_1.default.hostname(),
    agentVersion: `@apollo/server@${packageVersion_js_1.packageVersion}`,
    runtimeVersion: `node ${process.version}`,
    uname: `${os_1.default.platform()}, ${os_1.default.type()}, ${os_1.default.release()}, ${os_1.default.arch()})`,
};
function ApolloServerPluginUsageReporting(options = Object.create(null)) {
    const fieldLevelInstrumentationOption = options.fieldLevelInstrumentation;
    const fieldLevelInstrumentation = typeof fieldLevelInstrumentationOption === 'number'
        ? async () => Math.random() < fieldLevelInstrumentationOption
            ? 1 / fieldLevelInstrumentationOption
            : 0
        : fieldLevelInstrumentationOption
            ? fieldLevelInstrumentationOption
            : async () => true;
    let requestDidStartHandler;
    return (0, internalPlugin_js_1.internalPlugin)({
        __internal_plugin_id__: 'UsageReporting',
        __is_disabled_plugin__: false,
        async requestDidStart(requestContext) {
            if (!requestDidStartHandler) {
                throw Error('The usage reporting plugin has been asked to handle a request before the ' +
                    'server has started. See https://github.com/apollographql/apollo-server/issues/4588 ' +
                    'for more details.');
            }
            return requestDidStartHandler(requestContext);
        },
        async serverWillStart({ logger: serverLogger, apollo, startedInBackground, }) {
            const logger = options.logger ?? serverLogger;
            const { key, graphRef } = apollo;
            if (!(key && graphRef)) {
                throw new Error("You've enabled usage reporting via ApolloServerPluginUsageReporting, " +
                    'but you also need to provide your Apollo API key and graph ref, via ' +
                    'the APOLLO_KEY/APOLLO_GRAPH_REF environment ' +
                    'variables or via `new ApolloServer({apollo: {key, graphRef})`.');
            }
            logger.info('Apollo usage reporting starting! See your graph at ' +
                `https://studio.apollographql.com/graph/${encodeURI(graphRef)}/`);
            const sendReportsImmediately = options.sendReportsImmediately ?? startedInBackground;
            let operationDerivedDataCache = null;
            const reportByExecutableSchemaId = new Map();
            const getReportWhichMustBeUsedImmediately = (executableSchemaId) => {
                const existing = reportByExecutableSchemaId.get(executableSchemaId);
                if (existing) {
                    return existing;
                }
                const report = new stats_js_1.OurReport(new usage_reporting_protobuf_1.ReportHeader({
                    ...reportHeaderDefaults,
                    executableSchemaId,
                    graphRef,
                }));
                reportByExecutableSchemaId.set(executableSchemaId, report);
                return report;
            };
            const getAndDeleteReport = (executableSchemaId) => {
                const report = reportByExecutableSchemaId.get(executableSchemaId);
                if (report) {
                    reportByExecutableSchemaId.delete(executableSchemaId);
                    return report;
                }
                return null;
            };
            const overriddenExecutableSchemaId = options.overrideReportedSchema
                ? (0, computeCoreSchemaHash_js_1.computeCoreSchemaHash)(options.overrideReportedSchema)
                : undefined;
            let lastSeenExecutableSchemaToId;
            let reportTimer;
            if (!sendReportsImmediately) {
                reportTimer = setInterval(() => sendAllReportsAndReportErrors(), options.reportIntervalMs || 10 * 1000);
            }
            let sendTraces = options.sendTraces ?? true;
            const sendOperationAsTrace = options.experimental_sendOperationAsTrace ??
                (0, defaultSendOperationsAsTrace_js_1.defaultSendOperationsAsTrace)();
            let stopped = false;
            function executableSchemaIdForSchema(schema) {
                if (lastSeenExecutableSchemaToId?.executableSchema === schema) {
                    return lastSeenExecutableSchemaToId.executableSchemaId;
                }
                const id = (0, computeCoreSchemaHash_js_1.computeCoreSchemaHash)((0, graphql_1.printSchema)(schema));
                lastSeenExecutableSchemaToId = {
                    executableSchema: schema,
                    executableSchemaId: id,
                };
                return id;
            }
            async function sendAllReportsAndReportErrors() {
                await Promise.all([...reportByExecutableSchemaId.keys()].map((executableSchemaId) => sendReportAndReportErrors(executableSchemaId)));
            }
            async function sendReportAndReportErrors(executableSchemaId) {
                return sendReport(executableSchemaId).catch((err) => {
                    if (options.reportErrorFunction) {
                        options.reportErrorFunction(err);
                    }
                    else {
                        logger.error(err.message);
                    }
                });
            }
            const sendReport = async (executableSchemaId) => {
                let report = getAndDeleteReport(executableSchemaId);
                if (!report ||
                    (Object.keys(report.tracesPerQuery).length === 0 &&
                        report.operationCount === 0)) {
                    return;
                }
                report.endTime = (0, traceTreeBuilder_js_1.dateToProtoTimestamp)(new Date());
                report.ensureCountsAreIntegers();
                const protobufError = usage_reporting_protobuf_1.Report.verify(report);
                if (protobufError) {
                    throw new Error(`Error verifying report: ${protobufError}`);
                }
                let message = usage_reporting_protobuf_1.Report.encode(report).finish();
                report = null;
                if (options.debugPrintReports) {
                    const decodedReport = usage_reporting_protobuf_1.Report.decode(message);
                    logger.info(`Apollo usage report: ${JSON.stringify(decodedReport.toJSON())}`);
                }
                const compressed = await gzipPromise(message);
                message = null;
                const fetcher = options.fetcher ?? node_fetch_1.default;
                const response = await (0, async_retry_1.default)(async () => {
                    const controller = new node_abort_controller_1.AbortController();
                    const abortTimeout = setTimeout(() => {
                        controller.abort();
                    }, options.requestTimeoutMs ?? 30000);
                    let curResponse;
                    try {
                        curResponse = await fetcher((options.endpointUrl ||
                            'https://usage-reporting.api.apollographql.com') +
                            '/api/ingress/traces', {
                            method: 'POST',
                            headers: {
                                'user-agent': 'ApolloServerPluginUsageReporting',
                                'x-api-key': key,
                                'content-encoding': 'gzip',
                                accept: 'application/json',
                            },
                            body: compressed,
                            signal: controller.signal,
                        });
                    }
                    finally {
                        clearTimeout(abortTimeout);
                    }
                    if (curResponse.status >= 500 && curResponse.status < 600) {
                        throw new Error(`HTTP status ${curResponse.status}, ${(await curResponse.text()) || '(no body)'}`);
                    }
                    else {
                        return curResponse;
                    }
                }, {
                    retries: (options.maxAttempts || 5) - 1,
                    minTimeout: options.minimumRetryDelayMs || 100,
                    factor: 2,
                }).catch((err) => {
                    throw new Error(`Error sending report to Apollo servers: ${err.message}`);
                });
                if (response.status < 200 || response.status >= 300) {
                    throw new Error(`Error sending report to Apollo servers: HTTP status ${response.status}, ${(await response.text()) || '(no body)'}`);
                }
                if (sendTraces &&
                    response.status === 200 &&
                    response.headers
                        .get('content-type')
                        ?.match(/^\s*application\/json\s*(?:;|$)/i)) {
                    const body = await response.text();
                    let parsedBody;
                    try {
                        parsedBody = JSON.parse(body);
                    }
                    catch (e) {
                        throw new Error(`Error parsing response from Apollo servers: ${e}`);
                    }
                    if (parsedBody.tracesIgnored === true) {
                        logger.debug("This graph's organization does not have access to traces; sending all " +
                            'subsequent operations as stats.');
                        sendTraces = false;
                    }
                }
                if (options.debugPrintReports) {
                    logger.info(`Apollo usage report: status ${response.status}`);
                }
            };
            requestDidStartHandler = ({ metrics, schema, request: { http, variables }, }) => {
                const treeBuilder = new traceTreeBuilder_js_1.TraceTreeBuilder({
                    maskedBy: 'ApolloServerPluginUsageReporting',
                    sendErrors: options.sendErrors,
                    logger,
                });
                treeBuilder.startTiming();
                metrics.startHrTime = treeBuilder.startHrTime;
                let graphqlValidationFailure = false;
                let graphqlUnknownOperationName = false;
                let includeOperationInUsageReporting = null;
                if (http) {
                    treeBuilder.trace.http = new usage_reporting_protobuf_1.Trace.HTTP({
                        method: usage_reporting_protobuf_1.Trace.HTTP.Method[http.method] || usage_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN,
                        host: null,
                        path: null,
                    });
                    if (options.sendHeaders) {
                        makeHTTPRequestHeaders(treeBuilder.trace.http, http.headers, options.sendHeaders);
                    }
                }
                async function maybeCallIncludeRequestHook(requestContext) {
                    if (includeOperationInUsageReporting !== null)
                        return;
                    if (typeof options.includeRequest !== 'function') {
                        includeOperationInUsageReporting = true;
                        return;
                    }
                    includeOperationInUsageReporting = await options.includeRequest(requestContext);
                    if (typeof includeOperationInUsageReporting !== 'boolean') {
                        logger.warn("The 'includeRequest' async predicate function must return a boolean value.");
                        includeOperationInUsageReporting = true;
                    }
                }
                let didResolveSource = false;
                return {
                    async didResolveSource(requestContext) {
                        didResolveSource = true;
                        if (metrics.persistedQueryHit) {
                            treeBuilder.trace.persistedQueryHit = true;
                        }
                        if (metrics.persistedQueryRegister) {
                            treeBuilder.trace.persistedQueryRegister = true;
                        }
                        if (variables) {
                            treeBuilder.trace.details = (0, traceDetails_js_1.makeTraceDetails)(variables, options.sendVariableValues, requestContext.source);
                        }
                        const clientInfo = (options.generateClientInfo || defaultGenerateClientInfo)(requestContext);
                        if (clientInfo) {
                            const { clientName, clientVersion } = clientInfo;
                            treeBuilder.trace.clientVersion = clientVersion || '';
                            treeBuilder.trace.clientName = clientName || '';
                        }
                    },
                    async validationDidStart() {
                        return async (validationErrors) => {
                            graphqlValidationFailure = validationErrors
                                ? validationErrors.length !== 0
                                : false;
                        };
                    },
                    async didResolveOperation(requestContext) {
                        graphqlUnknownOperationName =
                            requestContext.operation === undefined;
                        await maybeCallIncludeRequestHook(requestContext);
                        if (includeOperationInUsageReporting &&
                            !graphqlUnknownOperationName) {
                            if (metrics.captureTraces === undefined) {
                                const rawWeight = await fieldLevelInstrumentation(requestContext);
                                treeBuilder.trace.fieldExecutionWeight =
                                    typeof rawWeight === 'number' ? rawWeight : rawWeight ? 1 : 0;
                                metrics.captureTraces =
                                    !!treeBuilder.trace.fieldExecutionWeight;
                            }
                        }
                    },
                    async executionDidStart() {
                        if (!metrics.captureTraces)
                            return;
                        return {
                            willResolveField({ info }) {
                                return treeBuilder.willResolveField(info);
                            },
                        };
                    },
                    async didEncounterSubsequentErrors(_requestContext, errors) {
                        treeBuilder.didEncounterErrors(errors);
                    },
                    async willSendSubsequentPayload(requestContext, payload) {
                        if (!payload.hasNext) {
                            await operationFinished(requestContext);
                        }
                    },
                    async willSendResponse(requestContext) {
                        if (!didResolveSource)
                            return;
                        if (requestContext.errors) {
                            treeBuilder.didEncounterErrors(requestContext.errors);
                        }
                        if (requestContext.response.body.kind === 'single') {
                            await operationFinished(requestContext);
                        }
                    },
                };
                async function operationFinished(requestContext) {
                    const resolvedOperation = !!requestContext.operation;
                    await maybeCallIncludeRequestHook(requestContext);
                    treeBuilder.stopTiming();
                    const executableSchemaId = overriddenExecutableSchemaId ?? executableSchemaIdForSchema(schema);
                    if (includeOperationInUsageReporting === false) {
                        if (resolvedOperation) {
                            getReportWhichMustBeUsedImmediately(executableSchemaId)
                                .operationCount++;
                        }
                        return;
                    }
                    treeBuilder.trace.fullQueryCacheHit = !!metrics.responseCacheHit;
                    treeBuilder.trace.forbiddenOperation = !!metrics.forbiddenOperation;
                    treeBuilder.trace.registeredOperation = !!metrics.registeredOperation;
                    const policyIfCacheable = requestContext.overallCachePolicy.policyIfCacheable();
                    if (policyIfCacheable) {
                        treeBuilder.trace.cachePolicy = new usage_reporting_protobuf_1.Trace.CachePolicy({
                            scope: policyIfCacheable.scope === 'PRIVATE'
                                ? usage_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE
                                : policyIfCacheable.scope === 'PUBLIC'
                                    ? usage_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC
                                    : usage_reporting_protobuf_1.Trace.CachePolicy.Scope.UNKNOWN,
                            maxAgeNs: policyIfCacheable.maxAge * 1e9,
                        });
                    }
                    if (metrics.queryPlanTrace) {
                        treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                    }
                    addTrace().catch(logger.error);
                    async function addTrace() {
                        if (stopped) {
                            return;
                        }
                        await new Promise((res) => setImmediate(res));
                        const executableSchemaId = overriddenExecutableSchemaId ??
                            executableSchemaIdForSchema(schema);
                        const { trace } = treeBuilder;
                        let statsReportKey = undefined;
                        let referencedFieldsByType;
                        if (!requestContext.document) {
                            statsReportKey = `## GraphQLParseFailure\n`;
                        }
                        else if (graphqlValidationFailure) {
                            statsReportKey = `## GraphQLValidationFailure\n`;
                        }
                        else if (graphqlUnknownOperationName) {
                            statsReportKey = `## GraphQLUnknownOperationName\n`;
                        }
                        const isExecutable = statsReportKey === undefined;
                        if (statsReportKey) {
                            if (options.sendUnexecutableOperationDocuments) {
                                trace.unexecutedOperationBody = requestContext.source;
                                trace.unexecutedOperationName =
                                    requestContext.request.operationName || '';
                            }
                            referencedFieldsByType = Object.create(null);
                        }
                        else {
                            const operationDerivedData = getOperationDerivedData();
                            statsReportKey = `# ${requestContext.operationName || '-'}\n${operationDerivedData.signature}`;
                            referencedFieldsByType =
                                operationDerivedData.referencedFieldsByType;
                        }
                        const protobufError = usage_reporting_protobuf_1.Trace.verify(trace);
                        if (protobufError) {
                            throw new Error(`Error encoding trace: ${protobufError}`);
                        }
                        if (resolvedOperation) {
                            getReportWhichMustBeUsedImmediately(executableSchemaId)
                                .operationCount++;
                        }
                        getReportWhichMustBeUsedImmediately(executableSchemaId).addTrace({
                            statsReportKey,
                            trace,
                            asTrace: sendTraces &&
                                (!isExecutable || !!metrics.captureTraces) &&
                                sendOperationAsTrace(trace, statsReportKey),
                            referencedFieldsByType,
                        });
                        if (sendReportsImmediately ||
                            getReportWhichMustBeUsedImmediately(executableSchemaId)
                                .sizeEstimator.bytes >=
                                (options.maxUncompressedReportSize || 4 * 1024 * 1024)) {
                            await sendReportAndReportErrors(executableSchemaId);
                        }
                    }
                    function getOperationDerivedData() {
                        if (!requestContext.document) {
                            throw new Error('No document?');
                        }
                        const cacheKey = (0, operationDerivedDataCache_js_1.operationDerivedDataCacheKey)(requestContext.queryHash, requestContext.operationName || '');
                        if (!operationDerivedDataCache ||
                            operationDerivedDataCache.forSchema !== schema) {
                            operationDerivedDataCache = {
                                forSchema: schema,
                                cache: (0, operationDerivedDataCache_js_1.createOperationDerivedDataCache)({ logger }),
                            };
                        }
                        const cachedOperationDerivedData = operationDerivedDataCache.cache.get(cacheKey);
                        if (cachedOperationDerivedData) {
                            return cachedOperationDerivedData;
                        }
                        const generatedSignature = (options.calculateSignature || utils_usagereporting_1.usageReportingSignature)(requestContext.document, requestContext.operationName || '');
                        const generatedOperationDerivedData = {
                            signature: generatedSignature,
                            referencedFieldsByType: (0, utils_usagereporting_1.calculateReferencedFieldsByType)({
                                document: requestContext.document,
                                schema,
                                resolvedOperationName: requestContext.operationName ?? null,
                            }),
                        };
                        operationDerivedDataCache.cache.set(cacheKey, generatedOperationDerivedData);
                        return generatedOperationDerivedData;
                    }
                }
            };
            return {
                async serverWillStop() {
                    if (reportTimer) {
                        clearInterval(reportTimer);
                        reportTimer = undefined;
                    }
                    stopped = true;
                    await sendAllReportsAndReportErrors();
                },
            };
        },
    });
}
exports.ApolloServerPluginUsageReporting = ApolloServerPluginUsageReporting;
function makeHTTPRequestHeaders(http, headers, sendHeaders) {
    if (!sendHeaders ||
        ('none' in sendHeaders && sendHeaders.none) ||
        ('all' in sendHeaders && !sendHeaders.all)) {
        return;
    }
    for (const [key, value] of headers) {
        if (('exceptNames' in sendHeaders &&
            sendHeaders.exceptNames.some((exceptHeader) => {
                return exceptHeader.toLowerCase() === key;
            })) ||
            ('onlyNames' in sendHeaders &&
                !sendHeaders.onlyNames.some((header) => {
                    return header.toLowerCase() === key;
                }))) {
            continue;
        }
        switch (key) {
            case 'authorization':
            case 'cookie':
            case 'set-cookie':
                break;
            default:
                http.requestHeaders[key] = new usage_reporting_protobuf_1.Trace.HTTP.Values({
                    value: [value],
                });
        }
    }
}
exports.makeHTTPRequestHeaders = makeHTTPRequestHeaders;
function defaultGenerateClientInfo({ request, }) {
    const clientNameHeaderKey = 'apollographql-client-name';
    const clientVersionHeaderKey = 'apollographql-client-version';
    if (request.http?.headers?.get(clientNameHeaderKey) ||
        request.http?.headers?.get(clientVersionHeaderKey)) {
        return {
            clientName: request.http?.headers?.get(clientNameHeaderKey),
            clientVersion: request.http?.headers?.get(clientVersionHeaderKey),
        };
    }
    else if (request.extensions?.clientInfo) {
        return request.extensions.clientInfo;
    }
    else {
        return {};
    }
}
//# sourceMappingURL=plugin.js.mapŸ3/dist/esm/plugin/usageReporting/traceDetails.js.map≈Ê{"version":3,"file":"traceDetails.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/traceDetails.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,kCAAkC,CAAC;AAUzD,MAAM,UAAU,gBAAgB,CAC9B,SAA8B,EAC9B,kBAAyC,EACzC,eAAwB;IAExB,MAAM,OAAO,GAAG,IAAI,KAAK,CAAC,OAAO,EAAE,CAAC;IACpC,MAAM,iBAAiB,GAAG,CAAC,GAAG,EAAE;QAC9B,IAAI,kBAAkB,IAAI,WAAW,IAAI,kBAAkB,EAAE;YAC3D,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC5C,IAAI;gBAEF,MAAM,iBAAiB,GAAG,kBAAkB,CAAC,SAAS,CAAC;oBACrD,SAAS,EAAE,SAAS;oBACpB,eAAe,EAAE,eAAe;iBACjC,CAAC,CAAC;gBACH,OAAO,sBAAsB,CAAC,YAAY,EAAE,iBAAiB,CAAC,CAAC;aAChE;YAAC,OAAO,CAAC,EAAE;gBAGV,OAAO,iCAAiC,CAAC,YAAY,CAAC,CAAC;aACxD;SACF;aAAM;YACL,OAAO,SAAS,CAAC;SAClB;IACH,CAAC,CAAC,EAAE,CAAC;IAOL,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC9C,IACE,CAAC,kBAAkB;YACnB,CAAC,MAAM,IAAI,kBAAkB,IAAI,kBAAkB,CAAC,IAAI,CAAC;YACzD,CAAC,KAAK,IAAI,kBAAkB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;YACxD,CAAC,aAAa,IAAI,kBAAkB;gBAIlC,kBAAkB,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YAChD,CAAC,WAAW,IAAI,kBAAkB;gBAChC,CAAC,kBAAkB,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,EAC/C;YAIA,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;SACnC;aAAM;YACL,IAAI;gBACF,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC;oBAC1B,OAAO,iBAAiB,CAAC,IAAI,CAAC,KAAK,WAAW;wBAC5C,CAAC,CAAC,EAAE;wBACJ,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;aAC/C;YAAC,OAAO,CAAC,EAAE;gBACV,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAC3C,mCAAmC,CACpC,CAAC;aACH;SACF;IACH,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,SAAS,iCAAiC,CACxC,aAAuB;IAEvB,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC9C,aAAa,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC7B,iBAAiB,CAAC,IAAI,CAAC,GAAG,4BAA4B,CAAC;IACzD,CAAC,CAAC,CAAC;IACH,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAID,SAAS,sBAAsB,CAC7B,YAA2B,EAC3B,iBAAsC;IAEtC,MAAM,gBAAgB,GAAwB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAClE,YAAY,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC5B,gBAAgB,CAAC,IAAI,CAAC,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC;IACH,OAAO,gBAAgB,CAAC;AAC1B,CAAC"}º/src/internalErrorClasses.ts≈Ûimport { GraphQLError, GraphQLErrorOptions } from 'graphql';
import { ApolloServerErrorCode } from './errors/index.js';
import { newHTTPGraphQLHead } from './runHttpQuery.js';
import { HeaderMap } from './utils/HeaderMap.js';

// These error classes are not part of Apollo Server's external API; the
// ApolloServerErrorCode enum is (exported from `@apollo/server/errors`).

class GraphQLErrorWithCode extends GraphQLError {
  constructor(
    message: string,
    code: ApolloServerErrorCode,
    options?: GraphQLErrorOptions,
  ) {
    super(message, {
      ...options,
      extensions: { ...options?.extensions, code },
    });
    this.name = this.constructor.name;
  }
}

export class SyntaxError extends GraphQLErrorWithCode {
  constructor(graphqlError: GraphQLError) {
    super(graphqlError.message, ApolloServerErrorCode.GRAPHQL_PARSE_FAILED, {
      source: graphqlError.source,
      positions: graphqlError.positions,
      extensions: { http: newHTTPGraphQLHead(400), ...graphqlError.extensions },
      originalError: graphqlError,
    });
  }
}

export class ValidationError extends GraphQLErrorWithCode {
  constructor(graphqlError: GraphQLError) {
    super(
      graphqlError.message,
      ApolloServerErrorCode.GRAPHQL_VALIDATION_FAILED,
      {
        nodes: graphqlError.nodes,
        extensions: {
          http: newHTTPGraphQLHead(400),
          ...graphqlError.extensions,
        },
        originalError: graphqlError.originalError ?? graphqlError,
      },
    );
  }
}

// Persisted query errors (especially "not found") need to be uncached, because
// hopefully we're about to fill in the APQ cache and the same request will
// succeed next time. We also want a 200 response to avoid any error handling
// that may mask the contents of an error response. (Otherwise, the default
// status code for a response with `errors` but no `data` (even null) is 400.)
const getPersistedQueryErrorHttp = () => ({
  status: 200,
  headers: new HeaderMap([
    ['cache-control', 'private, no-cache, must-revalidate'],
  ]),
});

export class PersistedQueryNotFoundError extends GraphQLErrorWithCode {
  constructor() {
    super(
      'PersistedQueryNotFound',
      ApolloServerErrorCode.PERSISTED_QUERY_NOT_FOUND,
      { extensions: { http: getPersistedQueryErrorHttp() } },
    );
  }
}

export class PersistedQueryNotSupportedError extends GraphQLErrorWithCode {
  constructor() {
    super(
      'PersistedQueryNotSupported',
      ApolloServerErrorCode.PERSISTED_QUERY_NOT_SUPPORTED,
      // Not super clear why we need this to be uncached (makes sense for
      // PersistedQueryNotFoundError, because there we're about to fill the
      // cache and make the next copy of the same request succeed) but we've
      // been doing it for years so :shrug:
      { extensions: { http: getPersistedQueryErrorHttp() } },
    );
  }
}

export class UserInputError extends GraphQLErrorWithCode {
  constructor(graphqlError: GraphQLError) {
    super(graphqlError.message, ApolloServerErrorCode.BAD_USER_INPUT, {
      nodes: graphqlError.nodes,
      originalError: graphqlError.originalError ?? graphqlError,
      extensions: graphqlError.extensions,
    });
  }
}

export class OperationResolutionError extends GraphQLErrorWithCode {
  constructor(graphqlError: GraphQLError) {
    super(
      graphqlError.message,
      ApolloServerErrorCode.OPERATION_RESOLUTION_FAILURE,
      {
        nodes: graphqlError.nodes,
        originalError: graphqlError.originalError ?? graphqlError,
        extensions: {
          http: newHTTPGraphQLHead(400),
          ...graphqlError.extensions,
        },
      },
    );
  }
}

export class BadRequestError extends GraphQLErrorWithCode {
  constructor(message: string, options?: GraphQLErrorOptions) {
    super(message, ApolloServerErrorCode.BAD_REQUEST, {
      ...options,
      // Default to 400 status code, but caller can override. (If caller just
      // wants to override headers... well, they can't, sorry.)
      extensions: { http: newHTTPGraphQLHead(400), ...options?.extensions },
    });
  }
}
Ÿ+/dist/esm/plugin/inlineTrace/index.d.ts.map≈Ñ{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/plugin/inlineTrace/index.ts"],"names":[],"mappings":"AAEA,OAAO,KAAK,EAAE,iBAAiB,EAAE,MAAM,4BAA4B,CAAC;AAGpE,OAAO,KAAK,EAAE,kBAAkB,EAAE,MAAM,8BAA8B,CAAC;AAEvE,MAAM,WAAW,oCAAoC;IAoBnD,aAAa,CAAC,EAAE,iBAAiB,CAAC;IAWlC,yBAAyB,CAAC,EAAE,OAAO,CAAC;CACrC;AAOD,wBAAgB,6BAA6B,CAC3C,OAAO,GAAE,oCAA0D,GAClE,kBAAkB,CA4GpB"}ø/dist/cjs/externalTypes/http.jsƒm"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=http.js.mapŸ,/dist/cjs/utils/schemaInstrumentation.js.map≈	„{"version":3,"file":"schemaInstrumentation.js","sourceRoot":"","sources":["../../../src/utils/schemaInstrumentation.ts"],"names":[],"mappings":";;;AAAA,qCAOiB;AAMJ,QAAA,yCAAyC,GAAG,MAAM,CAC7D,iDAAiD,CAClD,CAAC;AACW,QAAA,uBAAuB,GAAG,MAAM,CAAC,+BAA+B,CAAC,CAAC;AAC/E,MAAM,oBAAoB,GAAG,MAAM,CAAC,4BAA4B,CAAC,CAAC;AAElE,SAAgB,+BAA+B,CAC7C,MAA4D;IAE5D,IAAI,gCAAgC,CAAC,MAAM,CAAC,EAAE;QAC5C,OAAO,MAAM,CAAC;KACf;IACD,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,oBAAoB,EAAE;QAClD,KAAK,EAAE,IAAI;KACZ,CAAC,CAAC;IAEH,MAAM,OAAO,GAAG,MAAM,CAAC,UAAU,EAAE,CAAC;IACpC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACtC,IACE,CAAC,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YACzC,IAAI,YAAY,2BAAiB,EACjC;YACA,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;YAChC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;gBACtC,SAAS,CAAW,KAAK,CAAC,CAAC;YAC7B,CAAC,CAAC,CAAC;SACJ;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;AAChB,CAAC;AAxBD,0EAwBC;AAED,SAAgB,gCAAgC,CAC9C,MAA4D;IAE5D,OAAO,CAAC,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC;AACxC,CAAC;AAJD,4EAIC;AAED,SAAS,SAAS,CAChB,KAA6B;IAE7B,MAAM,oBAAoB,GAAG,KAAK,CAAC,OAAO,CAAC;IAE3C,KAAK,CAAC,OAAO,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,EAAE,EAAE;QACnD,MAAM,gBAAgB,GAAG,YAAY,EAAE,CACrC,iDAAyC,CAG9B,CAAC;QAEd,MAAM,iBAAiB,GAAG,YAAY,EAAE,CAAC,+BAAuB,CAEnD,CAAC;QAQd,MAAM,eAAe,GACnB,OAAO,gBAAgB,KAAK,UAAU;YACtC,gBAAgB,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;QAEzD,MAAM,aAAa,GACjB,oBAAoB,IAAI,iBAAiB,IAAI,8BAAoB,CAAC;QAEpE,IAAI;YACF,MAAM,MAAM,GAAG,aAAa,CAAC,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;YAK/D,IAAI,OAAO,eAAe,KAAK,UAAU,EAAE;gBACzC,oBAAoB,CAAC,MAAM,EAAE,eAAe,CAAC,CAAC;aAC/C;YACD,OAAO,MAAM,CAAC;SACf;QAAC,OAAO,KAAK,EAAE;YAId,IAAI,OAAO,eAAe,KAAK,UAAU,EAAE;gBACzC,eAAe,CAAC,KAAc,CAAC,CAAC;aACjC;YACD,MAAM,KAAK,CAAC;SACb;IACH,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,SAAS,CAAC,CAAM;IACvB,OAAO,CAAC,IAAI,OAAO,CAAC,CAAC,IAAI,KAAK,UAAU,CAAC;AAC3C,CAAC;AAKD,SAAgB,oBAAoB,CAClC,MAAW,EACX,QAAmD;IAEnD,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;QACrB,MAAM,CAAC,IAAI,CACT,CAAC,CAAM,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,EAC7B,CAAC,GAAU,EAAE,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAC9B,CAAC;KACH;SAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QAChC,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;YAC1B,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,IAAI,CACtB,CAAC,CAAM,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,EAC7B,CAAC,GAAU,EAAE,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAC9B,CAAC;SACH;aAAM;YACL,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;SACxB;KACF;SAAM;QACL,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;KACxB;AACH,CAAC;AArBD,oDAqBC"}Ÿ</dist/esm/externalTypes/incrementalDeliveryPolyfill.d.ts.map≈Ë{"version":3,"file":"incrementalDeliveryPolyfill.d.ts","sourceRoot":"","sources":["../../../src/externalTypes/incrementalDeliveryPolyfill.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,EAAE,wBAAwB,EAAE,qBAAqB,EAAE,MAAM,SAAS,CAAC;AAS/E,UAAU,MAAM,CAAC,CAAC;IAChB,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,CAAC;CAClB;AAED,MAAM,WAAW,6DAA6D,CAC5E,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,CAC7B,SAAQ,wBAAwB,CAAC,KAAK,EAAE,WAAW,CAAC;IACpD,OAAO,EAAE,OAAO,CAAC;IACjB,WAAW,CAAC,EAAE,aAAa,CACzB,6CAA6C,CAAC,KAAK,EAAE,WAAW,CAAC,CAClE,CAAC;IACF,UAAU,CAAC,EAAE,WAAW,CAAC;CAC1B;AAED,MAAM,WAAW,gEAAgE,CAC/E,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC;IAE7B,OAAO,EAAE,OAAO,CAAC;IACjB,WAAW,CAAC,EAAE,aAAa,CACzB,6CAA6C,CAAC,KAAK,EAAE,WAAW,CAAC,CAClE,CAAC;IACF,UAAU,CAAC,EAAE,WAAW,CAAC;CAC1B;AAED,oBAAY,6CAA6C,CACvD,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,IAE3B,kDAAkD,CAAC,KAAK,EAAE,WAAW,CAAC,GACtE,mDAAmD,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;AAE5E,MAAM,WAAW,kDAAkD,CACjE,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,EACvB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,CAC7B,SAAQ,wBAAwB,CAAC,KAAK,EAAE,WAAW,CAAC;IACpD,IAAI,CAAC,EAAE,aAAa,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACtC,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB;AAED,MAAM,WAAW,mDAAmD,CAClE,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,EACtB,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC;IAE7B,MAAM,CAAC,EAAE,aAAa,CAAC,qBAAqB,CAAC,CAAC;IAC9C,KAAK,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC;IACrB,IAAI,CAAC,EAAE,aAAa,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC;IACtC,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,UAAU,CAAC,EAAE,WAAW,CAAC;CAC1B"}Ÿ(/dist/cjs/utils/schemaInstrumentation.js≈"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.whenResultIsFinished = exports.pluginsEnabledForSchemaResolvers = exports.enablePluginsForSchemaResolvers = exports.symbolUserFieldResolver = exports.symbolExecutionDispatcherWillResolveField = void 0;
const graphql_1 = require("graphql");
exports.symbolExecutionDispatcherWillResolveField = Symbol('apolloServerExecutionDispatcherWillResolveField');
exports.symbolUserFieldResolver = Symbol('apolloServerUserFieldResolver');
const symbolPluginsEnabled = Symbol('apolloServerPluginsEnabled');
function enablePluginsForSchemaResolvers(schema) {
    if (pluginsEnabledForSchemaResolvers(schema)) {
        return schema;
    }
    Object.defineProperty(schema, symbolPluginsEnabled, {
        value: true,
    });
    const typeMap = schema.getTypeMap();
    Object.values(typeMap).forEach((type) => {
        if (!(0, graphql_1.getNamedType)(type).name.startsWith('__') &&
            type instanceof graphql_1.GraphQLObjectType) {
            const fields = type.getFields();
            Object.values(fields).forEach((field) => {
                wrapField(field);
            });
        }
    });
    return schema;
}
exports.enablePluginsForSchemaResolvers = enablePluginsForSchemaResolvers;
function pluginsEnabledForSchemaResolvers(schema) {
    return !!schema[symbolPluginsEnabled];
}
exports.pluginsEnabledForSchemaResolvers = pluginsEnabledForSchemaResolvers;
function wrapField(field) {
    const originalFieldResolve = field.resolve;
    field.resolve = (source, args, contextValue, info) => {
        const willResolveField = contextValue?.[exports.symbolExecutionDispatcherWillResolveField];
        const userFieldResolver = contextValue?.[exports.symbolUserFieldResolver];
        const didResolveField = typeof willResolveField === 'function' &&
            willResolveField({ source, args, contextValue, info });
        const fieldResolver = originalFieldResolve || userFieldResolver || graphql_1.defaultFieldResolver;
        try {
            const result = fieldResolver(source, args, contextValue, info);
            if (typeof didResolveField === 'function') {
                whenResultIsFinished(result, didResolveField);
            }
            return result;
        }
        catch (error) {
            if (typeof didResolveField === 'function') {
                didResolveField(error);
            }
            throw error;
        }
    };
}
function isPromise(x) {
    return x && typeof x.then === 'function';
}
function whenResultIsFinished(result, callback) {
    if (isPromise(result)) {
        result.then((r) => callback(null, r), (err) => callback(err));
    }
    else if (Array.isArray(result)) {
        if (result.some(isPromise)) {
            Promise.all(result).then((r) => callback(null, r), (err) => callback(err));
        }
        else {
            callback(null, result);
        }
    }
    else {
        callback(null, result);
    }
}
exports.whenResultIsFinished = whenResultIsFinished;
//# sourceMappingURL=schemaInstrumentation.js.mapŸ%/dist/esm/plugin/inlineTrace/index.js≈÷import { Trace } from '@apollo/usage-reporting-protobuf';
import { TraceTreeBuilder } from '../traceTreeBuilder.js';
import { internalPlugin } from '../../internalPlugin.js';
import { schemaIsFederated } from '../schemaIsFederated.js';
export function ApolloServerPluginInlineTrace(options = Object.create(null)) {
    let enabled = options.__onlyIfSchemaIsFederated ? null : true;
    return internalPlugin({
        __internal_plugin_id__: 'InlineTrace',
        __is_disabled_plugin__: false,
        async serverWillStart({ schema, logger }) {
            if (enabled === null) {
                enabled = schemaIsFederated(schema);
                if (enabled) {
                    logger.info('Enabling inline tracing for this federated service. To disable, use ' +
                        'ApolloServerPluginInlineTraceDisabled.');
                }
            }
        },
        async requestDidStart({ request: { http }, metrics, logger }) {
            if (!enabled) {
                return;
            }
            const treeBuilder = new TraceTreeBuilder({
                maskedBy: 'ApolloServerPluginInlineTrace',
                sendErrors: options.includeErrors,
                logger,
            });
            if (http?.headers.get('apollo-federation-include-trace') !== 'ftv1') {
                return;
            }
            if (metrics.captureTraces === false) {
                return;
            }
            metrics.captureTraces = true;
            treeBuilder.startTiming();
            return {
                async executionDidStart() {
                    return {
                        willResolveField({ info }) {
                            return treeBuilder.willResolveField(info);
                        },
                    };
                },
                async didEncounterErrors({ errors }) {
                    treeBuilder.didEncounterErrors(errors);
                },
                async willSendResponse({ response }) {
                    treeBuilder.stopTiming();
                    if (response.body.kind === 'incremental') {
                        return;
                    }
                    if (metrics.queryPlanTrace) {
                        treeBuilder.trace.queryPlan = metrics.queryPlanTrace;
                    }
                    const encodedUint8Array = Trace.encode(treeBuilder.trace).finish();
                    const encodedBuffer = Buffer.from(encodedUint8Array, encodedUint8Array.byteOffset, encodedUint8Array.byteLength);
                    const extensions = response.body.singleResult.extensions ||
                        (response.body.singleResult.extensions = Object.create(null));
                    if (typeof extensions.ftv1 !== 'undefined') {
                        throw new Error('The `ftv1` extension was already present.');
                    }
                    extensions.ftv1 = encodedBuffer.toString('base64');
                },
            };
        },
    });
}
//# sourceMappingURL=index.js.mapŸ)/dist/esm/utils/urlForHttpServer.d.ts.mapƒ{"version":3,"file":"urlForHttpServer.d.ts","sourceRoot":"","sources":["../../../src/utils/urlForHttpServer.ts"],"names":[],"mappings":";AAAA,OAAO,KAAK,EAAE,MAAM,EAAE,MAAM,MAAM,CAAC;AAInC,wBAAgB,gBAAgB,CAAC,UAAU,EAAE,MAAM,GAAG,MAAM,CAgB3D"}Ÿ!/dist/esm/errorNormalize.d.ts.map≈y{"version":3,"file":"errorNormalize.d.ts","sourceRoot":"","sources":["../../src/errorNormalize.ts"],"names":[],"mappings":"AAEA,OAAO,EACL,YAAY,EAEZ,qBAAqB,EACtB,MAAM,SAAS,CAAC;AAEjB,OAAO,KAAK,EAAE,eAAe,EAAE,MAAM,yBAAyB,CAAC;AAY/D,wBAAgB,wBAAwB,CACtC,MAAM,EAAE,aAAa,CAAC,OAAO,CAAC,EAC9B,OAAO,GAAE;IACP,WAAW,CAAC,EAAE,CACZ,cAAc,EAAE,qBAAqB,EACrC,KAAK,EAAE,OAAO,KACX,qBAAqB,CAAC;IAC3B,iCAAiC,CAAC,EAAE,OAAO,CAAC;CACxC,GACL;IACD,eAAe,EAAE,KAAK,CAAC,qBAAqB,CAAC,CAAC;IAC9C,cAAc,EAAE,eAAe,CAAC;CACjC,CAqDA;AAED,wBAAgB,WAAW,CAAC,UAAU,EAAE,OAAO,GAAG,KAAK,CAItD;AAED,wBAAgB,kBAAkB,CAChC,UAAU,EAAE,OAAO,EACnB,8BAA8B,GAAE,MAAW,GAC1C,YAAY,CAQd"}Ÿ7/dist/esm/plugin/landingPage/default/getEmbeddedHTML.js≈	≥function getConfigStringForHtml(config) {
    return JSON.stringify(config)
        .replace('<', '\\u003c')
        .replace('>', '\\u003e')
        .replace('&', '\\u0026')
        .replace("'", '\\u0027');
}
export const getEmbeddedExplorerHTML = (version, config) => {
    const productionLandingPageConfigOrDefault = {
        displayOptions: {},
        persistExplorerState: false,
        ...(typeof config.embed === 'boolean' ? {} : config.embed),
    };
    const embeddedExplorerParams = {
        ...config,
        target: '#embeddableExplorer',
        initialState: {
            ...config,
            displayOptions: {
                ...productionLandingPageConfigOrDefault.displayOptions,
            },
        },
        persistExplorerState: productionLandingPageConfigOrDefault.persistExplorerState,
    };
    return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Explorer cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableExplorer"
></div>
<script src="https://embeddable-explorer.cdn.apollographql.com/${version}/embeddable-explorer.umd.production.min.js"></script>
<script>
  var endpointUrl = window.location.href;
  var embeddedExplorerConfig = ${getConfigStringForHtml(embeddedExplorerParams)};
  new window.EmbeddedExplorer({
    ...embeddedExplorerConfig,
    endpointUrl,
  });
</script>
`;
};
export const getEmbeddedSandboxHTML = (version, config) => {
    return `
<div class="fallback">
  <h1>Welcome to Apollo Server</h1>
  <p>Apollo Sandbox cannot be loaded; it appears that you might be offline.</p>
</div>
<style>
  iframe {
    background-color: white;
  }
</style>
<div
style="width: 100vw; height: 100vh; position: absolute; top: 0;"
id="embeddableSandbox"
></div>
<script src="https://embeddable-sandbox.cdn.apollographql.com/${version}/embeddable-sandbox.umd.production.min.js"></script>
<script>
  var initialEndpoint = window.location.href;
  new window.EmbeddedSandbox({
    target: '#embeddableSandbox',
    initialEndpoint,
    includeCookies: ${config.includeCookies ?? 'false'},
    initialState: ${getConfigStringForHtml({
        document: config.document ?? undefined,
        variables: config.variables ?? undefined,
        headers: config.headers ?? undefined,
    })},
  });
</script>
`;
};
//# sourceMappingURL=getEmbeddedHTML.js.mapΩ/src/determineApolloConfig.ts≈Uimport { createHash } from '@apollo/utils.createhash';
import type { ApolloConfig, ApolloConfigInput } from './externalTypes/index.js';

// This function combines the `apollo` constructor argument and some environment
// variables to come up with a full ApolloConfig.
export function determineApolloConfig(
  input: ApolloConfigInput | undefined,
): ApolloConfig {
  const apolloConfig: ApolloConfig = {};

  const {
    APOLLO_KEY,
    APOLLO_GRAPH_REF,
    APOLLO_GRAPH_ID,
    APOLLO_GRAPH_VARIANT,
  } = process.env;

  // Determine key.
  if (input?.key) {
    apolloConfig.key = input.key;
  } else if (APOLLO_KEY) {
    apolloConfig.key = APOLLO_KEY;
  }

  // Determine key hash.
  if (apolloConfig.key) {
    apolloConfig.keyHash = createHash('sha512')
      .update(apolloConfig.key)
      .digest('hex');
  }

  // Determine graph ref, if provided together.
  if (input?.graphRef) {
    apolloConfig.graphRef = input.graphRef;
  } else if (APOLLO_GRAPH_REF) {
    apolloConfig.graphRef = APOLLO_GRAPH_REF;
  }

  // See if graph ID and variant were provided separately.
  const graphId = input?.graphId ?? APOLLO_GRAPH_ID;
  const graphVariant = input?.graphVariant ?? APOLLO_GRAPH_VARIANT;

  if (apolloConfig.graphRef) {
    if (graphId) {
      throw new Error(
        'Cannot specify both graph ref and graph ID. Please use ' +
          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.',
      );
    }
    if (graphVariant) {
      throw new Error(
        'Cannot specify both graph ref and graph variant. Please use ' +
          '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.',
      );
    }
  } else if (graphId) {
    // Graph ref is not specified, but the ID is. We can construct the ref
    // from the ID and variant. Note that after this, we stop tracking the ID
    // and variant, because Apollo Server 3 does not assume that all graph refs
    // can be decomposed into ID and variant (except in the op reg plugin).
    apolloConfig.graphRef = graphVariant
      ? `${graphId}@${graphVariant}`
      : graphId;
  }

  return apolloConfig;
}
Ÿ+/dist/esm/plugin/drainHttpServer/index.d.ts≈©/// <reference types="node" />
import type http from 'http';
import type { ApolloServerPlugin } from '../../externalTypes/index.js';
export interface ApolloServerPluginDrainHttpServerOptions {
    httpServer: http.Server;
    stopGracePeriodMillis?: number;
}
export declare function ApolloServerPluginDrainHttpServer(options: ApolloServerPluginDrainHttpServerOptions): ApolloServerPlugin;
//# sourceMappingURL=index.d.ts.mapŸ1/dist/esm/plugin/drainHttpServer/stoppable.js.map≈Õ{"version":3,"file":"stoppable.js","sourceRoot":"","sources":["../../../../src/plugin/drainHttpServer/stoppable.ts"],"names":[],"mappings":"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"}º/dist/esm/utils/isDefined.jsƒ\export function isDefined(t) {
    return t != null;
}
//# sourceMappingURL=isDefined.js.map∑/src/utils/isDefined.tsƒ]export function isDefined<T>(t: T | undefined | null | void): t is T {
  return t != null;
}
Ÿ$/src/plugin/schemaReporting/index.ts≈·import os from 'os';
import { internalPlugin } from '../../internalPlugin.js';
import { v4 as uuidv4 } from 'uuid';
import { printSchema, validateSchema, buildSchema } from 'graphql';
import { SchemaReporter } from './schemaReporter.js';
import { schemaIsFederated } from '../schemaIsFederated.js';
import type { SchemaReport } from './generated/operations.js';
import type { ApolloServerPlugin } from '../../externalTypes/index.js';
import type { Fetcher } from '@apollo/utils.fetcher';
import { packageVersion } from '../../generated/packageVersion.js';
import { computeCoreSchemaHash } from '../../utils/computeCoreSchemaHash.js';

export interface ApolloServerPluginSchemaReportingOptions {
  /**
   * The schema reporter waits before starting reporting.
   * By default, the report waits some random amount of time between 0 and 10 seconds.
   * A longer interval leads to more staggered starts which means it is less likely
   * multiple servers will get asked to upload the same schema.
   *
   * If this server runs in lambda or in other constrained environments it would be useful
   * to decrease the schema reporting max wait time to be less than default.
   *
   * This number will be the max for the range in ms that the schema reporter will
   * wait before starting to report.
   */
  initialDelayMaxMs?: number;
  /**
   * Override the reported schema that is reported to the Apollo registry. This
   * schema does not go through any normalizations and the string is directly
   * sent to the Apollo registry. This can be useful for comments or other
   * ordering and whitespace changes that get stripped when generating a
   * `GraphQLSchema`.
   *
   * **If you pass this option to this plugin, you should explicitly configure
   * `ApolloServerPluginUsageReporting` and pass the same value to its
   * `overrideReportedSchema` option.** This ensures that the schema ID
   * associated with requests reported by the usage reporting plugin matches the
   * schema ID that this plugin reports. For example:
   *
   * ```js
   * new ApolloServer({
   *   plugins: [
   *     ApolloServerPluginSchemaReporting({overrideReportedSchema: schema}),
   *     ApolloServerPluginUsageReporting({overrideReportedSchema: schema}),
   *   ],
   * })
   * ```
   */
  overrideReportedSchema?: string;
  /**
   * The URL to use for reporting schemas. Primarily for testing and internal
   * Apollo use.
   */
  endpointUrl?: string;
  /**
   * Specifies which Fetch API implementation to use when reporting schemas.
   */
  fetcher?: Fetcher;
}

export function ApolloServerPluginSchemaReporting(
  {
    initialDelayMaxMs,
    overrideReportedSchema,
    endpointUrl,
    fetcher,
  }: ApolloServerPluginSchemaReportingOptions = Object.create(null),
): ApolloServerPlugin {
  const bootId = uuidv4();

  return internalPlugin({
    __internal_plugin_id__: 'SchemaReporting',
    __is_disabled_plugin__: false,
    async serverWillStart({ apollo, schema, logger }) {
      const { key, graphRef } = apollo;
      if (!key) {
        throw Error(
          'To use ApolloServerPluginSchemaReporting, you must provide an Apollo API ' +
            'key, via the APOLLO_KEY environment variable or via `new ApolloServer({apollo: {key})`',
        );
      }
      if (!graphRef) {
        // This error is a bit imprecise as you can also specify ID and variant separately,
        // or rely on API-key parsing (before AS3), but this is "best practices".
        throw Error(
          'To use ApolloServerPluginSchemaReporting, you must provide your graph ref (eg, ' +
            "'my-graph-id@my-graph-variant'). Try setting the APOLLO_GRAPH_REF environment " +
            'variable or passing `new ApolloServer({apollo: {graphRef}})`.',
        );
      }

      // Ensure a provided override schema can be parsed and validated
      if (overrideReportedSchema) {
        try {
          const validationErrors = validateSchema(
            buildSchema(overrideReportedSchema, { noLocation: true }),
          );
          if (validationErrors.length) {
            throw new Error(
              validationErrors.map((error) => error.message).join('\n'),
            );
          }
        } catch (err) {
          throw new Error(
            'The schema provided to overrideReportedSchema failed to parse or ' +
              `validate: ${(err as Error).message}`,
          );
        }
      }

      if (schemaIsFederated(schema)) {
        throw Error(
          [
            'Schema reporting is not yet compatible with federated services.',
            "If you're interested in using schema reporting with federated",
            'services, please contact Apollo support. To set up managed federation, see',
            'https://go.apollo.dev/s/managed-federation',
          ].join(' '),
        );
      }

      if (endpointUrl !== undefined) {
        logger.info(
          `Apollo schema reporting: schema reporting URL override: ${endpointUrl}`,
        );
      }

      const baseSchemaReport: Omit<SchemaReport, 'coreSchemaHash'> = {
        bootId,
        graphRef,
        // The infra environment in which this edge server is running, e.g. localhost, Kubernetes
        // Length must be <= 256 characters.
        platform: process.env.APOLLO_SERVER_PLATFORM || 'local',
        runtimeVersion: `node ${process.version}`,
        // An identifier used to distinguish the version of the server code such as git or docker sha.
        // Length must be <= 256 characters
        userVersion: process.env.APOLLO_SERVER_USER_VERSION,
        // "An identifier for the server instance. Length must be <= 256 characters.
        serverId:
          process.env.APOLLO_SERVER_ID || process.env.HOSTNAME || os.hostname(),
        libraryVersion: `@apollo/server@${packageVersion}`,
      };
      let currentSchemaReporter: SchemaReporter | undefined;

      return {
        schemaDidLoadOrUpdate({ apiSchema, coreSupergraphSdl }): void {
          if (overrideReportedSchema !== undefined) {
            if (currentSchemaReporter) {
              // When the schema to report has been overridden, there is no need
              // to create a new schema reporter.
              return;
            } else {
              logger.info(
                'Apollo schema reporting: schema to report has been overridden',
              );
            }
          }

          const coreSchema =
            overrideReportedSchema ??
            coreSupergraphSdl ??
            printSchema(apiSchema);
          const coreSchemaHash = computeCoreSchemaHash(coreSchema);
          const schemaReport: SchemaReport = {
            ...baseSchemaReport,
            coreSchemaHash,
          };

          currentSchemaReporter?.stop();
          currentSchemaReporter = new SchemaReporter({
            schemaReport,
            coreSchema,
            apiKey: key,
            endpointUrl,
            logger,
            // Jitter the startup between 0 and 10 seconds
            initialReportingDelayInMs: Math.floor(
              Math.random() * (initialDelayMaxMs ?? 10_000),
            ),
            fallbackReportingDelayInMs: 20_000,
            fetcher,
          });
          currentSchemaReporter.start();

          logger.info(
            'Apollo schema reporting: reporting a new schema to Studio! See your graph at ' +
              `https://studio.apollographql.com/graph/${encodeURI(
                graphRef,
              )}/ with server info ${JSON.stringify(schemaReport)}`,
          );
        },
        async serverWillStop() {
          currentSchemaReporter?.stop();
        },
      };
    },
  });
}
Ÿ /dist/cjs/utils/schemaManager.js≈,"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaManager = void 0;
class SchemaManager {
    constructor(options) {
        this.onSchemaLoadOrUpdateListeners = new Set();
        this.isStopped = false;
        this.logger = options.logger;
        this.schemaDerivedDataProvider = options.schemaDerivedDataProvider;
        if ('gateway' in options) {
            this.modeSpecificState = {
                mode: 'gateway',
                gateway: options.gateway,
                apolloConfig: options.apolloConfig,
            };
        }
        else {
            this.modeSpecificState = {
                mode: 'schema',
                apiSchema: options.apiSchema,
                schemaDerivedData: options.schemaDerivedDataProvider(options.apiSchema),
            };
        }
    }
    async start() {
        if (this.modeSpecificState.mode === 'gateway') {
            const gateway = this.modeSpecificState.gateway;
            if (gateway.onSchemaLoadOrUpdate) {
                this.modeSpecificState.unsubscribeFromGateway =
                    gateway.onSchemaLoadOrUpdate((schemaContext) => {
                        this.processSchemaLoadOrUpdateEvent(schemaContext);
                    });
            }
            else {
                throw new Error("Unexpectedly couldn't find onSchemaLoadOrUpdate on gateway");
            }
            const config = await this.modeSpecificState.gateway.load({
                apollo: this.modeSpecificState.apolloConfig,
            });
            return config.executor;
        }
        else {
            this.processSchemaLoadOrUpdateEvent({
                apiSchema: this.modeSpecificState.apiSchema,
            }, this.modeSpecificState.schemaDerivedData);
            return null;
        }
    }
    onSchemaLoadOrUpdate(callback) {
        if (!this.schemaContext) {
            throw new Error('You must call start() before onSchemaLoadOrUpdate()');
        }
        if (!this.isStopped) {
            try {
                callback(this.schemaContext);
            }
            catch (e) {
                throw new Error(`An error was thrown from an 'onSchemaLoadOrUpdate' listener: ${e.message}`);
            }
        }
        this.onSchemaLoadOrUpdateListeners.add(callback);
        return () => {
            this.onSchemaLoadOrUpdateListeners.delete(callback);
        };
    }
    getSchemaDerivedData() {
        if (!this.schemaDerivedData) {
            throw new Error('You must call start() before getSchemaDerivedData()');
        }
        return this.schemaDerivedData;
    }
    async stop() {
        this.isStopped = true;
        if (this.modeSpecificState.mode === 'gateway') {
            this.modeSpecificState.unsubscribeFromGateway?.();
            await this.modeSpecificState.gateway.stop?.();
        }
    }
    processSchemaLoadOrUpdateEvent(schemaContext, schemaDerivedData) {
        if (!this.isStopped) {
            this.schemaDerivedData =
                schemaDerivedData ??
                    this.schemaDerivedDataProvider(schemaContext.apiSchema);
            this.schemaContext = schemaContext;
            this.onSchemaLoadOrUpdateListeners.forEach((listener) => {
                try {
                    listener(schemaContext);
                }
                catch (e) {
                    this.logger.error("An error was thrown from an 'onSchemaLoadOrUpdate' listener");
                    this.logger.error(e);
                }
            });
        }
    }
}
exports.SchemaManager = SchemaManager;
//# sourceMappingURL=schemaManager.js.mapŸ"/dist/esm/externalTypes/index.d.ts≈export type { BaseContext, ContextFunction, ContextThunk } from './context.js';
export type { GraphQLRequest, GraphQLResponse } from './graphql.js';
export type { HTTPGraphQLRequest, HTTPGraphQLResponse, HTTPGraphQLHead, } from './http.js';
export type { ApolloServerPlugin, GraphQLFieldResolverParams, GraphQLRequestExecutionListener, GraphQLRequestListener, GraphQLRequestListenerDidResolveField, GraphQLRequestListenerExecutionDidEnd, GraphQLRequestListenerParsingDidEnd, GraphQLRequestListenerValidationDidEnd, GraphQLSchemaContext, GraphQLServerListener, GraphQLServerContext, LandingPage, } from './plugins.js';
export type { GraphQLRequestContext, GraphQLRequestMetrics, GraphQLRequestContextDidEncounterErrors, GraphQLRequestContextDidResolveOperation, GraphQLRequestContextDidResolveSource, GraphQLRequestContextExecutionDidStart, GraphQLRequestContextParsingDidStart, GraphQLRequestContextResponseForOperation, GraphQLRequestContextValidationDidStart, GraphQLRequestContextWillSendResponse, } from './requestPipeline.js';
export type { DocumentStore, ApolloConfigInput, ApolloConfig, PersistedQueryOptions, CSRFPreventionOptions, ApolloServerOptions, } from './constructor.js';
export type { GraphQLExperimentalFormattedInitialIncrementalExecutionResult, GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult, GraphQLExperimentalFormattedIncrementalResult, GraphQLExperimentalFormattedIncrementalDeferResult, GraphQLExperimentalFormattedIncrementalStreamResult, } from './incrementalDeliveryPolyfill.js';
//# sourceMappingURL=index.d.ts.mapæ/dist/esm/utils/invokeHooks.js≈∑import { isDefined } from './isDefined.js';
export async function invokeDidStartHook(targets, hook) {
    const didEndHooks = (await Promise.all(targets.map((target) => hook(target)))).filter(isDefined);
    didEndHooks.reverse();
    return async (...args) => {
        for (const didEndHook of didEndHooks) {
            didEndHook(...args);
        }
    };
}
export function invokeSyncDidStartHook(targets, hook) {
    const didEndHooks = targets
        .map((target) => hook(target))
        .filter(isDefined);
    didEndHooks.reverse();
    return (...args) => {
        for (const didEndHook of didEndHooks) {
            didEndHook(...args);
        }
    };
}
export async function invokeHooksUntilDefinedAndNonNull(targets, hook) {
    for (const target of targets) {
        const value = await hook(target);
        if (value != null) {
            return value;
        }
    }
    return null;
}
//# sourceMappingURL=invokeHooks.js.mapŸ,/dist/esm/externalTypes/requestPipeline.d.ts≈+import type { WithRequired } from '@apollo/utils.withrequired';
import type { Trace } from '@apollo/usage-reporting-protobuf';
import type { BaseContext } from './context.js';
import type { GraphQLInProgressResponse, GraphQLRequest, GraphQLResponse } from './graphql.js';
import type { Logger } from '@apollo/utils.logger';
import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { DocumentNode, GraphQLError, GraphQLSchema, OperationDefinitionNode } from 'graphql';
import type { CachePolicy } from '@apollo/cache-control-types';
export interface GraphQLRequestMetrics {
    captureTraces?: boolean;
    persistedQueryHit?: boolean;
    persistedQueryRegister?: boolean;
    responseCacheHit?: boolean;
    forbiddenOperation?: boolean;
    registeredOperation?: boolean;
    startHrTime?: [number, number];
    queryPlanTrace?: Trace.QueryPlanNode;
}
export interface GraphQLRequestContext<TContext extends BaseContext> {
    readonly logger: Logger;
    readonly cache: KeyValueCache<string>;
    readonly request: GraphQLRequest;
    readonly response: GraphQLInProgressResponse;
    readonly schema: GraphQLSchema;
    readonly contextValue: TContext;
    readonly queryHash?: string;
    readonly document?: DocumentNode;
    readonly source?: string;
    readonly operationName?: string | null;
    readonly operation?: OperationDefinitionNode;
    readonly errors?: ReadonlyArray<GraphQLError>;
    readonly metrics: GraphQLRequestMetrics;
    readonly overallCachePolicy: CachePolicy;
    readonly requestIsBatched: boolean;
}
export declare type GraphQLRequestContextDidResolveSource<TContext extends BaseContext> = WithRequired<GraphQLRequestContext<TContext>, 'source' | 'queryHash'>;
export declare type GraphQLRequestContextParsingDidStart<TContext extends BaseContext> = GraphQLRequestContextDidResolveSource<TContext>;
export declare type GraphQLRequestContextValidationDidStart<TContext extends BaseContext> = GraphQLRequestContextParsingDidStart<TContext> & WithRequired<GraphQLRequestContext<TContext>, 'document'>;
export declare type GraphQLRequestContextDidResolveOperation<TContext extends BaseContext> = GraphQLRequestContextValidationDidStart<TContext> & WithRequired<GraphQLRequestContext<TContext>, 'operationName'>;
export declare type GraphQLRequestContextDidEncounterErrors<TContext extends BaseContext> = WithRequired<GraphQLRequestContext<TContext>, 'errors'>;
export declare type GraphQLRequestContextResponseForOperation<TContext extends BaseContext> = WithRequired<GraphQLRequestContext<TContext>, 'source' | 'document' | 'operation' | 'operationName'>;
export declare type GraphQLRequestContextExecutionDidStart<TContext extends BaseContext> = GraphQLRequestContextParsingDidStart<TContext> & WithRequired<GraphQLRequestContext<TContext>, 'document' | 'operation' | 'operationName'>;
export declare type GraphQLRequestContextWillSendResponse<TContext extends BaseContext> = GraphQLRequestContextDidResolveSource<TContext> & {
    readonly response: GraphQLResponse;
};
export declare type GraphQLRequestContextDidEncounterSubsequentErrors<TContext extends BaseContext> = GraphQLRequestContextWillSendResponse<TContext>;
export declare type GraphQLRequestContextWillSendSubsequentPayload<TContext extends BaseContext> = GraphQLRequestContextWillSendResponse<TContext>;
//# sourceMappingURL=requestPipeline.d.ts.mapŸ)/dist/cjs/generated/packageVersion.js.mapƒ®{"version":3,"file":"packageVersion.js","sourceRoot":"","sources":["../../../src/generated/packageVersion.ts"],"names":[],"mappings":";;;AAAa,QAAA,cAAc,GAAG,OAAO,CAAC"}Ÿ,/dist/cjs/utils/computeCoreSchemaHash.js.map≈/{"version":3,"file":"computeCoreSchemaHash.js","sourceRoot":"","sources":["../../../src/utils/computeCoreSchemaHash.ts"],"names":[],"mappings":";;;AAAA,+DAAsD;AAMtD,SAAgB,qBAAqB,CAAC,MAAc;IAClD,OAAO,IAAA,6BAAU,EAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC3D,CAAC;AAFD,sDAEC"}Ÿ(/dist/cjs/plugin/usageReporting/index.js≈p"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApolloServerPluginUsageReporting = void 0;
var plugin_js_1 = require("./plugin.js");
Object.defineProperty(exports, "ApolloServerPluginUsageReporting", { enumerable: true, get: function () { return plugin_js_1.ApolloServerPluginUsageReporting; } });
//# sourceMappingURL=index.js.mapŸ*/dist/esm/incrementalDeliveryPolyfill.d.ts≈ import { ExecutionArgs, ExecutionResult, GraphQLError } from 'graphql';
interface ObjMap<T> {
    [key: string]: T;
}
export interface GraphQLExperimentalInitialIncrementalExecutionResult<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> extends ExecutionResult<TData, TExtensions> {
    hasNext: boolean;
    incremental?: ReadonlyArray<GraphQLExperimentalIncrementalResult<TData, TExtensions>>;
    extensions?: TExtensions;
}
export interface GraphQLExperimentalSubsequentIncrementalExecutionResult<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> {
    hasNext: boolean;
    incremental?: ReadonlyArray<GraphQLExperimentalIncrementalResult<TData, TExtensions>>;
    extensions?: TExtensions;
}
declare type GraphQLExperimentalIncrementalResult<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> = GraphQLExperimentalIncrementalDeferResult<TData, TExtensions> | GraphQLExperimentalIncrementalStreamResult<TData, TExtensions>;
interface GraphQLExperimentalIncrementalDeferResult<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> extends ExecutionResult<TData, TExtensions> {
    path?: ReadonlyArray<string | number>;
    label?: string;
}
interface GraphQLExperimentalIncrementalStreamResult<TData = Array<unknown>, TExtensions = ObjMap<unknown>> {
    errors?: ReadonlyArray<GraphQLError>;
    items?: TData | null;
    path?: ReadonlyArray<string | number>;
    label?: string;
    extensions?: TExtensions;
}
export interface GraphQLExperimentalIncrementalExecutionResults<TData = ObjMap<unknown>, TExtensions = ObjMap<unknown>> {
    initialResult: GraphQLExperimentalInitialIncrementalExecutionResult<TData, TExtensions>;
    subsequentResults: AsyncGenerator<GraphQLExperimentalSubsequentIncrementalExecutionResult<TData, TExtensions>, void, void>;
}
export declare function executeIncrementally(args: ExecutionArgs): Promise<ExecutionResult | GraphQLExperimentalIncrementalExecutionResults>;
export {};
//# sourceMappingURL=incrementalDeliveryPolyfill.d.ts.mapŸ#/dist/cjs/utils/urlForHttpServer.js≈"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.urlForHttpServer = void 0;
const url_1 = require("url");
function urlForHttpServer(httpServer) {
    const { address, port } = httpServer.address();
    const hostname = address === '' || address === '::' ? 'localhost' : address;
    return (0, url_1.format)({
        protocol: 'http',
        hostname,
        port,
        pathname: '/',
    });
}
exports.urlForHttpServer = urlForHttpServer;
//# sourceMappingURL=urlForHttpServer.js.mapŸ8/dist/esm/plugin/usageReporting/durationHistogram.js.map≈	{"version":3,"file":"durationHistogram.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/durationHistogram.ts"],"names":[],"mappings":"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"}Ÿ3/dist/esm/plugin/usageReporting/iterateOverTrace.js≈	export function iterateOverTrace(trace, f, includePath) {
    const rootPath = includePath
        ? new RootCollectingPathsResponseNamePath()
        : notCollectingPathsResponseNamePath;
    if (trace.root) {
        if (iterateOverTraceNode(trace.root, rootPath, f))
            return;
    }
    if (trace.queryPlan) {
        if (iterateOverQueryPlan(trace.queryPlan, rootPath, f))
            return;
    }
}
function iterateOverQueryPlan(node, rootPath, f) {
    if (!node)
        return false;
    if (node.fetch?.trace?.root && node.fetch.serviceName) {
        return iterateOverTraceNode(node.fetch.trace.root, rootPath.child(`service:${node.fetch.serviceName}`), f);
    }
    if (node.flatten?.node) {
        return iterateOverQueryPlan(node.flatten.node, rootPath, f);
    }
    if (node.parallel?.nodes) {
        return node.parallel.nodes.some((node) => iterateOverQueryPlan(node, rootPath, f));
    }
    if (node.sequence?.nodes) {
        return node.sequence.nodes.some((node) => iterateOverQueryPlan(node, rootPath, f));
    }
    return false;
}
function iterateOverTraceNode(node, path, f) {
    if (f(node, path)) {
        return true;
    }
    return (node.child?.some((child) => {
        const childPath = child.responseName
            ? path.child(child.responseName)
            : path;
        return iterateOverTraceNode(child, childPath, f);
    }) ?? false);
}
const notCollectingPathsResponseNamePath = {
    toArray() {
        throw Error('not collecting paths!');
    },
    child() {
        return this;
    },
};
class RootCollectingPathsResponseNamePath {
    toArray() {
        return [];
    }
    child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
    }
}
class ChildCollectingPathsResponseNamePath {
    constructor(responseName, prev) {
        this.responseName = responseName;
        this.prev = prev;
    }
    toArray() {
        const out = [];
        let curr = this;
        while (curr instanceof ChildCollectingPathsResponseNamePath) {
            out.push(curr.responseName);
            curr = curr.prev;
        }
        return out.reverse();
    }
    child(responseName) {
        return new ChildCollectingPathsResponseNamePath(responseName, this);
    }
}
//# sourceMappingURL=iterateOverTrace.js.mapπ/src/utils/invokeHooks.ts≈import { isDefined } from './isDefined.js';

type AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;
type SyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => void;

export async function invokeDidStartHook<T, TEndHookArgs extends unknown[]>(
  targets: T[],
  hook: (t: T) => Promise<AsyncDidEndHook<TEndHookArgs> | undefined | void>,
): Promise<AsyncDidEndHook<TEndHookArgs>> {
  const didEndHooks = (
    await Promise.all(targets.map((target) => hook(target)))
  ).filter(isDefined);

  didEndHooks.reverse();

  return async (...args: TEndHookArgs) => {
    for (const didEndHook of didEndHooks) {
      didEndHook(...args);
    }
  };
}

// Almost all hooks are async, but as a special case, willResolveField is sync
// due to performance concerns.
export function invokeSyncDidStartHook<T, TEndHookArgs extends unknown[]>(
  targets: T[],
  hook: (t: T) => SyncDidEndHook<TEndHookArgs> | undefined | void,
): SyncDidEndHook<TEndHookArgs> {
  const didEndHooks: SyncDidEndHook<TEndHookArgs>[] = targets
    .map((target) => hook(target))
    .filter(isDefined);

  didEndHooks.reverse();

  return (...args: TEndHookArgs) => {
    for (const didEndHook of didEndHooks) {
      didEndHook(...args);
    }
  };
}

export async function invokeHooksUntilDefinedAndNonNull<T, TOut>(
  targets: T[],
  hook: (t: T) => Promise<TOut | null | undefined>,
): Promise<TOut | null> {
  for (const target of targets) {
    const value = await hook(target);
    if (value != null) {
      return value;
    }
  }
  return null;
}
Ÿ&/dist/esm/plugin/traceTreeBuilder.d.ts≈Èimport { GraphQLError, GraphQLResolveInfo } from 'graphql';
import { Trace, google } from '@apollo/usage-reporting-protobuf';
import type { Logger } from '@apollo/utils.logger';
import type { SendErrorsOptions } from './usageReporting';
export declare class TraceTreeBuilder {
    private rootNode;
    private logger;
    trace: Trace;
    startHrTime?: [number, number];
    private stopped;
    private nodes;
    private readonly transformError;
    constructor(options: {
        maskedBy: string;
        logger: Logger;
        sendErrors?: SendErrorsOptions;
    });
    startTiming(): void;
    stopTiming(): void;
    willResolveField(info: GraphQLResolveInfo): () => void;
    didEncounterErrors(errors: readonly GraphQLError[]): void;
    private addProtobufError;
    private newNode;
    private ensureParentNode;
    private transformAndNormalizeError;
}
export declare function dateToProtoTimestamp(date: Date): google.protobuf.Timestamp;
//# sourceMappingURL=traceTreeBuilder.d.ts.mapŸ*/dist/esm/plugin/cacheControl/index.js.map≈}{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/cacheControl/index.ts"],"names":[],"mappings":"AACA,OAAO,EAEL,YAAY,EAGZ,eAAe,EACf,eAAe,EACf,YAAY,EACZ,mBAAmB,GACpB,MAAM,SAAS,CAAC;AACjB,OAAO,EAAE,cAAc,EAAE,MAAM,sBAAsB,CAAC;AACtD,OAAO,EAAE,cAAc,EAAE,MAAM,yBAAyB,CAAC;AACzD,OAAO,QAAQ,MAAM,WAAW,CAAC;AAyCjC,MAAM,UAAU,8BAA8B,CAC5C,UAAiD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;IAEpE,IAAI,mBAAoE,CAAC;IAEzE,IAAI,oBAGH,CAAC;IAEF,OAAO,cAAc,CAAC;QACpB,sBAAsB,EAAE,cAAc;QACtC,sBAAsB,EAAE,KAAK;QAE7B,KAAK,CAAC,eAAe,CAAC,EAAE,MAAM,EAAE;YAS9B,mBAAmB,GAAG,IAAI,QAAQ,CAChC;gBACE,GAAG,EAAE,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC,MAAM,CAAC,eAAe,CAAC;qBAC5D,MAAM;aACV,CACF,CAAC;YAEF,oBAAoB,GAAG,IAAI,QAAQ,CAGjC;gBACA,GAAG,EACD,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC;qBAC/B,MAAM,CAAC,YAAY,CAAC;qBACpB,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,MAAM;oBACtD,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC;yBAC/B,MAAM,CAAC,eAAe,CAAC;yBACvB,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,MAAM;aACzD,CAAC,CAAC;YAEH,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,KAAK,CAAC,eAAe,CAAC,cAAc;YAClC,SAAS,+BAA+B,CACtC,CAAuB;gBAEvB,MAAM,QAAQ,GAAG,mBAAmB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC5C,IAAI,QAAQ,EAAE;oBACZ,OAAO,QAAQ,CAAC;iBACjB;gBACD,MAAM,UAAU,GAAG,uBAAuB,CAAC,CAAC,CAAC,CAAC;gBAC9C,mBAAmB,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;gBACvC,OAAO,UAAU,CAAC;YACpB,CAAC;YAED,SAAS,gCAAgC,CACvC,KAAqC;gBAErC,MAAM,QAAQ,GAAG,oBAAoB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBACjD,IAAI,QAAQ,EAAE;oBACZ,OAAO,QAAQ,CAAC;iBACjB;gBACD,MAAM,UAAU,GAAG,wBAAwB,CAAC,KAAK,CAAC,CAAC;gBACnD,oBAAoB,CAAC,GAAG,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;gBAC5C,OAAO,UAAU,CAAC;YACpB,CAAC;YAED,MAAM,aAAa,GAAW,OAAO,CAAC,aAAa,IAAI,CAAC,CAAC;YACzD,MAAM,oBAAoB,GAAG,OAAO,CAAC,oBAAoB,IAAI,IAAI,CAAC;YAClE,MAAM,EAAE,qBAAqB,EAAE,GAAG,OAAO,CAAC;YAE1C,OAAO;gBACL,KAAK,CAAC,iBAAiB;oBAUrB,IAAI,YAAY,CAAC,cAAc,CAAC,kBAAkB,CAAC,EAAE;wBAGnD,MAAM,eAAe,GAAG,cAAc,EAAE,CAAC;wBACzC,OAAO;4BACL,gBAAgB,CAAC,EAAE,IAAI,EAAE;gCAItB,IAA2C,CAAC,YAAY,GAAG;oCAC1D,YAAY,EAAE,CAAC,WAAsB,EAAE,EAAE;wCACvC,eAAe,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;oCACvC,CAAC;oCACD,SAAS,EAAE,eAAe;oCAC1B,iBAAiB,EAAE,+BAA+B;iCACnD,CAAC;4BACJ,CAAC;yBACF,CAAC;qBACH;oBAED,OAAO;wBACL,gBAAgB,CAAC,EAAE,IAAI,EAAE;4BACvB,MAAM,WAAW,GAAG,cAAc,EAAE,CAAC;4BAErC,IAAI,aAAa,GAAG,KAAK,CAAC;4BAK1B,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;4BACjD,IAAI,eAAe,CAAC,UAAU,CAAC,EAAE;gCAC/B,MAAM,cAAc,GAClB,+BAA+B,CAAC,UAAU,CAAC,CAAC;gCAC9C,WAAW,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;gCACpC,aAAa,GAAG,CAAC,CAAC,cAAc,CAAC,aAAa,CAAC;6BAChD;4BAID,MAAM,eAAe,GAAG,gCAAgC,CACtD,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAC5C,CAAC;4BAMF,IACE,eAAe,CAAC,aAAa;gCAC7B,WAAW,CAAC,MAAM,KAAK,SAAS,EAChC;gCACA,aAAa,GAAG,IAAI,CAAC;gCAIrB,IAAI,eAAe,CAAC,KAAK,EAAE;oCACzB,WAAW,CAAC,OAAO,CAAC,EAAE,KAAK,EAAE,eAAe,CAAC,KAAK,EAAE,CAAC,CAAC;iCACvD;6BACF;iCAAM;gCACL,WAAW,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;6BACtC;4BAKA,IAA2C,CAAC,YAAY,GAAG;gCAC1D,YAAY,EAAE,CAAC,WAAsB,EAAE,EAAE;oCACvC,WAAW,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;gCACnC,CAAC;gCACD,SAAS,EAAE,WAAW;gCACtB,iBAAiB,EAAE,+BAA+B;6BACnD,CAAC;4BAMF,OAAO,GAAG,EAAE;gCAsBV,IACE,WAAW,CAAC,MAAM,KAAK,SAAS;oCAChC,CAAC,CAAC,eAAe,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC;wCAC9C,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAClB;oCACA,WAAW,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,aAAa,EAAE,CAAC,CAAC;iCACjD;gCAED,IAAI,qBAAqB,IAAI,YAAY,CAAC,WAAW,CAAC,EAAE;oCACtD,MAAM,IAAI,GAAG,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oCACtD,IAAI,qBAAqB,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;wCACnC,MAAM,KAAK,CACT,+DAA+D,CAChE,CAAC;qCACH;oCACD,qBAAqB,CAAC,GAAG,CAAC,IAAI,EAAE;wCAC9B,MAAM,EAAE,WAAW,CAAC,MAAM;wCAC1B,KAAK,EAAE,WAAW,CAAC,KAAK;qCACzB,CAAC,CAAC;iCACJ;gCACD,cAAc,CAAC,kBAAkB,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;4BAC1D,CAAC,CAAC;wBACJ,CAAC;qBACF,CAAC;gBACJ,CAAC;gBAED,KAAK,CAAC,gBAAgB,CAAC,cAAc;oBAGnC,IAAI,CAAC,oBAAoB,EAAE;wBACzB,OAAO;qBACR;oBAED,MAAM,EAAE,QAAQ,EAAE,kBAAkB,EAAE,GAAG,cAAc,CAAC;oBAMxD,MAAM,0BAA0B,GAAG,+BAA+B,CAChE,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,CAC3C,CAAC;oBAOF,IAAI,0BAA0B,CAAC,IAAI,KAAK,YAAY,EAAE;wBACpD,OAAO;qBACR;oBAED,MAAM,WAAW,GAAG,cAAc,EAAE,CAAC;oBACrC,WAAW,CAAC,OAAO,CAAC,kBAAkB,CAAC,CAAC;oBACxC,IAAI,0BAA0B,CAAC,IAAI,KAAK,wBAAwB,EAAE;wBAChE,WAAW,CAAC,QAAQ,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAC;qBACvD;oBACD,MAAM,iBAAiB,GAAG,WAAW,CAAC,iBAAiB,EAAE,CAAC;oBAE1D,IAEE,iBAAiB;wBAOjB,0BAA0B,CAAC,IAAI,KAAK,aAAa;wBAMjD,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,QAAQ;wBAC/B,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,EAClC;wBACA,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CACvB,eAAe,EACf,WACE,iBAAiB,CAAC,MACpB,KAAK,iBAAiB,CAAC,KAAK,CAAC,WAAW,EAAE,EAAE,CAC7C,CAAC;qBACH;yBAAM,IAAI,oBAAoB,KAAK,cAAc,EAAE;wBAMlD,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CACvB,eAAe,EACf,gCAAgC,CACjC,CAAC;qBACH;gBACH,CAAC;aACF,CAAC;QACJ,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AAED,MAAM,qCAAqC,GACzC,mCAAmC,CAAC;AACtC,MAAM,gCAAgC,GAAG,UAAU,CAAC;AAQpD,SAAS,+BAA+B,CACtC,MAA0B;IAE1B,IAAI,CAAC,MAAM,EAAE;QACX,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE,CAAC;KAC9B;IACD,IAAI,MAAM,KAAK,gCAAgC,EAAE;QAC/C,OAAO,EAAE,IAAI,EAAE,aAAa,EAAE,CAAC;KAChC;IACD,MAAM,KAAK,GAAG,qCAAqC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IACjE,IAAI,CAAC,KAAK,EAAE;QACV,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,CAAC;KAC/B;IACD,OAAO;QACL,IAAI,EAAE,wBAAwB;QAC9B,IAAI,EAAE;YACJ,MAAM,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;YACjB,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS;SACpD;KACF,CAAC;AACJ,CAAC;AAED,SAAS,6BAA6B,CACpC,UAAoD;IAEpD,IAAI,CAAC,UAAU;QAAE,OAAO,SAAS,CAAC;IAElC,MAAM,qBAAqB,GAAG,UAAU,CAAC,IAAI,CAC3C,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,KAAK,cAAc,CACvD,CAAC;IACF,IAAI,CAAC,qBAAqB;QAAE,OAAO,SAAS,CAAC;IAE7C,IAAI,CAAC,qBAAqB,CAAC,SAAS;QAAE,OAAO,SAAS,CAAC;IAEvD,MAAM,cAAc,GAAG,qBAAqB,CAAC,SAAS,CAAC,IAAI,CACzD,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,QAAQ,CAC/C,CAAC;IACF,MAAM,aAAa,GAAG,qBAAqB,CAAC,SAAS,CAAC,IAAI,CACxD,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,OAAO,CAC9C,CAAC;IACF,MAAM,qBAAqB,GAAG,qBAAqB,CAAC,SAAS,CAAC,IAAI,CAChE,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,eAAe,CACtD,CAAC;IAEF,MAAM,WAAW,GACf,aAAa,EAAE,KAAK,EAAE,IAAI,KAAK,WAAW;QACxC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK;QAC3B,CAAC,CAAC,SAAS,CAAC;IAEhB,MAAM,KAAK,GACT,WAAW,KAAK,QAAQ,IAAI,WAAW,KAAK,SAAS;QACnD,CAAC,CAAC,WAAW;QACb,CAAC,CAAC,SAAS,CAAC;IAEhB,IACE,qBAAqB,EAAE,KAAK,EAAE,IAAI,KAAK,cAAc;QACrD,qBAAqB,CAAC,KAAK,CAAC,KAAK,EACjC;QAEA,OAAO,EAAE,aAAa,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;KACvC;IAED,OAAO;QACL,MAAM,EACJ,cAAc,EAAE,KAAK,EAAE,IAAI,KAAK,UAAU;YACxC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,KAAK,CAAC;YACtC,CAAC,CAAC,SAAS;QACf,KAAK;KACN,CAAC;AACJ,CAAC;AAED,SAAS,uBAAuB,CAAC,CAAuB;IACtD,IAAI,CAAC,CAAC,OAAO,EAAE;QACb,MAAM,IAAI,GAAG,6BAA6B,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QACjE,IAAI,IAAI,EAAE;YACR,OAAO,IAAI,CAAC;SACb;KACF;IACD,IAAI,CAAC,CAAC,iBAAiB,EAAE;QACvB,KAAK,MAAM,IAAI,IAAI,CAAC,CAAC,iBAAiB,EAAE;YACtC,MAAM,IAAI,GAAG,6BAA6B,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC5D,IAAI,IAAI,EAAE;gBACR,OAAO,IAAI,CAAC;aACb;SACF;KACF;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AAED,SAAS,wBAAwB,CAC/B,KAAqC;IAErC,IAAI,KAAK,CAAC,OAAO,EAAE;QACjB,MAAM,IAAI,GAAG,6BAA6B,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QACrE,IAAI,IAAI,EAAE;YACR,OAAO,IAAI,CAAC;SACb;KACF;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AAED,SAAS,YAAY,CAAC,IAAe;IACnC,OAAO,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC;AAC/D,CAAC"}ø/dist/esm/errors/index.d.ts.map≈ã{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/errors/index.ts"],"names":[],"mappings":"AAEA,oBAAY,qBAAqB;IAC/B,qBAAqB,0BAA0B;IAC/C,oBAAoB,yBAAyB;IAC7C,yBAAyB,8BAA8B;IACvD,yBAAyB,8BAA8B;IACvD,6BAA6B,kCAAkC;IAC/D,cAAc,mBAAmB;IACjC,4BAA4B,iCAAiC;IAC7D,WAAW,gBAAgB;CAC5B;AAED,oBAAY,+BAA+B;IACzC,sBAAsB,2BAA2B;CAClD;AAWD,wBAAgB,mBAAmB,CAAC,KAAK,EAAE,OAAO,GAAG,OAAO,CAK3D"}ŸC/dist/esm/plugin/usageReporting/defaultSendOperationsAsTrace.js.map≈“{"version":3,"file":"defaultSendOperationsAsTrace.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/defaultSendOperationsAsTrace.ts"],"names":[],"mappings":"AAAA,OAAO,QAAQ,MAAM,WAAW,CAAC;AAEjC,OAAO,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAC;AACzD,OAAO,EAAE,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;AAE3D,MAAM,UAAU,4BAA4B;IAU1C,MAAM,KAAK,GAAG,IAAI,QAAQ,CAAe;QAWvC,OAAO,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;QACxB,eAAe,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;YAC7B,OAAO,CAAC,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;KACF,CAAC,CAAC;IAEH,OAAO,CAAC,KAAY,EAAE,cAAsB,EAAW,EAAE;QACvD,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC;QAC9C,IAAI,cAAc,IAAI,IAAI,EAAE;YAC1B,MAAM,KAAK,CAAC,6CAA6C,CAAC,CAAC;SAC5D;QAED,MAAM,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QACxC,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;YAC9B,cAAc;YACd,iBAAiB,CAAC,gBAAgB,CAAC,KAAK,CAAC,UAAU,CAAC;YAEpD,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,EAAE,CAAC;YAG/B,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;SAChD,CAAC,CAAC;QAGH,IAAI,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;YACvB,OAAO,KAAK,CAAC;SACd;QAED,KAAK,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAC1B,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;AACJ,CAAC;AAID,SAAS,cAAc,CAAC,KAAY;IAClC,IAAI,SAAS,GAAG,KAAK,CAAC;IAEtB,SAAS,cAAc,CAAC,IAAiB;QACvC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE;YACjC,SAAS,GAAG,IAAI,CAAC;SAClB;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,gBAAgB,CAAC,KAAK,EAAE,cAAc,EAAE,KAAK,CAAC,CAAC;IAC/C,OAAO,SAAS,CAAC;AACnB,CAAC"}Ÿ(/dist/esm/externalTypes/context.d.ts.map≈~{"version":3,"file":"context.d.ts","sourceRoot":"","sources":["../../../src/externalTypes/context.ts"],"names":[],"mappings":"AAGA,oBAAY,WAAW,GAAG,EAAE,CAAC;AAI7B,oBAAY,eAAe,CACzB,wBAAwB,SAAS,GAAG,EAAE,EACtC,QAAQ,SAAS,WAAW,GAAG,WAAW,IACxC,CAAC,GAAG,kBAAkB,EAAE,wBAAwB,KAAK,OAAO,CAAC,QAAQ,CAAC,CAAC;AAM3E,oBAAY,YAAY,CAAC,QAAQ,SAAS,WAAW,GAAG,WAAW,IACjE,MAAM,OAAO,CAAC,QAAQ,CAAC,CAAC"}Ÿ>/dist/esm/plugin/usageReporting/operationDerivedDataCache.d.ts≈=import type { Logger } from '@apollo/utils.logger';
import type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';
import LRUCache from 'lru-cache';
export interface OperationDerivedData {
    signature: string;
    referencedFieldsByType: ReferencedFieldsByType;
}
export declare function createOperationDerivedDataCache({ logger, }: {
    logger: Logger;
}): LRUCache<string, OperationDerivedData>;
export declare function operationDerivedDataCacheKey(queryHash: string, operationName: string): string;
//# sourceMappingURL=operationDerivedDataCache.d.ts.mapº/dist/cjs/cachePolicy.js.map≈—{"version":3,"file":"cachePolicy.js","sourceRoot":"","sources":["../../src/cachePolicy.ts"],"names":[],"mappings":";;;AAEA,SAAgB,cAAc;IAC5B,OAAO;QACL,MAAM,EAAE,SAAS;QACjB,KAAK,EAAE,SAAS;QAChB,QAAQ,CAAC,IAAe;YACtB,IACE,IAAI,CAAC,MAAM,KAAK,SAAS;gBACzB,CAAC,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,EACxD;gBACA,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;aAC3B;YACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;gBACxD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;aACzB;QACH,CAAC;QACD,OAAO,CAAC,IAAe;YACrB,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,EAAE;gBAC7B,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;aAC3B;YACD,IAAI,IAAI,CAAC,KAAK,KAAK,SAAS,EAAE;gBAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;aACzB;QACH,CAAC;QACD,iBAAiB;YACf,IAAI,IAAI,CAAC,MAAM,KAAK,SAAS,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;gBAClD,OAAO,IAAI,CAAC;aACb;YACD,OAAO,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,IAAI,QAAQ,EAAE,CAAC;QAChE,CAAC;KACF,CAAC;AACJ,CAAC;AA9BD,wCA8BC"}Ÿ(/dist/esm/plugin/usageReporting/stats.js≈(timport { Trace, } from '@apollo/usage-reporting-protobuf';
import { DurationHistogram } from './durationHistogram.js';
import { iterateOverTrace } from './iterateOverTrace.js';
export class SizeEstimator {
    constructor() {
        this.bytes = 0;
    }
}
export class OurReport {
    constructor(header) {
        this.header = header;
        this.tracesPerQuery = Object.create(null);
        this.endTime = null;
        this.operationCount = 0;
        this.sizeEstimator = new SizeEstimator();
    }
    ensureCountsAreIntegers() {
        for (const tracesAndStats of Object.values(this.tracesPerQuery)) {
            tracesAndStats.ensureCountsAreIntegers();
        }
    }
    addTrace({ statsReportKey, trace, asTrace, referencedFieldsByType, maxTraceBytes = 10 * 1024 * 1024, }) {
        const tracesAndStats = this.getTracesAndStats({
            statsReportKey,
            referencedFieldsByType,
        });
        if (asTrace) {
            const encodedTrace = Trace.encode(trace).finish();
            if (!isNaN(maxTraceBytes) && encodedTrace.length > maxTraceBytes) {
                tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
            }
            else {
                tracesAndStats.trace.push(encodedTrace);
                this.sizeEstimator.bytes += 2 + encodedTrace.length;
            }
        }
        else {
            tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);
        }
    }
    getTracesAndStats({ statsReportKey, referencedFieldsByType, }) {
        const existing = this.tracesPerQuery[statsReportKey];
        if (existing) {
            return existing;
        }
        this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);
        for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {
            this.sizeEstimator.bytes += 2 + 2;
            if (referencedFieldsForType.isInterface) {
                this.sizeEstimator.bytes += 2;
            }
            this.sizeEstimator.bytes += estimatedBytesForString(typeName);
            for (const fieldName of referencedFieldsForType.fieldNames) {
                this.sizeEstimator.bytes += estimatedBytesForString(fieldName);
            }
        }
        return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType));
    }
}
class OurTracesAndStats {
    constructor(referencedFieldsByType) {
        this.referencedFieldsByType = referencedFieldsByType;
        this.trace = [];
        this.statsWithContext = new StatsByContext();
        this.internalTracesContributingToStats = [];
    }
    ensureCountsAreIntegers() {
        this.statsWithContext.ensureCountsAreIntegers();
    }
}
class StatsByContext {
    constructor() {
        this.map = Object.create(null);
    }
    toArray() {
        return Object.values(this.map);
    }
    ensureCountsAreIntegers() {
        for (const contextualizedStats of Object.values(this.map)) {
            contextualizedStats.ensureCountsAreIntegers();
        }
    }
    addTrace(trace, sizeEstimator) {
        this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);
    }
    getContextualizedStats(trace, sizeEstimator) {
        const statsContext = {
            clientName: trace.clientName,
            clientVersion: trace.clientVersion,
        };
        const statsContextKey = JSON.stringify(statsContext);
        const existing = this.map[statsContextKey];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes +=
            20 +
                estimatedBytesForString(trace.clientName) +
                estimatedBytesForString(trace.clientVersion);
        const contextualizedStats = new OurContextualizedStats(statsContext);
        this.map[statsContextKey] = contextualizedStats;
        return contextualizedStats;
    }
}
export class OurContextualizedStats {
    constructor(context) {
        this.context = context;
        this.queryLatencyStats = new OurQueryLatencyStats();
        this.perTypeStat = Object.create(null);
    }
    ensureCountsAreIntegers() {
        for (const typeStat of Object.values(this.perTypeStat)) {
            typeStat.ensureCountsAreIntegers();
        }
    }
    addTrace(trace, sizeEstimator) {
        const { fieldExecutionWeight } = trace;
        if (!fieldExecutionWeight) {
            this.queryLatencyStats.requestsWithoutFieldInstrumentation++;
        }
        this.queryLatencyStats.requestCount++;
        if (trace.fullQueryCacheHit) {
            this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);
            this.queryLatencyStats.cacheHits++;
        }
        else {
            this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);
        }
        if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {
            switch (trace.cachePolicy.scope) {
                case Trace.CachePolicy.Scope.PRIVATE:
                    this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
                    break;
                case Trace.CachePolicy.Scope.PUBLIC:
                    this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);
                    break;
            }
        }
        if (trace.persistedQueryHit) {
            this.queryLatencyStats.persistedQueryHits++;
        }
        if (trace.persistedQueryRegister) {
            this.queryLatencyStats.persistedQueryMisses++;
        }
        if (trace.forbiddenOperation) {
            this.queryLatencyStats.forbiddenOperationCount++;
        }
        if (trace.registeredOperation) {
            this.queryLatencyStats.registeredOperationCount++;
        }
        let hasError = false;
        const traceNodeStats = (node, path) => {
            if (node.error?.length) {
                hasError = true;
                let currPathErrorStats = this.queryLatencyStats.rootErrorStats;
                path.toArray().forEach((subPath) => {
                    currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);
                });
                currPathErrorStats.requestsWithErrorsCount += 1;
                currPathErrorStats.errorsCount += node.error.length;
            }
            if (fieldExecutionWeight) {
                const fieldName = node.originalFieldName || node.responseName;
                if (node.parentType &&
                    fieldName &&
                    node.type &&
                    node.endTime != null &&
                    node.startTime != null &&
                    node.endTime >= node.startTime) {
                    const typeStat = this.getTypeStat(node.parentType, sizeEstimator);
                    const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);
                    fieldStat.errorsCount += node.error?.length ?? 0;
                    fieldStat.observedExecutionCount++;
                    fieldStat.estimatedExecutionCount += fieldExecutionWeight;
                    fieldStat.requestsWithErrorsCount +=
                        (node.error?.length ?? 0) > 0 ? 1 : 0;
                    fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);
                }
            }
            return false;
        };
        iterateOverTrace(trace, traceNodeStats, true);
        if (hasError) {
            this.queryLatencyStats.requestsWithErrorsCount++;
        }
    }
    getTypeStat(parentType, sizeEstimator) {
        const existing = this.perTypeStat[parentType];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes += estimatedBytesForString(parentType);
        const typeStat = new OurTypeStat();
        this.perTypeStat[parentType] = typeStat;
        return typeStat;
    }
}
class OurQueryLatencyStats {
    constructor() {
        this.latencyCount = new DurationHistogram();
        this.requestCount = 0;
        this.requestsWithoutFieldInstrumentation = 0;
        this.cacheHits = 0;
        this.persistedQueryHits = 0;
        this.persistedQueryMisses = 0;
        this.cacheLatencyCount = new DurationHistogram();
        this.rootErrorStats = new OurPathErrorStats();
        this.requestsWithErrorsCount = 0;
        this.publicCacheTtlCount = new DurationHistogram();
        this.privateCacheTtlCount = new DurationHistogram();
        this.registeredOperationCount = 0;
        this.forbiddenOperationCount = 0;
    }
}
class OurPathErrorStats {
    constructor() {
        this.children = Object.create(null);
        this.errorsCount = 0;
        this.requestsWithErrorsCount = 0;
    }
    getChild(subPath, sizeEstimator) {
        const existing = this.children[subPath];
        if (existing) {
            return existing;
        }
        const child = new OurPathErrorStats();
        this.children[subPath] = child;
        sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;
        return child;
    }
}
class OurTypeStat {
    constructor() {
        this.perFieldStat = Object.create(null);
    }
    getFieldStat(fieldName, returnType, sizeEstimator) {
        const existing = this.perFieldStat[fieldName];
        if (existing) {
            return existing;
        }
        sizeEstimator.bytes +=
            estimatedBytesForString(fieldName) +
                estimatedBytesForString(returnType) +
                10;
        const fieldStat = new OurFieldStat(returnType);
        this.perFieldStat[fieldName] = fieldStat;
        return fieldStat;
    }
    ensureCountsAreIntegers() {
        for (const fieldStat of Object.values(this.perFieldStat)) {
            fieldStat.ensureCountsAreIntegers();
        }
    }
}
class OurFieldStat {
    constructor(returnType) {
        this.returnType = returnType;
        this.errorsCount = 0;
        this.observedExecutionCount = 0;
        this.estimatedExecutionCount = 0;
        this.requestsWithErrorsCount = 0;
        this.latencyCount = new DurationHistogram();
    }
    ensureCountsAreIntegers() {
        this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);
    }
}
function estimatedBytesForString(s) {
    return 2 + Buffer.byteLength(s);
}
//# sourceMappingURL=stats.js.mapª/dist/esm/ApolloServer.d.ts≈∞import type { Logger } from '@apollo/utils.logger';
import { Resolvable } from '@josephg/resolvable';
import { DocumentNode, GraphQLFieldResolver, GraphQLFormattedError, GraphQLSchema, ParseOptions, TypedQueryDocumentNode, ValidationRule } from 'graphql';
import { type KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { ApolloServerPlugin, BaseContext, GraphQLRequest, GraphQLResponse, HTTPGraphQLRequest, HTTPGraphQLResponse, LandingPage, ApolloConfig, ApolloServerOptions, DocumentStore, PersistedQueryOptions, ContextThunk, HTTPGraphQLHead } from './externalTypes/index.js';
import { SchemaManager } from './utils/schemaManager.js';
import type { WithRequired } from '@apollo/utils.withrequired';
import type { GatewayExecutor } from '@apollo/server-gateway-interface';
import type { GraphQLExperimentalIncrementalExecutionResults } from './incrementalDeliveryPolyfill.js';
import type { ExecuteOperationOptions, VariableValues } from './externalTypes/graphql.js';
export declare type SchemaDerivedData = {
    schema: GraphQLSchema;
    documentStore: DocumentStore | null;
};
declare type RunningServerState = {
    schemaManager: SchemaManager;
    landingPage: LandingPage | null;
};
declare type ServerState = {
    phase: 'initialized';
    schemaManager: SchemaManager;
} | {
    phase: 'starting';
    barrier: Resolvable<void>;
    schemaManager: SchemaManager;
    startedInBackground: boolean;
} | {
    phase: 'failed to start';
    error: Error;
} | ({
    phase: 'started';
    drainServers: (() => Promise<void>) | null;
    toDispose: (() => Promise<void>)[];
    toDisposeLast: (() => Promise<void>)[];
} & RunningServerState) | ({
    phase: 'draining';
    barrier: Resolvable<void>;
} & RunningServerState) | {
    phase: 'stopping';
    barrier: Resolvable<void>;
} | {
    phase: 'stopped';
    stopError: Error | null;
};
export interface ApolloServerInternals<TContext extends BaseContext> {
    state: ServerState;
    gatewayExecutor: GatewayExecutor | null;
    formatError?: (formattedError: GraphQLFormattedError, error: unknown) => GraphQLFormattedError;
    includeStacktraceInErrorResponses: boolean;
    persistedQueries?: WithRequired<PersistedQueryOptions, 'cache'>;
    nodeEnv: string;
    allowBatchedHttpRequests: boolean;
    apolloConfig: ApolloConfig;
    plugins: ApolloServerPlugin<TContext>[];
    parseOptions: ParseOptions;
    stopOnTerminationSignals: boolean | undefined;
    csrfPreventionRequestHeaders: string[] | null;
    rootValue?: ((parsedQuery: DocumentNode) => unknown) | unknown;
    validationRules: Array<ValidationRule>;
    fieldResolver?: GraphQLFieldResolver<any, TContext>;
    __testing_incrementalExecutionResults?: GraphQLExperimentalIncrementalExecutionResults;
}
export declare class ApolloServer<in out TContext extends BaseContext = BaseContext> {
    private internals;
    readonly cache: KeyValueCache<string>;
    readonly logger: Logger;
    constructor(config: ApolloServerOptions<TContext>);
    start(): Promise<void>;
    startInBackgroundHandlingStartupErrorsByLoggingAndFailingAllRequests(): void;
    private _start;
    private maybeRegisterTerminationSignalHandlers;
    private _ensureStarted;
    assertStarted(expressionForError: string): void;
    private logStartupError;
    private static constructSchema;
    private static generateSchemaDerivedData;
    stop(): Promise<void>;
    private addDefaultPlugins;
    addPlugin(plugin: ApolloServerPlugin<TContext>): void;
    executeHTTPGraphQLRequest({ httpGraphQLRequest, context, }: {
        httpGraphQLRequest: HTTPGraphQLRequest;
        context: ContextThunk<TContext>;
    }): Promise<HTTPGraphQLResponse>;
    private errorResponse;
    private prefersHTML;
    executeOperation<TData = Record<string, unknown>, TVariables extends VariableValues = VariableValues>(this: ApolloServer<BaseContext>, request: Omit<GraphQLRequest<TVariables>, 'query'> & {
        query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;
    }): Promise<GraphQLResponse<TData>>;
    executeOperation<TData = Record<string, unknown>, TVariables extends VariableValues = VariableValues>(request: Omit<GraphQLRequest<TVariables>, 'query'> & {
        query?: string | DocumentNode | TypedQueryDocumentNode<TData, TVariables>;
    }, options?: ExecuteOperationOptions<TContext>): Promise<GraphQLResponse<TData>>;
}
export declare function internalExecuteOperation<TContext extends BaseContext>({ server, graphQLRequest, internals, schemaDerivedData, sharedResponseHTTPGraphQLHead, }: {
    server: ApolloServer<TContext>;
    graphQLRequest: GraphQLRequest;
    internals: ApolloServerInternals<TContext>;
    schemaDerivedData: SchemaDerivedData;
    sharedResponseHTTPGraphQLHead: HTTPGraphQLHead | null;
}, options: ExecuteOperationOptions<TContext>): Promise<GraphQLResponse>;
export declare type ImplicitlyInstallablePlugin<TContext extends BaseContext> = ApolloServerPlugin<TContext> & {
    __internal_installed_implicitly__: boolean;
};
export declare function isImplicitlyInstallablePlugin<TContext extends BaseContext>(p: ApolloServerPlugin<TContext>): p is ImplicitlyInstallablePlugin<TContext>;
export declare const MEDIA_TYPES: {
    APPLICATION_JSON: string;
    APPLICATION_GRAPHQL_RESPONSE_JSON: string;
    MULTIPART_MIXED_NO_DEFER_SPEC: string;
    MULTIPART_MIXED_EXPERIMENTAL: string;
    TEXT_HTML: string;
};
export declare function chooseContentTypeForSingleResultResponse(head: HTTPGraphQLHead): string | null;
export {};
//# sourceMappingURL=ApolloServer.d.ts.mapŸ*/dist/esm/utils/computeCoreSchemaHash.d.tsƒzexport declare function computeCoreSchemaHash(schema: string): string;
//# sourceMappingURL=computeCoreSchemaHash.d.ts.mapŸ*/dist/esm/plugin/usageReporting/stats.d.ts≈Äimport { type google, type IContextualizedStats, type IFieldStat, type IPathErrorStats, type IQueryLatencyStats, type IReport, type IStatsContext, type ITracesAndStats, type ITypeStat, type ReportHeader, Trace } from '@apollo/usage-reporting-protobuf';
import type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';
import { DurationHistogram } from './durationHistogram.js';
export declare class SizeEstimator {
    bytes: number;
}
export declare class OurReport implements Required<IReport> {
    readonly header: ReportHeader;
    constructor(header: ReportHeader);
    readonly tracesPerQuery: Record<string, OurTracesAndStats>;
    endTime: google.protobuf.ITimestamp | null;
    operationCount: number;
    readonly sizeEstimator: SizeEstimator;
    ensureCountsAreIntegers(): void;
    addTrace({ statsReportKey, trace, asTrace, referencedFieldsByType, maxTraceBytes, }: {
        statsReportKey: string;
        trace: Trace;
        asTrace: boolean;
        referencedFieldsByType: ReferencedFieldsByType;
        maxTraceBytes?: number;
    }): void;
    private getTracesAndStats;
}
declare class OurTracesAndStats implements Required<ITracesAndStats> {
    readonly referencedFieldsByType: ReferencedFieldsByType;
    constructor(referencedFieldsByType: ReferencedFieldsByType);
    readonly trace: Uint8Array[];
    readonly statsWithContext: StatsByContext;
    readonly internalTracesContributingToStats: Uint8Array[];
    ensureCountsAreIntegers(): void;
}
declare class StatsByContext {
    readonly map: {
        [k: string]: OurContextualizedStats;
    };
    toArray(): IContextualizedStats[];
    ensureCountsAreIntegers(): void;
    addTrace(trace: Trace, sizeEstimator: SizeEstimator): void;
    private getContextualizedStats;
}
export declare class OurContextualizedStats implements Required<IContextualizedStats> {
    readonly context: IStatsContext;
    queryLatencyStats: OurQueryLatencyStats;
    perTypeStat: {
        [k: string]: OurTypeStat;
    };
    constructor(context: IStatsContext);
    ensureCountsAreIntegers(): void;
    addTrace(trace: Trace, sizeEstimator: SizeEstimator): void;
    getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat;
}
declare class OurQueryLatencyStats implements Required<IQueryLatencyStats> {
    latencyCount: DurationHistogram;
    requestCount: number;
    requestsWithoutFieldInstrumentation: number;
    cacheHits: number;
    persistedQueryHits: number;
    persistedQueryMisses: number;
    cacheLatencyCount: DurationHistogram;
    rootErrorStats: OurPathErrorStats;
    requestsWithErrorsCount: number;
    publicCacheTtlCount: DurationHistogram;
    privateCacheTtlCount: DurationHistogram;
    registeredOperationCount: number;
    forbiddenOperationCount: number;
}
declare class OurPathErrorStats implements Required<IPathErrorStats> {
    children: {
        [k: string]: OurPathErrorStats;
    };
    errorsCount: number;
    requestsWithErrorsCount: number;
    getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats;
}
declare class OurTypeStat implements Required<ITypeStat> {
    perFieldStat: {
        [k: string]: OurFieldStat;
    };
    getFieldStat(fieldName: string, returnType: string, sizeEstimator: SizeEstimator): OurFieldStat;
    ensureCountsAreIntegers(): void;
}
declare class OurFieldStat implements Required<IFieldStat> {
    readonly returnType: string;
    errorsCount: number;
    observedExecutionCount: number;
    estimatedExecutionCount: number;
    requestsWithErrorsCount: number;
    latencyCount: DurationHistogram;
    constructor(returnType: string);
    ensureCountsAreIntegers(): void;
}
export {};
//# sourceMappingURL=stats.d.ts.mapŸ"/dist/esm/determineApolloConfig.js≈Ìimport { createHash } from '@apollo/utils.createhash';
export function determineApolloConfig(input) {
    const apolloConfig = {};
    const { APOLLO_KEY, APOLLO_GRAPH_REF, APOLLO_GRAPH_ID, APOLLO_GRAPH_VARIANT, } = process.env;
    if (input?.key) {
        apolloConfig.key = input.key;
    }
    else if (APOLLO_KEY) {
        apolloConfig.key = APOLLO_KEY;
    }
    if (apolloConfig.key) {
        apolloConfig.keyHash = createHash('sha512')
            .update(apolloConfig.key)
            .digest('hex');
    }
    if (input?.graphRef) {
        apolloConfig.graphRef = input.graphRef;
    }
    else if (APOLLO_GRAPH_REF) {
        apolloConfig.graphRef = APOLLO_GRAPH_REF;
    }
    const graphId = input?.graphId ?? APOLLO_GRAPH_ID;
    const graphVariant = input?.graphVariant ?? APOLLO_GRAPH_VARIANT;
    if (apolloConfig.graphRef) {
        if (graphId) {
            throw new Error('Cannot specify both graph ref and graph ID. Please use ' +
                '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph ID.');
        }
        if (graphVariant) {
            throw new Error('Cannot specify both graph ref and graph variant. Please use ' +
                '`apollo.graphRef` or `APOLLO_GRAPH_REF` without also setting the graph variant.');
        }
    }
    else if (graphId) {
        apolloConfig.graphRef = graphVariant
            ? `${graphId}@${graphVariant}`
            : graphId;
    }
    return apolloConfig;
}
//# sourceMappingURL=determineApolloConfig.js.mapŸ3/dist/cjs/plugin/usageReporting/traceDetails.js.map≈’{"version":3,"file":"traceDetails.js","sourceRoot":"","sources":["../../../../src/plugin/usageReporting/traceDetails.ts"],"names":[],"mappings":";;;AAAA,+EAAyD;AAUzD,SAAgB,gBAAgB,CAC9B,SAA8B,EAC9B,kBAAyC,EACzC,eAAwB;IAExB,MAAM,OAAO,GAAG,IAAI,gCAAK,CAAC,OAAO,EAAE,CAAC;IACpC,MAAM,iBAAiB,GAAG,CAAC,GAAG,EAAE;QAC9B,IAAI,kBAAkB,IAAI,WAAW,IAAI,kBAAkB,EAAE;YAC3D,MAAM,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YAC5C,IAAI;gBAEF,MAAM,iBAAiB,GAAG,kBAAkB,CAAC,SAAS,CAAC;oBACrD,SAAS,EAAE,SAAS;oBACpB,eAAe,EAAE,eAAe;iBACjC,CAAC,CAAC;gBACH,OAAO,sBAAsB,CAAC,YAAY,EAAE,iBAAiB,CAAC,CAAC;aAChE;YAAC,OAAO,CAAC,EAAE;gBAGV,OAAO,iCAAiC,CAAC,YAAY,CAAC,CAAC;aACxD;SACF;aAAM;YACL,OAAO,SAAS,CAAC;SAClB;IACH,CAAC,CAAC,EAAE,CAAC;IAOL,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC9C,IACE,CAAC,kBAAkB;YACnB,CAAC,MAAM,IAAI,kBAAkB,IAAI,kBAAkB,CAAC,IAAI,CAAC;YACzD,CAAC,KAAK,IAAI,kBAAkB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC;YACxD,CAAC,aAAa,IAAI,kBAAkB;gBAIlC,kBAAkB,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YAChD,CAAC,WAAW,IAAI,kBAAkB;gBAChC,CAAC,kBAAkB,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,EAC/C;YAIA,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;SACnC;aAAM;YACL,IAAI;gBACF,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC;oBAC1B,OAAO,iBAAiB,CAAC,IAAI,CAAC,KAAK,WAAW;wBAC5C,CAAC,CAAC,EAAE;wBACJ,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;aAC/C;YAAC,OAAO,CAAC,EAAE;gBACV,OAAO,CAAC,aAAc,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAC3C,mCAAmC,CACpC,CAAC;aACH;SACF;IACH,CAAC,CAAC,CAAC;IACH,OAAO,OAAO,CAAC;AACjB,CAAC;AA9DD,4CA8DC;AAED,SAAS,iCAAiC,CACxC,aAAuB;IAEvB,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC9C,aAAa,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC7B,iBAAiB,CAAC,IAAI,CAAC,GAAG,4BAA4B,CAAC;IACzD,CAAC,CAAC,CAAC;IACH,OAAO,iBAAiB,CAAC;AAC3B,CAAC;AAID,SAAS,sBAAsB,CAC7B,YAA2B,EAC3B,iBAAsC;IAEtC,MAAM,gBAAgB,GAAwB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAClE,YAAY,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAC5B,gBAAgB,CAAC,IAAI,CAAC,GAAG,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACnD,CAAC,CAAC,CAAC;IACH,OAAO,gBAAgB,CAAC;AAC1B,CAAC"}∫/src/externalTypes/http.ts≈+/**
 * This file exports types related to GraphQL execution with respect to HTTP.
 * These types define the inputs and outputs for `executeHTTPGraphQLRequest` and
 * are most interesting for integration authors.
 */
import type { HeaderMap } from '../utils/HeaderMap.js';

export interface HTTPGraphQLRequest {
  // capitalized (GET, POST, etc)
  method: string;
  // lowercase header name, multiple headers joined with ', ' like Headers.get
  // does
  headers: HeaderMap;
  /**
   * The part of the URL after the question mark (not including the #fragment),
   * or the empty string if there is no question mark. Including the question
   * mark in this string is allowed but not required. Do not %-decode this
   * string. You can get this from a standard Node request with
   * `url.parse(request.url).search ?? ''`.
   */
  search: string;
  // read by your body-parser or whatever. we poke at it to make it into
  // the right real type.
  body: unknown;
}

export interface HTTPGraphQLHead {
  status?: number;
  headers: HeaderMap;
}

/**
 * Here we use `string`s for the response body since the response can be either
 * HTML (for the landing page - see `executeHTTPGraphQLRequest`) or JSON (for a
 * GraphQL response). Based on `headers` and `method` on the request, we know
 * how to correctly interpret the response body.
 */
export type HTTPGraphQLResponseBody =
  | { kind: 'complete'; string: string }
  | { kind: 'chunked'; asyncIterator: AsyncIterableIterator<string> };

export type HTTPGraphQLResponse = HTTPGraphQLHead & {
  body: HTTPGraphQLResponseBody;
};
Ω/src/externalTypes/plugins.ts≈#Ö/**
 * The types defined in this file are useful to plugin authors. In particular,
 * defining a plugin as an `ApolloServerPlugin` will provide typings for all of
 * the hooks that are available to a plugin.
 */
import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { Logger } from '@apollo/utils.logger';
import type { GraphQLError, GraphQLResolveInfo, GraphQLSchema } from 'graphql';
import type { ApolloConfig } from './constructor.js';
import type { BaseContext } from './context.js';
import type { GraphQLResponse } from './graphql.js';
import type { GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult } from './incrementalDeliveryPolyfill.js';
import type {
  GraphQLRequestContext,
  GraphQLRequestContextDidEncounterErrors,
  GraphQLRequestContextDidEncounterSubsequentErrors,
  GraphQLRequestContextDidResolveOperation,
  GraphQLRequestContextDidResolveSource,
  GraphQLRequestContextExecutionDidStart,
  GraphQLRequestContextParsingDidStart,
  GraphQLRequestContextResponseForOperation,
  GraphQLRequestContextValidationDidStart,
  GraphQLRequestContextWillSendResponse,
  GraphQLRequestContextWillSendSubsequentPayload,
} from './requestPipeline.js';

export interface GraphQLServerContext {
  readonly logger: Logger;
  readonly cache: KeyValueCache<string>;

  schema: GraphQLSchema;
  apollo: ApolloConfig;
  startedInBackground: boolean;
}

export interface GraphQLSchemaContext {
  apiSchema: GraphQLSchema;
  coreSupergraphSdl?: string;
}

export interface ApolloServerPlugin<
  in TContext extends BaseContext = BaseContext,
> {
  // Called once on server startup, after the schema has been loaded.
  serverWillStart?(
    service: GraphQLServerContext,
  ): Promise<GraphQLServerListener | void>;

  // Called once per request, before parsing or validation of the request has
  // occurred. This hook can return an object of more fine-grained hooks (see
  // `GraphQLRequestListener`) which pertain to the lifecycle of the request.
  requestDidStart?(
    requestContext: GraphQLRequestContext<TContext>,
  ): Promise<GraphQLRequestListener<TContext> | void>;

  /**
   * "Unexpected" errors do not include more common errors like validation,
   * parsing, or graphql execution errors. Rather, an unexpected error might
   * occur when a plugin hook throws unexpectedly or a bug in Apollo Server is
   * encountered. Notably, when errors like this occur, the error is masked to
   * the client.
   */
  unexpectedErrorProcessingRequest?({
    requestContext,
    error,
  }: {
    requestContext: GraphQLRequestContext<TContext>;
    error: Error;
  }): Promise<void>;
  // Called specifically when the user-provided `context` function throws an
  // error.
  contextCreationDidFail?({ error }: { error: Error }): Promise<void>;
  /**
   * This hook is called any time a "Bad Request" error is thrown during request
   * execution. This includes CSRF prevention and malformed requests (e.g.
   * incorrect headers, invalid JSON body, or invalid search params for GET),
   * but does not include malformed GraphQL.
   */
  invalidRequestWasReceived?({ error }: { error: Error }): Promise<void>;
  // Called on startup fail. This can occur if the schema fails to load or if a
  // `serverWillStart` or `renderLandingPage` hook throws.
  startupDidFail?({ error }: { error: Error }): Promise<void>;
}

export interface GraphQLServerListener {
  // Called on server startup after a successful schema load and on successful
  // schema updates when running in `gateway` mode.
  schemaDidLoadOrUpdate?(schemaContext: GraphQLSchemaContext): void;

  // When your server is stopped (by calling `stop()` or via the
  // `SIGINT`/`SIGTERM` handlers), Apollo Server first awaits all `drainServer`
  // hooks in parallel. GraphQL operations can still execute while `drainServer`
  // is in progress. A typical use is to stop listening for new connections and
  // wait until all current connections are idle. The built-in
  // ApolloServerPluginDrainHttpServer implements this method.
  drainServer?(): Promise<void>;

  // When your server is stopped (by calling `stop()` or via the
  // `SIGINT`/`SIGTERM` handlers) then (after the `drainServer` phase finishes)
  // Apollo Server transitions into a state where no new operations will run and
  // then awaits all `drainServer` hooks in parallel. A typical use is to flush
  // outstanding observability data.
  serverWillStop?(): Promise<void>;

  // At most one plugin's serverWillStart may return a GraphQLServerListener
  // with this method. If one does, it is called once on server startup and the
  // page it returns is served to clients with `accept: text/html` headers. This
  // is an intentionally simple API; if you want to do something fancy to serve
  // a landing page, you probably should just define a handler in your web
  // framework.
  renderLandingPage?(): Promise<LandingPage>;
}

// The page served to clients with `accept: text/html` headers.
export interface LandingPage {
  html: string;
}

export type GraphQLRequestListenerParsingDidEnd = (
  err?: Error,
) => Promise<void>;
export type GraphQLRequestListenerValidationDidEnd = (
  err?: ReadonlyArray<Error>,
) => Promise<void>;
export type GraphQLRequestListenerExecutionDidEnd = (
  err?: Error,
) => Promise<void>;
export type GraphQLRequestListenerDidResolveField = (
  error: Error | null,
  result?: any,
) => void;

export interface GraphQLRequestListener<TContext extends BaseContext> {
  didResolveSource?(
    requestContext: GraphQLRequestContextDidResolveSource<TContext>,
  ): Promise<void>;

  parsingDidStart?(
    requestContext: GraphQLRequestContextParsingDidStart<TContext>,
  ): Promise<GraphQLRequestListenerParsingDidEnd | void>;

  validationDidStart?(
    requestContext: GraphQLRequestContextValidationDidStart<TContext>,
  ): Promise<GraphQLRequestListenerValidationDidEnd | void>;

  didResolveOperation?(
    requestContext: GraphQLRequestContextDidResolveOperation<TContext>,
  ): Promise<void>;

  didEncounterErrors?(
    requestContext: GraphQLRequestContextDidEncounterErrors<TContext>,
  ): Promise<void>;

  // If this hook is defined, it is invoked immediately before GraphQL execution
  // would take place. If its return value resolves to a non-null
  // GraphQLResponse, that result is used instead of executing the query.
  // Hooks from different plugins are invoked in series and the first non-null
  // response is used.
  responseForOperation?(
    requestContext: GraphQLRequestContextResponseForOperation<TContext>,
  ): Promise<GraphQLResponse | null>;

  // Note that in the case of incremental delivery, the end hook gets called
  // when the initial response is ready to go: further execution can still occur.
  executionDidStart?(
    requestContext: GraphQLRequestContextExecutionDidStart<TContext>,
  ): Promise<GraphQLRequestExecutionListener<TContext> | void>;

  // Note that in the case of incremental delivery, this is called when the
  // initial response is ready to go.
  willSendResponse?(
    requestContext: GraphQLRequestContextWillSendResponse<TContext>,
  ): Promise<void>;

  didEncounterSubsequentErrors?(
    requestContext: GraphQLRequestContextDidEncounterSubsequentErrors<TContext>,
    errors: ReadonlyArray<GraphQLError>,
  ): Promise<void>;

  // You can use hasNext to tell if this is the end or not.
  willSendSubsequentPayload?(
    requestContext: GraphQLRequestContextWillSendSubsequentPayload<TContext>,
    payload: GraphQLExperimentalFormattedSubsequentIncrementalExecutionResult,
  ): Promise<void>;
}

/**
 * This is an object form of the parameters received by typical
 * `graphql-js` resolvers.  The function type is `GraphQLFieldResolver`
 * and normally uses positional parameters.  In order to facilitate better
 * ergonomics in the Apollo Server plugin API, these have been converted to
 * named properties on the object using their names from the upstream
 * `GraphQLFieldResolver` type signature.  Ergonomic wins, in this case,
 * include not needing to have three unused variables in scope just because
 * there was a need to access the `info` property in a wrapped plugin.
 */
export type GraphQLFieldResolverParams<
  TSource,
  TContext,
  TArgs = { [argName: string]: any },
> = {
  source: TSource;
  args: TArgs;
  contextValue: TContext;
  info: GraphQLResolveInfo;
};

export interface GraphQLRequestExecutionListener<TContext extends BaseContext> {
  executionDidEnd?: GraphQLRequestListenerExecutionDidEnd;
  // willResolveField is not async because we've observed that it already has
  // quite a performance impact on execution even without involving the Promise
  // queue. If we can come up with ways to alleviate the burden (eg having an
  // uninstrumented schema and an instrumented schema and only using the
  // instrumented schema for a subset of operations that need detailed
  // performance traces) we could be happier supporting async willResolveField.
  willResolveField?(
    fieldResolverParams: GraphQLFieldResolverParams<any, TContext>,
  ): GraphQLRequestListenerDidResolveField | void;
}
Ÿ-/dist/esm/plugin/drainHttpServer/index.js.map≈«{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/drainHttpServer/index.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,OAAO,EAAE,MAAM,gBAAgB,CAAC;AAuBzC,MAAM,UAAU,iCAAiC,CAC/C,OAAiD;IAEjD,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAChD,OAAO;QACL,KAAK,CAAC,eAAe;YACnB,OAAO;gBACL,KAAK,CAAC,WAAW;oBACf,MAAM,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,qBAAqB,IAAI,KAAM,CAAC,CAAC;gBAC9D,CAAC;aACF,CAAC;QACJ,CAAC;KACF,CAAC;AACJ,CAAC"}Ÿ9/dist/esm/plugin/landingPage/default/getEmbeddedHTML.d.ts≈ïimport type { ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions, LandingPageConfig } from './types';
export declare const getEmbeddedExplorerHTML: (version: string, config: ApolloServerPluginEmbeddedLandingPageProductionDefaultOptions) => string;
export declare const getEmbeddedSandboxHTML: (version: string, config: LandingPageConfig) => string;
//# sourceMappingURL=getEmbeddedHTML.d.ts.mapŸ-/dist/esm/plugin/schemaReporting/index.js.map≈ë{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../src/plugin/schemaReporting/index.ts"],"names":[],"mappings":"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"}æ/dist/cjs/utils/invokeHooks.js≈>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeHooksUntilDefinedAndNonNull = exports.invokeSyncDidStartHook = exports.invokeDidStartHook = void 0;
const isDefined_js_1 = require("./isDefined.js");
async function invokeDidStartHook(targets, hook) {
    const didEndHooks = (await Promise.all(targets.map((target) => hook(target)))).filter(isDefined_js_1.isDefined);
    didEndHooks.reverse();
    return async (...args) => {
        for (const didEndHook of didEndHooks) {
            didEndHook(...args);
        }
    };
}
exports.invokeDidStartHook = invokeDidStartHook;
function invokeSyncDidStartHook(targets, hook) {
    const didEndHooks = targets
        .map((target) => hook(target))
        .filter(isDefined_js_1.isDefined);
    didEndHooks.reverse();
    return (...args) => {
        for (const didEndHook of didEndHooks) {
            didEndHook(...args);
        }
    };
}
exports.invokeSyncDidStartHook = invokeSyncDidStartHook;
async function invokeHooksUntilDefinedAndNonNull(targets, hook) {
    for (const target of targets) {
        const value = await hook(target);
        if (value != null) {
            return value;
        }
    }
    return null;
}
exports.invokeHooksUntilDefinedAndNonNull = invokeHooksUntilDefinedAndNonNull;
//# sourceMappingURL=invokeHooks.js.map
‡«/index.d.tsÅ§import * as vue_demi from 'vue-demi';
import { WatchOptionsBase, Ref, ComputedRef, WritableComputedRef, WatchSource, ComputedGetter, WritableComputedOptions, ShallowUnwrapRef as ShallowUnwrapRef$1, WatchOptions, UnwrapRef, ToRefs, WatchCallback, WatchStopHandle } from 'vue-demi';

declare function computedEager<T>(fn: () => T, options?: WatchOptionsBase): Readonly<Ref<T>>;

interface ComputedWithControlRefExtra {
    /**
     * Force update the computed value.
     */
    trigger(): void;
}
interface ComputedRefWithControl<T> extends ComputedRef<T>, ComputedWithControlRefExtra {
}
interface WritableComputedRefWithControl<T> extends WritableComputedRef<T>, ComputedWithControlRefExtra {
}
declare function computedWithControl<T, S>(source: WatchSource<S> | WatchSource<S>[], fn: ComputedGetter<T>): ComputedRefWithControl<T>;
declare function computedWithControl<T, S>(source: WatchSource<S> | WatchSource<S>[], fn: WritableComputedOptions<T>): WritableComputedRefWithControl<T>;

declare type EventHookOn<T = any> = (fn: (param: T) => void) => {
    off: () => void;
};
declare type EventHookOff<T = any> = (fn: (param: T) => void) => void;
declare type EventHookTrigger<T = any> = (param: T) => void;
interface EventHook<T = any> {
    on: EventHookOn<T>;
    off: EventHookOff<T>;
    trigger: EventHookTrigger<T>;
}
/**
 * Utility for creating event hooks
 *
 * @see https://vueuse.org/createEventHook
 */
declare function createEventHook<T = any>(): EventHook<T>;

declare type CreateGlobalStateReturn<T> = () => T;
/**
 * Keep states in the global scope to be reusable across Vue instances.
 *
 * @see https://vueuse.org/createGlobalState
 * @param stateFactory A factory function to create the state
 */
declare function createGlobalState<T>(stateFactory: () => T): CreateGlobalStateReturn<T>;

/**
 * Create global state that can be injected into components.
 *
 * @see https://vueuse.org/createInjectionState
 *
 */
declare function createInjectionState<Arguments extends Array<any>, Return>(composable: (...args: Arguments) => Return): readonly [useProvidingState: (...args: Arguments) => void, useInjectedState: () => Return | undefined];

/**
 * Make a composable function usable with multiple Vue instances.
 *
 * @see https://vueuse.org/createSharedComposable
 */
declare function createSharedComposable<Fn extends ((...args: any[]) => any)>(composable: Fn): Fn;

interface ExtendRefOptions<Unwrap extends boolean = boolean> {
    /**
     * Is the extends properties enumerable
     *
     * @default false
     */
    enumerable?: boolean;
    /**
     * Unwrap for Ref properties
     *
     * @default true
     */
    unwrap?: Unwrap;
}
/**
 * Overload 1: Unwrap set to false
 */
declare function extendRef<R extends Ref<any>, Extend extends object, Options extends ExtendRefOptions<false>>(ref: R, extend: Extend, options?: Options): ShallowUnwrapRef$1<Extend> & R;
/**
 * Overload 2: Unwrap unset or set to true
 */
declare function extendRef<R extends Ref<any>, Extend extends object, Options extends ExtendRefOptions>(ref: R, extend: Extend, options?: Options): Extend & R;

declare const isClient: boolean;
declare const isDef: <T = any>(val?: T | undefined) => val is T;
declare const assert: (condition: boolean, ...infos: any[]) => void;
declare const isBoolean: (val: any) => val is boolean;
declare const isFunction: <T extends Function>(val: any) => val is T;
declare const isNumber: (val: any) => val is number;
declare const isString: (val: unknown) => val is string;
declare const isObject: (val: any) => val is object;
declare const isWindow: (val: any) => val is Window;
declare const now: () => number;
declare const timestamp: () => number;
declare const clamp: (n: number, min: number, max: number) => number;
declare const noop: () => void;
declare const rand: (min: number, max: number) => number;
declare const isIOS: boolean | "";
declare const hasOwn: <T extends object, K extends keyof T>(val: T, key: K) => key is K;

/**
 * Any function
 */
declare type Fn = () => void;
/**
 * A ref that allow to set null or undefined
 */
declare type RemovableRef<T> = Omit<Ref<T>, 'value'> & {
    get value(): T;
    set value(value: T | null | undefined);
};
/**
 * @deprecated Use `RemovableRef`
 */
declare type RemoveableRef<T> = RemovableRef<T>;
/**
 * Maybe it's a ref, or a plain value
 *
 * ```ts
 * type MaybeRef<T> = T | Ref<T>
 * ```
 */
declare type MaybeRef<T> = T | Ref<T>;
/**
 * Maybe it's a ref, or a plain value, or a getter function
 *
 * ```ts
 * type MaybeComputedRef<T> = (() => T) | T | Ref<T> | ComputedRef<T>
 * ```
 */
declare type MaybeComputedRef<T> = MaybeReadonlyRef<T> | MaybeRef<T>;
/**
 * Maybe it's a computed ref, or a getter function
 *
 * ```ts
 * type MaybeReadonlyRef<T> = (() => T) | ComputedRef<T>
 * ```
 */
declare type MaybeReadonlyRef<T> = (() => T) | ComputedRef<T>;
/**
 * Make all the nested attributes of an object or array to MaybeRef<T>
 *
 * Good for accepting options that will be wrapped with `reactive` or `ref`
 *
 * ```ts
 * UnwrapRef<DeepMaybeRef<T>> === T
 * ```
 */
declare type DeepMaybeRef<T> = T extends Ref<infer V> ? MaybeRef<V> : T extends Array<any> | object ? {
    [K in keyof T]: DeepMaybeRef<T[K]>;
} : MaybeRef<T>;
declare type Arrayable<T> = T[] | T;
/**
 * Infers the element type of an array
 */
declare type ElementOf<T> = T extends (infer E)[] ? E : never;
declare type ShallowUnwrapRef<T> = T extends Ref<infer P> ? P : T;
declare type Awaitable<T> = Promise<T> | T;
declare type ArgumentsType<T> = T extends (...args: infer U) => any ? U : never;
interface Pausable {
    /**
     * A ref indicate whether a pausable instance is active
     */
    isActive: Ref<boolean>;
    /**
     * Temporary pause the effect from executing
     */
    pause: Fn;
    /**
     * Resume the effects
     */
    resume: Fn;
}
interface Stoppable {
    /**
     * A ref indicate whether a stoppable instance is executing
     */
    isPending: Ref<boolean>;
    /**
     * Stop the effect from executing
     */
    stop: Fn;
    /**
     * Start the effects
     */
    start: Fn;
}
/**
 * @deprecated Use `Stoppable`
 */
declare type Stopable = Stoppable;
interface ConfigurableFlush {
    /**
     * Timing for monitoring changes, refer to WatchOptions for more details
     *
     * @default 'pre'
     */
    flush?: WatchOptions['flush'];
}
interface ConfigurableFlushSync {
    /**
     * Timing for monitoring changes, refer to WatchOptions for more details.
     * Unlike `watch()`, the default is set to `sync`
     *
     * @default 'sync'
     */
    flush?: WatchOptions['flush'];
}
declare type MapSources<T> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? V : never;
};
declare type MapOldSources<T, Immediate> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? Immediate extends true ? V | undefined : V : never;
};

declare type FunctionArgs<Args extends any[] = any[], Return = void> = (...args: Args) => Return;
interface FunctionWrapperOptions<Args extends any[] = any[], This = any> {
    fn: FunctionArgs<Args, This>;
    args: Args;
    thisArg: This;
}
declare type EventFilter<Args extends any[] = any[], This = any> = (invoke: Fn, options: FunctionWrapperOptions<Args, This>) => void;
interface ConfigurableEventFilter {
    /**
     * Filter for if events should to be received.
     *
     * @see https://vueuse.org/guide/config.html#event-filters
     */
    eventFilter?: EventFilter;
}
interface DebounceFilterOptions {
    /**
     * The maximum time allowed to be delayed before it's invoked.
     * In milliseconds.
     */
    maxWait?: MaybeComputedRef<number>;
}
/**
 * @internal
 */
declare function createFilterWrapper<T extends FunctionArgs>(filter: EventFilter, fn: T): T;
declare const bypassFilter: EventFilter;
/**
 * Create an EventFilter that debounce the events
 *
 * @param ms
 * @param options
 */
declare function debounceFilter(ms: MaybeComputedRef<number>, options?: DebounceFilterOptions): EventFilter<any[], any>;
/**
 * Create an EventFilter that throttle the events
 *
 * @param ms
 * @param [trailing=true]
 * @param [leading=true]
 */
declare function throttleFilter(ms: MaybeComputedRef<number>, trailing?: boolean, leading?: boolean): EventFilter<any[], any>;
/**
 * EventFilter that gives extra controls to pause and resume the filter
 *
 * @param extendFilter  Extra filter to apply when the PausableFilter is active, default to none
 *
 */
declare function pausableFilter(extendFilter?: EventFilter): Pausable & {
    eventFilter: EventFilter;
};

declare function __onlyVue3(name?: string): void;
declare function __onlyVue27Plus(name?: string): void;
declare const directiveHooks: {
    mounted: "mounted";
    updated: "updated";
    unmounted: "unmounted";
};

declare function promiseTimeout(ms: number, throwOnTimeout?: boolean, reason?: string): Promise<void>;
declare function identity<T>(arg: T): T;
interface SingletonPromiseReturn<T> {
    (): Promise<T>;
    /**
     * Reset current staled promise.
     * await it to have proper shutdown.
     */
    reset: () => Promise<void>;
}
/**
 * Create singleton promise function
 *
 * @example
 * ```
 * const promise = createSingletonPromise(async () => { ... })
 *
 * await promise()
 * await promise() // all of them will be bind to a single promise instance
 * await promise() // and be resolved together
 * ```
 */
declare function createSingletonPromise<T>(fn: () => Promise<T>): SingletonPromiseReturn<T>;
declare function invoke<T>(fn: () => T): T;
declare function containsProp(obj: object, ...props: string[]): boolean;
/**
 * Increase string a value with unit
 *
 * @example '2px' + 1 = '3px'
 * @example '15em' + (-2) = '13em'
 */
declare function increaseWithUnit(target: number, delta: number): number;
declare function increaseWithUnit(target: string, delta: number): string;
declare function increaseWithUnit(target: string | number, delta: number): string | number;
/**
 * Create a new subset object by giving keys
 *
 * @category Object
 */
declare function objectPick<O, T extends keyof O>(obj: O, keys: T[], omitUndefined?: boolean): Pick<O, T>;

/**
 * Shorthand for accessing `ref.value`
 */
declare function get<T>(ref: MaybeRef<T>): T;
declare function get<T, K extends keyof T>(ref: MaybeRef<T>, key: K): T[K];

declare function isDefined<T>(v: Ref<T>): v is Ref<Exclude<T, null | undefined>>;
declare function isDefined<T>(v: ComputedRef<T>): v is ComputedRef<Exclude<T, null | undefined>>;
declare function isDefined<T>(v: T): v is Exclude<T, null | undefined>;

declare function makeDestructurable<T extends Record<string, unknown>, A extends readonly any[]>(obj: T, arr: A): T & A;

declare type Reactified<T, Computed extends boolean> = T extends (...args: infer A) => infer R ? (...args: {
    [K in keyof A]: Computed extends true ? MaybeComputedRef<A[K]> : MaybeRef<A[K]>;
}) => ComputedRef<R> : never;
interface ReactifyOptions<T extends boolean> {
    /**
     * Accept passing a function as a reactive getter
     *
     * @default true
     */
    computedGetter?: T;
}
/**
 * Converts plain function into a reactive function.
 * The converted function accepts refs as it's arguments
 * and returns a ComputedRef, with proper typing.
 *
 * @param fn - Source function
 */
declare function reactify<T extends Function, K extends boolean = true>(fn: T, options?: ReactifyOptions<K>): Reactified<T, K>;

declare type ReactifyNested<T, Keys extends keyof T = keyof T, S extends boolean = true> = {
    [K in Keys]: T[K] extends (...args: any[]) => any ? Reactified<T[K], S> : T[K];
};
interface ReactifyObjectOptions<T extends boolean> extends ReactifyOptions<T> {
    /**
     * Includes names from Object.getOwnPropertyNames
     *
     * @default true
     */
    includeOwnProperties?: boolean;
}
/**
 * Apply `reactify` to an object
 */
declare function reactifyObject<T extends object, Keys extends keyof T>(obj: T, keys?: (keyof T)[]): ReactifyNested<T, Keys, true>;
declare function reactifyObject<T extends object, S extends boolean = true>(obj: T, options?: ReactifyObjectOptions<S>): ReactifyNested<T, keyof T, S>;

/**
 * Computed reactive object.
 */
declare function reactiveComputed<T extends {}>(fn: () => T): T;

/**
 * Reactively omit fields from a reactive object
 *
 * @see https://vueuse.org/reactiveOmit
 */
declare function reactiveOmit<T extends object, K extends keyof T>(obj: T, ...keys: (K | K[])[]): Omit<T, K>;

/**
 * Reactively pick fields from a reactive object
 *
 * @see https://vueuse.org/reactivePick
 */
declare function reactivePick<T extends object, K extends keyof T>(obj: T, ...keys: (K | K[])[]): {
    [S in K]: UnwrapRef<T[S]>;
};

/**
 * Create a ref which will be reset to the default value after some time.
 *
 * @see https://vueuse.org/refAutoReset
 * @param defaultValue The value which will be set.
 * @param afterMs      A zero-or-greater delay in milliseconds.
 */
declare function refAutoReset<T>(defaultValue: T, afterMs?: MaybeComputedRef<number>): Ref<T>;

/**
 * Debounce updates of a ref.
 *
 * @return A new debounced ref.
 */
declare function refDebounced<T>(value: Ref<T>, ms?: MaybeComputedRef<number>, options?: DebounceFilterOptions): Readonly<Ref<T>>;

/**
 * Apply default value to a ref.
 *
 * @param source source ref
 * @param targets
 */
declare function refDefault<T>(source: Ref<T | undefined | null>, defaultValue: T): Ref<T>;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param value Ref value to be watched with throttle effect
 * @param  delay  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param [trailing=true] if true, update the value again after the delay time is up
 * @param [leading=true] if true, update the value on the leading edge of the ms timeout
 */
declare function refThrottled<T>(value: Ref<T>, delay?: number, trailing?: boolean, leading?: boolean): Ref<T>;

interface ControlledRefOptions<T> {
    /**
     * Callback function before the ref changing.
     *
     * Returning `false` to dismiss the change.
     */
    onBeforeChange?: (value: T, oldValue: T) => void | boolean;
    /**
     * Callback function after the ref changed
     *
     * This happens synchronously, with less overhead compare to `watch`
     */
    onChanged?: (value: T, oldValue: T) => void;
}
/**
 * Explicitly define the deps of computed.
 *
 * @param source
 * @param fn
 */
declare function refWithControl<T>(initial: T, options?: ControlledRefOptions<T>): vue_demi.ShallowUnwrapRef<{
    get: (tracking?: boolean) => T;
    set: (value: T, triggering?: boolean) => void;
    untrackedGet: () => T;
    silentSet: (v: T) => void;
    peek: () => T;
    lay: (v: T) => void;
}> & vue_demi.Ref<T>;
/**
 * Alias for `refWithControl`
 */
declare const controlledRef: typeof refWithControl;

/**
 * Normalize value/ref/getter to `ref` or `computed`.
 */
declare function resolveRef<T>(r: MaybeComputedRef<T>): ComputedRef<T>;
declare function resolveRef<T>(r: MaybeRef<T>): Ref<T>;
declare function resolveRef<T>(r: T): Ref<T>;

/**
 * Get the value of value/ref/getter.
 */
declare function resolveUnref<T>(r: MaybeComputedRef<T>): T;

declare function set<T>(ref: Ref<T>, value: T): void;
declare function set<O extends object, K extends keyof O>(target: O, key: K, value: O[K]): void;

interface SyncRefOptions<L, R = L> extends ConfigurableFlushSync {
    /**
     * Watch deeply
     *
     * @default false
     */
    deep?: boolean;
    /**
     * Sync values immediately
     *
     * @default true
     */
    immediate?: boolean;
    /**
     * Direction of syncing. Value will be redefined if you define syncConvertors
     *
     * @default 'both'
     */
    direction?: 'ltr' | 'rtl' | 'both';
    /**
     * Custom transform function
     */
    transform?: {
        ltr?: (left: L) => R;
        rtl?: (right: R) => L;
    };
}
/**
 * Two-way refs synchronization.
 *
 * @param left
 * @param right
 */
declare function syncRef<L, R = L>(left: Ref<L>, right: Ref<R>, options?: SyncRefOptions<L, R>): () => void;

interface SyncRefsOptions extends ConfigurableFlushSync {
    /**
     * Watch deeply
     *
     * @default false
     */
    deep?: boolean;
    /**
     * Sync values immediately
     *
     * @default true
     */
    immediate?: boolean;
}
/**
 * Keep target ref(s) in sync with the source ref
 *
 * @param source source ref
 * @param targets
 */
declare function syncRefs<T>(source: WatchSource<T>, targets: Ref<T> | Ref<T>[], options?: SyncRefsOptions): vue_demi.WatchStopHandle;

/**
 * Converts ref to reactive.
 *
 * @see https://vueuse.org/toReactive
 * @param objectRef A ref of object
 */
declare function toReactive<T extends object>(objectRef: MaybeRef<T>): T;

/**
 * Extended `toRefs` that also accepts refs of an object.
 *
 * @see https://vueuse.org/toRefs
 * @param objectRef A ref or normal object or array.
 */
declare function toRefs<T extends object>(objectRef: MaybeRef<T>): ToRefs<T>;

/**
 * Call onBeforeMount() if it's inside a component lifecycle, if not, just call the function
 *
 * @param fn
 * @param sync if set to false, it will run in the nextTick() of Vue
 */
declare function tryOnBeforeMount(fn: Fn, sync?: boolean): void;

/**
 * Call onBeforeUnmount() if it's inside a component lifecycle, if not, do nothing
 *
 * @param fn
 */
declare function tryOnBeforeUnmount(fn: Fn): void;

/**
 * Call onMounted() if it's inside a component lifecycle, if not, just call the function
 *
 * @param fn
 * @param sync if set to false, it will run in the nextTick() of Vue
 */
declare function tryOnMounted(fn: Fn, sync?: boolean): void;

/**
 * Call onScopeDispose() if it's inside a effect scope lifecycle, if not, do nothing
 *
 * @param fn
 */
declare function tryOnScopeDispose(fn: Fn): boolean;

/**
 * Call onUnmounted() if it's inside a component lifecycle, if not, do nothing
 *
 * @param fn
 */
declare function tryOnUnmounted(fn: Fn): void;

interface UntilToMatchOptions {
    /**
     * Milliseconds timeout for promise to resolve/reject if the when condition does not meet.
     * 0 for never timed out
     *
     * @default 0
     */
    timeout?: number;
    /**
     * Reject the promise when timeout
     *
     * @default false
     */
    throwOnTimeout?: boolean;
    /**
     * `flush` option for internal watch
     *
     * @default 'sync'
     */
    flush?: WatchOptions['flush'];
    /**
     * `deep` option for internal watch
     *
     * @default 'false'
     */
    deep?: WatchOptions['deep'];
}
interface UntilBaseInstance<T, Not extends boolean = false> {
    toMatch<U extends T = T>(condition: (v: T) => v is U, options?: UntilToMatchOptions): Not extends true ? Promise<Exclude<T, U>> : Promise<U>;
    toMatch(condition: (v: T) => boolean, options?: UntilToMatchOptions): Promise<T>;
    changed(options?: UntilToMatchOptions): Promise<T>;
    changedTimes(n?: number, options?: UntilToMatchOptions): Promise<T>;
}
declare type Falsy = false | void | null | undefined | 0 | 0n | '';
interface UntilValueInstance<T, Not extends boolean = false> extends UntilBaseInstance<T, Not> {
    readonly not: UntilValueInstance<T, Not extends true ? false : true>;
    toBe<P = T>(value: MaybeComputedRef<P>, options?: UntilToMatchOptions): Not extends true ? Promise<T> : Promise<P>;
    toBeTruthy(options?: UntilToMatchOptions): Not extends true ? Promise<T & Falsy> : Promise<Exclude<T, Falsy>>;
    toBeNull(options?: UntilToMatchOptions): Not extends true ? Promise<Exclude<T, null>> : Promise<null>;
    toBeUndefined(options?: UntilToMatchOptions): Not extends true ? Promise<Exclude<T, undefined>> : Promise<undefined>;
    toBeNaN(options?: UntilToMatchOptions): Promise<T>;
}
interface UntilArrayInstance<T> extends UntilBaseInstance<T> {
    readonly not: UntilArrayInstance<T>;
    toContains(value: MaybeComputedRef<ElementOf<ShallowUnwrapRef<T>>>, options?: UntilToMatchOptions): Promise<T>;
}
/**
 * Promised one-time watch for changes
 *
 * @see https://vueuse.org/until
 * @example
 * ```
 * const { count } = useCounter()
 *
 * await until(count).toMatch(v => v > 7)
 *
 * alert('Counter is now larger than 7!')
 * ```
 */
declare function until<T extends unknown[]>(r: WatchSource<T> | MaybeComputedRef<T>): UntilArrayInstance<T>;
declare function until<T>(r: WatchSource<T> | MaybeComputedRef<T>): UntilValueInstance<T>;

/**
 * Reactive `Array.every`
 *
 * @see https://vueuse.org/useArrayEvery
 * @param {Array} list - the array was called upon.
 * @param fn - a function to test each element.
 *
 * @returns {boolean} **true** if the `fn` function returns a **truthy** value for every element from the array. Otherwise, **false**.
 */
declare function useArrayEvery<T>(list: MaybeComputedRef<MaybeComputedRef<T>[]>, fn: (element: T, index: number, array: MaybeComputedRef<T>[]) => unknown): ComputedRef<boolean>;

/**
 * Reactive `Array.filter`
 *
 * @see https://vueuse.org/useArrayFilter
 * @param {Array} list - the array was called upon.
 * @param fn - a function that is called for every element of the given `list`. Each time `fn` executes, the returned value is added to the new array.
 *
 * @returns {Array} a shallow copy of a portion of the given array, filtered down to just the elements from the given array that pass the test implemented by the provided function. If no elements pass the test, an empty array will be returned.
 */
declare function useArrayFilter<T>(list: MaybeComputedRef<MaybeComputedRef<T>[]>, fn: (element: T, index: number, array: T[]) => boolean): ComputedRef<T[]>;

/**
 * Reactive `Array.find`
 *
 * @see https://vueuse.org/useArrayFind
 * @param {Array} list - the array was called upon.
 * @param fn - a function to test each element.
 *
 * @returns the first element in the array that satisfies the provided testing function. Otherwise, undefined is returned.
 */
declare function useArrayFind<T>(list: MaybeComputedRef<MaybeComputedRef<T>[]>, fn: (element: T, index: number, array: MaybeComputedRef<T>[]) => boolean): ComputedRef<T | undefined>;

/**
 * Reactive `Array.findIndex`
 *
 * @see https://vueuse.org/useArrayFindIndex
 * @param {Array} list - the array was called upon.
 * @param fn - a function to test each element.
 *
 * @returns {number} the index of the first element in the array that passes the test. Otherwise, "-1".
 */
declare function useArrayFindIndex<T>(list: MaybeComputedRef<MaybeComputedRef<T>[]>, fn: (element: T, index: number, array: MaybeComputedRef<T>[]) => unknown): ComputedRef<number>;

/**
 * Reactive `Array.join`
 *
 * @see https://vueuse.org/useArrayJoin
 * @param {Array} list - the array was called upon.
 * @param {string} separator - a string to separate each pair of adjacent elements of the array. If omitted, the array elements are separated with a comma (",").
 *
 * @returns {string} a string with all array elements joined. If arr.length is 0, the empty string is returned.
 */
declare function useArrayJoin(list: MaybeComputedRef<MaybeComputedRef<any>[]>, separator?: MaybeComputedRef<string>): ComputedRef<string>;

/**
 * Reactive `Array.map`
 *
 * @see https://vueuse.org/useArrayMap
 * @param {Array} list - the array was called upon.
 * @param fn - a function that is called for every element of the given `list`. Each time `fn` executes, the returned value is added to the new array.
 *
 * @returns {Array} a new array with each element being the result of the callback function.
 */
declare function useArrayMap<T, U = T>(list: MaybeComputedRef<MaybeComputedRef<T>[]>, fn: (element: T, index: number, array: T[]) => U): ComputedRef<U[]>;

declare type UseArrayReducer<PV, CV, R> = (previousValue: PV, currentValue: CV, currentIndex: number) => R;
/**
 * Reactive `Array.reduce`
 *
 * @see https://vueuse.org/useArrayReduce
 * @param {Array} list - the array was called upon.
 * @param reducer - a "reducer" function.
 *
 * @returns the value that results from running the "reducer" callback function to completion over the entire array.
 */
declare function useArrayReduce<T>(list: MaybeComputedRef<MaybeComputedRef<T>[]>, reducer: UseArrayReducer<T, T, T>): ComputedRef<T>;
/**
 * Reactive `Array.reduce`
 *
 * @see https://vueuse.org/useArrayReduce
 * @param {Array} list - the array was called upon.
 * @param reducer - a "reducer" function.
 * @param initialValue - a value to be initialized the first time when the callback is called.
 *
 * @returns the value that results from running the "reducer" callback function to completion over the entire array.
 */
declare function useArrayReduce<T, U>(list: MaybeComputedRef<MaybeComputedRef<T>[]>, reducer: UseArrayReducer<U, T, U>, initialValue: MaybeComputedRef<U>): ComputedRef<U>;

/**
 * Reactive `Array.some`
 *
 * @see https://vueuse.org/useArraySome
 * @param {Array} list - the array was called upon.
 * @param fn - a function to test each element.
 *
 * @returns {boolean} **true** if the `fn` function returns a **truthy** value for any element from the array. Otherwise, **false**.
 */
declare function useArraySome<T>(list: MaybeComputedRef<MaybeComputedRef<T>[]>, fn: (element: T, index: number, array: MaybeComputedRef<T>[]) => unknown): ComputedRef<boolean>;

interface UseCounterOptions {
    min?: number;
    max?: number;
}
/**
 * Basic counter with utility functions.
 *
 * @see https://vueuse.org/useCounter
 * @param [initialValue=0]
 * @param {Object} options
 */
declare function useCounter(initialValue?: number, options?: UseCounterOptions): {
    count: vue_demi.Ref<number>;
    inc: (delta?: number) => number;
    dec: (delta?: number) => number;
    get: () => number;
    set: (val: number) => number;
    reset: (val?: number) => number;
};

declare type DateLike = Date | number | string | undefined;
interface UseDateFormatOptions {
    /**
     * The locale(s) to used for dd/ddd/dddd/MMM/MMMM format
     *
     * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument).
     */
    locales?: Intl.LocalesArgument;
    /**
     * A custom function to re-modify the way to display meridiem
     *
     */
    customMeridiem?: (hours: number, minutes: number, isLowercase?: boolean, hasPeriod?: boolean) => string;
}
declare const formatDate: (date: Date, formatStr: string, options?: UseDateFormatOptions) => string;
declare const normalizeDate: (date: DateLike) => Date;
/**
 * Get the formatted date according to the string of tokens passed in.
 *
 * @see https://vueuse.org/useDateFormat
 * @param date - The date to format, can either be a `Date` object, a timestamp, or a string
 * @param formatStr - The combination of tokens to format the date
 * @param options - UseDateFormatOptions
 */
declare function useDateFormat(date: MaybeComputedRef<DateLike>, formatStr?: MaybeComputedRef<string>, options?: UseDateFormatOptions): vue_demi.ComputedRef<string>;
declare type UseDateFormatReturn = ReturnType<typeof useDateFormat>;

/**
 * Debounce execution of a function.
 *
 * @see https://vueuse.org/useDebounceFn
 * @param  fn          A function to be executed after delay milliseconds debounced.
 * @param  ms          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  opts        options
 *
 * @return A new, debounce, function.
 */
declare function useDebounceFn<T extends FunctionArgs>(fn: T, ms?: MaybeComputedRef<number>, options?: DebounceFilterOptions): T;

interface UseIntervalOptions<Controls extends boolean> {
    /**
     * Expose more controls
     *
     * @default false
     */
    controls?: Controls;
    /**
     * Execute the update immediately on calling
     *
     * @default true
     */
    immediate?: boolean;
    /**
     * Callback on every interval
     */
    callback?: (count: number) => void;
}
/**
 * Reactive counter increases on every interval
 *
 * @see https://vueuse.org/useInterval
 * @param interval
 * @param options
 */
declare function useInterval(interval?: MaybeComputedRef<number>, options?: UseIntervalOptions<false>): Ref<number>;
declare function useInterval(interval: MaybeComputedRef<number>, options: UseIntervalOptions<true>): {
    counter: Ref<number>;
} & Pausable;

interface UseIntervalFnOptions {
    /**
     * Start the timer immediately
     *
     * @default true
     */
    immediate?: boolean;
    /**
     * Execute the callback immediate after calling this function
     *
     * @default false
     */
    immediateCallback?: boolean;
}
/**
 * Wrapper for `setInterval` with controls
 *
 * @param cb
 * @param interval
 * @param options
 */
declare function useIntervalFn(cb: Fn, interval?: MaybeComputedRef<number>, options?: UseIntervalFnOptions): Pausable;

interface UseLastChangedOptions<Immediate extends boolean, InitialValue extends number | null | undefined = undefined> extends WatchOptions<Immediate> {
    initialValue?: InitialValue;
}
/**
 * Records the timestamp of the last change
 *
 * @see https://vueuse.org/useLastChanged
 */
declare function useLastChanged(source: WatchSource, options?: UseLastChangedOptions<false>): Ref<number | null>;
declare function useLastChanged(source: WatchSource, options: UseLastChangedOptions<true>): Ref<number>;
declare function useLastChanged(source: WatchSource, options: UseLastChangedOptions<boolean, number>): Ref<number>;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param   fn             A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param   ms             A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 *
 * @param [trailing=false] if true, call fn again after the time is up
 *
 * @param [leading=true] if true, call fn on the leading edge of the ms timeout
 *
 * @return  A new, throttled, function.
 */
declare function useThrottleFn<T extends FunctionArgs>(fn: T, ms?: MaybeComputedRef<number>, trailing?: boolean, leading?: boolean): T;

interface UseTimeoutFnOptions {
    /**
     * Start the timer immediate after calling this function
     *
     * @default true
     */
    immediate?: boolean;
}
/**
 * Wrapper for `setTimeout` with controls.
 *
 * @param cb
 * @param interval
 * @param options
 */
declare function useTimeoutFn(cb: (...args: unknown[]) => any, interval: MaybeComputedRef<number>, options?: UseTimeoutFnOptions): Stoppable;

interface UseTimeoutOptions<Controls extends boolean> extends UseTimeoutFnOptions {
    /**
     * Expose more controls
     *
     * @default false
     */
    controls?: Controls;
    /**
     * Callback on timeout
     */
    callback?: Fn;
}
/**
 * Update value after a given time with controls.
 *
 * @see   {@link https://vueuse.org/useTimeout}
 * @param interval
 * @param options
 */
declare function useTimeout(interval?: number, options?: UseTimeoutOptions<false>): ComputedRef<boolean>;
declare function useTimeout(interval: number, options: UseTimeoutOptions<true>): {
    ready: ComputedRef<boolean>;
} & Stoppable;

interface UseToNumberOptions {
    /**
     * Method to use to convert the value to a number.
     *
     * @default 'parseFloat'
     */
    method?: 'parseFloat' | 'parseInt';
    /**
     * The base in mathematical numeral systems passed to `parseInt`.
     * Only works with `method: 'parseInt'`
     */
    radix?: number;
    /**
     * Replace NaN with zero
     *
     * @default false
     */
    nanToZero?: boolean;
}
/**
 * Computed reactive object.
 */
declare function useToNumber(value: MaybeComputedRef<number | string>, options?: UseToNumberOptions): ComputedRef<number>;

/**
 * Reactively convert a ref to string.
 *
 * @see https://vueuse.org/useToString
 */
declare function useToString(value: MaybeComputedRef<unknown>): ComputedRef<string>;

interface UseToggleOptions<Truthy, Falsy> {
    truthyValue?: MaybeComputedRef<Truthy>;
    falsyValue?: MaybeComputedRef<Falsy>;
}
declare function useToggle<Truthy, Falsy, T = Truthy | Falsy>(initialValue: Ref<T>, options?: UseToggleOptions<Truthy, Falsy>): (value?: T) => T;
declare function useToggle<Truthy = true, Falsy = false, T = Truthy | Falsy>(initialValue?: T, options?: UseToggleOptions<Truthy, Falsy>): [Ref<T>, (value?: T) => T];

declare type WatchArrayCallback<V = any, OV = any> = (value: V, oldValue: OV, added: V, removed: OV, onCleanup: (cleanupFn: () => void) => void) => any;
/**
 * Watch for an array with additions and removals.
 *
 * @see https://vueuse.org/watchArray
 */
declare function watchArray<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T[]> | T[], cb: WatchArrayCallback<T[], Immediate extends true ? T[] | undefined : T[]>, options?: WatchOptions<Immediate>): vue_demi.WatchStopHandle;

interface WatchWithFilterOptions<Immediate> extends WatchOptions<Immediate>, ConfigurableEventFilter {
}
declare function watchWithFilter<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;
declare function watchWithFilter<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;
declare function watchWithFilter<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchStopHandle;

interface WatchAtMostOptions<Immediate> extends WatchWithFilterOptions<Immediate> {
    count: MaybeComputedRef<number>;
}
interface WatchAtMostReturn {
    stop: WatchStopHandle;
    count: Ref<number>;
}
declare function watchAtMost<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options: WatchAtMostOptions<Immediate>): WatchAtMostReturn;
declare function watchAtMost<T, Immediate extends Readonly<boolean> = false>(sources: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options: WatchAtMostOptions<Immediate>): WatchAtMostReturn;

interface WatchDebouncedOptions<Immediate> extends WatchOptions<Immediate>, DebounceFilterOptions {
    debounce?: MaybeComputedRef<number>;
}
declare function watchDebounced<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchDebouncedOptions<Immediate>): WatchStopHandle;
declare function watchDebounced<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchDebouncedOptions<Immediate>): WatchStopHandle;
declare function watchDebounced<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchDebouncedOptions<Immediate>): WatchStopHandle;

declare type IgnoredUpdater = (updater: () => void) => void;
interface WatchIgnorableReturn {
    ignoreUpdates: IgnoredUpdater;
    ignorePrevAsyncUpdates: () => void;
    stop: WatchStopHandle;
}
declare function watchIgnorable<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): WatchIgnorableReturn;
declare function watchIgnorable<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchIgnorableReturn;
declare function watchIgnorable<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchIgnorableReturn;

declare function watchOnce<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(source: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchOptions<Immediate>): void;
declare function watchOnce<T, Immediate extends Readonly<boolean> = false>(sources: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchOptions<Immediate>): void;

interface WatchPausableReturn extends Pausable {
    stop: WatchStopHandle;
}
declare function watchPausable<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): WatchPausableReturn;
declare function watchPausable<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchPausableReturn;
declare function watchPausable<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchPausableReturn;

interface WatchThrottledOptions<Immediate> extends WatchOptions<Immediate> {
    throttle?: MaybeComputedRef<number>;
    trailing?: boolean;
    leading?: boolean;
}
declare function watchThrottled<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchThrottledOptions<Immediate>): WatchStopHandle;
declare function watchThrottled<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchThrottledOptions<Immediate>): WatchStopHandle;
declare function watchThrottled<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchThrottledOptions<Immediate>): WatchStopHandle;

interface WatchTriggerableReturn<FnReturnT = void> extends WatchIgnorableReturn {
    /** Execute `WatchCallback` immediately */
    trigger: () => FnReturnT;
}
declare type OnCleanup = (cleanupFn: () => void) => void;
declare type WatchTriggerableCallback<V = any, OV = any, R = void> = (value: V, oldValue: OV, onCleanup: OnCleanup) => R;
declare function watchTriggerable<T extends Readonly<WatchSource<unknown>[]>, FnReturnT>(sources: [...T], cb: WatchTriggerableCallback<MapSources<T>, MapOldSources<T, true>, FnReturnT>, options?: WatchWithFilterOptions<boolean>): WatchTriggerableReturn<FnReturnT>;
declare function watchTriggerable<T, FnReturnT>(source: WatchSource<T>, cb: WatchTriggerableCallback<T, T | undefined, FnReturnT>, options?: WatchWithFilterOptions<boolean>): WatchTriggerableReturn<FnReturnT>;
declare function watchTriggerable<T extends object, FnReturnT>(source: T, cb: WatchTriggerableCallback<T, T | undefined, FnReturnT>, options?: WatchWithFilterOptions<boolean>): WatchTriggerableReturn<FnReturnT>;

/**
 * Shorthand for watching value to be truthy
 *
 * @see https://vueuse.org/whenever
 */
declare function whenever<T>(source: WatchSource<T | false | null | undefined>, cb: WatchCallback<T>, options?: WatchOptions): vue_demi.WatchStopHandle;

export { ArgumentsType, Arrayable, Awaitable, ComputedRefWithControl, ComputedWithControlRefExtra, ConfigurableEventFilter, ConfigurableFlush, ConfigurableFlushSync, ControlledRefOptions, CreateGlobalStateReturn, DateLike, DebounceFilterOptions, DeepMaybeRef, ElementOf, EventFilter, EventHook, EventHookOff, EventHookOn, EventHookTrigger, ExtendRefOptions, Fn, FunctionArgs, FunctionWrapperOptions, IgnoredUpdater, MapOldSources, MapSources, MaybeComputedRef, MaybeReadonlyRef, MaybeRef, Pausable, Reactified, ReactifyNested, ReactifyObjectOptions, ReactifyOptions, RemovableRef, RemoveableRef, ShallowUnwrapRef, SingletonPromiseReturn, Stopable, Stoppable, SyncRefOptions, SyncRefsOptions, UntilArrayInstance, UntilBaseInstance, UntilToMatchOptions, UntilValueInstance, UseArrayReducer, UseCounterOptions, UseDateFormatOptions, UseDateFormatReturn, UseIntervalFnOptions, UseIntervalOptions, UseLastChangedOptions, UseTimeoutFnOptions, UseTimeoutOptions, UseToNumberOptions, UseToggleOptions, WatchArrayCallback, WatchAtMostOptions, WatchAtMostReturn, WatchDebouncedOptions, WatchIgnorableReturn, WatchPausableReturn, WatchThrottledOptions, WatchTriggerableCallback, WatchTriggerableReturn, WatchWithFilterOptions, WritableComputedRefWithControl, __onlyVue27Plus, __onlyVue3, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, makeDestructurable, noop, normalizeDate, now, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };
ª/index.cjsÅÀ'use strict';

var vueDemi = require('vue-demi');

var __defProp$9 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
function computedEager(fn, options) {
  var _a;
  const result = vueDemi.shallowRef();
  vueDemi.watchEffect(() => {
    result.value = fn();
  }, __spreadProps$6(__spreadValues$9({}, options), {
    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
  }));
  return vueDemi.readonly(result);
}

var _a;
const isClient = typeof window !== "undefined";
const isDef = (val) => typeof val !== "undefined";
const assert = (condition, ...infos) => {
  if (!condition)
    console.warn(...infos);
};
const toString = Object.prototype.toString;
const isBoolean = (val) => typeof val === "boolean";
const isFunction = (val) => typeof val === "function";
const isNumber = (val) => typeof val === "number";
const isString = (val) => typeof val === "string";
const isObject = (val) => toString.call(val) === "[object Object]";
const isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
const now = () => Date.now();
const timestamp = () => +Date.now();
const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
const noop = () => {
};
const rand = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};
const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);

function resolveUnref(r) {
  return typeof r === "function" ? r() : vueDemi.unref(r);
}

function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = resolveUnref(ms);
    const maxDuration = resolveUnref(options.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  };
  const filter = (invoke) => {
    const duration = resolveUnref(ms);
    const elapsed = Date.now() - lastExec;
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke();
    } else if (trailing) {
      timer = setTimeout(() => {
        lastExec = Date.now();
        isLeading = true;
        clear();
        invoke();
      }, duration - elapsed);
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = vueDemi.ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}

function __onlyVue3(name = "this function") {
  if (vueDemi.isVue3)
    return;
  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);
}
function __onlyVue27Plus(name = "this function") {
  if (vueDemi.isVue3 || vueDemi.version.startsWith("2.7."))
    return;
  throw new Error(`[VueUse] ${name} is only works on Vue 2.7 or above.`);
}
const directiveHooks = {
  mounted: vueDemi.isVue3 ? "mounted" : "inserted",
  updated: vueDemi.isVue3 ? "updated" : "componentUpdated",
  unmounted: vueDemi.isVue3 ? "unmounted" : "unbind"
};

function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms);
    else
      setTimeout(resolve, ms);
  });
}
function identity(arg) {
  return arg;
}
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function invoke(fn) {
  return fn();
}
function containsProp(obj, ...props) {
  return props.some((k) => k in obj);
}
function increaseWithUnit(target, delta) {
  var _a;
  if (typeof target === "number")
    return target + delta;
  const value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a[0]) || "";
  const unit = target.slice(value.length);
  const result = parseFloat(value) + delta;
  if (Number.isNaN(result))
    return target;
  return result + unit;
}
function objectPick(obj, keys, omitUndefined = false) {
  return keys.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}

function computedWithControl(source, fn) {
  let v = void 0;
  let track;
  let trigger;
  const dirty = vueDemi.ref(true);
  const update = () => {
    dirty.value = true;
    trigger();
  };
  vueDemi.watch(source, update, { flush: "sync" });
  const get = isFunction(fn) ? fn : fn.get;
  const set = isFunction(fn) ? void 0 : fn.set;
  const result = vueDemi.customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty.value) {
          v = get();
          dirty.value = false;
        }
        track();
        return v;
      },
      set(v2) {
        set == null ? void 0 : set(v2);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}

function tryOnScopeDispose(fn) {
  if (vueDemi.getCurrentScope()) {
    vueDemi.onScopeDispose(fn);
    return true;
  }
  return false;
}

function createEventHook() {
  const fns = [];
  const off = (fn) => {
    const index = fns.indexOf(fn);
    if (index !== -1)
      fns.splice(index, 1);
  };
  const on = (fn) => {
    fns.push(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (param) => {
    fns.forEach((fn) => fn(param));
  };
  return {
    on,
    off,
    trigger
  };
}

function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = vueDemi.effectScope(true);
  return () => {
    if (!initialized) {
      state = scope.run(stateFactory);
      initialized = true;
    }
    return state;
  };
}

function createInjectionState(composable) {
  const key = Symbol("InjectionState");
  const useProvidingState = (...args) => {
    vueDemi.provide(key, composable(...args));
  };
  const useInjectedState = () => vueDemi.inject(key);
  return [useProvidingState, useInjectedState];
}

function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!state) {
      scope = vueDemi.effectScope(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}

function extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {
  __onlyVue27Plus();
  for (const [key, value] of Object.entries(extend)) {
    if (key === "value")
      continue;
    if (vueDemi.isRef(value) && unwrap) {
      Object.defineProperty(ref, key, {
        get() {
          return value.value;
        },
        set(v) {
          value.value = v;
        },
        enumerable
      });
    } else {
      Object.defineProperty(ref, key, { value, enumerable });
    }
  }
  return ref;
}

function get(obj, key) {
  if (key == null)
    return vueDemi.unref(obj);
  return vueDemi.unref(obj)[key];
}

function isDefined(v) {
  return vueDemi.unref(v) != null;
}

var __defProp$8 = Object.defineProperty;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone = __spreadValues$8({}, obj);
    Object.defineProperty(clone, Symbol.iterator, {
      enumerable: false,
      value() {
        let index = 0;
        return {
          next: () => ({
            value: arr[index++],
            done: index > arr.length
          })
        };
      }
    });
    return clone;
  } else {
    return Object.assign([...arr], obj);
  }
}

function reactify(fn, options) {
  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? vueDemi.unref : resolveUnref;
  return function(...args) {
    return vueDemi.computed(() => fn.apply(this, args.map((i) => unrefFn(i))));
  };
}

function reactifyObject(obj, optionsOrKeys = {}) {
  let keys = [];
  let options;
  if (Array.isArray(optionsOrKeys)) {
    keys = optionsOrKeys;
  } else {
    options = optionsOrKeys;
    const { includeOwnProperties = true } = optionsOrKeys;
    keys.push(...Object.keys(obj));
    if (includeOwnProperties)
      keys.push(...Object.getOwnPropertyNames(obj));
  }
  return Object.fromEntries(keys.map((key) => {
    const value = obj[key];
    return [
      key,
      typeof value === "function" ? reactify(value.bind(obj), options) : value
    ];
  }));
}

function toReactive(objectRef) {
  if (!vueDemi.isRef(objectRef))
    return vueDemi.reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_, p, receiver) {
      return vueDemi.unref(Reflect.get(objectRef.value, p, receiver));
    },
    set(_, p, value) {
      if (vueDemi.isRef(objectRef.value[p]) && !vueDemi.isRef(value))
        objectRef.value[p].value = value;
      else
        objectRef.value[p] = value;
      return true;
    },
    deleteProperty(_, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(_, p) {
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return vueDemi.reactive(proxy);
}

function reactiveComputed(fn) {
  return toReactive(vueDemi.computed(fn));
}

function reactiveOmit(obj, ...keys) {
  const flatKeys = keys.flat();
  return reactiveComputed(() => Object.fromEntries(Object.entries(vueDemi.toRefs(obj)).filter((e) => !flatKeys.includes(e[0]))));
}

function reactivePick(obj, ...keys) {
  const flatKeys = keys.flat();
  return vueDemi.reactive(Object.fromEntries(flatKeys.map((k) => [k, vueDemi.toRef(obj, k)])));
}

function refAutoReset(defaultValue, afterMs = 1e4) {
  return vueDemi.customRef((track, trigger) => {
    let value = defaultValue;
    let timer;
    const resetAfter = () => setTimeout(() => {
      value = defaultValue;
      trigger();
    }, resolveUnref(afterMs));
    tryOnScopeDispose(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        trigger();
        clearTimeout(timer);
        timer = resetAfter();
      }
    };
  });
}

function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}

function refDebounced(value, ms = 200, options = {}) {
  const debounced = vueDemi.ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  vueDemi.watch(value, () => updater());
  return debounced;
}

function refDefault(source, defaultValue) {
  return vueDemi.computed({
    get() {
      var _a;
      return (_a = source.value) != null ? _a : defaultValue;
    },
    set(value) {
      source.value = value;
    }
  });
}

function useThrottleFn(fn, ms = 200, trailing = false, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
}

function refThrottled(value, delay = 200, trailing = true, leading = true) {
  if (delay <= 0)
    return value;
  const throttled = vueDemi.ref(value.value);
  const updater = useThrottleFn(() => {
    throttled.value = value.value;
  }, delay, trailing, leading);
  vueDemi.watch(value, () => updater());
  return throttled;
}

function refWithControl(initial, options = {}) {
  let source = initial;
  let track;
  let trigger;
  const ref = vueDemi.customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        return get();
      },
      set(v) {
        set(v);
      }
    };
  });
  function get(tracking = true) {
    if (tracking)
      track();
    return source;
  }
  function set(value, triggering = true) {
    var _a, _b;
    if (value === source)
      return;
    const old = source;
    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)
      return;
    source = value;
    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);
    if (triggering)
      trigger();
  }
  const untrackedGet = () => get(false);
  const silentSet = (v) => set(v, false);
  const peek = () => get(false);
  const lay = (v) => set(v, false);
  return extendRef(ref, {
    get,
    set,
    untrackedGet,
    silentSet,
    peek,
    lay
  }, { enumerable: true });
}
const controlledRef = refWithControl;

function resolveRef(r) {
  return typeof r === "function" ? vueDemi.computed(r) : vueDemi.ref(r);
}

function set(...args) {
  if (args.length === 2) {
    const [ref, value] = args;
    ref.value = value;
  }
  if (args.length === 3) {
    if (vueDemi.isVue2) {
      vueDemi.set(...args);
    } else {
      const [target, key, value] = args;
      target[key] = value;
    }
  }
}

function syncRef(left, right, options = {}) {
  var _a, _b;
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both",
    transform = {}
  } = options;
  let watchLeft;
  let watchRight;
  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;
  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;
  if (direction === "both" || direction === "ltr") {
    watchLeft = vueDemi.watch(left, (newValue) => right.value = transformLTR(newValue), { flush, deep, immediate });
  }
  if (direction === "both" || direction === "rtl") {
    watchRight = vueDemi.watch(right, (newValue) => left.value = transformRTL(newValue), { flush, deep, immediate });
  }
  return () => {
    watchLeft == null ? void 0 : watchLeft();
    watchRight == null ? void 0 : watchRight();
  };
}

function syncRefs(source, targets, options = {}) {
  const {
    flush = "sync",
    deep = false,
    immediate = true
  } = options;
  if (!Array.isArray(targets))
    targets = [targets];
  return vueDemi.watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });
}

var __defProp$7 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
function toRefs(objectRef) {
  if (!vueDemi.isRef(objectRef))
    return vueDemi.toRefs(objectRef);
  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};
  for (const key in objectRef.value) {
    result[key] = vueDemi.customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        if (Array.isArray(objectRef.value)) {
          const copy = [...objectRef.value];
          copy[key] = v;
          objectRef.value = copy;
        } else {
          const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });
          Object.setPrototypeOf(newObject, objectRef.value);
          objectRef.value = newObject;
        }
      }
    }));
  }
  return result;
}

function tryOnBeforeMount(fn, sync = true) {
  if (vueDemi.getCurrentInstance())
    vueDemi.onBeforeMount(fn);
  else if (sync)
    fn();
  else
    vueDemi.nextTick(fn);
}

function tryOnBeforeUnmount(fn) {
  if (vueDemi.getCurrentInstance())
    vueDemi.onBeforeUnmount(fn);
}

function tryOnMounted(fn, sync = true) {
  if (vueDemi.getCurrentInstance())
    vueDemi.onMounted(fn);
  else if (sync)
    fn();
  else
    vueDemi.nextTick(fn);
}

function tryOnUnmounted(fn) {
  if (vueDemi.getCurrentInstance())
    vueDemi.onUnmounted(fn);
}

function createUntil(r, isNot = false) {
  function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
    let stop = null;
    const watcher = new Promise((resolve) => {
      stop = vueDemi.watch(r, (v) => {
        if (condition(v) !== isNot) {
          stop == null ? void 0 : stop();
          resolve(v);
        }
      }, {
        flush,
        deep,
        immediate: true
      });
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => stop == null ? void 0 : stop()));
    }
    return Promise.race(promises);
  }
  function toBe(value, options) {
    if (!vueDemi.isRef(value))
      return toMatch((v) => v === value, options);
    const { flush = "sync", deep = false, timeout, throwOnTimeout } = options != null ? options : {};
    let stop = null;
    const watcher = new Promise((resolve) => {
      stop = vueDemi.watch([r, value], ([v1, v2]) => {
        if (isNot !== (v1 === v2)) {
          stop == null ? void 0 : stop();
          resolve(v1);
        }
      }, {
        flush,
        deep,
        immediate: true
      });
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => {
        stop == null ? void 0 : stop();
        return resolveUnref(r);
      }));
    }
    return Promise.race(promises);
  }
  function toBeTruthy(options) {
    return toMatch((v) => Boolean(v), options);
  }
  function toBeNull(options) {
    return toBe(null, options);
  }
  function toBeUndefined(options) {
    return toBe(void 0, options);
  }
  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }
  function toContains(value, options) {
    return toMatch((v) => {
      const array = Array.from(v);
      return array.includes(value) || array.includes(resolveUnref(value));
    }, options);
  }
  function changed(options) {
    return changedTimes(1, options);
  }
  function changedTimes(n = 1, options) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options);
  }
  if (Array.isArray(resolveUnref(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  }
}
function until(r) {
  return createUntil(r);
}

function useArrayEvery(list, fn) {
  return vueDemi.computed(() => resolveUnref(list).every((element, index, array) => fn(resolveUnref(element), index, array)));
}

function useArrayFilter(list, fn) {
  return vueDemi.computed(() => resolveUnref(list).map((i) => resolveUnref(i)).filter(fn));
}

function useArrayFind(list, fn) {
  return vueDemi.computed(() => resolveUnref(resolveUnref(list).find((element, index, array) => fn(resolveUnref(element), index, array))));
}

function useArrayFindIndex(list, fn) {
  return vueDemi.computed(() => resolveUnref(list).findIndex((element, index, array) => fn(resolveUnref(element), index, array)));
}

function useArrayJoin(list, separator) {
  return vueDemi.computed(() => resolveUnref(list).map((i) => resolveUnref(i)).join(resolveUnref(separator)));
}

function useArrayMap(list, fn) {
  return vueDemi.computed(() => resolveUnref(list).map((i) => resolveUnref(i)).map(fn));
}

function useArrayReduce(list, reducer, ...args) {
  const reduceCallback = (sum, value, index) => reducer(resolveUnref(sum), resolveUnref(value), index);
  return vueDemi.computed(() => {
    const resolved = resolveUnref(list);
    return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);
  });
}

function useArraySome(list, fn) {
  return vueDemi.computed(() => resolveUnref(list).some((element, index, array) => fn(resolveUnref(element), index, array)));
}

function useCounter(initialValue = 0, options = {}) {
  const count = vueDemi.ref(initialValue);
  const {
    max = Infinity,
    min = -Infinity
  } = options;
  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);
  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);
  const get = () => count.value;
  const set = (val) => count.value = Math.max(min, Math.min(max, val));
  const reset = (val = initialValue) => {
    initialValue = val;
    return set(val);
  };
  return { count, inc, dec, get, set, reset };
}

const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
const REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
const defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {
  let m = hours < 12 ? "AM" : "PM";
  if (hasPeriod)
    m = m.split("").reduce((acc, curr) => acc += `${curr}.`, "");
  return isLowercase ? m.toLowerCase() : m;
};
const formatDate = (date, formatStr, options = {}) => {
  var _a;
  const years = date.getFullYear();
  const month = date.getMonth();
  const days = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();
  const day = date.getDay();
  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;
  const matches = {
    YY: () => String(years).slice(-2),
    YYYY: () => years,
    M: () => month + 1,
    MM: () => `${month + 1}`.padStart(2, "0"),
    MMM: () => date.toLocaleDateString(options.locales, { month: "short" }),
    MMMM: () => date.toLocaleDateString(options.locales, { month: "long" }),
    D: () => String(days),
    DD: () => `${days}`.padStart(2, "0"),
    H: () => String(hours),
    HH: () => `${hours}`.padStart(2, "0"),
    h: () => `${hours % 12 || 12}`.padStart(1, "0"),
    hh: () => `${hours % 12 || 12}`.padStart(2, "0"),
    m: () => String(minutes),
    mm: () => `${minutes}`.padStart(2, "0"),
    s: () => String(seconds),
    ss: () => `${seconds}`.padStart(2, "0"),
    SSS: () => `${milliseconds}`.padStart(3, "0"),
    d: () => day,
    dd: () => date.toLocaleDateString(options.locales, { weekday: "narrow" }),
    ddd: () => date.toLocaleDateString(options.locales, { weekday: "short" }),
    dddd: () => date.toLocaleDateString(options.locales, { weekday: "long" }),
    A: () => meridiem(hours, minutes),
    AA: () => meridiem(hours, minutes, false, true),
    a: () => meridiem(hours, minutes, true),
    aa: () => meridiem(hours, minutes, true, true)
  };
  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());
};
const normalizeDate = (date) => {
  if (date === null)
    return new Date(NaN);
  if (date === void 0)
    return new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    const d = date.match(REGEX_PARSE);
    if (d) {
      const m = d[2] - 1 || 0;
      const ms = (d[7] || "0").substring(0, 3);
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
};
function useDateFormat(date, formatStr = "HH:mm:ss", options = {}) {
  return vueDemi.computed(() => formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options));
}

function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = vueDemi.ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    if (vueDemi.unref(interval) <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, resolveUnref(interval));
  }
  if (immediate && isClient)
    resume();
  if (vueDemi.isRef(interval) || isFunction(interval)) {
    const stopWatch = vueDemi.watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}

var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
function useInterval(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    immediate = true,
    callback
  } = options;
  const counter = vueDemi.ref(0);
  const update = () => counter.value += 1;
  const controls = useIntervalFn(callback ? () => {
    update();
    callback(counter.value);
  } : update, interval, { immediate });
  if (exposeControls) {
    return __spreadValues$6({
      counter
    }, controls);
  } else {
    return counter;
  }
}

function useLastChanged(source, options = {}) {
  var _a;
  const ms = vueDemi.ref((_a = options.initialValue) != null ? _a : null);
  vueDemi.watch(source, () => ms.value = timestamp(), options);
  return ms;
}

function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = vueDemi.ref(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, resolveUnref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending,
    start,
    stop
  };
}

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options;
  const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);
  const ready = vueDemi.computed(() => !controls.isPending.value);
  if (exposeControls) {
    return __spreadValues$5({
      ready
    }, controls);
  } else {
    return ready;
  }
}

function useToNumber(value, options = {}) {
  const {
    method = "parseFloat",
    radix,
    nanToZero
  } = options;
  return vueDemi.computed(() => {
    let resolved = resolveUnref(value);
    if (typeof resolved === "string")
      resolved = Number[method](resolved, radix);
    if (nanToZero && isNaN(resolved))
      resolved = 0;
    return resolved;
  });
}

function useToString(value) {
  return vueDemi.computed(() => `${resolveUnref(value)}`);
}

function useToggle(initialValue = false, options = {}) {
  const {
    truthyValue = true,
    falsyValue = false
  } = options;
  const valueIsRef = vueDemi.isRef(initialValue);
  const _value = vueDemi.ref(initialValue);
  function toggle(value) {
    if (arguments.length) {
      _value.value = value;
      return _value.value;
    } else {
      const truthy = resolveUnref(truthyValue);
      _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;
      return _value.value;
    }
  }
  if (valueIsRef)
    return toggle;
  else
    return [_value, toggle];
}

function watchArray(source, cb, options) {
  let oldList = (options == null ? void 0 : options.immediate) ? [] : [
    ...source instanceof Function ? source() : Array.isArray(source) ? source : vueDemi.unref(source)
  ];
  return vueDemi.watch(source, (newList, _, onCleanup) => {
    const oldListRemains = new Array(oldList.length);
    const added = [];
    for (const obj of newList) {
      let found = false;
      for (let i = 0; i < oldList.length; i++) {
        if (!oldListRemains[i] && obj === oldList[i]) {
          oldListRemains[i] = true;
          found = true;
          break;
        }
      }
      if (!found)
        added.push(obj);
    }
    const removed = oldList.filter((_2, i) => !oldListRemains[i]);
    cb(newList, oldList, added, removed, onCleanup);
    oldList = [...newList];
  }, options);
}

var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$5(_a, [
    "eventFilter"
  ]);
  return vueDemi.watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}

var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __objRest$4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchAtMost(source, cb, options) {
  const _a = options, {
    count
  } = _a, watchOptions = __objRest$4(_a, [
    "count"
  ]);
  const current = vueDemi.ref(0);
  const stop = watchWithFilter(source, (...args) => {
    current.value += 1;
    if (current.value >= resolveUnref(count))
      vueDemi.nextTick(() => stop());
    cb(...args);
  }, watchOptions);
  return { count: current, stop };
}

var __defProp$4 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
var __objRest$3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchDebounced(source, cb, options = {}) {
  const _a = options, {
    debounce = 0,
    maxWait = void 0
  } = _a, watchOptions = __objRest$3(_a, [
    "debounce",
    "maxWait"
  ]);
  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {
    eventFilter: debounceFilter(debounce, { maxWait })
  }));
}

var __defProp$3 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchIgnorable(source, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$2(_a, [
    "eventFilter"
  ]);
  const filteredCb = createFilterWrapper(eventFilter, cb);
  let ignoreUpdates;
  let ignorePrevAsyncUpdates;
  let stop;
  if (watchOptions.flush === "sync") {
    const ignore = vueDemi.ref(false);
    ignorePrevAsyncUpdates = () => {
    };
    ignoreUpdates = (updater) => {
      ignore.value = true;
      updater();
      ignore.value = false;
    };
    stop = vueDemi.watch(source, (...args) => {
      if (!ignore.value)
        filteredCb(...args);
    }, watchOptions);
  } else {
    const disposables = [];
    const ignoreCounter = vueDemi.ref(0);
    const syncCounter = vueDemi.ref(0);
    ignorePrevAsyncUpdates = () => {
      ignoreCounter.value = syncCounter.value;
    };
    disposables.push(vueDemi.watch(source, () => {
      syncCounter.value++;
    }, __spreadProps$3(__spreadValues$3({}, watchOptions), { flush: "sync" })));
    ignoreUpdates = (updater) => {
      const syncCounterPrev = syncCounter.value;
      updater();
      ignoreCounter.value += syncCounter.value - syncCounterPrev;
    };
    disposables.push(vueDemi.watch(source, (...args) => {
      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
      ignoreCounter.value = 0;
      syncCounter.value = 0;
      if (ignore)
        return;
      filteredCb(...args);
    }, watchOptions));
    stop = () => {
      disposables.forEach((fn) => fn());
    };
  }
  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };
}

function watchOnce(source, cb, options) {
  const stop = vueDemi.watch(source, (...args) => {
    vueDemi.nextTick(() => stop());
    return cb(...args);
  }, options);
}

var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchPausable(source, cb, options = {}) {
  const _a = options, {
    eventFilter: filter
  } = _a, watchOptions = __objRest$1(_a, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
    eventFilter
  }));
  return { stop, pause, resume, isActive };
}

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchThrottled(source, cb, options = {}) {
  const _a = options, {
    throttle = 0,
    trailing = true,
    leading = true
  } = _a, watchOptions = __objRest(_a, [
    "throttle",
    "trailing",
    "leading"
  ]);
  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {
    eventFilter: throttleFilter(throttle, trailing, leading)
  }));
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function watchTriggerable(source, cb, options = {}) {
  let cleanupFn;
  function onEffect() {
    if (!cleanupFn)
      return;
    const fn = cleanupFn;
    cleanupFn = void 0;
    fn();
  }
  function onCleanup(callback) {
    cleanupFn = callback;
  }
  const _cb = (value, oldValue) => {
    onEffect();
    return cb(value, oldValue, onCleanup);
  };
  const res = watchIgnorable(source, _cb, options);
  const { ignoreUpdates } = res;
  const trigger = () => {
    let res2;
    ignoreUpdates(() => {
      res2 = _cb(getWatchSources(source), getOldValue(source));
    });
    return res2;
  };
  return __spreadProps(__spreadValues({}, res), {
    trigger
  });
}
function getWatchSources(sources) {
  if (vueDemi.isReactive(sources))
    return sources;
  if (Array.isArray(sources))
    return sources.map((item) => getOneWatchSource(item));
  return getOneWatchSource(sources);
}
function getOneWatchSource(source) {
  return typeof source === "function" ? source() : vueDemi.unref(source);
}
function getOldValue(source) {
  return Array.isArray(source) ? source.map(() => void 0) : void 0;
}

function whenever(source, cb, options) {
  return vueDemi.watch(source, (v, ov, onInvalidate) => {
    if (v)
      cb(v, ov, onInvalidate);
  }, options);
}

exports.__onlyVue27Plus = __onlyVue27Plus;
exports.__onlyVue3 = __onlyVue3;
exports.assert = assert;
exports.autoResetRef = refAutoReset;
exports.bypassFilter = bypassFilter;
exports.clamp = clamp;
exports.computedEager = computedEager;
exports.computedWithControl = computedWithControl;
exports.containsProp = containsProp;
exports.controlledComputed = computedWithControl;
exports.controlledRef = controlledRef;
exports.createEventHook = createEventHook;
exports.createFilterWrapper = createFilterWrapper;
exports.createGlobalState = createGlobalState;
exports.createInjectionState = createInjectionState;
exports.createReactiveFn = reactify;
exports.createSharedComposable = createSharedComposable;
exports.createSingletonPromise = createSingletonPromise;
exports.debounceFilter = debounceFilter;
exports.debouncedRef = refDebounced;
exports.debouncedWatch = watchDebounced;
exports.directiveHooks = directiveHooks;
exports.eagerComputed = computedEager;
exports.extendRef = extendRef;
exports.formatDate = formatDate;
exports.get = get;
exports.hasOwn = hasOwn;
exports.identity = identity;
exports.ignorableWatch = watchIgnorable;
exports.increaseWithUnit = increaseWithUnit;
exports.invoke = invoke;
exports.isBoolean = isBoolean;
exports.isClient = isClient;
exports.isDef = isDef;
exports.isDefined = isDefined;
exports.isFunction = isFunction;
exports.isIOS = isIOS;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isString = isString;
exports.isWindow = isWindow;
exports.makeDestructurable = makeDestructurable;
exports.noop = noop;
exports.normalizeDate = normalizeDate;
exports.now = now;
exports.objectPick = objectPick;
exports.pausableFilter = pausableFilter;
exports.pausableWatch = watchPausable;
exports.promiseTimeout = promiseTimeout;
exports.rand = rand;
exports.reactify = reactify;
exports.reactifyObject = reactifyObject;
exports.reactiveComputed = reactiveComputed;
exports.reactiveOmit = reactiveOmit;
exports.reactivePick = reactivePick;
exports.refAutoReset = refAutoReset;
exports.refDebounced = refDebounced;
exports.refDefault = refDefault;
exports.refThrottled = refThrottled;
exports.refWithControl = refWithControl;
exports.resolveRef = resolveRef;
exports.resolveUnref = resolveUnref;
exports.set = set;
exports.syncRef = syncRef;
exports.syncRefs = syncRefs;
exports.throttleFilter = throttleFilter;
exports.throttledRef = refThrottled;
exports.throttledWatch = watchThrottled;
exports.timestamp = timestamp;
exports.toReactive = toReactive;
exports.toRefs = toRefs;
exports.tryOnBeforeMount = tryOnBeforeMount;
exports.tryOnBeforeUnmount = tryOnBeforeUnmount;
exports.tryOnMounted = tryOnMounted;
exports.tryOnScopeDispose = tryOnScopeDispose;
exports.tryOnUnmounted = tryOnUnmounted;
exports.until = until;
exports.useArrayEvery = useArrayEvery;
exports.useArrayFilter = useArrayFilter;
exports.useArrayFind = useArrayFind;
exports.useArrayFindIndex = useArrayFindIndex;
exports.useArrayJoin = useArrayJoin;
exports.useArrayMap = useArrayMap;
exports.useArrayReduce = useArrayReduce;
exports.useArraySome = useArraySome;
exports.useCounter = useCounter;
exports.useDateFormat = useDateFormat;
exports.useDebounce = refDebounced;
exports.useDebounceFn = useDebounceFn;
exports.useInterval = useInterval;
exports.useIntervalFn = useIntervalFn;
exports.useLastChanged = useLastChanged;
exports.useThrottle = refThrottled;
exports.useThrottleFn = useThrottleFn;
exports.useTimeout = useTimeout;
exports.useTimeoutFn = useTimeoutFn;
exports.useToNumber = useToNumber;
exports.useToString = useToString;
exports.useToggle = useToggle;
exports.watchArray = watchArray;
exports.watchAtMost = watchAtMost;
exports.watchDebounced = watchDebounced;
exports.watchIgnorable = watchIgnorable;
exports.watchOnce = watchOnce;
exports.watchPausable = watchPausable;
exports.watchThrottled = watchThrottled;
exports.watchTriggerable = watchTriggerable;
exports.watchWithFilter = watchWithFilter;
exports.whenever = whenever;
²/index.iife.min.jsÅ^Kvar VueDemi=function(o,i,F){if(o.install)return o;if(!i)return console.error("[vue-demi] no Vue instance found, please be sure to import `vue` before `vue-demi`."),o;if(i.version.slice(0,4)==="2.7."){let O=function(w,A){var g,C={},N={config:i.config,use:i.use.bind(i),mixin:i.mixin.bind(i),component:i.component.bind(i),provide:function(b,$){return C[b]=$,this},directive:function(b,$){return $?(i.directive(b,$),N):i.directive(b)},mount:function(b,$){return g||(g=new i(Object.assign({propsData:A},w,{provide:Object.assign(C,w.provide)})),g.$mount(b,$),g)},unmount:function(){g&&(g.$destroy(),g=void 0)}};return N};var zt=O;for(var P in i)o[P]=i[P];o.isVue2=!0,o.isVue3=!1,o.install=function(){},o.Vue=i,o.Vue2=i,o.version=i.version,o.warn=i.util.warn,o.createApp=O}else if(i.version.slice(0,2)==="2.")if(F){for(var P in F)o[P]=F[P];o.isVue2=!0,o.isVue3=!1,o.install=function(){},o.Vue=i,o.Vue2=i,o.version=i.version}else console.error("[vue-demi] no VueCompositionAPI instance found, please be sure to import `@vue/composition-api` before `vue-demi`.");else if(i.version.slice(0,2)==="3."){for(var P in i)o[P]=i[P];o.isVue2=!1,o.isVue3=!0,o.install=function(){},o.Vue=i,o.Vue2=void 0,o.version=i.version,o.set=function(O,w,A){return Array.isArray(O)?(O.length=Math.max(O.length,w),O.splice(w,1,A),A):(O[w]=A,A)},o.del=function(O,w){if(Array.isArray(O)){O.splice(w,1);return}delete O[w]}}else console.error("[vue-demi] Vue version "+i.version+" is unsupported.");return o}(this.VueDemi=this.VueDemi||(typeof VueDemi!="undefined"?VueDemi:{}),this.Vue||(typeof Vue!="undefined"?Vue:void 0),this.VueCompositionAPI||(typeof VueCompositionAPI!="undefined"?VueCompositionAPI:void 0));(function(o,i){"use strict";var F=Object.defineProperty,P=Object.defineProperties,zt=Object.getOwnPropertyDescriptors,O=Object.getOwnPropertySymbols,w=Object.prototype.hasOwnProperty,A=Object.prototype.propertyIsEnumerable,g=(t,e,r)=>e in t?F(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,C=(t,e)=>{for(var r in e||(e={}))w.call(e,r)&&g(t,r,e[r]);if(O)for(var r of O(e))A.call(e,r)&&g(t,r,e[r]);return t},N=(t,e)=>P(t,zt(e));function b(t,e){var r;const n=i.shallowRef();return i.watchEffect(()=>{n.value=t()},N(C({},e),{flush:(r=e==null?void 0:e.flush)!=null?r:"sync"})),i.readonly(n)}var $;const E=typeof window!="undefined",Zt=t=>typeof t!="undefined",Jt=(t,...e)=>{t||console.warn(...e)},D=Object.prototype.toString,Xt=t=>typeof t=="boolean",W=t=>typeof t=="function",qt=t=>typeof t=="number",Kt=t=>typeof t=="string",Qt=t=>D.call(t)==="[object Object]",Vt=t=>typeof window!="undefined"&&D.call(t)==="[object Window]",Dt=()=>Date.now(),x=()=>+Date.now(),xt=(t,e,r)=>Math.min(r,Math.max(e,t)),tt=()=>{},te=(t,e)=>(t=Math.ceil(t),e=Math.floor(e),Math.floor(Math.random()*(e-t+1))+t),ee=E&&(($=window==null?void 0:window.navigator)==null?void 0:$.userAgent)&&/iP(ad|hone|od)/.test(window.navigator.userAgent),re=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);function y(t){return typeof t=="function"?t():i.unref(t)}function M(t,e){function r(...n){t(()=>e.apply(this,n),{fn:e,thisArg:this,args:n})}return r}const U=t=>t();function G(t,e={}){let r,n;return l=>{const c=y(t),u=y(e.maxWait);if(r&&clearTimeout(r),c<=0||u!==void 0&&u<=0)return n&&(clearTimeout(n),n=null),l();u&&!n&&(n=setTimeout(()=>{r&&clearTimeout(r),n=null,l()},u)),r=setTimeout(()=>{n&&clearTimeout(n),n=null,l()},c)}}function z(t,e=!0,r=!0){let n=0,a,l=!0;const c=()=>{a&&(clearTimeout(a),a=void 0)};return d=>{const _=y(t),s=Date.now()-n;if(c(),_<=0)return n=Date.now(),d();s>_&&(r||!l)?(n=Date.now(),d()):e&&(a=setTimeout(()=>{n=Date.now(),l=!0,c(),d()},_-s)),!r&&!a&&(a=setTimeout(()=>l=!0,_)),l=!1}}function et(t=U){const e=i.ref(!0);function r(){e.value=!1}function n(){e.value=!0}return{isActive:e,pause:r,resume:n,eventFilter:(...l)=>{e.value&&t(...l)}}}function ne(t="this function"){if(!i.isVue3)throw new Error(`[VueUse] ${t} is only works on Vue 3.`)}function rt(t="this function"){if(!(i.isVue3||i.version.startsWith("2.7.")))throw new Error(`[VueUse] ${t} is only works on Vue 2.7 or above.`)}const oe={mounted:i.isVue3?"mounted":"inserted",updated:i.isVue3?"updated":"componentUpdated",unmounted:i.isVue3?"unmounted":"unbind"};function Z(t,e=!1,r="Timeout"){return new Promise((n,a)=>{setTimeout(e?()=>a(r):n,t)})}function ae(t){return t}function ie(t){let e;function r(){return e||(e=t()),e}return r.reset=async()=>{const n=e;e=void 0,n&&await n},r}function le(t){return t()}function ce(t,...e){return e.some(r=>r in t)}function ue(t,e){var r;if(typeof t=="number")return t+e;const n=((r=t.match(/^-?[0-9]+\.?[0-9]*/))==null?void 0:r[0])||"",a=t.slice(n.length),l=parseFloat(n)+e;return Number.isNaN(l)?t:l+a}function se(t,e,r=!1){return e.reduce((n,a)=>(a in t&&(!r||t[a]!==void 0)&&(n[a]=t[a]),n),{})}function nt(t,e){let r,n,a;const l=i.ref(!0),c=()=>{l.value=!0,a()};i.watch(t,c,{flush:"sync"});const u=W(e)?e:e.get,d=W(e)?void 0:e.set,_=i.customRef((s,f)=>(n=s,a=f,{get(){return l.value&&(r=u(),l.value=!1),n(),r},set(p){d==null||d(p)}}));return Object.isExtensible(_)&&(_.trigger=c),_}function j(t){return i.getCurrentScope()?(i.onScopeDispose(t),!0):!1}function fe(){const t=[],e=a=>{const l=t.indexOf(a);l!==-1&&t.splice(l,1)};return{on:a=>{t.push(a);const l=()=>e(a);return j(l),{off:l}},off:e,trigger:a=>{t.forEach(l=>l(a))}}}function de(t){let e=!1,r;const n=i.effectScope(!0);return()=>(e||(r=n.run(t),e=!0),r)}function pe(t){const e=Symbol("InjectionState");return[(...a)=>{i.provide(e,t(...a))},()=>i.inject(e)]}function ye(t){let e=0,r,n;const a=()=>{e-=1,n&&e<=0&&(n.stop(),r=void 0,n=void 0)};return(...l)=>(e+=1,r||(n=i.effectScope(!0),r=n.run(()=>t(...l))),j(a),r)}function ot(t,e,{enumerable:r=!1,unwrap:n=!0}={}){rt();for(const[a,l]of Object.entries(e))a!=="value"&&(i.isRef(l)&&n?Object.defineProperty(t,a,{get(){return l.value},set(c){l.value=c},enumerable:r}):Object.defineProperty(t,a,{value:l,enumerable:r}));return t}function _e(t,e){return e==null?i.unref(t):i.unref(t)[e]}function ve(t){return i.unref(t)!=null}var he=Object.defineProperty,at=Object.getOwnPropertySymbols,Oe=Object.prototype.hasOwnProperty,we=Object.prototype.propertyIsEnumerable,it=(t,e,r)=>e in t?he(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ge=(t,e)=>{for(var r in e||(e={}))Oe.call(e,r)&&it(t,r,e[r]);if(at)for(var r of at(e))we.call(e,r)&&it(t,r,e[r]);return t};function Pe(t,e){if(typeof Symbol!="undefined"){const r=ge({},t);return Object.defineProperty(r,Symbol.iterator,{enumerable:!1,value(){let n=0;return{next:()=>({value:e[n++],done:n>e.length})}}}),r}else return Object.assign([...e],t)}function J(t,e){const r=(e==null?void 0:e.computedGetter)===!1?i.unref:y;return function(...n){return i.computed(()=>t.apply(this,n.map(a=>r(a))))}}function me(t,e={}){let r=[],n;if(Array.isArray(e))r=e;else{n=e;const{includeOwnProperties:a=!0}=e;r.push(...Object.keys(t)),a&&r.push(...Object.getOwnPropertyNames(t))}return Object.fromEntries(r.map(a=>{const l=t[a];return[a,typeof l=="function"?J(l.bind(t),n):l]}))}function lt(t){if(!i.isRef(t))return i.reactive(t);const e=new Proxy({},{get(r,n,a){return i.unref(Reflect.get(t.value,n,a))},set(r,n,a){return i.isRef(t.value[n])&&!i.isRef(a)?t.value[n].value=a:t.value[n]=a,!0},deleteProperty(r,n){return Reflect.deleteProperty(t.value,n)},has(r,n){return Reflect.has(t.value,n)},ownKeys(){return Object.keys(t.value)},getOwnPropertyDescriptor(){return{enumerable:!0,configurable:!0}}});return i.reactive(e)}function ct(t){return lt(i.computed(t))}function be(t,...e){const r=e.flat();return ct(()=>Object.fromEntries(Object.entries(i.toRefs(t)).filter(n=>!r.includes(n[0]))))}function $e(t,...e){const r=e.flat();return i.reactive(Object.fromEntries(r.map(n=>[n,i.toRef(t,n)])))}function ut(t,e=1e4){return i.customRef((r,n)=>{let a=t,l;const c=()=>setTimeout(()=>{a=t,n()},y(e));return j(()=>{clearTimeout(l)}),{get(){return r(),a},set(u){a=u,n(),clearTimeout(l),l=c()}}})}function st(t,e=200,r={}){return M(G(e,r),t)}function X(t,e=200,r={}){const n=i.ref(t.value),a=st(()=>{n.value=t.value},e,r);return i.watch(t,()=>a()),n}function Se(t,e){return i.computed({get(){var r;return(r=t.value)!=null?r:e},set(r){t.value=r}})}function ft(t,e=200,r=!1,n=!0){return M(z(e,r,n),t)}function q(t,e=200,r=!0,n=!0){if(e<=0)return t;const a=i.ref(t.value),l=ft(()=>{a.value=t.value},e,r,n);return i.watch(t,()=>l()),a}function dt(t,e={}){let r=t,n,a;const l=i.customRef((p,h)=>(n=p,a=h,{get(){return c()},set(v){u(v)}}));function c(p=!0){return p&&n(),r}function u(p,h=!0){var v,S;if(p===r)return;const m=r;((v=e.onBeforeChange)==null?void 0:v.call(e,p,m))!==!1&&(r=p,(S=e.onChanged)==null||S.call(e,p,m),h&&a())}return ot(l,{get:c,set:u,untrackedGet:()=>c(!1),silentSet:p=>u(p,!1),peek:()=>c(!1),lay:p=>u(p,!1)},{enumerable:!0})}const Ae=dt;function je(t){return typeof t=="function"?i.computed(t):i.ref(t)}function Ie(...t){if(t.length===2){const[e,r]=t;e.value=r}if(t.length===3)if(i.isVue2)i.set(...t);else{const[e,r,n]=t;e[r]=n}}function Te(t,e,r={}){var n,a;const{flush:l="sync",deep:c=!1,immediate:u=!0,direction:d="both",transform:_={}}=r;let s,f;const p=(n=_.ltr)!=null?n:v=>v,h=(a=_.rtl)!=null?a:v=>v;return(d==="both"||d==="ltr")&&(s=i.watch(t,v=>e.value=p(v),{flush:l,deep:c,immediate:u})),(d==="both"||d==="rtl")&&(f=i.watch(e,v=>t.value=h(v),{flush:l,deep:c,immediate:u})),()=>{s==null||s(),f==null||f()}}function Fe(t,e,r={}){const{flush:n="sync",deep:a=!1,immediate:l=!0}=r;return Array.isArray(e)||(e=[e]),i.watch(t,c=>e.forEach(u=>u.value=c),{flush:n,deep:a,immediate:l})}var Ee=Object.defineProperty,Me=Object.defineProperties,Re=Object.getOwnPropertyDescriptors,pt=Object.getOwnPropertySymbols,Ce=Object.prototype.hasOwnProperty,Ne=Object.prototype.propertyIsEnumerable,yt=(t,e,r)=>e in t?Ee(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,We=(t,e)=>{for(var r in e||(e={}))Ce.call(e,r)&&yt(t,r,e[r]);if(pt)for(var r of pt(e))Ne.call(e,r)&&yt(t,r,e[r]);return t},Ue=(t,e)=>Me(t,Re(e));function Be(t){if(!i.isRef(t))return i.toRefs(t);const e=Array.isArray(t.value)?new Array(t.value.length):{};for(const r in t.value)e[r]=i.customRef(()=>({get(){return t.value[r]},set(n){if(Array.isArray(t.value)){const a=[...t.value];a[r]=n,t.value=a}else{const a=Ue(We({},t.value),{[r]:n});Object.setPrototypeOf(a,t.value),t.value=a}}}));return e}function Le(t,e=!0){i.getCurrentInstance()?i.onBeforeMount(t):e?t():i.nextTick(t)}function He(t){i.getCurrentInstance()&&i.onBeforeUnmount(t)}function Ye(t,e=!0){i.getCurrentInstance()?i.onMounted(t):e?t():i.nextTick(t)}function ke(t){i.getCurrentInstance()&&i.onUnmounted(t)}function K(t,e=!1){function r(f,{flush:p="sync",deep:h=!1,timeout:v,throwOnTimeout:S}={}){let m=null;const V=[new Promise(k=>{m=i.watch(t,T=>{f(T)!==e&&(m==null||m(),k(T))},{flush:p,deep:h,immediate:!0})})];return v!=null&&V.push(Z(v,S).then(()=>y(t)).finally(()=>m==null?void 0:m())),Promise.race(V)}function n(f,p){if(!i.isRef(f))return r(T=>T===f,p);const{flush:h="sync",deep:v=!1,timeout:S,throwOnTimeout:m}=p??{};let I=null;const k=[new Promise(T=>{I=i.watch([t,f],([Gt,cn])=>{e!==(Gt===cn)&&(I==null||I(),T(Gt))},{flush:h,deep:v,immediate:!0})})];return S!=null&&k.push(Z(S,m).then(()=>y(t)).finally(()=>(I==null||I(),y(t)))),Promise.race(k)}function a(f){return r(p=>Boolean(p),f)}function l(f){return n(null,f)}function c(f){return n(void 0,f)}function u(f){return r(Number.isNaN,f)}function d(f,p){return r(h=>{const v=Array.from(h);return v.includes(f)||v.includes(y(f))},p)}function _(f){return s(1,f)}function s(f=1,p){let h=-1;return r(()=>(h+=1,h>=f),p)}return Array.isArray(y(t))?{toMatch:r,toContains:d,changed:_,changedTimes:s,get not(){return K(t,!e)}}:{toMatch:r,toBe:n,toBeTruthy:a,toBeNull:l,toBeNaN:u,toBeUndefined:c,changed:_,changedTimes:s,get not(){return K(t,!e)}}}function Ge(t){return K(t)}function ze(t,e){return i.computed(()=>y(t).every((r,n,a)=>e(y(r),n,a)))}function Ze(t,e){return i.computed(()=>y(t).map(r=>y(r)).filter(e))}function Je(t,e){return i.computed(()=>y(y(t).find((r,n,a)=>e(y(r),n,a))))}function Xe(t,e){return i.computed(()=>y(t).findIndex((r,n,a)=>e(y(r),n,a)))}function qe(t,e){return i.computed(()=>y(t).map(r=>y(r)).join(y(e)))}function Ke(t,e){return i.computed(()=>y(t).map(r=>y(r)).map(e))}function Qe(t,e,...r){const n=(a,l,c)=>e(y(a),y(l),c);return i.computed(()=>{const a=y(t);return r.length?a.reduce(n,y(r[0])):a.reduce(n)})}function Ve(t,e){return i.computed(()=>y(t).some((r,n,a)=>e(y(r),n,a)))}function De(t=0,e={}){const r=i.ref(t),{max:n=1/0,min:a=-1/0}=e,l=(s=1)=>r.value=Math.min(n,r.value+s),c=(s=1)=>r.value=Math.max(a,r.value-s),u=()=>r.value,d=s=>r.value=Math.max(a,Math.min(n,s));return{count:r,inc:l,dec:c,get:u,set:d,reset:(s=t)=>(t=s,d(s))}}const xe=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,tr=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g,er=(t,e,r,n)=>{let a=t<12?"AM":"PM";return n&&(a=a.split("").reduce((l,c)=>l+=`${c}.`,"")),r?a.toLowerCase():a},_t=(t,e,r={})=>{var n;const a=t.getFullYear(),l=t.getMonth(),c=t.getDate(),u=t.getHours(),d=t.getMinutes(),_=t.getSeconds(),s=t.getMilliseconds(),f=t.getDay(),p=(n=r.customMeridiem)!=null?n:er,h={YY:()=>String(a).slice(-2),YYYY:()=>a,M:()=>l+1,MM:()=>`${l+1}`.padStart(2,"0"),MMM:()=>t.toLocaleDateString(r.locales,{month:"short"}),MMMM:()=>t.toLocaleDateString(r.locales,{month:"long"}),D:()=>String(c),DD:()=>`${c}`.padStart(2,"0"),H:()=>String(u),HH:()=>`${u}`.padStart(2,"0"),h:()=>`${u%12||12}`.padStart(1,"0"),hh:()=>`${u%12||12}`.padStart(2,"0"),m:()=>String(d),mm:()=>`${d}`.padStart(2,"0"),s:()=>String(_),ss:()=>`${_}`.padStart(2,"0"),SSS:()=>`${s}`.padStart(3,"0"),d:()=>f,dd:()=>t.toLocaleDateString(r.locales,{weekday:"narrow"}),ddd:()=>t.toLocaleDateString(r.locales,{weekday:"short"}),dddd:()=>t.toLocaleDateString(r.locales,{weekday:"long"}),A:()=>p(u,d),AA:()=>p(u,d,!1,!0),a:()=>p(u,d,!0),aa:()=>p(u,d,!0,!0)};return e.replace(tr,(v,S)=>S||h[v]())},vt=t=>{if(t===null)return new Date(NaN);if(t===void 0)return new Date;if(t instanceof Date)return new Date(t);if(typeof t=="string"&&!/Z$/i.test(t)){const e=t.match(xe);if(e){const r=e[2]-1||0,n=(e[7]||"0").substring(0,3);return new Date(e[1],r,e[3]||1,e[4]||0,e[5]||0,e[6]||0,n)}}return new Date(t)};function rr(t,e="HH:mm:ss",r={}){return i.computed(()=>_t(vt(y(t)),y(e),r))}function ht(t,e=1e3,r={}){const{immediate:n=!0,immediateCallback:a=!1}=r;let l=null;const c=i.ref(!1);function u(){l&&(clearInterval(l),l=null)}function d(){c.value=!1,u()}function _(){i.unref(e)<=0||(c.value=!0,a&&t(),u(),l=setInterval(t,y(e)))}if(n&&E&&_(),i.isRef(e)||W(e)){const s=i.watch(e,()=>{c.value&&E&&_()});j(s)}return j(d),{isActive:c,pause:d,resume:_}}var nr=Object.defineProperty,Ot=Object.getOwnPropertySymbols,or=Object.prototype.hasOwnProperty,ar=Object.prototype.propertyIsEnumerable,wt=(t,e,r)=>e in t?nr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,ir=(t,e)=>{for(var r in e||(e={}))or.call(e,r)&&wt(t,r,e[r]);if(Ot)for(var r of Ot(e))ar.call(e,r)&&wt(t,r,e[r]);return t};function lr(t=1e3,e={}){const{controls:r=!1,immediate:n=!0,callback:a}=e,l=i.ref(0),c=()=>l.value+=1,u=ht(a?()=>{c(),a(l.value)}:c,t,{immediate:n});return r?ir({counter:l},u):l}function cr(t,e={}){var r;const n=i.ref((r=e.initialValue)!=null?r:null);return i.watch(t,()=>n.value=x(),e),n}function gt(t,e,r={}){const{immediate:n=!0}=r,a=i.ref(!1);let l=null;function c(){l&&(clearTimeout(l),l=null)}function u(){a.value=!1,c()}function d(..._){c(),a.value=!0,l=setTimeout(()=>{a.value=!1,l=null,t(..._)},y(e))}return n&&(a.value=!0,E&&d()),j(u),{isPending:a,start:d,stop:u}}var ur=Object.defineProperty,Pt=Object.getOwnPropertySymbols,sr=Object.prototype.hasOwnProperty,fr=Object.prototype.propertyIsEnumerable,mt=(t,e,r)=>e in t?ur(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,dr=(t,e)=>{for(var r in e||(e={}))sr.call(e,r)&&mt(t,r,e[r]);if(Pt)for(var r of Pt(e))fr.call(e,r)&&mt(t,r,e[r]);return t};function pr(t=1e3,e={}){const{controls:r=!1,callback:n}=e,a=gt(n??tt,t,e),l=i.computed(()=>!a.isPending.value);return r?dr({ready:l},a):l}function yr(t,e={}){const{method:r="parseFloat",radix:n,nanToZero:a}=e;return i.computed(()=>{let l=y(t);return typeof l=="string"&&(l=Number[r](l,n)),a&&isNaN(l)&&(l=0),l})}function _r(t){return i.computed(()=>`${y(t)}`)}function vr(t=!1,e={}){const{truthyValue:r=!0,falsyValue:n=!1}=e,a=i.isRef(t),l=i.ref(t);function c(u){if(arguments.length)return l.value=u,l.value;{const d=y(r);return l.value=l.value===d?y(n):d,l.value}}return a?c:[l,c]}function hr(t,e,r){let n=(r==null?void 0:r.immediate)?[]:[...t instanceof Function?t():Array.isArray(t)?t:i.unref(t)];return i.watch(t,(a,l,c)=>{const u=new Array(n.length),d=[];for(const s of a){let f=!1;for(let p=0;p<n.length;p++)if(!u[p]&&s===n[p]){u[p]=!0,f=!0;break}f||d.push(s)}const _=n.filter((s,f)=>!u[f]);e(a,n,d,_,c),n=[...a]},r)}var bt=Object.getOwnPropertySymbols,Or=Object.prototype.hasOwnProperty,wr=Object.prototype.propertyIsEnumerable,gr=(t,e)=>{var r={};for(var n in t)Or.call(t,n)&&e.indexOf(n)<0&&(r[n]=t[n]);if(t!=null&&bt)for(var n of bt(t))e.indexOf(n)<0&&wr.call(t,n)&&(r[n]=t[n]);return r};function R(t,e,r={}){const n=r,{eventFilter:a=U}=n,l=gr(n,["eventFilter"]);return i.watch(t,M(a,e),l)}var $t=Object.getOwnPropertySymbols,Pr=Object.prototype.hasOwnProperty,mr=Object.prototype.propertyIsEnumerable,br=(t,e)=>{var r={};for(var n in t)Pr.call(t,n)&&e.indexOf(n)<0&&(r[n]=t[n]);if(t!=null&&$t)for(var n of $t(t))e.indexOf(n)<0&&mr.call(t,n)&&(r[n]=t[n]);return r};function $r(t,e,r){const n=r,{count:a}=n,l=br(n,["count"]),c=i.ref(0),u=R(t,(...d)=>{c.value+=1,c.value>=y(a)&&i.nextTick(()=>u()),e(...d)},l);return{count:c,stop:u}}var Sr=Object.defineProperty,Ar=Object.defineProperties,jr=Object.getOwnPropertyDescriptors,B=Object.getOwnPropertySymbols,St=Object.prototype.hasOwnProperty,At=Object.prototype.propertyIsEnumerable,jt=(t,e,r)=>e in t?Sr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,Ir=(t,e)=>{for(var r in e||(e={}))St.call(e,r)&&jt(t,r,e[r]);if(B)for(var r of B(e))At.call(e,r)&&jt(t,r,e[r]);return t},Tr=(t,e)=>Ar(t,jr(e)),Fr=(t,e)=>{var r={};for(var n in t)St.call(t,n)&&e.indexOf(n)<0&&(r[n]=t[n]);if(t!=null&&B)for(var n of B(t))e.indexOf(n)<0&&At.call(t,n)&&(r[n]=t[n]);return r};function It(t,e,r={}){const n=r,{debounce:a=0,maxWait:l=void 0}=n,c=Fr(n,["debounce","maxWait"]);return R(t,e,Tr(Ir({},c),{eventFilter:G(a,{maxWait:l})}))}var Er=Object.defineProperty,Mr=Object.defineProperties,Rr=Object.getOwnPropertyDescriptors,L=Object.getOwnPropertySymbols,Tt=Object.prototype.hasOwnProperty,Ft=Object.prototype.propertyIsEnumerable,Et=(t,e,r)=>e in t?Er(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,Cr=(t,e)=>{for(var r in e||(e={}))Tt.call(e,r)&&Et(t,r,e[r]);if(L)for(var r of L(e))Ft.call(e,r)&&Et(t,r,e[r]);return t},Nr=(t,e)=>Mr(t,Rr(e)),Wr=(t,e)=>{var r={};for(var n in t)Tt.call(t,n)&&e.indexOf(n)<0&&(r[n]=t[n]);if(t!=null&&L)for(var n of L(t))e.indexOf(n)<0&&Ft.call(t,n)&&(r[n]=t[n]);return r};function Q(t,e,r={}){const n=r,{eventFilter:a=U}=n,l=Wr(n,["eventFilter"]),c=M(a,e);let u,d,_;if(l.flush==="sync"){const s=i.ref(!1);d=()=>{},u=f=>{s.value=!0,f(),s.value=!1},_=i.watch(t,(...f)=>{s.value||c(...f)},l)}else{const s=[],f=i.ref(0),p=i.ref(0);d=()=>{f.value=p.value},s.push(i.watch(t,()=>{p.value++},Nr(Cr({},l),{flush:"sync"}))),u=h=>{const v=p.value;h(),f.value+=p.value-v},s.push(i.watch(t,(...h)=>{const v=f.value>0&&f.value===p.value;f.value=0,p.value=0,!v&&c(...h)},l)),_=()=>{s.forEach(h=>h())}}return{stop:_,ignoreUpdates:u,ignorePrevAsyncUpdates:d}}function Ur(t,e,r){const n=i.watch(t,(...a)=>(i.nextTick(()=>n()),e(...a)),r)}var Br=Object.defineProperty,Lr=Object.defineProperties,Hr=Object.getOwnPropertyDescriptors,H=Object.getOwnPropertySymbols,Mt=Object.prototype.hasOwnProperty,Rt=Object.prototype.propertyIsEnumerable,Ct=(t,e,r)=>e in t?Br(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,Yr=(t,e)=>{for(var r in e||(e={}))Mt.call(e,r)&&Ct(t,r,e[r]);if(H)for(var r of H(e))Rt.call(e,r)&&Ct(t,r,e[r]);return t},kr=(t,e)=>Lr(t,Hr(e)),Gr=(t,e)=>{var r={};for(var n in t)Mt.call(t,n)&&e.indexOf(n)<0&&(r[n]=t[n]);if(t!=null&&H)for(var n of H(t))e.indexOf(n)<0&&Rt.call(t,n)&&(r[n]=t[n]);return r};function Nt(t,e,r={}){const n=r,{eventFilter:a}=n,l=Gr(n,["eventFilter"]),{eventFilter:c,pause:u,resume:d,isActive:_}=et(a);return{stop:R(t,e,kr(Yr({},l),{eventFilter:c})),pause:u,resume:d,isActive:_}}var zr=Object.defineProperty,Zr=Object.defineProperties,Jr=Object.getOwnPropertyDescriptors,Y=Object.getOwnPropertySymbols,Wt=Object.prototype.hasOwnProperty,Ut=Object.prototype.propertyIsEnumerable,Bt=(t,e,r)=>e in t?zr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,Xr=(t,e)=>{for(var r in e||(e={}))Wt.call(e,r)&&Bt(t,r,e[r]);if(Y)for(var r of Y(e))Ut.call(e,r)&&Bt(t,r,e[r]);return t},qr=(t,e)=>Zr(t,Jr(e)),Kr=(t,e)=>{var r={};for(var n in t)Wt.call(t,n)&&e.indexOf(n)<0&&(r[n]=t[n]);if(t!=null&&Y)for(var n of Y(t))e.indexOf(n)<0&&Ut.call(t,n)&&(r[n]=t[n]);return r};function Lt(t,e,r={}){const n=r,{throttle:a=0,trailing:l=!0,leading:c=!0}=n,u=Kr(n,["throttle","trailing","leading"]);return R(t,e,qr(Xr({},u),{eventFilter:z(a,l,c)}))}var Qr=Object.defineProperty,Vr=Object.defineProperties,Dr=Object.getOwnPropertyDescriptors,Ht=Object.getOwnPropertySymbols,xr=Object.prototype.hasOwnProperty,tn=Object.prototype.propertyIsEnumerable,Yt=(t,e,r)=>e in t?Qr(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,en=(t,e)=>{for(var r in e||(e={}))xr.call(e,r)&&Yt(t,r,e[r]);if(Ht)for(var r of Ht(e))tn.call(e,r)&&Yt(t,r,e[r]);return t},rn=(t,e)=>Vr(t,Dr(e));function nn(t,e,r={}){let n;function a(){if(!n)return;const s=n;n=void 0,s()}function l(s){n=s}const c=(s,f)=>(a(),e(s,f,l)),u=Q(t,c,r),{ignoreUpdates:d}=u,_=()=>{let s;return d(()=>{s=c(on(t),an(t))}),s};return rn(en({},u),{trigger:_})}function on(t){return i.isReactive(t)?t:Array.isArray(t)?t.map(e=>kt(e)):kt(t)}function kt(t){return typeof t=="function"?t():i.unref(t)}function an(t){return Array.isArray(t)?t.map(()=>{}):void 0}function ln(t,e,r){return i.watch(t,(n,a,l)=>{n&&e(n,a,l)},r)}o.__onlyVue27Plus=rt,o.__onlyVue3=ne,o.assert=Jt,o.autoResetRef=ut,o.bypassFilter=U,o.clamp=xt,o.computedEager=b,o.computedWithControl=nt,o.containsProp=ce,o.controlledComputed=nt,o.controlledRef=Ae,o.createEventHook=fe,o.createFilterWrapper=M,o.createGlobalState=de,o.createInjectionState=pe,o.createReactiveFn=J,o.createSharedComposable=ye,o.createSingletonPromise=ie,o.debounceFilter=G,o.debouncedRef=X,o.debouncedWatch=It,o.directiveHooks=oe,o.eagerComputed=b,o.extendRef=ot,o.formatDate=_t,o.get=_e,o.hasOwn=re,o.identity=ae,o.ignorableWatch=Q,o.increaseWithUnit=ue,o.invoke=le,o.isBoolean=Xt,o.isClient=E,o.isDef=Zt,o.isDefined=ve,o.isFunction=W,o.isIOS=ee,o.isNumber=qt,o.isObject=Qt,o.isString=Kt,o.isWindow=Vt,o.makeDestructurable=Pe,o.noop=tt,o.normalizeDate=vt,o.now=Dt,o.objectPick=se,o.pausableFilter=et,o.pausableWatch=Nt,o.promiseTimeout=Z,o.rand=te,o.reactify=J,o.reactifyObject=me,o.reactiveComputed=ct,o.reactiveOmit=be,o.reactivePick=$e,o.refAutoReset=ut,o.refDebounced=X,o.refDefault=Se,o.refThrottled=q,o.refWithControl=dt,o.resolveRef=je,o.resolveUnref=y,o.set=Ie,o.syncRef=Te,o.syncRefs=Fe,o.throttleFilter=z,o.throttledRef=q,o.throttledWatch=Lt,o.timestamp=x,o.toReactive=lt,o.toRefs=Be,o.tryOnBeforeMount=Le,o.tryOnBeforeUnmount=He,o.tryOnMounted=Ye,o.tryOnScopeDispose=j,o.tryOnUnmounted=ke,o.until=Ge,o.useArrayEvery=ze,o.useArrayFilter=Ze,o.useArrayFind=Je,o.useArrayFindIndex=Xe,o.useArrayJoin=qe,o.useArrayMap=Ke,o.useArrayReduce=Qe,o.useArraySome=Ve,o.useCounter=De,o.useDateFormat=rr,o.useDebounce=X,o.useDebounceFn=st,o.useInterval=lr,o.useIntervalFn=ht,o.useLastChanged=cr,o.useThrottle=q,o.useThrottleFn=ft,o.useTimeout=pr,o.useTimeoutFn=gt,o.useToNumber=yr,o.useToString=_r,o.useToggle=vr,o.watchArray=hr,o.watchAtMost=$r,o.watchDebounced=It,o.watchIgnorable=Q,o.watchOnce=Ur,o.watchPausable=Nt,o.watchThrottled=Lt,o.watchTriggerable=nn,o.watchWithFilter=R,o.whenever=ln})(this.VueUse=this.VueUse||{},VueDemi);
¨/LICENSEÅMMIT License

Copyright (c) 2019-PRESENT Anthony Fu<https://github.com/antfu>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
­/package.jsonÅw{
  "name": "@vueuse/shared",
  "version": "9.8.2",
  "author": "Anthony Fu <https://github.com/antfu>",
  "license": "MIT",
  "funding": "https://github.com/sponsors/antfu",
  "homepage": "https://github.com/vueuse/vueuse/tree/main/packages/shared#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/vueuse/vueuse.git",
    "directory": "packages/shared"
  },
  "bugs": {
    "url": "https://github.com/vueuse/vueuse/issues"
  },
  "keywords": [
    "vue",
    "vue-use",
    "utils"
  ],
  "sideEffects": false,
  "exports": {
    ".": {
      "types": "./index.d.ts",
      "require": "./index.cjs",
      "import": "./index.mjs"
    },
    "./*": "./*"
  },
  "main": "./index.cjs",
  "module": "./index.mjs",
  "unpkg": "./index.iife.min.js",
  "jsdelivr": "./index.iife.min.js",
  "types": "./index.d.ts",
  "dependencies": {
    "vue-demi": "*"
  }
}
®/index.iife.jsÅÙvar VueDemi = (function (VueDemi, Vue, VueCompositionAPI) {
  if (VueDemi.install) {
    return VueDemi
  }
  if (!Vue) {
    console.error('[vue-demi] no Vue instance found, please be sure to import `vue` before `vue-demi`.')
    return VueDemi
  }

  // Vue 2.7
  if (Vue.version.slice(0, 4) === '2.7.') {
    for (var key in Vue) {
      VueDemi[key] = Vue[key]
    }
    VueDemi.isVue2 = true
    VueDemi.isVue3 = false
    VueDemi.install = function () {}
    VueDemi.Vue = Vue
    VueDemi.Vue2 = Vue
    VueDemi.version = Vue.version
    VueDemi.warn = Vue.util.warn
    function createApp(rootComponent, rootProps) {
      var vm
      var provide = {}
      var app = {
        config: Vue.config,
        use: Vue.use.bind(Vue),
        mixin: Vue.mixin.bind(Vue),
        component: Vue.component.bind(Vue),
        provide: function (key, value) {
          provide[key] = value
          return this
        },
        directive: function (name, dir) {
          if (dir) {
            Vue.directive(name, dir)
            return app
          } else {
            return Vue.directive(name)
          }
        },
        mount: function (el, hydrating) {
          if (!vm) {
            vm = new Vue(Object.assign({ propsData: rootProps }, rootComponent, { provide: Object.assign(provide, rootComponent.provide) }))
            vm.$mount(el, hydrating)
            return vm
          } else {
            return vm
          }
        },
        unmount: function () {
          if (vm) {
            vm.$destroy()
            vm = undefined
          }
        },
      }
      return app
    }
    VueDemi.createApp = createApp
  }
  // Vue 2.6.x
  else if (Vue.version.slice(0, 2) === '2.') {
    if (VueCompositionAPI) {
      for (var key in VueCompositionAPI) {
        VueDemi[key] = VueCompositionAPI[key]
      }
      VueDemi.isVue2 = true
      VueDemi.isVue3 = false
      VueDemi.install = function () {}
      VueDemi.Vue = Vue
      VueDemi.Vue2 = Vue
      VueDemi.version = Vue.version
    } else {
      console.error('[vue-demi] no VueCompositionAPI instance found, please be sure to import `@vue/composition-api` before `vue-demi`.')
    }
  }
  // Vue 3
  else if (Vue.version.slice(0, 2) === '3.') {
    for (var key in Vue) {
      VueDemi[key] = Vue[key]
    }
    VueDemi.isVue2 = false
    VueDemi.isVue3 = true
    VueDemi.install = function () {}
    VueDemi.Vue = Vue
    VueDemi.Vue2 = undefined
    VueDemi.version = Vue.version
    VueDemi.set = function (target, key, val) {
      if (Array.isArray(target)) {
        target.length = Math.max(target.length, key)
        target.splice(key, 1, val)
        return val
      }
      target[key] = val
      return val
    }
    VueDemi.del = function (target, key) {
      if (Array.isArray(target)) {
        target.splice(key, 1)
        return
      }
      delete target[key]
    }
  } else {
    console.error('[vue-demi] Vue version ' + Vue.version + ' is unsupported.')
  }
  return VueDemi
})(
  (this.VueDemi = this.VueDemi || (typeof VueDemi !== 'undefined' ? VueDemi : {})),
  this.Vue || (typeof Vue !== 'undefined' ? Vue : undefined),
  this.VueCompositionAPI || (typeof VueCompositionAPI !== 'undefined' ? VueCompositionAPI : undefined)
);
;
;(function (exports, vueDemi) {
  'use strict';

  var __defProp$9 = Object.defineProperty;
  var __defProps$6 = Object.defineProperties;
  var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
  var __hasOwnProp$b = Object.prototype.hasOwnProperty;
  var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$9 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$b.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    if (__getOwnPropSymbols$b)
      for (var prop of __getOwnPropSymbols$b(b)) {
        if (__propIsEnum$b.call(b, prop))
          __defNormalProp$9(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
  function computedEager(fn, options) {
    var _a;
    const result = vueDemi.shallowRef();
    vueDemi.watchEffect(() => {
      result.value = fn();
    }, __spreadProps$6(__spreadValues$9({}, options), {
      flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
    }));
    return vueDemi.readonly(result);
  }

  var _a;
  const isClient = typeof window !== "undefined";
  const isDef = (val) => typeof val !== "undefined";
  const assert = (condition, ...infos) => {
    if (!condition)
      console.warn(...infos);
  };
  const toString = Object.prototype.toString;
  const isBoolean = (val) => typeof val === "boolean";
  const isFunction = (val) => typeof val === "function";
  const isNumber = (val) => typeof val === "number";
  const isString = (val) => typeof val === "string";
  const isObject = (val) => toString.call(val) === "[object Object]";
  const isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
  const now = () => Date.now();
  const timestamp = () => +Date.now();
  const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
  const noop = () => {
  };
  const rand = (min, max) => {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };
  const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
  const hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);

  function resolveUnref(r) {
    return typeof r === "function" ? r() : vueDemi.unref(r);
  }

  function createFilterWrapper(filter, fn) {
    function wrapper(...args) {
      filter(() => fn.apply(this, args), { fn, thisArg: this, args });
    }
    return wrapper;
  }
  const bypassFilter = (invoke) => {
    return invoke();
  };
  function debounceFilter(ms, options = {}) {
    let timer;
    let maxTimer;
    const filter = (invoke) => {
      const duration = resolveUnref(ms);
      const maxDuration = resolveUnref(options.maxWait);
      if (timer)
        clearTimeout(timer);
      if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
        if (maxTimer) {
          clearTimeout(maxTimer);
          maxTimer = null;
        }
        return invoke();
      }
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            clearTimeout(timer);
          maxTimer = null;
          invoke();
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          clearTimeout(maxTimer);
        maxTimer = null;
        invoke();
      }, duration);
    };
    return filter;
  }
  function throttleFilter(ms, trailing = true, leading = true) {
    let lastExec = 0;
    let timer;
    let isLeading = true;
    const clear = () => {
      if (timer) {
        clearTimeout(timer);
        timer = void 0;
      }
    };
    const filter = (invoke) => {
      const duration = resolveUnref(ms);
      const elapsed = Date.now() - lastExec;
      clear();
      if (duration <= 0) {
        lastExec = Date.now();
        return invoke();
      }
      if (elapsed > duration && (leading || !isLeading)) {
        lastExec = Date.now();
        invoke();
      } else if (trailing) {
        timer = setTimeout(() => {
          lastExec = Date.now();
          isLeading = true;
          clear();
          invoke();
        }, duration - elapsed);
      }
      if (!leading && !timer)
        timer = setTimeout(() => isLeading = true, duration);
      isLeading = false;
    };
    return filter;
  }
  function pausableFilter(extendFilter = bypassFilter) {
    const isActive = vueDemi.ref(true);
    function pause() {
      isActive.value = false;
    }
    function resume() {
      isActive.value = true;
    }
    const eventFilter = (...args) => {
      if (isActive.value)
        extendFilter(...args);
    };
    return { isActive, pause, resume, eventFilter };
  }

  function __onlyVue3(name = "this function") {
    if (vueDemi.isVue3)
      return;
    throw new Error(`[VueUse] ${name} is only works on Vue 3.`);
  }
  function __onlyVue27Plus(name = "this function") {
    if (vueDemi.isVue3 || vueDemi.version.startsWith("2.7."))
      return;
    throw new Error(`[VueUse] ${name} is only works on Vue 2.7 or above.`);
  }
  const directiveHooks = {
    mounted: vueDemi.isVue3 ? "mounted" : "inserted",
    updated: vueDemi.isVue3 ? "updated" : "componentUpdated",
    unmounted: vueDemi.isVue3 ? "unmounted" : "unbind"
  };

  function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
    return new Promise((resolve, reject) => {
      if (throwOnTimeout)
        setTimeout(() => reject(reason), ms);
      else
        setTimeout(resolve, ms);
    });
  }
  function identity(arg) {
    return arg;
  }
  function createSingletonPromise(fn) {
    let _promise;
    function wrapper() {
      if (!_promise)
        _promise = fn();
      return _promise;
    }
    wrapper.reset = async () => {
      const _prev = _promise;
      _promise = void 0;
      if (_prev)
        await _prev;
    };
    return wrapper;
  }
  function invoke(fn) {
    return fn();
  }
  function containsProp(obj, ...props) {
    return props.some((k) => k in obj);
  }
  function increaseWithUnit(target, delta) {
    var _a;
    if (typeof target === "number")
      return target + delta;
    const value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a[0]) || "";
    const unit = target.slice(value.length);
    const result = parseFloat(value) + delta;
    if (Number.isNaN(result))
      return target;
    return result + unit;
  }
  function objectPick(obj, keys, omitUndefined = false) {
    return keys.reduce((n, k) => {
      if (k in obj) {
        if (!omitUndefined || obj[k] !== void 0)
          n[k] = obj[k];
      }
      return n;
    }, {});
  }

  function computedWithControl(source, fn) {
    let v = void 0;
    let track;
    let trigger;
    const dirty = vueDemi.ref(true);
    const update = () => {
      dirty.value = true;
      trigger();
    };
    vueDemi.watch(source, update, { flush: "sync" });
    const get = isFunction(fn) ? fn : fn.get;
    const set = isFunction(fn) ? void 0 : fn.set;
    const result = vueDemi.customRef((_track, _trigger) => {
      track = _track;
      trigger = _trigger;
      return {
        get() {
          if (dirty.value) {
            v = get();
            dirty.value = false;
          }
          track();
          return v;
        },
        set(v2) {
          set == null ? void 0 : set(v2);
        }
      };
    });
    if (Object.isExtensible(result))
      result.trigger = update;
    return result;
  }

  function tryOnScopeDispose(fn) {
    if (vueDemi.getCurrentScope()) {
      vueDemi.onScopeDispose(fn);
      return true;
    }
    return false;
  }

  function createEventHook() {
    const fns = [];
    const off = (fn) => {
      const index = fns.indexOf(fn);
      if (index !== -1)
        fns.splice(index, 1);
    };
    const on = (fn) => {
      fns.push(fn);
      const offFn = () => off(fn);
      tryOnScopeDispose(offFn);
      return {
        off: offFn
      };
    };
    const trigger = (param) => {
      fns.forEach((fn) => fn(param));
    };
    return {
      on,
      off,
      trigger
    };
  }

  function createGlobalState(stateFactory) {
    let initialized = false;
    let state;
    const scope = vueDemi.effectScope(true);
    return () => {
      if (!initialized) {
        state = scope.run(stateFactory);
        initialized = true;
      }
      return state;
    };
  }

  function createInjectionState(composable) {
    const key = Symbol("InjectionState");
    const useProvidingState = (...args) => {
      vueDemi.provide(key, composable(...args));
    };
    const useInjectedState = () => vueDemi.inject(key);
    return [useProvidingState, useInjectedState];
  }

  function createSharedComposable(composable) {
    let subscribers = 0;
    let state;
    let scope;
    const dispose = () => {
      subscribers -= 1;
      if (scope && subscribers <= 0) {
        scope.stop();
        state = void 0;
        scope = void 0;
      }
    };
    return (...args) => {
      subscribers += 1;
      if (!state) {
        scope = vueDemi.effectScope(true);
        state = scope.run(() => composable(...args));
      }
      tryOnScopeDispose(dispose);
      return state;
    };
  }

  function extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {
    __onlyVue27Plus();
    for (const [key, value] of Object.entries(extend)) {
      if (key === "value")
        continue;
      if (vueDemi.isRef(value) && unwrap) {
        Object.defineProperty(ref, key, {
          get() {
            return value.value;
          },
          set(v) {
            value.value = v;
          },
          enumerable
        });
      } else {
        Object.defineProperty(ref, key, { value, enumerable });
      }
    }
    return ref;
  }

  function get(obj, key) {
    if (key == null)
      return vueDemi.unref(obj);
    return vueDemi.unref(obj)[key];
  }

  function isDefined(v) {
    return vueDemi.unref(v) != null;
  }

  var __defProp$8 = Object.defineProperty;
  var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
  var __hasOwnProp$a = Object.prototype.hasOwnProperty;
  var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$8 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$a.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    if (__getOwnPropSymbols$a)
      for (var prop of __getOwnPropSymbols$a(b)) {
        if (__propIsEnum$a.call(b, prop))
          __defNormalProp$8(a, prop, b[prop]);
      }
    return a;
  };
  function makeDestructurable(obj, arr) {
    if (typeof Symbol !== "undefined") {
      const clone = __spreadValues$8({}, obj);
      Object.defineProperty(clone, Symbol.iterator, {
        enumerable: false,
        value() {
          let index = 0;
          return {
            next: () => ({
              value: arr[index++],
              done: index > arr.length
            })
          };
        }
      });
      return clone;
    } else {
      return Object.assign([...arr], obj);
    }
  }

  function reactify(fn, options) {
    const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? vueDemi.unref : resolveUnref;
    return function(...args) {
      return vueDemi.computed(() => fn.apply(this, args.map((i) => unrefFn(i))));
    };
  }

  function reactifyObject(obj, optionsOrKeys = {}) {
    let keys = [];
    let options;
    if (Array.isArray(optionsOrKeys)) {
      keys = optionsOrKeys;
    } else {
      options = optionsOrKeys;
      const { includeOwnProperties = true } = optionsOrKeys;
      keys.push(...Object.keys(obj));
      if (includeOwnProperties)
        keys.push(...Object.getOwnPropertyNames(obj));
    }
    return Object.fromEntries(keys.map((key) => {
      const value = obj[key];
      return [
        key,
        typeof value === "function" ? reactify(value.bind(obj), options) : value
      ];
    }));
  }

  function toReactive(objectRef) {
    if (!vueDemi.isRef(objectRef))
      return vueDemi.reactive(objectRef);
    const proxy = new Proxy({}, {
      get(_, p, receiver) {
        return vueDemi.unref(Reflect.get(objectRef.value, p, receiver));
      },
      set(_, p, value) {
        if (vueDemi.isRef(objectRef.value[p]) && !vueDemi.isRef(value))
          objectRef.value[p].value = value;
        else
          objectRef.value[p] = value;
        return true;
      },
      deleteProperty(_, p) {
        return Reflect.deleteProperty(objectRef.value, p);
      },
      has(_, p) {
        return Reflect.has(objectRef.value, p);
      },
      ownKeys() {
        return Object.keys(objectRef.value);
      },
      getOwnPropertyDescriptor() {
        return {
          enumerable: true,
          configurable: true
        };
      }
    });
    return vueDemi.reactive(proxy);
  }

  function reactiveComputed(fn) {
    return toReactive(vueDemi.computed(fn));
  }

  function reactiveOmit(obj, ...keys) {
    const flatKeys = keys.flat();
    return reactiveComputed(() => Object.fromEntries(Object.entries(vueDemi.toRefs(obj)).filter((e) => !flatKeys.includes(e[0]))));
  }

  function reactivePick(obj, ...keys) {
    const flatKeys = keys.flat();
    return vueDemi.reactive(Object.fromEntries(flatKeys.map((k) => [k, vueDemi.toRef(obj, k)])));
  }

  function refAutoReset(defaultValue, afterMs = 1e4) {
    return vueDemi.customRef((track, trigger) => {
      let value = defaultValue;
      let timer;
      const resetAfter = () => setTimeout(() => {
        value = defaultValue;
        trigger();
      }, resolveUnref(afterMs));
      tryOnScopeDispose(() => {
        clearTimeout(timer);
      });
      return {
        get() {
          track();
          return value;
        },
        set(newValue) {
          value = newValue;
          trigger();
          clearTimeout(timer);
          timer = resetAfter();
        }
      };
    });
  }

  function useDebounceFn(fn, ms = 200, options = {}) {
    return createFilterWrapper(debounceFilter(ms, options), fn);
  }

  function refDebounced(value, ms = 200, options = {}) {
    const debounced = vueDemi.ref(value.value);
    const updater = useDebounceFn(() => {
      debounced.value = value.value;
    }, ms, options);
    vueDemi.watch(value, () => updater());
    return debounced;
  }

  function refDefault(source, defaultValue) {
    return vueDemi.computed({
      get() {
        var _a;
        return (_a = source.value) != null ? _a : defaultValue;
      },
      set(value) {
        source.value = value;
      }
    });
  }

  function useThrottleFn(fn, ms = 200, trailing = false, leading = true) {
    return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
  }

  function refThrottled(value, delay = 200, trailing = true, leading = true) {
    if (delay <= 0)
      return value;
    const throttled = vueDemi.ref(value.value);
    const updater = useThrottleFn(() => {
      throttled.value = value.value;
    }, delay, trailing, leading);
    vueDemi.watch(value, () => updater());
    return throttled;
  }

  function refWithControl(initial, options = {}) {
    let source = initial;
    let track;
    let trigger;
    const ref = vueDemi.customRef((_track, _trigger) => {
      track = _track;
      trigger = _trigger;
      return {
        get() {
          return get();
        },
        set(v) {
          set(v);
        }
      };
    });
    function get(tracking = true) {
      if (tracking)
        track();
      return source;
    }
    function set(value, triggering = true) {
      var _a, _b;
      if (value === source)
        return;
      const old = source;
      if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)
        return;
      source = value;
      (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);
      if (triggering)
        trigger();
    }
    const untrackedGet = () => get(false);
    const silentSet = (v) => set(v, false);
    const peek = () => get(false);
    const lay = (v) => set(v, false);
    return extendRef(ref, {
      get,
      set,
      untrackedGet,
      silentSet,
      peek,
      lay
    }, { enumerable: true });
  }
  const controlledRef = refWithControl;

  function resolveRef(r) {
    return typeof r === "function" ? vueDemi.computed(r) : vueDemi.ref(r);
  }

  function set(...args) {
    if (args.length === 2) {
      const [ref, value] = args;
      ref.value = value;
    }
    if (args.length === 3) {
      if (vueDemi.isVue2) {
        vueDemi.set(...args);
      } else {
        const [target, key, value] = args;
        target[key] = value;
      }
    }
  }

  function syncRef(left, right, options = {}) {
    var _a, _b;
    const {
      flush = "sync",
      deep = false,
      immediate = true,
      direction = "both",
      transform = {}
    } = options;
    let watchLeft;
    let watchRight;
    const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;
    const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;
    if (direction === "both" || direction === "ltr") {
      watchLeft = vueDemi.watch(left, (newValue) => right.value = transformLTR(newValue), { flush, deep, immediate });
    }
    if (direction === "both" || direction === "rtl") {
      watchRight = vueDemi.watch(right, (newValue) => left.value = transformRTL(newValue), { flush, deep, immediate });
    }
    return () => {
      watchLeft == null ? void 0 : watchLeft();
      watchRight == null ? void 0 : watchRight();
    };
  }

  function syncRefs(source, targets, options = {}) {
    const {
      flush = "sync",
      deep = false,
      immediate = true
    } = options;
    if (!Array.isArray(targets))
      targets = [targets];
    return vueDemi.watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });
  }

  var __defProp$7 = Object.defineProperty;
  var __defProps$5 = Object.defineProperties;
  var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
  var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
  var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$7 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$9.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    if (__getOwnPropSymbols$9)
      for (var prop of __getOwnPropSymbols$9(b)) {
        if (__propIsEnum$9.call(b, prop))
          __defNormalProp$7(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
  function toRefs(objectRef) {
    if (!vueDemi.isRef(objectRef))
      return vueDemi.toRefs(objectRef);
    const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};
    for (const key in objectRef.value) {
      result[key] = vueDemi.customRef(() => ({
        get() {
          return objectRef.value[key];
        },
        set(v) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });
            Object.setPrototypeOf(newObject, objectRef.value);
            objectRef.value = newObject;
          }
        }
      }));
    }
    return result;
  }

  function tryOnBeforeMount(fn, sync = true) {
    if (vueDemi.getCurrentInstance())
      vueDemi.onBeforeMount(fn);
    else if (sync)
      fn();
    else
      vueDemi.nextTick(fn);
  }

  function tryOnBeforeUnmount(fn) {
    if (vueDemi.getCurrentInstance())
      vueDemi.onBeforeUnmount(fn);
  }

  function tryOnMounted(fn, sync = true) {
    if (vueDemi.getCurrentInstance())
      vueDemi.onMounted(fn);
    else if (sync)
      fn();
    else
      vueDemi.nextTick(fn);
  }

  function tryOnUnmounted(fn) {
    if (vueDemi.getCurrentInstance())
      vueDemi.onUnmounted(fn);
  }

  function createUntil(r, isNot = false) {
    function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
      let stop = null;
      const watcher = new Promise((resolve) => {
        stop = vueDemi.watch(r, (v) => {
          if (condition(v) !== isNot) {
            stop == null ? void 0 : stop();
            resolve(v);
          }
        }, {
          flush,
          deep,
          immediate: true
        });
      });
      const promises = [watcher];
      if (timeout != null) {
        promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => stop == null ? void 0 : stop()));
      }
      return Promise.race(promises);
    }
    function toBe(value, options) {
      if (!vueDemi.isRef(value))
        return toMatch((v) => v === value, options);
      const { flush = "sync", deep = false, timeout, throwOnTimeout } = options != null ? options : {};
      let stop = null;
      const watcher = new Promise((resolve) => {
        stop = vueDemi.watch([r, value], ([v1, v2]) => {
          if (isNot !== (v1 === v2)) {
            stop == null ? void 0 : stop();
            resolve(v1);
          }
        }, {
          flush,
          deep,
          immediate: true
        });
      });
      const promises = [watcher];
      if (timeout != null) {
        promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => {
          stop == null ? void 0 : stop();
          return resolveUnref(r);
        }));
      }
      return Promise.race(promises);
    }
    function toBeTruthy(options) {
      return toMatch((v) => Boolean(v), options);
    }
    function toBeNull(options) {
      return toBe(null, options);
    }
    function toBeUndefined(options) {
      return toBe(void 0, options);
    }
    function toBeNaN(options) {
      return toMatch(Number.isNaN, options);
    }
    function toContains(value, options) {
      return toMatch((v) => {
        const array = Array.from(v);
        return array.includes(value) || array.includes(resolveUnref(value));
      }, options);
    }
    function changed(options) {
      return changedTimes(1, options);
    }
    function changedTimes(n = 1, options) {
      let count = -1;
      return toMatch(() => {
        count += 1;
        return count >= n;
      }, options);
    }
    if (Array.isArray(resolveUnref(r))) {
      const instance = {
        toMatch,
        toContains,
        changed,
        changedTimes,
        get not() {
          return createUntil(r, !isNot);
        }
      };
      return instance;
    } else {
      const instance = {
        toMatch,
        toBe,
        toBeTruthy,
        toBeNull,
        toBeNaN,
        toBeUndefined,
        changed,
        changedTimes,
        get not() {
          return createUntil(r, !isNot);
        }
      };
      return instance;
    }
  }
  function until(r) {
    return createUntil(r);
  }

  function useArrayEvery(list, fn) {
    return vueDemi.computed(() => resolveUnref(list).every((element, index, array) => fn(resolveUnref(element), index, array)));
  }

  function useArrayFilter(list, fn) {
    return vueDemi.computed(() => resolveUnref(list).map((i) => resolveUnref(i)).filter(fn));
  }

  function useArrayFind(list, fn) {
    return vueDemi.computed(() => resolveUnref(resolveUnref(list).find((element, index, array) => fn(resolveUnref(element), index, array))));
  }

  function useArrayFindIndex(list, fn) {
    return vueDemi.computed(() => resolveUnref(list).findIndex((element, index, array) => fn(resolveUnref(element), index, array)));
  }

  function useArrayJoin(list, separator) {
    return vueDemi.computed(() => resolveUnref(list).map((i) => resolveUnref(i)).join(resolveUnref(separator)));
  }

  function useArrayMap(list, fn) {
    return vueDemi.computed(() => resolveUnref(list).map((i) => resolveUnref(i)).map(fn));
  }

  function useArrayReduce(list, reducer, ...args) {
    const reduceCallback = (sum, value, index) => reducer(resolveUnref(sum), resolveUnref(value), index);
    return vueDemi.computed(() => {
      const resolved = resolveUnref(list);
      return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);
    });
  }

  function useArraySome(list, fn) {
    return vueDemi.computed(() => resolveUnref(list).some((element, index, array) => fn(resolveUnref(element), index, array)));
  }

  function useCounter(initialValue = 0, options = {}) {
    const count = vueDemi.ref(initialValue);
    const {
      max = Infinity,
      min = -Infinity
    } = options;
    const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);
    const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);
    const get = () => count.value;
    const set = (val) => count.value = Math.max(min, Math.min(max, val));
    const reset = (val = initialValue) => {
      initialValue = val;
      return set(val);
    };
    return { count, inc, dec, get, set, reset };
  }

  const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
  const REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
  const defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {
    let m = hours < 12 ? "AM" : "PM";
    if (hasPeriod)
      m = m.split("").reduce((acc, curr) => acc += `${curr}.`, "");
    return isLowercase ? m.toLowerCase() : m;
  };
  const formatDate = (date, formatStr, options = {}) => {
    var _a;
    const years = date.getFullYear();
    const month = date.getMonth();
    const days = date.getDate();
    const hours = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    const milliseconds = date.getMilliseconds();
    const day = date.getDay();
    const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;
    const matches = {
      YY: () => String(years).slice(-2),
      YYYY: () => years,
      M: () => month + 1,
      MM: () => `${month + 1}`.padStart(2, "0"),
      MMM: () => date.toLocaleDateString(options.locales, { month: "short" }),
      MMMM: () => date.toLocaleDateString(options.locales, { month: "long" }),
      D: () => String(days),
      DD: () => `${days}`.padStart(2, "0"),
      H: () => String(hours),
      HH: () => `${hours}`.padStart(2, "0"),
      h: () => `${hours % 12 || 12}`.padStart(1, "0"),
      hh: () => `${hours % 12 || 12}`.padStart(2, "0"),
      m: () => String(minutes),
      mm: () => `${minutes}`.padStart(2, "0"),
      s: () => String(seconds),
      ss: () => `${seconds}`.padStart(2, "0"),
      SSS: () => `${milliseconds}`.padStart(3, "0"),
      d: () => day,
      dd: () => date.toLocaleDateString(options.locales, { weekday: "narrow" }),
      ddd: () => date.toLocaleDateString(options.locales, { weekday: "short" }),
      dddd: () => date.toLocaleDateString(options.locales, { weekday: "long" }),
      A: () => meridiem(hours, minutes),
      AA: () => meridiem(hours, minutes, false, true),
      a: () => meridiem(hours, minutes, true),
      aa: () => meridiem(hours, minutes, true, true)
    };
    return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());
  };
  const normalizeDate = (date) => {
    if (date === null)
      return new Date(NaN);
    if (date === void 0)
      return new Date();
    if (date instanceof Date)
      return new Date(date);
    if (typeof date === "string" && !/Z$/i.test(date)) {
      const d = date.match(REGEX_PARSE);
      if (d) {
        const m = d[2] - 1 || 0;
        const ms = (d[7] || "0").substring(0, 3);
        return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
      }
    }
    return new Date(date);
  };
  function useDateFormat(date, formatStr = "HH:mm:ss", options = {}) {
    return vueDemi.computed(() => formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options));
  }

  function useIntervalFn(cb, interval = 1e3, options = {}) {
    const {
      immediate = true,
      immediateCallback = false
    } = options;
    let timer = null;
    const isActive = vueDemi.ref(false);
    function clean() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
    }
    function pause() {
      isActive.value = false;
      clean();
    }
    function resume() {
      if (vueDemi.unref(interval) <= 0)
        return;
      isActive.value = true;
      if (immediateCallback)
        cb();
      clean();
      timer = setInterval(cb, resolveUnref(interval));
    }
    if (immediate && isClient)
      resume();
    if (vueDemi.isRef(interval) || isFunction(interval)) {
      const stopWatch = vueDemi.watch(interval, () => {
        if (isActive.value && isClient)
          resume();
      });
      tryOnScopeDispose(stopWatch);
    }
    tryOnScopeDispose(pause);
    return {
      isActive,
      pause,
      resume
    };
  }

  var __defProp$6 = Object.defineProperty;
  var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
  var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
  var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$6 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$8.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    if (__getOwnPropSymbols$8)
      for (var prop of __getOwnPropSymbols$8(b)) {
        if (__propIsEnum$8.call(b, prop))
          __defNormalProp$6(a, prop, b[prop]);
      }
    return a;
  };
  function useInterval(interval = 1e3, options = {}) {
    const {
      controls: exposeControls = false,
      immediate = true,
      callback
    } = options;
    const counter = vueDemi.ref(0);
    const update = () => counter.value += 1;
    const controls = useIntervalFn(callback ? () => {
      update();
      callback(counter.value);
    } : update, interval, { immediate });
    if (exposeControls) {
      return __spreadValues$6({
        counter
      }, controls);
    } else {
      return counter;
    }
  }

  function useLastChanged(source, options = {}) {
    var _a;
    const ms = vueDemi.ref((_a = options.initialValue) != null ? _a : null);
    vueDemi.watch(source, () => ms.value = timestamp(), options);
    return ms;
  }

  function useTimeoutFn(cb, interval, options = {}) {
    const {
      immediate = true
    } = options;
    const isPending = vueDemi.ref(false);
    let timer = null;
    function clear() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    }
    function stop() {
      isPending.value = false;
      clear();
    }
    function start(...args) {
      clear();
      isPending.value = true;
      timer = setTimeout(() => {
        isPending.value = false;
        timer = null;
        cb(...args);
      }, resolveUnref(interval));
    }
    if (immediate) {
      isPending.value = true;
      if (isClient)
        start();
    }
    tryOnScopeDispose(stop);
    return {
      isPending,
      start,
      stop
    };
  }

  var __defProp$5 = Object.defineProperty;
  var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
  var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
  var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$5 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$7.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    if (__getOwnPropSymbols$7)
      for (var prop of __getOwnPropSymbols$7(b)) {
        if (__propIsEnum$7.call(b, prop))
          __defNormalProp$5(a, prop, b[prop]);
      }
    return a;
  };
  function useTimeout(interval = 1e3, options = {}) {
    const {
      controls: exposeControls = false,
      callback
    } = options;
    const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);
    const ready = vueDemi.computed(() => !controls.isPending.value);
    if (exposeControls) {
      return __spreadValues$5({
        ready
      }, controls);
    } else {
      return ready;
    }
  }

  function useToNumber(value, options = {}) {
    const {
      method = "parseFloat",
      radix,
      nanToZero
    } = options;
    return vueDemi.computed(() => {
      let resolved = resolveUnref(value);
      if (typeof resolved === "string")
        resolved = Number[method](resolved, radix);
      if (nanToZero && isNaN(resolved))
        resolved = 0;
      return resolved;
    });
  }

  function useToString(value) {
    return vueDemi.computed(() => `${resolveUnref(value)}`);
  }

  function useToggle(initialValue = false, options = {}) {
    const {
      truthyValue = true,
      falsyValue = false
    } = options;
    const valueIsRef = vueDemi.isRef(initialValue);
    const _value = vueDemi.ref(initialValue);
    function toggle(value) {
      if (arguments.length) {
        _value.value = value;
        return _value.value;
      } else {
        const truthy = resolveUnref(truthyValue);
        _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;
        return _value.value;
      }
    }
    if (valueIsRef)
      return toggle;
    else
      return [_value, toggle];
  }

  function watchArray(source, cb, options) {
    let oldList = (options == null ? void 0 : options.immediate) ? [] : [
      ...source instanceof Function ? source() : Array.isArray(source) ? source : vueDemi.unref(source)
    ];
    return vueDemi.watch(source, (newList, _, onCleanup) => {
      const oldListRemains = new Array(oldList.length);
      const added = [];
      for (const obj of newList) {
        let found = false;
        for (let i = 0; i < oldList.length; i++) {
          if (!oldListRemains[i] && obj === oldList[i]) {
            oldListRemains[i] = true;
            found = true;
            break;
          }
        }
        if (!found)
          added.push(obj);
      }
      const removed = oldList.filter((_2, i) => !oldListRemains[i]);
      cb(newList, oldList, added, removed, onCleanup);
      oldList = [...newList];
    }, options);
  }

  var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
  var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
  var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
  var __objRest$5 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$6)
      for (var prop of __getOwnPropSymbols$6(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function watchWithFilter(source, cb, options = {}) {
    const _a = options, {
      eventFilter = bypassFilter
    } = _a, watchOptions = __objRest$5(_a, [
      "eventFilter"
    ]);
    return vueDemi.watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
  }

  var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
  var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
  var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
  var __objRest$4 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$5)
      for (var prop of __getOwnPropSymbols$5(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function watchAtMost(source, cb, options) {
    const _a = options, {
      count
    } = _a, watchOptions = __objRest$4(_a, [
      "count"
    ]);
    const current = vueDemi.ref(0);
    const stop = watchWithFilter(source, (...args) => {
      current.value += 1;
      if (current.value >= resolveUnref(count))
        vueDemi.nextTick(() => stop());
      cb(...args);
    }, watchOptions);
    return { count: current, stop };
  }

  var __defProp$4 = Object.defineProperty;
  var __defProps$4 = Object.defineProperties;
  var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
  var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
  var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$4 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    if (__getOwnPropSymbols$4)
      for (var prop of __getOwnPropSymbols$4(b)) {
        if (__propIsEnum$4.call(b, prop))
          __defNormalProp$4(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
  var __objRest$3 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$4)
      for (var prop of __getOwnPropSymbols$4(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function watchDebounced(source, cb, options = {}) {
    const _a = options, {
      debounce = 0,
      maxWait = void 0
    } = _a, watchOptions = __objRest$3(_a, [
      "debounce",
      "maxWait"
    ]);
    return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {
      eventFilter: debounceFilter(debounce, { maxWait })
    }));
  }

  var __defProp$3 = Object.defineProperty;
  var __defProps$3 = Object.defineProperties;
  var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
  var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
  var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$3 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    if (__getOwnPropSymbols$3)
      for (var prop of __getOwnPropSymbols$3(b)) {
        if (__propIsEnum$3.call(b, prop))
          __defNormalProp$3(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
  var __objRest$2 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$3)
      for (var prop of __getOwnPropSymbols$3(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function watchIgnorable(source, cb, options = {}) {
    const _a = options, {
      eventFilter = bypassFilter
    } = _a, watchOptions = __objRest$2(_a, [
      "eventFilter"
    ]);
    const filteredCb = createFilterWrapper(eventFilter, cb);
    let ignoreUpdates;
    let ignorePrevAsyncUpdates;
    let stop;
    if (watchOptions.flush === "sync") {
      const ignore = vueDemi.ref(false);
      ignorePrevAsyncUpdates = () => {
      };
      ignoreUpdates = (updater) => {
        ignore.value = true;
        updater();
        ignore.value = false;
      };
      stop = vueDemi.watch(source, (...args) => {
        if (!ignore.value)
          filteredCb(...args);
      }, watchOptions);
    } else {
      const disposables = [];
      const ignoreCounter = vueDemi.ref(0);
      const syncCounter = vueDemi.ref(0);
      ignorePrevAsyncUpdates = () => {
        ignoreCounter.value = syncCounter.value;
      };
      disposables.push(vueDemi.watch(source, () => {
        syncCounter.value++;
      }, __spreadProps$3(__spreadValues$3({}, watchOptions), { flush: "sync" })));
      ignoreUpdates = (updater) => {
        const syncCounterPrev = syncCounter.value;
        updater();
        ignoreCounter.value += syncCounter.value - syncCounterPrev;
      };
      disposables.push(vueDemi.watch(source, (...args) => {
        const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
        ignoreCounter.value = 0;
        syncCounter.value = 0;
        if (ignore)
          return;
        filteredCb(...args);
      }, watchOptions));
      stop = () => {
        disposables.forEach((fn) => fn());
      };
    }
    return { stop, ignoreUpdates, ignorePrevAsyncUpdates };
  }

  function watchOnce(source, cb, options) {
    const stop = vueDemi.watch(source, (...args) => {
      vueDemi.nextTick(() => stop());
      return cb(...args);
    }, options);
  }

  var __defProp$2 = Object.defineProperty;
  var __defProps$2 = Object.defineProperties;
  var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
  var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
  var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$2 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    if (__getOwnPropSymbols$2)
      for (var prop of __getOwnPropSymbols$2(b)) {
        if (__propIsEnum$2.call(b, prop))
          __defNormalProp$2(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
  var __objRest$1 = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$2)
      for (var prop of __getOwnPropSymbols$2(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function watchPausable(source, cb, options = {}) {
    const _a = options, {
      eventFilter: filter
    } = _a, watchOptions = __objRest$1(_a, [
      "eventFilter"
    ]);
    const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
    const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
      eventFilter
    }));
    return { stop, pause, resume, isActive };
  }

  var __defProp$1 = Object.defineProperty;
  var __defProps$1 = Object.defineProperties;
  var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
  var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
  var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
  var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues$1 = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    if (__getOwnPropSymbols$1)
      for (var prop of __getOwnPropSymbols$1(b)) {
        if (__propIsEnum$1.call(b, prop))
          __defNormalProp$1(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols$1)
      for (var prop of __getOwnPropSymbols$1(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  function watchThrottled(source, cb, options = {}) {
    const _a = options, {
      throttle = 0,
      trailing = true,
      leading = true
    } = _a, watchOptions = __objRest(_a, [
      "throttle",
      "trailing",
      "leading"
    ]);
    return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {
      eventFilter: throttleFilter(throttle, trailing, leading)
    }));
  }

  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  function watchTriggerable(source, cb, options = {}) {
    let cleanupFn;
    function onEffect() {
      if (!cleanupFn)
        return;
      const fn = cleanupFn;
      cleanupFn = void 0;
      fn();
    }
    function onCleanup(callback) {
      cleanupFn = callback;
    }
    const _cb = (value, oldValue) => {
      onEffect();
      return cb(value, oldValue, onCleanup);
    };
    const res = watchIgnorable(source, _cb, options);
    const { ignoreUpdates } = res;
    const trigger = () => {
      let res2;
      ignoreUpdates(() => {
        res2 = _cb(getWatchSources(source), getOldValue(source));
      });
      return res2;
    };
    return __spreadProps(__spreadValues({}, res), {
      trigger
    });
  }
  function getWatchSources(sources) {
    if (vueDemi.isReactive(sources))
      return sources;
    if (Array.isArray(sources))
      return sources.map((item) => getOneWatchSource(item));
    return getOneWatchSource(sources);
  }
  function getOneWatchSource(source) {
    return typeof source === "function" ? source() : vueDemi.unref(source);
  }
  function getOldValue(source) {
    return Array.isArray(source) ? source.map(() => void 0) : void 0;
  }

  function whenever(source, cb, options) {
    return vueDemi.watch(source, (v, ov, onInvalidate) => {
      if (v)
        cb(v, ov, onInvalidate);
    }, options);
  }

  exports.__onlyVue27Plus = __onlyVue27Plus;
  exports.__onlyVue3 = __onlyVue3;
  exports.assert = assert;
  exports.autoResetRef = refAutoReset;
  exports.bypassFilter = bypassFilter;
  exports.clamp = clamp;
  exports.computedEager = computedEager;
  exports.computedWithControl = computedWithControl;
  exports.containsProp = containsProp;
  exports.controlledComputed = computedWithControl;
  exports.controlledRef = controlledRef;
  exports.createEventHook = createEventHook;
  exports.createFilterWrapper = createFilterWrapper;
  exports.createGlobalState = createGlobalState;
  exports.createInjectionState = createInjectionState;
  exports.createReactiveFn = reactify;
  exports.createSharedComposable = createSharedComposable;
  exports.createSingletonPromise = createSingletonPromise;
  exports.debounceFilter = debounceFilter;
  exports.debouncedRef = refDebounced;
  exports.debouncedWatch = watchDebounced;
  exports.directiveHooks = directiveHooks;
  exports.eagerComputed = computedEager;
  exports.extendRef = extendRef;
  exports.formatDate = formatDate;
  exports.get = get;
  exports.hasOwn = hasOwn;
  exports.identity = identity;
  exports.ignorableWatch = watchIgnorable;
  exports.increaseWithUnit = increaseWithUnit;
  exports.invoke = invoke;
  exports.isBoolean = isBoolean;
  exports.isClient = isClient;
  exports.isDef = isDef;
  exports.isDefined = isDefined;
  exports.isFunction = isFunction;
  exports.isIOS = isIOS;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isString = isString;
  exports.isWindow = isWindow;
  exports.makeDestructurable = makeDestructurable;
  exports.noop = noop;
  exports.normalizeDate = normalizeDate;
  exports.now = now;
  exports.objectPick = objectPick;
  exports.pausableFilter = pausableFilter;
  exports.pausableWatch = watchPausable;
  exports.promiseTimeout = promiseTimeout;
  exports.rand = rand;
  exports.reactify = reactify;
  exports.reactifyObject = reactifyObject;
  exports.reactiveComputed = reactiveComputed;
  exports.reactiveOmit = reactiveOmit;
  exports.reactivePick = reactivePick;
  exports.refAutoReset = refAutoReset;
  exports.refDebounced = refDebounced;
  exports.refDefault = refDefault;
  exports.refThrottled = refThrottled;
  exports.refWithControl = refWithControl;
  exports.resolveRef = resolveRef;
  exports.resolveUnref = resolveUnref;
  exports.set = set;
  exports.syncRef = syncRef;
  exports.syncRefs = syncRefs;
  exports.throttleFilter = throttleFilter;
  exports.throttledRef = refThrottled;
  exports.throttledWatch = watchThrottled;
  exports.timestamp = timestamp;
  exports.toReactive = toReactive;
  exports.toRefs = toRefs;
  exports.tryOnBeforeMount = tryOnBeforeMount;
  exports.tryOnBeforeUnmount = tryOnBeforeUnmount;
  exports.tryOnMounted = tryOnMounted;
  exports.tryOnScopeDispose = tryOnScopeDispose;
  exports.tryOnUnmounted = tryOnUnmounted;
  exports.until = until;
  exports.useArrayEvery = useArrayEvery;
  exports.useArrayFilter = useArrayFilter;
  exports.useArrayFind = useArrayFind;
  exports.useArrayFindIndex = useArrayFindIndex;
  exports.useArrayJoin = useArrayJoin;
  exports.useArrayMap = useArrayMap;
  exports.useArrayReduce = useArrayReduce;
  exports.useArraySome = useArraySome;
  exports.useCounter = useCounter;
  exports.useDateFormat = useDateFormat;
  exports.useDebounce = refDebounced;
  exports.useDebounceFn = useDebounceFn;
  exports.useInterval = useInterval;
  exports.useIntervalFn = useIntervalFn;
  exports.useLastChanged = useLastChanged;
  exports.useThrottle = refThrottled;
  exports.useThrottleFn = useThrottleFn;
  exports.useTimeout = useTimeout;
  exports.useTimeoutFn = useTimeoutFn;
  exports.useToNumber = useToNumber;
  exports.useToString = useToString;
  exports.useToggle = useToggle;
  exports.watchArray = watchArray;
  exports.watchAtMost = watchAtMost;
  exports.watchDebounced = watchDebounced;
  exports.watchIgnorable = watchIgnorable;
  exports.watchOnce = watchOnce;
  exports.watchPausable = watchPausable;
  exports.watchThrottled = watchThrottled;
  exports.watchTriggerable = watchTriggerable;
  exports.watchWithFilter = watchWithFilter;
  exports.whenever = whenever;

})(this.VueUse = this.VueUse || {}, VueDemi);
ª/index.mjsÅµimport { shallowRef, watchEffect, readonly, unref, ref, isVue3, version, watch, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject, isRef, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';

var __defProp$9 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));
function computedEager(fn, options) {
  var _a;
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, __spreadProps$6(__spreadValues$9({}, options), {
    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
  }));
  return readonly(result);
}

var _a;
const isClient = typeof window !== "undefined";
const isDef = (val) => typeof val !== "undefined";
const assert = (condition, ...infos) => {
  if (!condition)
    console.warn(...infos);
};
const toString = Object.prototype.toString;
const isBoolean = (val) => typeof val === "boolean";
const isFunction = (val) => typeof val === "function";
const isNumber = (val) => typeof val === "number";
const isString = (val) => typeof val === "string";
const isObject = (val) => toString.call(val) === "[object Object]";
const isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
const now = () => Date.now();
const timestamp = () => +Date.now();
const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
const noop = () => {
};
const rand = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min + 1)) + min;
};
const isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);

function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}

function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = resolveUnref(ms);
    const maxDuration = resolveUnref(options.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  };
  const filter = (invoke) => {
    const duration = resolveUnref(ms);
    const elapsed = Date.now() - lastExec;
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke();
    } else if (trailing) {
      timer = setTimeout(() => {
        lastExec = Date.now();
        isLeading = true;
        clear();
        invoke();
      }, duration - elapsed);
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}

function __onlyVue3(name = "this function") {
  if (isVue3)
    return;
  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);
}
function __onlyVue27Plus(name = "this function") {
  if (isVue3 || version.startsWith("2.7."))
    return;
  throw new Error(`[VueUse] ${name} is only works on Vue 2.7 or above.`);
}
const directiveHooks = {
  mounted: isVue3 ? "mounted" : "inserted",
  updated: isVue3 ? "updated" : "componentUpdated",
  unmounted: isVue3 ? "unmounted" : "unbind"
};

function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms);
    else
      setTimeout(resolve, ms);
  });
}
function identity(arg) {
  return arg;
}
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function invoke(fn) {
  return fn();
}
function containsProp(obj, ...props) {
  return props.some((k) => k in obj);
}
function increaseWithUnit(target, delta) {
  var _a;
  if (typeof target === "number")
    return target + delta;
  const value = ((_a = target.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a[0]) || "";
  const unit = target.slice(value.length);
  const result = parseFloat(value) + delta;
  if (Number.isNaN(result))
    return target;
  return result + unit;
}
function objectPick(obj, keys, omitUndefined = false) {
  return keys.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}

function computedWithControl(source, fn) {
  let v = void 0;
  let track;
  let trigger;
  const dirty = ref(true);
  const update = () => {
    dirty.value = true;
    trigger();
  };
  watch(source, update, { flush: "sync" });
  const get = isFunction(fn) ? fn : fn.get;
  const set = isFunction(fn) ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty.value) {
          v = get();
          dirty.value = false;
        }
        track();
        return v;
      },
      set(v2) {
        set == null ? void 0 : set(v2);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}

function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}

function createEventHook() {
  const fns = [];
  const off = (fn) => {
    const index = fns.indexOf(fn);
    if (index !== -1)
      fns.splice(index, 1);
  };
  const on = (fn) => {
    fns.push(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (param) => {
    fns.forEach((fn) => fn(param));
  };
  return {
    on,
    off,
    trigger
  };
}

function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = effectScope(true);
  return () => {
    if (!initialized) {
      state = scope.run(stateFactory);
      initialized = true;
    }
    return state;
  };
}

function createInjectionState(composable) {
  const key = Symbol("InjectionState");
  const useProvidingState = (...args) => {
    provide(key, composable(...args));
  };
  const useInjectedState = () => inject(key);
  return [useProvidingState, useInjectedState];
}

function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!state) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}

function extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {
  __onlyVue27Plus();
  for (const [key, value] of Object.entries(extend)) {
    if (key === "value")
      continue;
    if (isRef(value) && unwrap) {
      Object.defineProperty(ref, key, {
        get() {
          return value.value;
        },
        set(v) {
          value.value = v;
        },
        enumerable
      });
    } else {
      Object.defineProperty(ref, key, { value, enumerable });
    }
  }
  return ref;
}

function get(obj, key) {
  if (key == null)
    return unref(obj);
  return unref(obj)[key];
}

function isDefined(v) {
  return unref(v) != null;
}

var __defProp$8 = Object.defineProperty;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone = __spreadValues$8({}, obj);
    Object.defineProperty(clone, Symbol.iterator, {
      enumerable: false,
      value() {
        let index = 0;
        return {
          next: () => ({
            value: arr[index++],
            done: index > arr.length
          })
        };
      }
    });
    return clone;
  } else {
    return Object.assign([...arr], obj);
  }
}

function reactify(fn, options) {
  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : resolveUnref;
  return function(...args) {
    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));
  };
}

function reactifyObject(obj, optionsOrKeys = {}) {
  let keys = [];
  let options;
  if (Array.isArray(optionsOrKeys)) {
    keys = optionsOrKeys;
  } else {
    options = optionsOrKeys;
    const { includeOwnProperties = true } = optionsOrKeys;
    keys.push(...Object.keys(obj));
    if (includeOwnProperties)
      keys.push(...Object.getOwnPropertyNames(obj));
  }
  return Object.fromEntries(keys.map((key) => {
    const value = obj[key];
    return [
      key,
      typeof value === "function" ? reactify(value.bind(obj), options) : value
    ];
  }));
}

function toReactive(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_, p, receiver) {
      return unref(Reflect.get(objectRef.value, p, receiver));
    },
    set(_, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value))
        objectRef.value[p].value = value;
      else
        objectRef.value[p] = value;
      return true;
    },
    deleteProperty(_, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(_, p) {
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}

function reactiveComputed(fn) {
  return toReactive(computed(fn));
}

function reactiveOmit(obj, ...keys) {
  const flatKeys = keys.flat();
  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));
}

function reactivePick(obj, ...keys) {
  const flatKeys = keys.flat();
  return reactive(Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));
}

function refAutoReset(defaultValue, afterMs = 1e4) {
  return customRef((track, trigger) => {
    let value = defaultValue;
    let timer;
    const resetAfter = () => setTimeout(() => {
      value = defaultValue;
      trigger();
    }, resolveUnref(afterMs));
    tryOnScopeDispose(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        trigger();
        clearTimeout(timer);
        timer = resetAfter();
      }
    };
  });
}

function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}

function refDebounced(value, ms = 200, options = {}) {
  const debounced = ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  watch(value, () => updater());
  return debounced;
}

function refDefault(source, defaultValue) {
  return computed({
    get() {
      var _a;
      return (_a = source.value) != null ? _a : defaultValue;
    },
    set(value) {
      source.value = value;
    }
  });
}

function useThrottleFn(fn, ms = 200, trailing = false, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
}

function refThrottled(value, delay = 200, trailing = true, leading = true) {
  if (delay <= 0)
    return value;
  const throttled = ref(value.value);
  const updater = useThrottleFn(() => {
    throttled.value = value.value;
  }, delay, trailing, leading);
  watch(value, () => updater());
  return throttled;
}

function refWithControl(initial, options = {}) {
  let source = initial;
  let track;
  let trigger;
  const ref = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        return get();
      },
      set(v) {
        set(v);
      }
    };
  });
  function get(tracking = true) {
    if (tracking)
      track();
    return source;
  }
  function set(value, triggering = true) {
    var _a, _b;
    if (value === source)
      return;
    const old = source;
    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)
      return;
    source = value;
    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);
    if (triggering)
      trigger();
  }
  const untrackedGet = () => get(false);
  const silentSet = (v) => set(v, false);
  const peek = () => get(false);
  const lay = (v) => set(v, false);
  return extendRef(ref, {
    get,
    set,
    untrackedGet,
    silentSet,
    peek,
    lay
  }, { enumerable: true });
}
const controlledRef = refWithControl;

function resolveRef(r) {
  return typeof r === "function" ? computed(r) : ref(r);
}

function set(...args) {
  if (args.length === 2) {
    const [ref, value] = args;
    ref.value = value;
  }
  if (args.length === 3) {
    if (isVue2) {
      set$1(...args);
    } else {
      const [target, key, value] = args;
      target[key] = value;
    }
  }
}

function syncRef(left, right, options = {}) {
  var _a, _b;
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both",
    transform = {}
  } = options;
  let watchLeft;
  let watchRight;
  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;
  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;
  if (direction === "both" || direction === "ltr") {
    watchLeft = watch(left, (newValue) => right.value = transformLTR(newValue), { flush, deep, immediate });
  }
  if (direction === "both" || direction === "rtl") {
    watchRight = watch(right, (newValue) => left.value = transformRTL(newValue), { flush, deep, immediate });
  }
  return () => {
    watchLeft == null ? void 0 : watchLeft();
    watchRight == null ? void 0 : watchRight();
  };
}

function syncRefs(source, targets, options = {}) {
  const {
    flush = "sync",
    deep = false,
    immediate = true
  } = options;
  if (!Array.isArray(targets))
    targets = [targets];
  return watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });
}

var __defProp$7 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));
function toRefs(objectRef) {
  if (!isRef(objectRef))
    return toRefs$1(objectRef);
  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        if (Array.isArray(objectRef.value)) {
          const copy = [...objectRef.value];
          copy[key] = v;
          objectRef.value = copy;
        } else {
          const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });
          Object.setPrototypeOf(newObject, objectRef.value);
          objectRef.value = newObject;
        }
      }
    }));
  }
  return result;
}

function tryOnBeforeMount(fn, sync = true) {
  if (getCurrentInstance())
    onBeforeMount(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}

function tryOnBeforeUnmount(fn) {
  if (getCurrentInstance())
    onBeforeUnmount(fn);
}

function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}

function tryOnUnmounted(fn) {
  if (getCurrentInstance())
    onUnmounted(fn);
}

function createUntil(r, isNot = false) {
  function toMatch(condition, { flush = "sync", deep = false, timeout, throwOnTimeout } = {}) {
    let stop = null;
    const watcher = new Promise((resolve) => {
      stop = watch(r, (v) => {
        if (condition(v) !== isNot) {
          stop == null ? void 0 : stop();
          resolve(v);
        }
      }, {
        flush,
        deep,
        immediate: true
      });
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => stop == null ? void 0 : stop()));
    }
    return Promise.race(promises);
  }
  function toBe(value, options) {
    if (!isRef(value))
      return toMatch((v) => v === value, options);
    const { flush = "sync", deep = false, timeout, throwOnTimeout } = options != null ? options : {};
    let stop = null;
    const watcher = new Promise((resolve) => {
      stop = watch([r, value], ([v1, v2]) => {
        if (isNot !== (v1 === v2)) {
          stop == null ? void 0 : stop();
          resolve(v1);
        }
      }, {
        flush,
        deep,
        immediate: true
      });
    });
    const promises = [watcher];
    if (timeout != null) {
      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => {
        stop == null ? void 0 : stop();
        return resolveUnref(r);
      }));
    }
    return Promise.race(promises);
  }
  function toBeTruthy(options) {
    return toMatch((v) => Boolean(v), options);
  }
  function toBeNull(options) {
    return toBe(null, options);
  }
  function toBeUndefined(options) {
    return toBe(void 0, options);
  }
  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }
  function toContains(value, options) {
    return toMatch((v) => {
      const array = Array.from(v);
      return array.includes(value) || array.includes(resolveUnref(value));
    }, options);
  }
  function changed(options) {
    return changedTimes(1, options);
  }
  function changedTimes(n = 1, options) {
    let count = -1;
    return toMatch(() => {
      count += 1;
      return count >= n;
    }, options);
  }
  if (Array.isArray(resolveUnref(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  }
}
function until(r) {
  return createUntil(r);
}

function useArrayEvery(list, fn) {
  return computed(() => resolveUnref(list).every((element, index, array) => fn(resolveUnref(element), index, array)));
}

function useArrayFilter(list, fn) {
  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).filter(fn));
}

function useArrayFind(list, fn) {
  return computed(() => resolveUnref(resolveUnref(list).find((element, index, array) => fn(resolveUnref(element), index, array))));
}

function useArrayFindIndex(list, fn) {
  return computed(() => resolveUnref(list).findIndex((element, index, array) => fn(resolveUnref(element), index, array)));
}

function useArrayJoin(list, separator) {
  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).join(resolveUnref(separator)));
}

function useArrayMap(list, fn) {
  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).map(fn));
}

function useArrayReduce(list, reducer, ...args) {
  const reduceCallback = (sum, value, index) => reducer(resolveUnref(sum), resolveUnref(value), index);
  return computed(() => {
    const resolved = resolveUnref(list);
    return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);
  });
}

function useArraySome(list, fn) {
  return computed(() => resolveUnref(list).some((element, index, array) => fn(resolveUnref(element), index, array)));
}

function useCounter(initialValue = 0, options = {}) {
  const count = ref(initialValue);
  const {
    max = Infinity,
    min = -Infinity
  } = options;
  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);
  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);
  const get = () => count.value;
  const set = (val) => count.value = Math.max(min, Math.min(max, val));
  const reset = (val = initialValue) => {
    initialValue = val;
    return set(val);
  };
  return { count, inc, dec, get, set, reset };
}

const REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
const REGEX_FORMAT = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;
const defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {
  let m = hours < 12 ? "AM" : "PM";
  if (hasPeriod)
    m = m.split("").reduce((acc, curr) => acc += `${curr}.`, "");
  return isLowercase ? m.toLowerCase() : m;
};
const formatDate = (date, formatStr, options = {}) => {
  var _a;
  const years = date.getFullYear();
  const month = date.getMonth();
  const days = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();
  const day = date.getDay();
  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;
  const matches = {
    YY: () => String(years).slice(-2),
    YYYY: () => years,
    M: () => month + 1,
    MM: () => `${month + 1}`.padStart(2, "0"),
    MMM: () => date.toLocaleDateString(options.locales, { month: "short" }),
    MMMM: () => date.toLocaleDateString(options.locales, { month: "long" }),
    D: () => String(days),
    DD: () => `${days}`.padStart(2, "0"),
    H: () => String(hours),
    HH: () => `${hours}`.padStart(2, "0"),
    h: () => `${hours % 12 || 12}`.padStart(1, "0"),
    hh: () => `${hours % 12 || 12}`.padStart(2, "0"),
    m: () => String(minutes),
    mm: () => `${minutes}`.padStart(2, "0"),
    s: () => String(seconds),
    ss: () => `${seconds}`.padStart(2, "0"),
    SSS: () => `${milliseconds}`.padStart(3, "0"),
    d: () => day,
    dd: () => date.toLocaleDateString(options.locales, { weekday: "narrow" }),
    ddd: () => date.toLocaleDateString(options.locales, { weekday: "short" }),
    dddd: () => date.toLocaleDateString(options.locales, { weekday: "long" }),
    A: () => meridiem(hours, minutes),
    AA: () => meridiem(hours, minutes, false, true),
    a: () => meridiem(hours, minutes, true),
    aa: () => meridiem(hours, minutes, true, true)
  };
  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());
};
const normalizeDate = (date) => {
  if (date === null)
    return new Date(NaN);
  if (date === void 0)
    return new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    const d = date.match(REGEX_PARSE);
    if (d) {
      const m = d[2] - 1 || 0;
      const ms = (d[7] || "0").substring(0, 3);
      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);
    }
  }
  return new Date(date);
};
function useDateFormat(date, formatStr = "HH:mm:ss", options = {}) {
  return computed(() => formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options));
}

function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    if (unref(interval) <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, resolveUnref(interval));
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval) || isFunction(interval)) {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}

var __defProp$6 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
function useInterval(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    immediate = true,
    callback
  } = options;
  const counter = ref(0);
  const update = () => counter.value += 1;
  const controls = useIntervalFn(callback ? () => {
    update();
    callback(counter.value);
  } : update, interval, { immediate });
  if (exposeControls) {
    return __spreadValues$6({
      counter
    }, controls);
  } else {
    return counter;
  }
}

function useLastChanged(source, options = {}) {
  var _a;
  const ms = ref((_a = options.initialValue) != null ? _a : null);
  watch(source, () => ms.value = timestamp(), options);
  return ms;
}

function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, resolveUnref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending,
    start,
    stop
  };
}

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options;
  const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return __spreadValues$5({
      ready
    }, controls);
  } else {
    return ready;
  }
}

function useToNumber(value, options = {}) {
  const {
    method = "parseFloat",
    radix,
    nanToZero
  } = options;
  return computed(() => {
    let resolved = resolveUnref(value);
    if (typeof resolved === "string")
      resolved = Number[method](resolved, radix);
    if (nanToZero && isNaN(resolved))
      resolved = 0;
    return resolved;
  });
}

function useToString(value) {
  return computed(() => `${resolveUnref(value)}`);
}

function useToggle(initialValue = false, options = {}) {
  const {
    truthyValue = true,
    falsyValue = false
  } = options;
  const valueIsRef = isRef(initialValue);
  const _value = ref(initialValue);
  function toggle(value) {
    if (arguments.length) {
      _value.value = value;
      return _value.value;
    } else {
      const truthy = resolveUnref(truthyValue);
      _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;
      return _value.value;
    }
  }
  if (valueIsRef)
    return toggle;
  else
    return [_value, toggle];
}

function watchArray(source, cb, options) {
  let oldList = (options == null ? void 0 : options.immediate) ? [] : [
    ...source instanceof Function ? source() : Array.isArray(source) ? source : unref(source)
  ];
  return watch(source, (newList, _, onCleanup) => {
    const oldListRemains = new Array(oldList.length);
    const added = [];
    for (const obj of newList) {
      let found = false;
      for (let i = 0; i < oldList.length; i++) {
        if (!oldListRemains[i] && obj === oldList[i]) {
          oldListRemains[i] = true;
          found = true;
          break;
        }
      }
      if (!found)
        added.push(obj);
    }
    const removed = oldList.filter((_2, i) => !oldListRemains[i]);
    cb(newList, oldList, added, removed, onCleanup);
    oldList = [...newList];
  }, options);
}

var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$5(_a, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}

var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __objRest$4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchAtMost(source, cb, options) {
  const _a = options, {
    count
  } = _a, watchOptions = __objRest$4(_a, [
    "count"
  ]);
  const current = ref(0);
  const stop = watchWithFilter(source, (...args) => {
    current.value += 1;
    if (current.value >= resolveUnref(count))
      nextTick(() => stop());
    cb(...args);
  }, watchOptions);
  return { count: current, stop };
}

var __defProp$4 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
var __objRest$3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchDebounced(source, cb, options = {}) {
  const _a = options, {
    debounce = 0,
    maxWait = void 0
  } = _a, watchOptions = __objRest$3(_a, [
    "debounce",
    "maxWait"
  ]);
  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {
    eventFilter: debounceFilter(debounce, { maxWait })
  }));
}

var __defProp$3 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchIgnorable(source, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$2(_a, [
    "eventFilter"
  ]);
  const filteredCb = createFilterWrapper(eventFilter, cb);
  let ignoreUpdates;
  let ignorePrevAsyncUpdates;
  let stop;
  if (watchOptions.flush === "sync") {
    const ignore = ref(false);
    ignorePrevAsyncUpdates = () => {
    };
    ignoreUpdates = (updater) => {
      ignore.value = true;
      updater();
      ignore.value = false;
    };
    stop = watch(source, (...args) => {
      if (!ignore.value)
        filteredCb(...args);
    }, watchOptions);
  } else {
    const disposables = [];
    const ignoreCounter = ref(0);
    const syncCounter = ref(0);
    ignorePrevAsyncUpdates = () => {
      ignoreCounter.value = syncCounter.value;
    };
    disposables.push(watch(source, () => {
      syncCounter.value++;
    }, __spreadProps$3(__spreadValues$3({}, watchOptions), { flush: "sync" })));
    ignoreUpdates = (updater) => {
      const syncCounterPrev = syncCounter.value;
      updater();
      ignoreCounter.value += syncCounter.value - syncCounterPrev;
    };
    disposables.push(watch(source, (...args) => {
      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;
      ignoreCounter.value = 0;
      syncCounter.value = 0;
      if (ignore)
        return;
      filteredCb(...args);
    }, watchOptions));
    stop = () => {
      disposables.forEach((fn) => fn());
    };
  }
  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };
}

function watchOnce(source, cb, options) {
  const stop = watch(source, (...args) => {
    nextTick(() => stop());
    return cb(...args);
  }, options);
}

var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchPausable(source, cb, options = {}) {
  const _a = options, {
    eventFilter: filter
  } = _a, watchOptions = __objRest$1(_a, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {
    eventFilter
  }));
  return { stop, pause, resume, isActive };
}

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchThrottled(source, cb, options = {}) {
  const _a = options, {
    throttle = 0,
    trailing = true,
    leading = true
  } = _a, watchOptions = __objRest(_a, [
    "throttle",
    "trailing",
    "leading"
  ]);
  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {
    eventFilter: throttleFilter(throttle, trailing, leading)
  }));
}

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function watchTriggerable(source, cb, options = {}) {
  let cleanupFn;
  function onEffect() {
    if (!cleanupFn)
      return;
    const fn = cleanupFn;
    cleanupFn = void 0;
    fn();
  }
  function onCleanup(callback) {
    cleanupFn = callback;
  }
  const _cb = (value, oldValue) => {
    onEffect();
    return cb(value, oldValue, onCleanup);
  };
  const res = watchIgnorable(source, _cb, options);
  const { ignoreUpdates } = res;
  const trigger = () => {
    let res2;
    ignoreUpdates(() => {
      res2 = _cb(getWatchSources(source), getOldValue(source));
    });
    return res2;
  };
  return __spreadProps(__spreadValues({}, res), {
    trigger
  });
}
function getWatchSources(sources) {
  if (isReactive(sources))
    return sources;
  if (Array.isArray(sources))
    return sources.map((item) => getOneWatchSource(item));
  return getOneWatchSource(sources);
}
function getOneWatchSource(source) {
  return typeof source === "function" ? source() : unref(source);
}
function getOldValue(source) {
  return Array.isArray(source) ? source.map(() => void 0) : void 0;
}

function whenever(source, cb, options) {
  return watch(source, (v, ov, onInvalidate) => {
    if (v)
      cb(v, ov, onInvalidate);
  }, options);
}

export { __onlyVue27Plus, __onlyVue3, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, makeDestructurable, noop, normalizeDate, now, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };

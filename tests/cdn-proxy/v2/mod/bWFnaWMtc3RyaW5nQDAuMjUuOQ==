Š¨/LICENSEÅCopyright 2018 Rich Harris

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
¹/dist/magic-string.cjs.jsÅ„w'use strict';

var sourcemapCodec = require('sourcemap-codec');

var BitSet = function BitSet(arg) {
	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
};

BitSet.prototype.add = function add (n) {
	this.bits[n >> 5] |= 1 << (n & 31);
};

BitSet.prototype.has = function has (n) {
	return !!(this.bits[n >> 5] & (1 << (n & 31)));
};

var Chunk = function Chunk(start, end, content) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties(this, {
		previous: { writable: true, value: null },
		next: { writable: true, value: null },
	});
};

Chunk.prototype.appendLeft = function appendLeft (content) {
	this.outro += content;
};

Chunk.prototype.appendRight = function appendRight (content) {
	this.intro = this.intro + content;
};

Chunk.prototype.clone = function clone () {
	var chunk = new Chunk(this.start, this.end, this.original);

	chunk.intro = this.intro;
	chunk.outro = this.outro;
	chunk.content = this.content;
	chunk.storeName = this.storeName;
	chunk.edited = this.edited;

	return chunk;
};

Chunk.prototype.contains = function contains (index) {
	return this.start < index && index < this.end;
};

Chunk.prototype.eachNext = function eachNext (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.next;
	}
};

Chunk.prototype.eachPrevious = function eachPrevious (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.previous;
	}
};

Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
	this.content = content;
	if (!contentOnly) {
		this.intro = '';
		this.outro = '';
	}
	this.storeName = storeName;

	this.edited = true;

	return this;
};

Chunk.prototype.prependLeft = function prependLeft (content) {
	this.outro = content + this.outro;
};

Chunk.prototype.prependRight = function prependRight (content) {
	this.intro = content + this.intro;
};

Chunk.prototype.split = function split (index) {
	var sliceIndex = index - this.start;

	var originalBefore = this.original.slice(0, sliceIndex);
	var originalAfter = this.original.slice(sliceIndex);

	this.original = originalBefore;

	var newChunk = new Chunk(index, this.end, originalAfter);
	newChunk.outro = this.outro;
	this.outro = '';

	this.end = index;

	if (this.edited) {
		// TODO is this block necessary?...
		newChunk.edit('', false);
		this.content = '';
	} else {
		this.content = originalBefore;
	}

	newChunk.next = this.next;
	if (newChunk.next) { newChunk.next.previous = newChunk; }
	newChunk.previous = this;
	this.next = newChunk;

	return newChunk;
};

Chunk.prototype.toString = function toString () {
	return this.intro + this.content + this.outro;
};

Chunk.prototype.trimEnd = function trimEnd (rx) {
	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.start + trimmed.length).edit('', undefined, true);
		}
		return true;
	} else {
		this.edit('', undefined, true);

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }
	}
};

Chunk.prototype.trimStart = function trimStart (rx) {
	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.end - trimmed.length);
			this.edit('', undefined, true);
		}
		return true;
	} else {
		this.edit('', undefined, true);

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }
	}
};

var btoa = function () {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
} else if (typeof Buffer === 'function') {
	btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}

var SourceMap = function SourceMap(properties) {
	this.version = 3;
	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = sourcemapCodec.encode(properties.mappings);
};

SourceMap.prototype.toString = function toString () {
	return JSON.stringify(this);
};

SourceMap.prototype.toUrl = function toUrl () {
	return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
};

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	var fromParts = from.split(/[/\\]/);
	var toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) { fromParts[i] = '..'; }
	}

	return fromParts.concat(toParts).join('/');
}

var toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	var originalLines = source.split('\n');
	var lineOffsets = [];

	for (var i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		var i = 0;
		var j = lineOffsets.length;
		while (i < j) {
			var m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		var line = i - 1;
		var column = index - lineOffsets[line];
		return { line: line, column: column };
	};
}

var Mappings = function Mappings(hires) {
	this.hires = hires;
	this.generatedCodeLine = 0;
	this.generatedCodeColumn = 0;
	this.raw = [];
	this.rawSegments = this.raw[this.generatedCodeLine] = [];
	this.pending = null;
};

Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
	if (content.length) {
		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
		if (nameIndex >= 0) {
			segment.push(nameIndex);
		}
		this.rawSegments.push(segment);
	} else if (this.pending) {
		this.rawSegments.push(this.pending);
	}

	this.advance(content);
	this.pending = null;
};

Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
	var originalCharIndex = chunk.start;
	var first = true;

	while (originalCharIndex < chunk.end) {
		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
		}

		if (original[originalCharIndex] === '\n') {
			loc.line += 1;
			loc.column = 0;
			this.generatedCodeLine += 1;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
			this.generatedCodeColumn = 0;
			first = true;
		} else {
			loc.column += 1;
			this.generatedCodeColumn += 1;
			first = false;
		}

		originalCharIndex += 1;
	}

	this.pending = null;
};

Mappings.prototype.advance = function advance (str) {
	if (!str) { return; }

	var lines = str.split('\n');

	if (lines.length > 1) {
		for (var i = 0; i < lines.length - 1; i++) {
			this.generatedCodeLine++;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
		}
		this.generatedCodeColumn = 0;
	}

	this.generatedCodeColumn += lines[lines.length - 1].length;
};

var n = '\n';

var warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
};

var MagicString = function MagicString(string, options) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk(0, string.length, string);

	Object.defineProperties(this, {
		original: { writable: true, value: string },
		outro: { writable: true, value: '' },
		intro: { writable: true, value: '' },
		firstChunk: { writable: true, value: chunk },
		lastChunk: { writable: true, value: chunk },
		lastSearchedChunk: { writable: true, value: chunk },
		byStart: { writable: true, value: {} },
		byEnd: { writable: true, value: {} },
		filename: { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations: { writable: true, value: new BitSet() },
		storedNames: { writable: true, value: {} },
		indentStr: { writable: true, value: guessIndent(string) },
	});

	this.byStart[0] = chunk;
	this.byEnd[string.length] = chunk;
};

MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
	this.sourcemapLocations.add(char);
};

MagicString.prototype.append = function append (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.outro += content;
	return this;
};

MagicString.prototype.appendLeft = function appendLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.appendLeft(content);
	} else {
		this.intro += content;
	}
	return this;
};

MagicString.prototype.appendRight = function appendRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.appendRight(content);
	} else {
		this.outro += content;
	}
	return this;
};

MagicString.prototype.clone = function clone () {
	var cloned = new MagicString(this.original, { filename: this.filename });

	var originalChunk = this.firstChunk;
	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

	while (originalChunk) {
		cloned.byStart[clonedChunk.start] = clonedChunk;
		cloned.byEnd[clonedChunk.end] = clonedChunk;

		var nextOriginalChunk = originalChunk.next;
		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

		if (nextClonedChunk) {
			clonedChunk.next = nextClonedChunk;
			nextClonedChunk.previous = clonedChunk;

			clonedChunk = nextClonedChunk;
		}

		originalChunk = nextOriginalChunk;
	}

	cloned.lastChunk = clonedChunk;

	if (this.indentExclusionRanges) {
		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
	}

	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

	cloned.intro = this.intro;
	cloned.outro = this.outro;

	return cloned;
};

MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1$1 = this;

	options = options || {};

	var sourceIndex = 0;
	var names = Object.keys(this.storedNames);
	var mappings = new Mappings(options.hires);

	var locate = getLocator(this.original);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.firstChunk.eachNext(function (chunk) {
		var loc = locate(chunk.start);

		if (chunk.intro.length) { mappings.advance(chunk.intro); }

		if (chunk.edited) {
			mappings.addEdit(
				sourceIndex,
				chunk.content,
				loc,
				chunk.storeName ? names.indexOf(chunk.original) : -1
			);
		} else {
			mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
		}

		if (chunk.outro.length) { mappings.advance(chunk.outro); }
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
		sourcesContent: options.includeContent ? [this.original] : [null],
		names: names,
		mappings: mappings.raw,
	};
};

MagicString.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
};

MagicString.prototype.getIndentString = function getIndentString () {
	return this.indentStr === null ? '\t' : this.indentStr;
};

MagicString.prototype.indent = function indent (indentStr, options) {
	var pattern = /^[^\r\n]/gm;

	if (isObject(indentStr)) {
		options = indentStr;
		indentStr = undefined;
	}

	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

	if (indentStr === '') { return this; } // noop

	options = options || {};

	// Process exclusion ranges
	var isExcluded = {};

	if (options.exclude) {
		var exclusions =
			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
		exclusions.forEach(function (exclusion) {
			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
				isExcluded[i] = true;
			}
		});
	}

	var shouldIndentNextCharacter = options.indentStart !== false;
	var replacer = function (match) {
		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
		shouldIndentNextCharacter = true;
		return match;
	};

	this.intro = this.intro.replace(pattern, replacer);

	var charIndex = 0;
	var chunk = this.firstChunk;

	while (chunk) {
		var end = chunk.end;

		if (chunk.edited) {
			if (!isExcluded[charIndex]) {
				chunk.content = chunk.content.replace(pattern, replacer);

				if (chunk.content.length) {
					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
				}
			}
		} else {
			charIndex = chunk.start;

			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					} else if (char !== '\r' && shouldIndentNextCharacter) {
						shouldIndentNextCharacter = false;

						if (charIndex === chunk.start) {
							chunk.prependRight(indentStr);
						} else {
							this._splitChunk(chunk, charIndex);
							chunk = chunk.next;
							chunk.prependRight(indentStr);
						}
					}
				}

				charIndex += 1;
			}
		}

		charIndex = chunk.end;
		chunk = chunk.next;
	}

	this.outro = this.outro.replace(pattern, replacer);

	return this;
};

MagicString.prototype.insert = function insert () {
	throw new Error(
		'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'
	);
};

MagicString.prototype.insertLeft = function insertLeft (index, content) {
	if (!warned.insertLeft) {
		console.warn(
			'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'
		); // eslint-disable-line no-console
		warned.insertLeft = true;
	}

	return this.appendLeft(index, content);
};

MagicString.prototype.insertRight = function insertRight (index, content) {
	if (!warned.insertRight) {
		console.warn(
			'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'
		); // eslint-disable-line no-console
		warned.insertRight = true;
	}

	return this.prependRight(index, content);
};

MagicString.prototype.move = function move (start, end, index) {
	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }

	this._split(start);
	this._split(end);
	this._split(index);

	var first = this.byStart[start];
	var last = this.byEnd[end];

	var oldLeft = first.previous;
	var oldRight = last.next;

	var newRight = this.byStart[index];
	if (!newRight && last === this.lastChunk) { return this; }
	var newLeft = newRight ? newRight.previous : this.lastChunk;

	if (oldLeft) { oldLeft.next = oldRight; }
	if (oldRight) { oldRight.previous = oldLeft; }

	if (newLeft) { newLeft.next = first; }
	if (newRight) { newRight.previous = last; }

	if (!first.previous) { this.firstChunk = last.next; }
	if (!last.next) {
		this.lastChunk = first.previous;
		this.lastChunk.next = null;
	}

	first.previous = newLeft;
	last.next = newRight || null;

	if (!newLeft) { this.firstChunk = first; }
	if (!newRight) { this.lastChunk = last; }
	return this;
};

MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (end > this.original.length) { throw new Error('end is out of bounds'); }
	if (start === end)
		{ throw new Error(
			'Cannot overwrite a zero-length range â€“ use appendLeft or prependRight instead'
		); }

	this._split(start);
	this._split(end);

	if (options === true) {
		if (!warned.storeName) {
			console.warn(
				'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'
			); // eslint-disable-line no-console
			warned.storeName = true;
		}

		options = { storeName: true };
	}
	var storeName = options !== undefined ? options.storeName : false;
	var contentOnly = options !== undefined ? options.contentOnly : false;

	if (storeName) {
		var original = this.original.slice(start, end);
		Object.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });
	}

	var first = this.byStart[start];
	var last = this.byEnd[end];

	if (first) {
		var chunk = first;
		while (chunk !== last) {
			if (chunk.next !== this.byStart[chunk.end]) {
				throw new Error('Cannot overwrite across a split point');
			}
			chunk = chunk.next;
			chunk.edit('', false);
		}

		first.edit(content, storeName, contentOnly);
	} else {
		// must be inserting at the end
		var newChunk = new Chunk(start, end, '').edit(content, storeName);

		// TODO last chunk in the array may not be the last chunk, if it's moved...
		last.next = newChunk;
		newChunk.previous = last;
	}
	return this;
};

MagicString.prototype.prepend = function prepend (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.intro = content + this.intro;
	return this;
};

MagicString.prototype.prependLeft = function prependLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.prependLeft(content);
	} else {
		this.intro = content + this.intro;
	}
	return this;
};

MagicString.prototype.prependRight = function prependRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.prependRight(content);
	} else {
		this.outro = content + this.outro;
	}
	return this;
};

MagicString.prototype.remove = function remove (start, end) {
	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (start === end) { return this; }

	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
	if (start > end) { throw new Error('end must be greater than start'); }

	this._split(start);
	this._split(end);

	var chunk = this.byStart[start];

	while (chunk) {
		chunk.intro = '';
		chunk.outro = '';
		chunk.edit('');

		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
	}
	return this;
};

MagicString.prototype.lastChar = function lastChar () {
	if (this.outro.length) { return this.outro[this.outro.length - 1]; }
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length) { return chunk.outro[chunk.outro.length - 1]; }
		if (chunk.content.length) { return chunk.content[chunk.content.length - 1]; }
		if (chunk.intro.length) { return chunk.intro[chunk.intro.length - 1]; }
	} while ((chunk = chunk.previous));
	if (this.intro.length) { return this.intro[this.intro.length - 1]; }
	return '';
};

MagicString.prototype.lastLine = function lastLine () {
	var lineIndex = this.outro.lastIndexOf(n);
	if (lineIndex !== -1) { return this.outro.substr(lineIndex + 1); }
	var lineStr = this.outro;
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length > 0) {
			lineIndex = chunk.outro.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.outro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.outro + lineStr;
		}

		if (chunk.content.length > 0) {
			lineIndex = chunk.content.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.content.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.content + lineStr;
		}

		if (chunk.intro.length > 0) {
			lineIndex = chunk.intro.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.intro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.intro + lineStr;
		}
	} while ((chunk = chunk.previous));
	lineIndex = this.intro.lastIndexOf(n);
	if (lineIndex !== -1) { return this.intro.substr(lineIndex + 1) + lineStr; }
	return this.intro + lineStr;
};

MagicString.prototype.slice = function slice (start, end) {
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	var result = '';

	// find start chunk
	var chunk = this.firstChunk;
	while (chunk && (chunk.start > start || chunk.end <= start)) {
		// found end chunk before start
		if (chunk.start < end && chunk.end >= end) {
			return result;
		}

		chunk = chunk.next;
	}

	if (chunk && chunk.edited && chunk.start !== start)
		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

	var startChunk = chunk;
	while (chunk) {
		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
			result += chunk.intro;
		}

		var containsEnd = chunk.start < end && chunk.end >= end;
		if (containsEnd && chunk.edited && chunk.end !== end)
			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

		result += chunk.content.slice(sliceStart, sliceEnd);

		if (chunk.outro && (!containsEnd || chunk.end === end)) {
			result += chunk.outro;
		}

		if (containsEnd) {
			break;
		}

		chunk = chunk.next;
	}

	return result;
};

// TODO deprecate this? not really very useful
MagicString.prototype.snip = function snip (start, end) {
	var clone = this.clone();
	clone.remove(0, start);
	clone.remove(end, clone.original.length);

	return clone;
};

MagicString.prototype._split = function _split (index) {
	if (this.byStart[index] || this.byEnd[index]) { return; }

	var chunk = this.lastSearchedChunk;
	var searchForward = index > chunk.end;

	while (chunk) {
		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }

		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
	}
};

MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
	if (chunk.edited && chunk.content.length) {
		// zero-length edited chunks are a special case (overlapping replacements)
		var loc = getLocator(this.original)(index);
		throw new Error(
			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " â€“ \"" + (chunk.original) + "\")")
		);
	}

	var newChunk = chunk.split(index);

	this.byEnd[index] = chunk;
	this.byStart[index] = newChunk;
	this.byEnd[newChunk.end] = newChunk;

	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }

	this.lastSearchedChunk = chunk;
	return true;
};

MagicString.prototype.toString = function toString () {
	var str = this.intro;

	var chunk = this.firstChunk;
	while (chunk) {
		str += chunk.toString();
		chunk = chunk.next;
	}

	return str + this.outro;
};

MagicString.prototype.isEmpty = function isEmpty () {
	var chunk = this.firstChunk;
	do {
		if (
			(chunk.intro.length && chunk.intro.trim()) ||
			(chunk.content.length && chunk.content.trim()) ||
			(chunk.outro.length && chunk.outro.trim())
		)
			{ return false; }
	} while ((chunk = chunk.next));
	return true;
};

MagicString.prototype.length = function length () {
	var chunk = this.firstChunk;
	var length = 0;
	do {
		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
	} while ((chunk = chunk.next));
	return length;
};

MagicString.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

MagicString.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var chunk = this.lastChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimEnd(rx);

		// if chunk was trimmed, we have a new lastChunk
		if (chunk.end !== end) {
			if (this.lastChunk === chunk) {
				this.lastChunk = chunk.next;
			}

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.previous;
	} while (chunk);

	return false;
};

MagicString.prototype.trimEnd = function trimEnd (charType) {
	this.trimEndAborted(charType);
	return this;
};
MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');

	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var chunk = this.firstChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimStart(rx);

		if (chunk.end !== end) {
			// special case...
			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.next;
	} while (chunk);

	return false;
};

MagicString.prototype.trimStart = function trimStart (charType) {
	this.trimStartAborted(charType);
	return this;
};

var hasOwnProp = Object.prototype.hasOwnProperty;

var Bundle = function Bundle(options) {
	if ( options === void 0 ) options = {};

	this.intro = options.intro || '';
	this.separator = options.separator !== undefined ? options.separator : '\n';
	this.sources = [];
	this.uniqueSources = [];
	this.uniqueSourceIndexByFilename = {};
};

Bundle.prototype.addSource = function addSource (source) {
	if (source instanceof MagicString) {
		return this.addSource({
			content: source,
			filename: source.filename,
			separator: this.separator,
		});
	}

	if (!isObject(source) || !source.content) {
		throw new Error(
			'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'
		);
	}

	['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
		if (!hasOwnProp.call(source, option)) { source[option] = source.content[option]; }
	});

	if (source.separator === undefined) {
		// TODO there's a bunch of this sort of thing, needs cleaning up
		source.separator = this.separator;
	}

	if (source.filename) {
		if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
			this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
			this.uniqueSources.push({ filename: source.filename, content: source.content.original });
		} else {
			var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
			if (source.content.original !== uniqueSource.content) {
				throw new Error(("Illegal source: same filename (" + (source.filename) + "), different contents"));
			}
		}
	}

	this.sources.push(source);
	return this;
};

Bundle.prototype.append = function append (str, options) {
	this.addSource({
		content: new MagicString(str),
		separator: (options && options.separator) || '',
	});

	return this;
};

Bundle.prototype.clone = function clone () {
	var bundle = new Bundle({
		intro: this.intro,
		separator: this.separator,
	});

	this.sources.forEach(function (source) {
		bundle.addSource({
			filename: source.filename,
			content: source.content.clone(),
			separator: source.separator,
		});
	});

	return bundle;
};

Bundle.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1$1 = this;
		if ( options === void 0 ) options = {};

	var names = [];
	this.sources.forEach(function (source) {
		Object.keys(source.content.storedNames).forEach(function (name) {
			if (!~names.indexOf(name)) { names.push(name); }
		});
	});

	var mappings = new Mappings(options.hires);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.sources.forEach(function (source, i) {
		if (i > 0) {
			mappings.advance(this$1$1.separator);
		}

		var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
		var magicString = source.content;
		var locate = getLocator(magicString.original);

		if (magicString.intro) {
			mappings.advance(magicString.intro);
		}

		magicString.firstChunk.eachNext(function (chunk) {
			var loc = locate(chunk.start);

			if (chunk.intro.length) { mappings.advance(chunk.intro); }

			if (source.filename) {
				if (chunk.edited) {
					mappings.addEdit(
						sourceIndex,
						chunk.content,
						loc,
						chunk.storeName ? names.indexOf(chunk.original) : -1
					);
				} else {
					mappings.addUneditedChunk(
						sourceIndex,
						chunk,
						magicString.original,
						loc,
						magicString.sourcemapLocations
					);
				}
			} else {
				mappings.advance(chunk.content);
			}

			if (chunk.outro.length) { mappings.advance(chunk.outro); }
		});

		if (magicString.outro) {
			mappings.advance(magicString.outro);
		}
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: this.uniqueSources.map(function (source) {
			return options.file ? getRelativePath(options.file, source.filename) : source.filename;
		}),
		sourcesContent: this.uniqueSources.map(function (source) {
			return options.includeContent ? source.content : null;
		}),
		names: names,
		mappings: mappings.raw,
	};
};

Bundle.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
};

Bundle.prototype.getIndentString = function getIndentString () {
	var indentStringCounts = {};

	this.sources.forEach(function (source) {
		var indentStr = source.content.indentStr;

		if (indentStr === null) { return; }

		if (!indentStringCounts[indentStr]) { indentStringCounts[indentStr] = 0; }
		indentStringCounts[indentStr] += 1;
	});

	return (
		Object.keys(indentStringCounts).sort(function (a, b) {
			return indentStringCounts[a] - indentStringCounts[b];
		})[0] || '\t'
	);
};

Bundle.prototype.indent = function indent (indentStr) {
		var this$1$1 = this;

	if (!arguments.length) {
		indentStr = this.getIndentString();
	}

	if (indentStr === '') { return this; } // noop

	var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';

	this.sources.forEach(function (source, i) {
		var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
		var indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));

		source.content.indent(indentStr, {
			exclude: source.indentExclusionRanges,
			indentStart: indentStart, //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
		});

		trailingNewline = source.content.lastChar() === '\n';
	});

	if (this.intro) {
		this.intro =
			indentStr +
			this.intro.replace(/^[^\n]/gm, function (match, index) {
				return index > 0 ? indentStr + match : match;
			});
	}

	return this;
};

Bundle.prototype.prepend = function prepend (str) {
	this.intro = str + this.intro;
	return this;
};

Bundle.prototype.toString = function toString () {
		var this$1$1 = this;

	var body = this.sources
		.map(function (source, i) {
			var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
			var str = (i > 0 ? separator : '') + source.content.toString();

			return str;
		})
		.join('');

	return this.intro + body;
};

Bundle.prototype.isEmpty = function isEmpty () {
	if (this.intro.length && this.intro.trim()) { return false; }
	if (this.sources.some(function (source) { return !source.content.isEmpty(); })) { return false; }
	return true;
};

Bundle.prototype.length = function length () {
	return this.sources.reduce(
		function (length, source) { return length + source.content.length(); },
		this.intro.length
	);
};

Bundle.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

Bundle.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

Bundle.prototype.trimStart = function trimStart (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');
	this.intro = this.intro.replace(rx, '');

	if (!this.intro) {
		var source;
		var i = 0;

		do {
			source = this.sources[i++];
			if (!source) {
				break;
			}
		} while (!source.content.trimStartAborted(charType));
	}

	return this;
};

Bundle.prototype.trimEnd = function trimEnd (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	var source;
	var i = this.sources.length - 1;

	do {
		source = this.sources[i--];
		if (!source) {
			this.intro = this.intro.replace(rx, '');
			break;
		}
	} while (!source.content.trimEndAborted(charType));

	return this;
};

MagicString.Bundle = Bundle;
MagicString.SourceMap = SourceMap;
MagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121

module.exports = MagicString;
//# sourceMappingURL=magic-string.cjs.js.map
½/dist/magic-string.umd.js.mapÆ U¿{"version":3,"file":"magic-string.umd.js","sources":["../src/BitSet.js","../src/Chunk.js","../node_modules/sourcemap-codec/dist/sourcemap-codec.es.js","../src/SourceMap.js","../src/utils/guessIndent.js","../src/utils/getRelativePath.js","../src/utils/isObject.js","../src/utils/getLocator.js","../src/utils/Mappings.js","../src/MagicString.js","../src/Bundle.js","../src/index-legacy.js"],"sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext: { writable: true, value: null },\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","var charToInteger = {};\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nfor (var i = 0; i < chars.length; i++) {\n    charToInteger[chars.charCodeAt(i)] = i;\n}\nfunction decode(mappings) {\n    var decoded = [];\n    var line = [];\n    var segment = [\n        0,\n        0,\n        0,\n        0,\n        0,\n    ];\n    var j = 0;\n    for (var i = 0, shift = 0, value = 0; i < mappings.length; i++) {\n        var c = mappings.charCodeAt(i);\n        if (c === 44) { // \",\"\n            segmentify(line, segment, j);\n            j = 0;\n        }\n        else if (c === 59) { // \";\"\n            segmentify(line, segment, j);\n            j = 0;\n            decoded.push(line);\n            line = [];\n            segment[0] = 0;\n        }\n        else {\n            var integer = charToInteger[c];\n            if (integer === undefined) {\n                throw new Error('Invalid character (' + String.fromCharCode(c) + ')');\n            }\n            var hasContinuationBit = integer & 32;\n            integer &= 31;\n            value += integer << shift;\n            if (hasContinuationBit) {\n                shift += 5;\n            }\n            else {\n                var shouldNegate = value & 1;\n                value >>>= 1;\n                if (shouldNegate) {\n                    value = value === 0 ? -0x80000000 : -value;\n                }\n                segment[j] += value;\n                j++;\n                value = shift = 0; // reset\n            }\n        }\n    }\n    segmentify(line, segment, j);\n    decoded.push(line);\n    return decoded;\n}\nfunction segmentify(line, segment, j) {\n    // This looks ugly, but we're creating specialized arrays with a specific\n    // length. This is much faster than creating a new array (which v8 expands to\n    // a capacity of 17 after pushing the first item), or slicing out a subarray\n    // (which is slow). Length 4 is assumed to be the most frequent, followed by\n    // length 5 (since not everything will have an associated name), followed by\n    // length 1 (it's probably rare for a source substring to not have an\n    // associated segment data).\n    if (j === 4)\n        line.push([segment[0], segment[1], segment[2], segment[3]]);\n    else if (j === 5)\n        line.push([segment[0], segment[1], segment[2], segment[3], segment[4]]);\n    else if (j === 1)\n        line.push([segment[0]]);\n}\nfunction encode(decoded) {\n    var sourceFileIndex = 0; // second field\n    var sourceCodeLine = 0; // third field\n    var sourceCodeColumn = 0; // fourth field\n    var nameIndex = 0; // fifth field\n    var mappings = '';\n    for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        if (i > 0)\n            mappings += ';';\n        if (line.length === 0)\n            continue;\n        var generatedCodeColumn = 0; // first field\n        var lineMappings = [];\n        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {\n            var segment = line_1[_i];\n            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);\n            generatedCodeColumn = segment[0];\n            if (segment.length > 1) {\n                segmentMappings +=\n                    encodeInteger(segment[1] - sourceFileIndex) +\n                        encodeInteger(segment[2] - sourceCodeLine) +\n                        encodeInteger(segment[3] - sourceCodeColumn);\n                sourceFileIndex = segment[1];\n                sourceCodeLine = segment[2];\n                sourceCodeColumn = segment[3];\n            }\n            if (segment.length === 5) {\n                segmentMappings += encodeInteger(segment[4] - nameIndex);\n                nameIndex = segment[4];\n            }\n            lineMappings.push(segmentMappings);\n        }\n        mappings += lineMappings.join(',');\n    }\n    return mappings;\n}\nfunction encodeInteger(num) {\n    var result = '';\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        var clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) {\n            clamped |= 32;\n        }\n        result += chars[clamped];\n    } while (num > 0);\n    return result;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.es.js.map\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: guessIndent(string) },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range â€“ use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} â€“ \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport Bundle from './Bundle.js';\nimport SourceMap from './SourceMap.js';\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nexport default MagicString;\n"],"names":["const","let","this"],"mappings":"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"}«/index.d.tsÅþexport interface BundleOptions {
  intro?: string;
  separator?: string;
}

export interface SourceMapOptions {
  /**
   * Whether the mapping should be high-resolution.
   * Hi-res mappings map every single character, meaning (for example) your devtools will always
   * be able to pinpoint the exact location of function calls and so on.
   * With lo-res mappings, devtools may only be able to identify the correct
   * line - but they're quicker to generate and less bulky.
   * If sourcemap locations have been specified with s.addSourceMapLocation(), they will be used here.
   */
  hires?: boolean;
  /**
   * The filename where you plan to write the sourcemap.
   */
  file?: string;
  /**
   * The filename of the file containing the original source.
   */
  source?: string;
  /**
   * Whether to include the original content in the map's sourcesContent array.
   */
  includeContent?: boolean;
}

export type SourceMapSegment =
  | [number]
  | [number, number, number, number]
  | [number, number, number, number, number];

export interface DecodedSourceMap {
  file: string;
  sources: string[];
  sourcesContent: string[];
  names: string[];
  mappings: SourceMapSegment[][];
}

export class SourceMap {
  constructor(properties: DecodedSourceMap);

  version: number;
  file: string;
  sources: string[];
  sourcesContent: string[];
  names: string[];
  mappings: string;

  /**
   * Returns the equivalent of `JSON.stringify(map)`
   */
  toString(): string;
  /**
   * Returns a DataURI containing the sourcemap. Useful for doing this sort of thing:
   * `generateMap(options?: SourceMapOptions): SourceMap;`
   */
  toUrl(): string;
}

export class Bundle {
  constructor(options?: BundleOptions);
  addSource(source: MagicString | { filename?: string, content: MagicString }): Bundle;
  append(str: string, options?: BundleOptions): Bundle;
  clone(): Bundle;
  generateMap(options?: SourceMapOptions): SourceMap;
  generateDecodedMap(options?: SourceMapOptions): DecodedSourceMap;
  getIndentString(): string;
  indent(indentStr?: string): Bundle;
  indentExclusionRanges: ExclusionRange | Array<ExclusionRange>;
  prepend(str: string): Bundle;
  toString(): string;
  trimLines(): Bundle;
  trim(charType?: string): Bundle;
  trimStart(charType?: string): Bundle;
  trimEnd(charType?: string): Bundle;
  isEmpty(): boolean;
  length(): number;
}

export type ExclusionRange = [ number, number ];

export interface MagicStringOptions {
  filename?: string,
  indentExclusionRanges?: ExclusionRange | Array<ExclusionRange>;
}

export interface IndentOptions {
  exclude?: ExclusionRange | Array<ExclusionRange>;
  indentStart?: boolean;
}

export interface OverwriteOptions {
  storeName?: boolean;
  contentOnly?: boolean;
}

export default class MagicString {
  constructor(str: string, options?: MagicStringOptions);
  /**
   * Adds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is false.
   */
  addSourcemapLocation(char: number): void;
  /**
   * Appends the specified content to the end of the string.
   */
  append(content: string): MagicString;
  /**
   * Appends the specified content at the index in the original string.
   * If a range *ending* with index is subsequently moved, the insert will be moved with it. 
   * See also `s.prependLeft(...)`.
   */
  appendLeft(index: number, content: string): MagicString;
  /**
   * Appends the specified content at the index in the original string.
   * If a range *starting* with index is subsequently moved, the insert will be moved with it.
   * See also `s.prependRight(...)`.
   */
  appendRight(index: number, content: string): MagicString;
  /**
   * Does what you'd expect.
   */
  clone(): MagicString;
  /**
   * Generates a version 3 sourcemap.
   */
  generateMap(options?: SourceMapOptions): SourceMap;
  /**
   * Generates a sourcemap object with raw mappings in array form, rather than encoded as a string.
   * Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.
   */
  generateDecodedMap(options?: SourceMapOptions): DecodedSourceMap;
  getIndentString(): string;

  /**
   * Prefixes each line of the string with prefix.
   * If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.
   */
  indent(options?: IndentOptions): MagicString;
  /**
   * Prefixes each line of the string with prefix.
   * If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.
   *
   * The options argument can have an exclude property, which is an array of [start, end] character ranges.
   * These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.
   */
  indent(indentStr?: string, options?: IndentOptions): MagicString;
  indentExclusionRanges: ExclusionRange | Array<ExclusionRange>;

  /**
   * Moves the characters from `start and `end` to `index`.
   */
  move(start: number, end: number, index: number): MagicString;
  /**
   * Replaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply.
   *
   * The fourth argument is optional. It can have a storeName property â€” if true, the original name will be stored
   * for later inclusion in a sourcemap's names array â€” and a contentOnly property which determines whether only
   * the content is overwritten, or anything that was appended/prepended to the range as well.
   */
  overwrite(start: number, end: number, content: string, options?: boolean | OverwriteOptions): MagicString;
  /**
   * Prepends the string with the specified content. 
   */
  prepend(content: string): MagicString;
  /**
   * Same as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at index
   */
  prependLeft(index: number, content: string): MagicString;
  /**
   * Same as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`
   */
  prependRight(index: number, content: string): MagicString;
  /**
   * Removes the characters from `start` to `end` (of the original string, **not** the generated string).
   * Removing the same content twice, or making removals that partially overlap, will cause an error.
   */
  remove(start: number, end: number): MagicString;
  /**
   * Returns the content of the generated string that corresponds to the slice between `start` and `end` of the original string.
   * Throws error if the indices are for characters that were already removed.
   */
  slice(start: number, end: number): string;
  /**
   * Returns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.
   */
  snip(start: number, end: number): MagicString;
  /**
   * Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the start and end.
   */
  trim(charType?: string): MagicString;
  /**
   * Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the start.
   */
  trimStart(charType?: string): MagicString;
  /**
   * Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the end.
   */
  trimEnd(charType?: string): MagicString;
  /**
   * Removes empty lines from the start and end.
   */
  trimLines(): MagicString;

  lastChar(): string;
  lastLine(): string;
  /**
   * Returns true if the resulting source is empty (disregarding white space).
   */
  isEmpty(): boolean;
  length(): number;

  original: string;
  /**
   * Returns the generated string.
   */
  toString(): string;
}
½/dist/magic-string.cjs.js.mapÆ ;Û{"version":3,"file":"magic-string.cjs.js","sources":["../src/BitSet.js","../src/Chunk.js","../src/SourceMap.js","../src/utils/guessIndent.js","../src/utils/getRelativePath.js","../src/utils/isObject.js","../src/utils/getLocator.js","../src/utils/Mappings.js","../src/MagicString.js","../src/Bundle.js","../src/index-legacy.js"],"sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext: { writable: true, value: null },\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: guessIndent(string) },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range â€“ use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} â€“ \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport Bundle from './Bundle.js';\nimport SourceMap from './SourceMap.js';\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nexport default MagicString;\n"],"names":["const","let","encode","this"],"mappings":"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"}¸/dist/magic-string.es.jsÅƒ²import { encode } from 'sourcemap-codec';

var BitSet = function BitSet(arg) {
	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
};

BitSet.prototype.add = function add (n) {
	this.bits[n >> 5] |= 1 << (n & 31);
};

BitSet.prototype.has = function has (n) {
	return !!(this.bits[n >> 5] & (1 << (n & 31)));
};

var Chunk = function Chunk(start, end, content) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties(this, {
		previous: { writable: true, value: null },
		next: { writable: true, value: null },
	});
};

Chunk.prototype.appendLeft = function appendLeft (content) {
	this.outro += content;
};

Chunk.prototype.appendRight = function appendRight (content) {
	this.intro = this.intro + content;
};

Chunk.prototype.clone = function clone () {
	var chunk = new Chunk(this.start, this.end, this.original);

	chunk.intro = this.intro;
	chunk.outro = this.outro;
	chunk.content = this.content;
	chunk.storeName = this.storeName;
	chunk.edited = this.edited;

	return chunk;
};

Chunk.prototype.contains = function contains (index) {
	return this.start < index && index < this.end;
};

Chunk.prototype.eachNext = function eachNext (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.next;
	}
};

Chunk.prototype.eachPrevious = function eachPrevious (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.previous;
	}
};

Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
	this.content = content;
	if (!contentOnly) {
		this.intro = '';
		this.outro = '';
	}
	this.storeName = storeName;

	this.edited = true;

	return this;
};

Chunk.prototype.prependLeft = function prependLeft (content) {
	this.outro = content + this.outro;
};

Chunk.prototype.prependRight = function prependRight (content) {
	this.intro = content + this.intro;
};

Chunk.prototype.split = function split (index) {
	var sliceIndex = index - this.start;

	var originalBefore = this.original.slice(0, sliceIndex);
	var originalAfter = this.original.slice(sliceIndex);

	this.original = originalBefore;

	var newChunk = new Chunk(index, this.end, originalAfter);
	newChunk.outro = this.outro;
	this.outro = '';

	this.end = index;

	if (this.edited) {
		// TODO is this block necessary?...
		newChunk.edit('', false);
		this.content = '';
	} else {
		this.content = originalBefore;
	}

	newChunk.next = this.next;
	if (newChunk.next) { newChunk.next.previous = newChunk; }
	newChunk.previous = this;
	this.next = newChunk;

	return newChunk;
};

Chunk.prototype.toString = function toString () {
	return this.intro + this.content + this.outro;
};

Chunk.prototype.trimEnd = function trimEnd (rx) {
	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.start + trimmed.length).edit('', undefined, true);
		}
		return true;
	} else {
		this.edit('', undefined, true);

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }
	}
};

Chunk.prototype.trimStart = function trimStart (rx) {
	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.end - trimmed.length);
			this.edit('', undefined, true);
		}
		return true;
	} else {
		this.edit('', undefined, true);

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }
	}
};

var btoa = function () {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
};
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
} else if (typeof Buffer === 'function') {
	btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
}

var SourceMap = function SourceMap(properties) {
	this.version = 3;
	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = encode(properties.mappings);
};

SourceMap.prototype.toString = function toString () {
	return JSON.stringify(this);
};

SourceMap.prototype.toUrl = function toUrl () {
	return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
};

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
	var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	var fromParts = from.split(/[/\\]/);
	var toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) { fromParts[i] = '..'; }
	}

	return fromParts.concat(toParts).join('/');
}

var toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
}

function getLocator(source) {
	var originalLines = source.split('\n');
	var lineOffsets = [];

	for (var i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		var i = 0;
		var j = lineOffsets.length;
		while (i < j) {
			var m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		var line = i - 1;
		var column = index - lineOffsets[line];
		return { line: line, column: column };
	};
}

var Mappings = function Mappings(hires) {
	this.hires = hires;
	this.generatedCodeLine = 0;
	this.generatedCodeColumn = 0;
	this.raw = [];
	this.rawSegments = this.raw[this.generatedCodeLine] = [];
	this.pending = null;
};

Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
	if (content.length) {
		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
		if (nameIndex >= 0) {
			segment.push(nameIndex);
		}
		this.rawSegments.push(segment);
	} else if (this.pending) {
		this.rawSegments.push(this.pending);
	}

	this.advance(content);
	this.pending = null;
};

Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
	var originalCharIndex = chunk.start;
	var first = true;

	while (originalCharIndex < chunk.end) {
		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
		}

		if (original[originalCharIndex] === '\n') {
			loc.line += 1;
			loc.column = 0;
			this.generatedCodeLine += 1;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
			this.generatedCodeColumn = 0;
			first = true;
		} else {
			loc.column += 1;
			this.generatedCodeColumn += 1;
			first = false;
		}

		originalCharIndex += 1;
	}

	this.pending = null;
};

Mappings.prototype.advance = function advance (str) {
	if (!str) { return; }

	var lines = str.split('\n');

	if (lines.length > 1) {
		for (var i = 0; i < lines.length - 1; i++) {
			this.generatedCodeLine++;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
		}
		this.generatedCodeColumn = 0;
	}

	this.generatedCodeColumn += lines[lines.length - 1].length;
};

var n = '\n';

var warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
};

var MagicString = function MagicString(string, options) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk(0, string.length, string);

	Object.defineProperties(this, {
		original: { writable: true, value: string },
		outro: { writable: true, value: '' },
		intro: { writable: true, value: '' },
		firstChunk: { writable: true, value: chunk },
		lastChunk: { writable: true, value: chunk },
		lastSearchedChunk: { writable: true, value: chunk },
		byStart: { writable: true, value: {} },
		byEnd: { writable: true, value: {} },
		filename: { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations: { writable: true, value: new BitSet() },
		storedNames: { writable: true, value: {} },
		indentStr: { writable: true, value: guessIndent(string) },
	});

	this.byStart[0] = chunk;
	this.byEnd[string.length] = chunk;
};

MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
	this.sourcemapLocations.add(char);
};

MagicString.prototype.append = function append (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.outro += content;
	return this;
};

MagicString.prototype.appendLeft = function appendLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.appendLeft(content);
	} else {
		this.intro += content;
	}
	return this;
};

MagicString.prototype.appendRight = function appendRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.appendRight(content);
	} else {
		this.outro += content;
	}
	return this;
};

MagicString.prototype.clone = function clone () {
	var cloned = new MagicString(this.original, { filename: this.filename });

	var originalChunk = this.firstChunk;
	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

	while (originalChunk) {
		cloned.byStart[clonedChunk.start] = clonedChunk;
		cloned.byEnd[clonedChunk.end] = clonedChunk;

		var nextOriginalChunk = originalChunk.next;
		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

		if (nextClonedChunk) {
			clonedChunk.next = nextClonedChunk;
			nextClonedChunk.previous = clonedChunk;

			clonedChunk = nextClonedChunk;
		}

		originalChunk = nextOriginalChunk;
	}

	cloned.lastChunk = clonedChunk;

	if (this.indentExclusionRanges) {
		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
	}

	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

	cloned.intro = this.intro;
	cloned.outro = this.outro;

	return cloned;
};

MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1$1 = this;

	options = options || {};

	var sourceIndex = 0;
	var names = Object.keys(this.storedNames);
	var mappings = new Mappings(options.hires);

	var locate = getLocator(this.original);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.firstChunk.eachNext(function (chunk) {
		var loc = locate(chunk.start);

		if (chunk.intro.length) { mappings.advance(chunk.intro); }

		if (chunk.edited) {
			mappings.addEdit(
				sourceIndex,
				chunk.content,
				loc,
				chunk.storeName ? names.indexOf(chunk.original) : -1
			);
		} else {
			mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
		}

		if (chunk.outro.length) { mappings.advance(chunk.outro); }
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
		sourcesContent: options.includeContent ? [this.original] : [null],
		names: names,
		mappings: mappings.raw,
	};
};

MagicString.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
};

MagicString.prototype.getIndentString = function getIndentString () {
	return this.indentStr === null ? '\t' : this.indentStr;
};

MagicString.prototype.indent = function indent (indentStr, options) {
	var pattern = /^[^\r\n]/gm;

	if (isObject(indentStr)) {
		options = indentStr;
		indentStr = undefined;
	}

	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

	if (indentStr === '') { return this; } // noop

	options = options || {};

	// Process exclusion ranges
	var isExcluded = {};

	if (options.exclude) {
		var exclusions =
			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
		exclusions.forEach(function (exclusion) {
			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
				isExcluded[i] = true;
			}
		});
	}

	var shouldIndentNextCharacter = options.indentStart !== false;
	var replacer = function (match) {
		if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
		shouldIndentNextCharacter = true;
		return match;
	};

	this.intro = this.intro.replace(pattern, replacer);

	var charIndex = 0;
	var chunk = this.firstChunk;

	while (chunk) {
		var end = chunk.end;

		if (chunk.edited) {
			if (!isExcluded[charIndex]) {
				chunk.content = chunk.content.replace(pattern, replacer);

				if (chunk.content.length) {
					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
				}
			}
		} else {
			charIndex = chunk.start;

			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					} else if (char !== '\r' && shouldIndentNextCharacter) {
						shouldIndentNextCharacter = false;

						if (charIndex === chunk.start) {
							chunk.prependRight(indentStr);
						} else {
							this._splitChunk(chunk, charIndex);
							chunk = chunk.next;
							chunk.prependRight(indentStr);
						}
					}
				}

				charIndex += 1;
			}
		}

		charIndex = chunk.end;
		chunk = chunk.next;
	}

	this.outro = this.outro.replace(pattern, replacer);

	return this;
};

MagicString.prototype.insert = function insert () {
	throw new Error(
		'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'
	);
};

MagicString.prototype.insertLeft = function insertLeft (index, content) {
	if (!warned.insertLeft) {
		console.warn(
			'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'
		); // eslint-disable-line no-console
		warned.insertLeft = true;
	}

	return this.appendLeft(index, content);
};

MagicString.prototype.insertRight = function insertRight (index, content) {
	if (!warned.insertRight) {
		console.warn(
			'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'
		); // eslint-disable-line no-console
		warned.insertRight = true;
	}

	return this.prependRight(index, content);
};

MagicString.prototype.move = function move (start, end, index) {
	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }

	this._split(start);
	this._split(end);
	this._split(index);

	var first = this.byStart[start];
	var last = this.byEnd[end];

	var oldLeft = first.previous;
	var oldRight = last.next;

	var newRight = this.byStart[index];
	if (!newRight && last === this.lastChunk) { return this; }
	var newLeft = newRight ? newRight.previous : this.lastChunk;

	if (oldLeft) { oldLeft.next = oldRight; }
	if (oldRight) { oldRight.previous = oldLeft; }

	if (newLeft) { newLeft.next = first; }
	if (newRight) { newRight.previous = last; }

	if (!first.previous) { this.firstChunk = last.next; }
	if (!last.next) {
		this.lastChunk = first.previous;
		this.lastChunk.next = null;
	}

	first.previous = newLeft;
	last.next = newRight || null;

	if (!newLeft) { this.firstChunk = first; }
	if (!newRight) { this.lastChunk = last; }
	return this;
};

MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (end > this.original.length) { throw new Error('end is out of bounds'); }
	if (start === end)
		{ throw new Error(
			'Cannot overwrite a zero-length range â€“ use appendLeft or prependRight instead'
		); }

	this._split(start);
	this._split(end);

	if (options === true) {
		if (!warned.storeName) {
			console.warn(
				'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'
			); // eslint-disable-line no-console
			warned.storeName = true;
		}

		options = { storeName: true };
	}
	var storeName = options !== undefined ? options.storeName : false;
	var contentOnly = options !== undefined ? options.contentOnly : false;

	if (storeName) {
		var original = this.original.slice(start, end);
		Object.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });
	}

	var first = this.byStart[start];
	var last = this.byEnd[end];

	if (first) {
		var chunk = first;
		while (chunk !== last) {
			if (chunk.next !== this.byStart[chunk.end]) {
				throw new Error('Cannot overwrite across a split point');
			}
			chunk = chunk.next;
			chunk.edit('', false);
		}

		first.edit(content, storeName, contentOnly);
	} else {
		// must be inserting at the end
		var newChunk = new Chunk(start, end, '').edit(content, storeName);

		// TODO last chunk in the array may not be the last chunk, if it's moved...
		last.next = newChunk;
		newChunk.previous = last;
	}
	return this;
};

MagicString.prototype.prepend = function prepend (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

	this.intro = content + this.intro;
	return this;
};

MagicString.prototype.prependLeft = function prependLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.prependLeft(content);
	} else {
		this.intro = content + this.intro;
	}
	return this;
};

MagicString.prototype.prependRight = function prependRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.prependRight(content);
	} else {
		this.outro = content + this.outro;
	}
	return this;
};

MagicString.prototype.remove = function remove (start, end) {
	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	if (start === end) { return this; }

	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
	if (start > end) { throw new Error('end must be greater than start'); }

	this._split(start);
	this._split(end);

	var chunk = this.byStart[start];

	while (chunk) {
		chunk.intro = '';
		chunk.outro = '';
		chunk.edit('');

		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
	}
	return this;
};

MagicString.prototype.lastChar = function lastChar () {
	if (this.outro.length) { return this.outro[this.outro.length - 1]; }
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length) { return chunk.outro[chunk.outro.length - 1]; }
		if (chunk.content.length) { return chunk.content[chunk.content.length - 1]; }
		if (chunk.intro.length) { return chunk.intro[chunk.intro.length - 1]; }
	} while ((chunk = chunk.previous));
	if (this.intro.length) { return this.intro[this.intro.length - 1]; }
	return '';
};

MagicString.prototype.lastLine = function lastLine () {
	var lineIndex = this.outro.lastIndexOf(n);
	if (lineIndex !== -1) { return this.outro.substr(lineIndex + 1); }
	var lineStr = this.outro;
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length > 0) {
			lineIndex = chunk.outro.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.outro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.outro + lineStr;
		}

		if (chunk.content.length > 0) {
			lineIndex = chunk.content.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.content.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.content + lineStr;
		}

		if (chunk.intro.length > 0) {
			lineIndex = chunk.intro.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.intro.substr(lineIndex + 1) + lineStr; }
			lineStr = chunk.intro + lineStr;
		}
	} while ((chunk = chunk.previous));
	lineIndex = this.intro.lastIndexOf(n);
	if (lineIndex !== -1) { return this.intro.substr(lineIndex + 1) + lineStr; }
	return this.intro + lineStr;
};

MagicString.prototype.slice = function slice (start, end) {
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

	while (start < 0) { start += this.original.length; }
	while (end < 0) { end += this.original.length; }

	var result = '';

	// find start chunk
	var chunk = this.firstChunk;
	while (chunk && (chunk.start > start || chunk.end <= start)) {
		// found end chunk before start
		if (chunk.start < end && chunk.end >= end) {
			return result;
		}

		chunk = chunk.next;
	}

	if (chunk && chunk.edited && chunk.start !== start)
		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

	var startChunk = chunk;
	while (chunk) {
		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
			result += chunk.intro;
		}

		var containsEnd = chunk.start < end && chunk.end >= end;
		if (containsEnd && chunk.edited && chunk.end !== end)
			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

		result += chunk.content.slice(sliceStart, sliceEnd);

		if (chunk.outro && (!containsEnd || chunk.end === end)) {
			result += chunk.outro;
		}

		if (containsEnd) {
			break;
		}

		chunk = chunk.next;
	}

	return result;
};

// TODO deprecate this? not really very useful
MagicString.prototype.snip = function snip (start, end) {
	var clone = this.clone();
	clone.remove(0, start);
	clone.remove(end, clone.original.length);

	return clone;
};

MagicString.prototype._split = function _split (index) {
	if (this.byStart[index] || this.byEnd[index]) { return; }

	var chunk = this.lastSearchedChunk;
	var searchForward = index > chunk.end;

	while (chunk) {
		if (chunk.contains(index)) { return this._splitChunk(chunk, index); }

		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
	}
};

MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
	if (chunk.edited && chunk.content.length) {
		// zero-length edited chunks are a special case (overlapping replacements)
		var loc = getLocator(this.original)(index);
		throw new Error(
			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " â€“ \"" + (chunk.original) + "\")")
		);
	}

	var newChunk = chunk.split(index);

	this.byEnd[index] = chunk;
	this.byStart[index] = newChunk;
	this.byEnd[newChunk.end] = newChunk;

	if (chunk === this.lastChunk) { this.lastChunk = newChunk; }

	this.lastSearchedChunk = chunk;
	return true;
};

MagicString.prototype.toString = function toString () {
	var str = this.intro;

	var chunk = this.firstChunk;
	while (chunk) {
		str += chunk.toString();
		chunk = chunk.next;
	}

	return str + this.outro;
};

MagicString.prototype.isEmpty = function isEmpty () {
	var chunk = this.firstChunk;
	do {
		if (
			(chunk.intro.length && chunk.intro.trim()) ||
			(chunk.content.length && chunk.content.trim()) ||
			(chunk.outro.length && chunk.outro.trim())
		)
			{ return false; }
	} while ((chunk = chunk.next));
	return true;
};

MagicString.prototype.length = function length () {
	var chunk = this.firstChunk;
	var length = 0;
	do {
		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
	} while ((chunk = chunk.next));
	return length;
};

MagicString.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

MagicString.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; }

	var chunk = this.lastChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimEnd(rx);

		// if chunk was trimmed, we have a new lastChunk
		if (chunk.end !== end) {
			if (this.lastChunk === chunk) {
				this.lastChunk = chunk.next;
			}

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.previous;
	} while (chunk);

	return false;
};

MagicString.prototype.trimEnd = function trimEnd (charType) {
	this.trimEndAborted(charType);
	return this;
};
MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');

	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; }

	var chunk = this.firstChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimStart(rx);

		if (chunk.end !== end) {
			// special case...
			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		}

		if (aborted) { return true; }
		chunk = chunk.next;
	} while (chunk);

	return false;
};

MagicString.prototype.trimStart = function trimStart (charType) {
	this.trimStartAborted(charType);
	return this;
};

var hasOwnProp = Object.prototype.hasOwnProperty;

var Bundle = function Bundle(options) {
	if ( options === void 0 ) options = {};

	this.intro = options.intro || '';
	this.separator = options.separator !== undefined ? options.separator : '\n';
	this.sources = [];
	this.uniqueSources = [];
	this.uniqueSourceIndexByFilename = {};
};

Bundle.prototype.addSource = function addSource (source) {
	if (source instanceof MagicString) {
		return this.addSource({
			content: source,
			filename: source.filename,
			separator: this.separator,
		});
	}

	if (!isObject(source) || !source.content) {
		throw new Error(
			'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'
		);
	}

	['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
		if (!hasOwnProp.call(source, option)) { source[option] = source.content[option]; }
	});

	if (source.separator === undefined) {
		// TODO there's a bunch of this sort of thing, needs cleaning up
		source.separator = this.separator;
	}

	if (source.filename) {
		if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
			this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
			this.uniqueSources.push({ filename: source.filename, content: source.content.original });
		} else {
			var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
			if (source.content.original !== uniqueSource.content) {
				throw new Error(("Illegal source: same filename (" + (source.filename) + "), different contents"));
			}
		}
	}

	this.sources.push(source);
	return this;
};

Bundle.prototype.append = function append (str, options) {
	this.addSource({
		content: new MagicString(str),
		separator: (options && options.separator) || '',
	});

	return this;
};

Bundle.prototype.clone = function clone () {
	var bundle = new Bundle({
		intro: this.intro,
		separator: this.separator,
	});

	this.sources.forEach(function (source) {
		bundle.addSource({
			filename: source.filename,
			content: source.content.clone(),
			separator: source.separator,
		});
	});

	return bundle;
};

Bundle.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1$1 = this;
		if ( options === void 0 ) options = {};

	var names = [];
	this.sources.forEach(function (source) {
		Object.keys(source.content.storedNames).forEach(function (name) {
			if (!~names.indexOf(name)) { names.push(name); }
		});
	});

	var mappings = new Mappings(options.hires);

	if (this.intro) {
		mappings.advance(this.intro);
	}

	this.sources.forEach(function (source, i) {
		if (i > 0) {
			mappings.advance(this$1$1.separator);
		}

		var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
		var magicString = source.content;
		var locate = getLocator(magicString.original);

		if (magicString.intro) {
			mappings.advance(magicString.intro);
		}

		magicString.firstChunk.eachNext(function (chunk) {
			var loc = locate(chunk.start);

			if (chunk.intro.length) { mappings.advance(chunk.intro); }

			if (source.filename) {
				if (chunk.edited) {
					mappings.addEdit(
						sourceIndex,
						chunk.content,
						loc,
						chunk.storeName ? names.indexOf(chunk.original) : -1
					);
				} else {
					mappings.addUneditedChunk(
						sourceIndex,
						chunk,
						magicString.original,
						loc,
						magicString.sourcemapLocations
					);
				}
			} else {
				mappings.advance(chunk.content);
			}

			if (chunk.outro.length) { mappings.advance(chunk.outro); }
		});

		if (magicString.outro) {
			mappings.advance(magicString.outro);
		}
	});

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: this.uniqueSources.map(function (source) {
			return options.file ? getRelativePath(options.file, source.filename) : source.filename;
		}),
		sourcesContent: this.uniqueSources.map(function (source) {
			return options.includeContent ? source.content : null;
		}),
		names: names,
		mappings: mappings.raw,
	};
};

Bundle.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
};

Bundle.prototype.getIndentString = function getIndentString () {
	var indentStringCounts = {};

	this.sources.forEach(function (source) {
		var indentStr = source.content.indentStr;

		if (indentStr === null) { return; }

		if (!indentStringCounts[indentStr]) { indentStringCounts[indentStr] = 0; }
		indentStringCounts[indentStr] += 1;
	});

	return (
		Object.keys(indentStringCounts).sort(function (a, b) {
			return indentStringCounts[a] - indentStringCounts[b];
		})[0] || '\t'
	);
};

Bundle.prototype.indent = function indent (indentStr) {
		var this$1$1 = this;

	if (!arguments.length) {
		indentStr = this.getIndentString();
	}

	if (indentStr === '') { return this; } // noop

	var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';

	this.sources.forEach(function (source, i) {
		var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
		var indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));

		source.content.indent(indentStr, {
			exclude: source.indentExclusionRanges,
			indentStart: indentStart, //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
		});

		trailingNewline = source.content.lastChar() === '\n';
	});

	if (this.intro) {
		this.intro =
			indentStr +
			this.intro.replace(/^[^\n]/gm, function (match, index) {
				return index > 0 ? indentStr + match : match;
			});
	}

	return this;
};

Bundle.prototype.prepend = function prepend (str) {
	this.intro = str + this.intro;
	return this;
};

Bundle.prototype.toString = function toString () {
		var this$1$1 = this;

	var body = this.sources
		.map(function (source, i) {
			var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
			var str = (i > 0 ? separator : '') + source.content.toString();

			return str;
		})
		.join('');

	return this.intro + body;
};

Bundle.prototype.isEmpty = function isEmpty () {
	if (this.intro.length && this.intro.trim()) { return false; }
	if (this.sources.some(function (source) { return !source.content.isEmpty(); })) { return false; }
	return true;
};

Bundle.prototype.length = function length () {
	return this.sources.reduce(
		function (length, source) { return length + source.content.length(); },
		this.intro.length
	);
};

Bundle.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
};

Bundle.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
};

Bundle.prototype.trimStart = function trimStart (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');
	this.intro = this.intro.replace(rx, '');

	if (!this.intro) {
		var source;
		var i = 0;

		do {
			source = this.sources[i++];
			if (!source) {
				break;
			}
		} while (!source.content.trimStartAborted(charType));
	}

	return this;
};

Bundle.prototype.trimEnd = function trimEnd (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	var source;
	var i = this.sources.length - 1;

	do {
		source = this.sources[i--];
		if (!source) {
			this.intro = this.intro.replace(rx, '');
			break;
		}
	} while (!source.content.trimEndAborted(charType));

	return this;
};

export { Bundle, SourceMap, MagicString as default };
//# sourceMappingURL=magic-string.es.js.map
­/package.jsonÅâ{
  "name": "magic-string",
  "version": "0.25.9",
  "description": "Modify strings, generate sourcemaps",
  "keywords": [
    "string",
    "string manipulation",
    "sourcemap",
    "templating",
    "transpilation"
  ],
  "repository": "https://github.com/rich-harris/magic-string",
  "license": "MIT",
  "author": "Rich Harris",
  "main": "dist/magic-string.cjs.js",
  "module": "dist/magic-string.es.js",
  "jsnext:main": "dist/magic-string.es.js",
  "typings": "index.d.ts",
  "files": [
    "dist/*",
    "index.d.ts",
    "README.md"
  ],
  "scripts": {
    "build": "rollup -c",
    "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s",
    "format": "prettier --single-quote --print-width 100 --use-tabs --write src/*.js src/**/*.js",
    "lint": "eslint src test",
    "prepare": "npm run build",
    "prepublishOnly": "rm -rf dist && npm test",
    "release": "bumpp -x \"npm run changelog\" --all --commit --tag --push && npm publish",
    "pretest": "npm run lint && npm run build",
    "test": "mocha",
    "watch": "rollup -cw"
  },
  "dependencies": {
    "sourcemap-codec": "^1.4.8"
  },
  "devDependencies": {
    "@rollup/plugin-buble": "^0.21.3",
    "@rollup/plugin-node-resolve": "^13.1.3",
    "@rollup/plugin-replace": "^4.0.0",
    "bumpp": "^7.1.1",
    "conventional-changelog-cli": "^2.2.2",
    "eslint": "^7.32.0",
    "mocha": "^9.2.1",
    "prettier": "^2.5.1",
    "rollup": "^2.69.0",
    "source-map": "^0.6.1",
    "source-map-support": "^0.5.21"
  }
}
¹/dist/magic-string.umd.jsÅ‘8(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.MagicString = factory());
})(this, (function () { 'use strict';

	var BitSet = function BitSet(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	};

	BitSet.prototype.add = function add (n) {
		this.bits[n >> 5] |= 1 << (n & 31);
	};

	BitSet.prototype.has = function has (n) {
		return !!(this.bits[n >> 5] & (1 << (n & 31)));
	};

	var Chunk = function Chunk(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;

		this.intro = '';
		this.outro = '';

		this.content = content;
		this.storeName = false;
		this.edited = false;

		// we make these non-enumerable, for sanity while debugging
		Object.defineProperties(this, {
			previous: { writable: true, value: null },
			next: { writable: true, value: null },
		});
	};

	Chunk.prototype.appendLeft = function appendLeft (content) {
		this.outro += content;
	};

	Chunk.prototype.appendRight = function appendRight (content) {
		this.intro = this.intro + content;
	};

	Chunk.prototype.clone = function clone () {
		var chunk = new Chunk(this.start, this.end, this.original);

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	};

	Chunk.prototype.contains = function contains (index) {
		return this.start < index && index < this.end;
	};

	Chunk.prototype.eachNext = function eachNext (fn) {
		var chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	};

	Chunk.prototype.eachPrevious = function eachPrevious (fn) {
		var chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	};

	Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	};

	Chunk.prototype.prependLeft = function prependLeft (content) {
		this.outro = content + this.outro;
	};

	Chunk.prototype.prependRight = function prependRight (content) {
		this.intro = content + this.intro;
	};

	Chunk.prototype.split = function split (index) {
		var sliceIndex = index - this.start;

		var originalBefore = this.original.slice(0, sliceIndex);
		var originalAfter = this.original.slice(sliceIndex);

		this.original = originalBefore;

		var newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if (this.edited) {
			// TODO is this block necessary?...
			newChunk.edit('', false);
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if (newChunk.next) { newChunk.next.previous = newChunk; }
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	};

	Chunk.prototype.toString = function toString () {
		return this.intro + this.content + this.outro;
	};

	Chunk.prototype.trimEnd = function trimEnd (rx) {
		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }

		var trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) { return true; }
		}
	};

	Chunk.prototype.trimStart = function trimStart (rx) {
		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }

		var trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.end - trimmed.length);
				this.edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) { return true; }
		}
	};

	var charToInteger = {};
	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	for (var i = 0; i < chars.length; i++) {
	    charToInteger[chars.charCodeAt(i)] = i;
	}
	function encode(decoded) {
	    var sourceFileIndex = 0; // second field
	    var sourceCodeLine = 0; // third field
	    var sourceCodeColumn = 0; // fourth field
	    var nameIndex = 0; // fifth field
	    var mappings = '';
	    for (var i = 0; i < decoded.length; i++) {
	        var line = decoded[i];
	        if (i > 0)
	            mappings += ';';
	        if (line.length === 0)
	            continue;
	        var generatedCodeColumn = 0; // first field
	        var lineMappings = [];
	        for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
	            var segment = line_1[_i];
	            var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
	            generatedCodeColumn = segment[0];
	            if (segment.length > 1) {
	                segmentMappings +=
	                    encodeInteger(segment[1] - sourceFileIndex) +
	                        encodeInteger(segment[2] - sourceCodeLine) +
	                        encodeInteger(segment[3] - sourceCodeColumn);
	                sourceFileIndex = segment[1];
	                sourceCodeLine = segment[2];
	                sourceCodeColumn = segment[3];
	            }
	            if (segment.length === 5) {
	                segmentMappings += encodeInteger(segment[4] - nameIndex);
	                nameIndex = segment[4];
	            }
	            lineMappings.push(segmentMappings);
	        }
	        mappings += lineMappings.join(',');
	    }
	    return mappings;
	}
	function encodeInteger(num) {
	    var result = '';
	    num = num < 0 ? (-num << 1) | 1 : num << 1;
	    do {
	        var clamped = num & 31;
	        num >>>= 5;
	        if (num > 0) {
	            clamped |= 32;
	        }
	        result += chars[clamped];
	    } while (num > 0);
	    return result;
	}

	var btoa = function () {
		throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
	};
	if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
		btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); };
	} else if (typeof Buffer === 'function') {
		btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); };
	}

	var SourceMap = function SourceMap(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
	};

	SourceMap.prototype.toString = function toString () {
		return JSON.stringify(this);
	};

	SourceMap.prototype.toUrl = function toUrl () {
		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
	};

	function guessIndent(code) {
		var lines = code.split('\n');

		var tabbed = lines.filter(function (line) { return /^\t+/.test(line); });
		var spaced = lines.filter(function (line) { return /^ {2,}/.test(line); });

		if (tabbed.length === 0 && spaced.length === 0) {
			return null;
		}

		// More lines tabbed than spaced? Assume tabs, and
		// default to tabs in the case of a tie (or nothing
		// to go on)
		if (tabbed.length >= spaced.length) {
			return '\t';
		}

		// Otherwise, we need to guess the multiple
		var min = spaced.reduce(function (previous, current) {
			var numSpaces = /^ +/.exec(current)[0].length;
			return Math.min(numSpaces, previous);
		}, Infinity);

		return new Array(min + 1).join(' ');
	}

	function getRelativePath(from, to) {
		var fromParts = from.split(/[/\\]/);
		var toParts = to.split(/[/\\]/);

		fromParts.pop(); // get dirname

		while (fromParts[0] === toParts[0]) {
			fromParts.shift();
			toParts.shift();
		}

		if (fromParts.length) {
			var i = fromParts.length;
			while (i--) { fromParts[i] = '..'; }
		}

		return fromParts.concat(toParts).join('/');
	}

	var toString = Object.prototype.toString;

	function isObject(thing) {
		return toString.call(thing) === '[object Object]';
	}

	function getLocator(source) {
		var originalLines = source.split('\n');
		var lineOffsets = [];

		for (var i = 0, pos = 0; i < originalLines.length; i++) {
			lineOffsets.push(pos);
			pos += originalLines[i].length + 1;
		}

		return function locate(index) {
			var i = 0;
			var j = lineOffsets.length;
			while (i < j) {
				var m = (i + j) >> 1;
				if (index < lineOffsets[m]) {
					j = m;
				} else {
					i = m + 1;
				}
			}
			var line = i - 1;
			var column = index - lineOffsets[line];
			return { line: line, column: column };
		};
	}

	var Mappings = function Mappings(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	};

	Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
			if (nameIndex >= 0) {
				segment.push(nameIndex);
			}
			this.rawSegments.push(segment);
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
		}

		this.advance(content);
		this.pending = null;
	};

	Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
		var originalCharIndex = chunk.start;
		var first = true;

		while (originalCharIndex < chunk.end) {
			if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
				this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
			}

			if (original[originalCharIndex] === '\n') {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
			} else {
				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}

			originalCharIndex += 1;
		}

		this.pending = null;
	};

	Mappings.prototype.advance = function advance (str) {
		if (!str) { return; }

		var lines = str.split('\n');

		if (lines.length > 1) {
			for (var i = 0; i < lines.length - 1; i++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}

		this.generatedCodeColumn += lines[lines.length - 1].length;
	};

	var n = '\n';

	var warned = {
		insertLeft: false,
		insertRight: false,
		storeName: false,
	};

	var MagicString = function MagicString(string, options) {
		if ( options === void 0 ) options = {};

		var chunk = new Chunk(0, string.length, string);

		Object.defineProperties(this, {
			original: { writable: true, value: string },
			outro: { writable: true, value: '' },
			intro: { writable: true, value: '' },
			firstChunk: { writable: true, value: chunk },
			lastChunk: { writable: true, value: chunk },
			lastSearchedChunk: { writable: true, value: chunk },
			byStart: { writable: true, value: {} },
			byEnd: { writable: true, value: {} },
			filename: { writable: true, value: options.filename },
			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
			sourcemapLocations: { writable: true, value: new BitSet() },
			storedNames: { writable: true, value: {} },
			indentStr: { writable: true, value: guessIndent(string) },
		});

		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	};

	MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
		this.sourcemapLocations.add(char);
	};

	MagicString.prototype.append = function append (content) {
		if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

		this.outro += content;
		return this;
	};

	MagicString.prototype.appendLeft = function appendLeft (index, content) {
		if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

		this._split(index);

		var chunk = this.byEnd[index];

		if (chunk) {
			chunk.appendLeft(content);
		} else {
			this.intro += content;
		}
		return this;
	};

	MagicString.prototype.appendRight = function appendRight (index, content) {
		if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

		this._split(index);

		var chunk = this.byStart[index];

		if (chunk) {
			chunk.appendRight(content);
		} else {
			this.outro += content;
		}
		return this;
	};

	MagicString.prototype.clone = function clone () {
		var cloned = new MagicString(this.original, { filename: this.filename });

		var originalChunk = this.firstChunk;
		var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;

			var nextOriginalChunk = originalChunk.next;
			var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if (this.indentExclusionRanges) {
			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		}

		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

		cloned.intro = this.intro;
		cloned.outro = this.outro;

		return cloned;
	};

	MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
			var this$1$1 = this;

		options = options || {};

		var sourceIndex = 0;
		var names = Object.keys(this.storedNames);
		var mappings = new Mappings(options.hires);

		var locate = getLocator(this.original);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.firstChunk.eachNext(function (chunk) {
			var loc = locate(chunk.start);

			if (chunk.intro.length) { mappings.advance(chunk.intro); }

			if (chunk.edited) {
				mappings.addEdit(
					sourceIndex,
					chunk.content,
					loc,
					chunk.storeName ? names.indexOf(chunk.original) : -1
				);
			} else {
				mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
			}

			if (chunk.outro.length) { mappings.advance(chunk.outro); }
		});

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : null,
			sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
			sourcesContent: options.includeContent ? [this.original] : [null],
			names: names,
			mappings: mappings.raw,
		};
	};

	MagicString.prototype.generateMap = function generateMap (options) {
		return new SourceMap(this.generateDecodedMap(options));
	};

	MagicString.prototype.getIndentString = function getIndentString () {
		return this.indentStr === null ? '\t' : this.indentStr;
	};

	MagicString.prototype.indent = function indent (indentStr, options) {
		var pattern = /^[^\r\n]/gm;

		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}

		indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

		if (indentStr === '') { return this; } // noop

		options = options || {};

		// Process exclusion ranges
		var isExcluded = {};

		if (options.exclude) {
			var exclusions =
				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
			exclusions.forEach(function (exclusion) {
				for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
					isExcluded[i] = true;
				}
			});
		}

		var shouldIndentNextCharacter = options.indentStart !== false;
		var replacer = function (match) {
			if (shouldIndentNextCharacter) { return ("" + indentStr + match); }
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace(pattern, replacer);

		var charIndex = 0;
		var chunk = this.firstChunk;

		while (chunk) {
			var end = chunk.end;

			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);

					if (chunk.content.length) {
						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						var char = this.original[charIndex];

						if (char === '\n') {
							shouldIndentNextCharacter = true;
						} else if (char !== '\r' && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;

							if (charIndex === chunk.start) {
								chunk.prependRight(indentStr);
							} else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace(pattern, replacer);

		return this;
	};

	MagicString.prototype.insert = function insert () {
		throw new Error(
			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'
		);
	};

	MagicString.prototype.insertLeft = function insertLeft (index, content) {
		if (!warned.insertLeft) {
			console.warn(
				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'
			); // eslint-disable-line no-console
			warned.insertLeft = true;
		}

		return this.appendLeft(index, content);
	};

	MagicString.prototype.insertRight = function insertRight (index, content) {
		if (!warned.insertRight) {
			console.warn(
				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'
			); // eslint-disable-line no-console
			warned.insertRight = true;
		}

		return this.prependRight(index, content);
	};

	MagicString.prototype.move = function move (start, end, index) {
		if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); }

		this._split(start);
		this._split(end);
		this._split(index);

		var first = this.byStart[start];
		var last = this.byEnd[end];

		var oldLeft = first.previous;
		var oldRight = last.next;

		var newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) { return this; }
		var newLeft = newRight ? newRight.previous : this.lastChunk;

		if (oldLeft) { oldLeft.next = oldRight; }
		if (oldRight) { oldRight.previous = oldLeft; }

		if (newLeft) { newLeft.next = first; }
		if (newRight) { newRight.previous = last; }

		if (!first.previous) { this.firstChunk = last.next; }
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight || null;

		if (!newLeft) { this.firstChunk = first; }
		if (!newRight) { this.lastChunk = last; }
		return this;
	};

	MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
		if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); }

		while (start < 0) { start += this.original.length; }
		while (end < 0) { end += this.original.length; }

		if (end > this.original.length) { throw new Error('end is out of bounds'); }
		if (start === end)
			{ throw new Error(
				'Cannot overwrite a zero-length range â€“ use appendLeft or prependRight instead'
			); }

		this._split(start);
		this._split(end);

		if (options === true) {
			if (!warned.storeName) {
				console.warn(
					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'
				); // eslint-disable-line no-console
				warned.storeName = true;
			}

			options = { storeName: true };
		}
		var storeName = options !== undefined ? options.storeName : false;
		var contentOnly = options !== undefined ? options.contentOnly : false;

		if (storeName) {
			var original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });
		}

		var first = this.byStart[start];
		var last = this.byEnd[end];

		if (first) {
			var chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) {
					throw new Error('Cannot overwrite across a split point');
				}
				chunk = chunk.next;
				chunk.edit('', false);
			}

			first.edit(content, storeName, contentOnly);
		} else {
			// must be inserting at the end
			var newChunk = new Chunk(start, end, '').edit(content, storeName);

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	};

	MagicString.prototype.prepend = function prepend (content) {
		if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); }

		this.intro = content + this.intro;
		return this;
	};

	MagicString.prototype.prependLeft = function prependLeft (index, content) {
		if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

		this._split(index);

		var chunk = this.byEnd[index];

		if (chunk) {
			chunk.prependLeft(content);
		} else {
			this.intro = content + this.intro;
		}
		return this;
	};

	MagicString.prototype.prependRight = function prependRight (index, content) {
		if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); }

		this._split(index);

		var chunk = this.byStart[index];

		if (chunk) {
			chunk.prependRight(content);
		} else {
			this.outro = content + this.outro;
		}
		return this;
	};

	MagicString.prototype.remove = function remove (start, end) {
		while (start < 0) { start += this.original.length; }
		while (end < 0) { end += this.original.length; }

		if (start === end) { return this; }

		if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); }
		if (start > end) { throw new Error('end must be greater than start'); }

		this._split(start);
		this._split(end);

		var chunk = this.byStart[start];

		while (chunk) {
			chunk.intro = '';
			chunk.outro = '';
			chunk.edit('');

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	};

	MagicString.prototype.lastChar = function lastChar () {
		if (this.outro.length) { return this.outro[this.outro.length - 1]; }
		var chunk = this.lastChunk;
		do {
			if (chunk.outro.length) { return chunk.outro[chunk.outro.length - 1]; }
			if (chunk.content.length) { return chunk.content[chunk.content.length - 1]; }
			if (chunk.intro.length) { return chunk.intro[chunk.intro.length - 1]; }
		} while ((chunk = chunk.previous));
		if (this.intro.length) { return this.intro[this.intro.length - 1]; }
		return '';
	};

	MagicString.prototype.lastLine = function lastLine () {
		var lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) { return this.outro.substr(lineIndex + 1); }
		var lineStr = this.outro;
		var chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) { return chunk.outro.substr(lineIndex + 1) + lineStr; }
				lineStr = chunk.outro + lineStr;
			}

			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) { return chunk.content.substr(lineIndex + 1) + lineStr; }
				lineStr = chunk.content + lineStr;
			}

			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) { return chunk.intro.substr(lineIndex + 1) + lineStr; }
				lineStr = chunk.intro + lineStr;
			}
		} while ((chunk = chunk.previous));
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) { return this.intro.substr(lineIndex + 1) + lineStr; }
		return this.intro + lineStr;
	};

	MagicString.prototype.slice = function slice (start, end) {
			if ( start === void 0 ) start = 0;
			if ( end === void 0 ) end = this.original.length;

		while (start < 0) { start += this.original.length; }
		while (end < 0) { end += this.original.length; }

		var result = '';

		// find start chunk
		var chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			// found end chunk before start
			if (chunk.start < end && chunk.end >= end) {
				return result;
			}

			chunk = chunk.next;
		}

		if (chunk && chunk.edited && chunk.start !== start)
			{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

		var startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
				result += chunk.intro;
			}

			var containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end)
				{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

			var sliceStart = startChunk === chunk ? start - chunk.start : 0;
			var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice(sliceStart, sliceEnd);

			if (chunk.outro && (!containsEnd || chunk.end === end)) {
				result += chunk.outro;
			}

			if (containsEnd) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	};

	// TODO deprecate this? not really very useful
	MagicString.prototype.snip = function snip (start, end) {
		var clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	};

	MagicString.prototype._split = function _split (index) {
		if (this.byStart[index] || this.byEnd[index]) { return; }

		var chunk = this.lastSearchedChunk;
		var searchForward = index > chunk.end;

		while (chunk) {
			if (chunk.contains(index)) { return this._splitChunk(chunk, index); }

			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	};

	MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
		if (chunk.edited && chunk.content.length) {
			// zero-length edited chunks are a special case (overlapping replacements)
			var loc = getLocator(this.original)(index);
			throw new Error(
				("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " â€“ \"" + (chunk.original) + "\")")
			);
		}

		var newChunk = chunk.split(index);

		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;

		if (chunk === this.lastChunk) { this.lastChunk = newChunk; }

		this.lastSearchedChunk = chunk;
		return true;
	};

	MagicString.prototype.toString = function toString () {
		var str = this.intro;

		var chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	};

	MagicString.prototype.isEmpty = function isEmpty () {
		var chunk = this.firstChunk;
		do {
			if (
				(chunk.intro.length && chunk.intro.trim()) ||
				(chunk.content.length && chunk.content.trim()) ||
				(chunk.outro.length && chunk.outro.trim())
			)
				{ return false; }
		} while ((chunk = chunk.next));
		return true;
	};

	MagicString.prototype.length = function length () {
		var chunk = this.firstChunk;
		var length = 0;
		do {
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		} while ((chunk = chunk.next));
		return length;
	};

	MagicString.prototype.trimLines = function trimLines () {
		return this.trim('[\\r\\n]');
	};

	MagicString.prototype.trim = function trim (charType) {
		return this.trimStart(charType).trimEnd(charType);
	};

	MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
		var rx = new RegExp((charType || '\\s') + '+$');

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; }

		var chunk = this.lastChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimEnd(rx);

			// if chunk was trimmed, we have a new lastChunk
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) {
					this.lastChunk = chunk.next;
				}

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) { return true; }
			chunk = chunk.previous;
		} while (chunk);

		return false;
	};

	MagicString.prototype.trimEnd = function trimEnd (charType) {
		this.trimEndAborted(charType);
		return this;
	};
	MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
		var rx = new RegExp('^' + (charType || '\\s') + '+');

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; }

		var chunk = this.firstChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimStart(rx);

			if (chunk.end !== end) {
				// special case...
				if (chunk === this.lastChunk) { this.lastChunk = chunk.next; }

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) { return true; }
			chunk = chunk.next;
		} while (chunk);

		return false;
	};

	MagicString.prototype.trimStart = function trimStart (charType) {
		this.trimStartAborted(charType);
		return this;
	};

	var hasOwnProp = Object.prototype.hasOwnProperty;

	var Bundle = function Bundle(options) {
		if ( options === void 0 ) options = {};

		this.intro = options.intro || '';
		this.separator = options.separator !== undefined ? options.separator : '\n';
		this.sources = [];
		this.uniqueSources = [];
		this.uniqueSourceIndexByFilename = {};
	};

	Bundle.prototype.addSource = function addSource (source) {
		if (source instanceof MagicString) {
			return this.addSource({
				content: source,
				filename: source.filename,
				separator: this.separator,
			});
		}

		if (!isObject(source) || !source.content) {
			throw new Error(
				'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'
			);
		}

		['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
			if (!hasOwnProp.call(source, option)) { source[option] = source.content[option]; }
		});

		if (source.separator === undefined) {
			// TODO there's a bunch of this sort of thing, needs cleaning up
			source.separator = this.separator;
		}

		if (source.filename) {
			if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
				this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
			} else {
				var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
				if (source.content.original !== uniqueSource.content) {
					throw new Error(("Illegal source: same filename (" + (source.filename) + "), different contents"));
				}
			}
		}

		this.sources.push(source);
		return this;
	};

	Bundle.prototype.append = function append (str, options) {
		this.addSource({
			content: new MagicString(str),
			separator: (options && options.separator) || '',
		});

		return this;
	};

	Bundle.prototype.clone = function clone () {
		var bundle = new Bundle({
			intro: this.intro,
			separator: this.separator,
		});

		this.sources.forEach(function (source) {
			bundle.addSource({
				filename: source.filename,
				content: source.content.clone(),
				separator: source.separator,
			});
		});

		return bundle;
	};

	Bundle.prototype.generateDecodedMap = function generateDecodedMap (options) {
			var this$1$1 = this;
			if ( options === void 0 ) options = {};

		var names = [];
		this.sources.forEach(function (source) {
			Object.keys(source.content.storedNames).forEach(function (name) {
				if (!~names.indexOf(name)) { names.push(name); }
			});
		});

		var mappings = new Mappings(options.hires);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.sources.forEach(function (source, i) {
			if (i > 0) {
				mappings.advance(this$1$1.separator);
			}

			var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
			var magicString = source.content;
			var locate = getLocator(magicString.original);

			if (magicString.intro) {
				mappings.advance(magicString.intro);
			}

			magicString.firstChunk.eachNext(function (chunk) {
				var loc = locate(chunk.start);

				if (chunk.intro.length) { mappings.advance(chunk.intro); }

				if (source.filename) {
					if (chunk.edited) {
						mappings.addEdit(
							sourceIndex,
							chunk.content,
							loc,
							chunk.storeName ? names.indexOf(chunk.original) : -1
						);
					} else {
						mappings.addUneditedChunk(
							sourceIndex,
							chunk,
							magicString.original,
							loc,
							magicString.sourcemapLocations
						);
					}
				} else {
					mappings.advance(chunk.content);
				}

				if (chunk.outro.length) { mappings.advance(chunk.outro); }
			});

			if (magicString.outro) {
				mappings.advance(magicString.outro);
			}
		});

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : null,
			sources: this.uniqueSources.map(function (source) {
				return options.file ? getRelativePath(options.file, source.filename) : source.filename;
			}),
			sourcesContent: this.uniqueSources.map(function (source) {
				return options.includeContent ? source.content : null;
			}),
			names: names,
			mappings: mappings.raw,
		};
	};

	Bundle.prototype.generateMap = function generateMap (options) {
		return new SourceMap(this.generateDecodedMap(options));
	};

	Bundle.prototype.getIndentString = function getIndentString () {
		var indentStringCounts = {};

		this.sources.forEach(function (source) {
			var indentStr = source.content.indentStr;

			if (indentStr === null) { return; }

			if (!indentStringCounts[indentStr]) { indentStringCounts[indentStr] = 0; }
			indentStringCounts[indentStr] += 1;
		});

		return (
			Object.keys(indentStringCounts).sort(function (a, b) {
				return indentStringCounts[a] - indentStringCounts[b];
			})[0] || '\t'
		);
	};

	Bundle.prototype.indent = function indent (indentStr) {
			var this$1$1 = this;

		if (!arguments.length) {
			indentStr = this.getIndentString();
		}

		if (indentStr === '') { return this; } // noop

		var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';

		this.sources.forEach(function (source, i) {
			var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
			var indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));

			source.content.indent(indentStr, {
				exclude: source.indentExclusionRanges,
				indentStart: indentStart, //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
			});

			trailingNewline = source.content.lastChar() === '\n';
		});

		if (this.intro) {
			this.intro =
				indentStr +
				this.intro.replace(/^[^\n]/gm, function (match, index) {
					return index > 0 ? indentStr + match : match;
				});
		}

		return this;
	};

	Bundle.prototype.prepend = function prepend (str) {
		this.intro = str + this.intro;
		return this;
	};

	Bundle.prototype.toString = function toString () {
			var this$1$1 = this;

		var body = this.sources
			.map(function (source, i) {
				var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
				var str = (i > 0 ? separator : '') + source.content.toString();

				return str;
			})
			.join('');

		return this.intro + body;
	};

	Bundle.prototype.isEmpty = function isEmpty () {
		if (this.intro.length && this.intro.trim()) { return false; }
		if (this.sources.some(function (source) { return !source.content.isEmpty(); })) { return false; }
		return true;
	};

	Bundle.prototype.length = function length () {
		return this.sources.reduce(
			function (length, source) { return length + source.content.length(); },
			this.intro.length
		);
	};

	Bundle.prototype.trimLines = function trimLines () {
		return this.trim('[\\r\\n]');
	};

	Bundle.prototype.trim = function trim (charType) {
		return this.trimStart(charType).trimEnd(charType);
	};

	Bundle.prototype.trimStart = function trimStart (charType) {
		var rx = new RegExp('^' + (charType || '\\s') + '+');
		this.intro = this.intro.replace(rx, '');

		if (!this.intro) {
			var source;
			var i = 0;

			do {
				source = this.sources[i++];
				if (!source) {
					break;
				}
			} while (!source.content.trimStartAborted(charType));
		}

		return this;
	};

	Bundle.prototype.trimEnd = function trimEnd (charType) {
		var rx = new RegExp((charType || '\\s') + '+$');

		var source;
		var i = this.sources.length - 1;

		do {
			source = this.sources[i--];
			if (!source) {
				this.intro = this.intro.replace(rx, '');
				break;
			}
		} while (!source.content.trimEndAborted(charType));

		return this;
	};

	MagicString.Bundle = Bundle;
	MagicString.SourceMap = SourceMap;
	MagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121

	return MagicString;

}));
//# sourceMappingURL=magic-string.umd.js.map
¼/dist/magic-string.es.js.mapÆ 9é{"version":3,"file":"magic-string.es.js","sources":["../src/BitSet.js","../src/Chunk.js","../src/SourceMap.js","../src/utils/guessIndent.js","../src/utils/getRelativePath.js","../src/utils/isObject.js","../src/utils/getLocator.js","../src/utils/Mappings.js","../src/MagicString.js","../src/Bundle.js"],"sourcesContent":["export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n","export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\t// we make these non-enumerable, for sanity while debugging\n\t\tObject.defineProperties(this, {\n\t\t\tprevious: { writable: true, value: null },\n\t\t\tnext: { writable: true, value: null },\n\t\t});\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.end - trimmed.length);\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n","import { encode } from 'sourcemap-codec';\n\nlet btoa = () => {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\tbtoa = (str) => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n\tbtoa = (str) => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n","export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n","export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n","const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n","export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n","export default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t}\n\n\t\tthis.advance(content);\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tthis.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n","import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: guessIndent(string) },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range â€“ use appendLeft or prependRight instead'\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst contentOnly = options !== undefined ? options.contentOnly : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true });\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, contentOnly);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} â€“ \"${chunk.original}\")`\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n}\n","import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content.indentStr;\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n"],"names":["const","let","this"],"mappings":"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"}ª/README.mdÅ$a# magic-string

<a href="https://travis-ci.org/Rich-Harris/magic-string">
  <img src="http://img.shields.io/travis/Rich-Harris/magic-string.svg"
       alt="build status">
</a>
<a href="https://npmjs.org/package/magic-string">
  <img src="https://img.shields.io/npm/v/magic-string.svg"
       alt="npm version">
</a>
<a href="https://github.com/Rich-Harris/magic-string/blob/master/LICENSE.md">
  <img src="https://img.shields.io/npm/l/magic-string.svg"
       alt="license">
</a>

Suppose you have some source code. You want to make some light modifications to it - replacing a few characters here and there, wrapping it with a header and footer, etc - and ideally you'd like to generate a source map at the end of it. You've thought about using something like [recast](https://github.com/benjamn/recast) (which allows you to generate an AST from some JavaScript, manipulate it, and reprint it with a sourcemap without losing your comments and formatting), but it seems like overkill for your needs (or maybe the source code isn't JavaScript).

Your requirements are, frankly, rather niche. But they're requirements that I also have, and for which I made magic-string. It's a small, fast utility for manipulating strings and generating sourcemaps.

## Installation

magic-string works in both node.js and browser environments. For node, install with npm:

```bash
npm i magic-string
```

To use in browser, grab the [magic-string.umd.js](https://unpkg.com/magic-string/dist/magic-string.umd.js) file and add it to your page:

```html
<script src='magic-string.umd.js'></script>
```

(It also works with various module systems, if you prefer that sort of thing - it has a dependency on [vlq](https://github.com/Rich-Harris/vlq).)

## Usage

These examples assume you're in node.js, or something similar:

```js
import MagicString from 'magic-string';
import fs from 'fs'

const s = new MagicString('problems = 99');

s.overwrite(0, 8, 'answer');
s.toString(); // 'answer = 99'

s.overwrite(11, 13, '42'); // character indices always refer to the original string
s.toString(); // 'answer = 42'

s.prepend('var ').append(';'); // most methods are chainable
s.toString(); // 'var answer = 42;'

const map = s.generateMap({
  source: 'source.js',
  file: 'converted.js.map',
  includeContent: true
}); // generates a v3 sourcemap

fs.writeFileSync('converted.js', s.toString());
fs.writeFileSync('converted.js.map', map.toString());
```

You can pass an options argument:

```js
const s = new MagicString(someCode, {
  // both these options will be used if you later
  // call `bundle.addSource( s )` - see below
  filename: 'foo.js',
  indentExclusionRanges: [/*...*/]
});
```

## Methods

### s.addSourcemapLocation( index )

Adds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is `false` (see below).

### s.append( content )

Appends the specified content to the end of the string. Returns `this`.

### s.appendLeft( index, content )

Appends the specified `content` at the `index` in the original string. If a range *ending* with `index` is subsequently moved, the insert will be moved with it. Returns `this`. See also `s.prependLeft(...)`.

### s.appendRight( index, content )

Appends the specified `content` at the `index` in the original string. If a range *starting* with `index` is subsequently moved, the insert will be moved with it. Returns `this`. See also `s.prependRight(...)`.

### s.clone()

Does what you'd expect.

### s.generateDecodedMap( options )

Generates a sourcemap object with raw mappings in array form, rather than encoded as a string. See `generateMap` documentation below for options details. Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.

### s.generateMap( options )

Generates a [version 3 sourcemap](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit). All options are, well, optional:

* `file` - the filename where you plan to write the sourcemap
* `source` - the filename of the file containing the original source
* `includeContent` - whether to include the original content in the map's `sourcesContent` array
* `hires` - whether the mapping should be high-resolution. Hi-res mappings map every single character, meaning (for example) your devtools will always be able to pinpoint the exact location of function calls and so on. With lo-res mappings, devtools may only be able to identify the correct line - but they're quicker to generate and less bulky. If sourcemap locations have been specified with `s.addSourceMapLocation()`, they will be used here.

The returned sourcemap has two (non-enumerable) methods attached for convenience:

* `toString` - returns the equivalent of `JSON.stringify(map)`
* `toUrl` - returns a DataURI containing the sourcemap. Useful for doing this sort of thing:

```js
code += '\n//# sourceMappingURL=' + map.toUrl();
```

### s.indent( prefix[, options] )

Prefixes each line of the string with `prefix`. If `prefix` is not supplied, the indentation will be guessed from the original content, falling back to a single tab character. Returns `this`.

The `options` argument can have an `exclude` property, which is an array of `[start, end]` character ranges. These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.

### s.insertLeft( index, content )

**DEPRECATED** since 0.17 â€“ use `s.appendLeft(...)` instead

### s.insertRight( index, content )

**DEPRECATED** since 0.17 â€“ use `s.prependRight(...)` instead

### s.locate( index )

**DEPRECATED** since 0.10 â€“ see [#30](https://github.com/Rich-Harris/magic-string/pull/30)

### s.locateOrigin( index )

**DEPRECATED** since 0.10 â€“ see [#30](https://github.com/Rich-Harris/magic-string/pull/30)

### s.move( start, end, newIndex )

Moves the characters from `start` and `end` to `index`. Returns `this`.

### s.overwrite( start, end, content[, options] )

Replaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply. Returns `this`.

The fourth argument is optional. It can have a `storeName` property â€” if `true`, the original name will be stored for later inclusion in a sourcemap's `names` array â€” and a `contentOnly` property which determines whether only the content is overwritten, or anything that was appended/prepended to the range as well.

### s.prepend( content )

Prepends the string with the specified content. Returns `this`.

### s.prependLeft ( index, content )

Same as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`

### s.prependRight ( index, content )

Same as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`

### s.remove( start, end )

Removes the characters from `start` to `end` (of the original string, **not** the generated string). Removing the same content twice, or making removals that partially overlap, will cause an error. Returns `this`.

### s.slice( start, end )

Returns the content of the generated string that corresponds to the slice between `start` and `end` of the original string. Throws error if the indices are for characters that were already removed.

### s.snip( start, end )

Returns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.

### s.toString()

Returns the generated string.

### s.trim([ charType ])

Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the start and end. Returns `this`.

### s.trimStart([ charType ])

Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the start. Returns `this`.

### s.trimEnd([ charType ])

Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the end. Returns `this`.

### s.trimLines()

Removes empty lines from the start and end. Returns `this`.

### s.isEmpty()

Returns true if the resulting source is empty (disregarding white space).

## Bundling

To concatenate several sources, use `MagicString.Bundle`:

```js
const bundle = new MagicString.Bundle();

bundle.addSource({
  filename: 'foo.js',
  content: new MagicString('var answer = 42;')
});

bundle.addSource({
  filename: 'bar.js',
  content: new MagicString('console.log( answer )')
});

// Advanced: a source can include an `indentExclusionRanges` property
// alongside `filename` and `content`. This will be passed to `s.indent()`
// - see documentation above

bundle.indent() // optionally, pass an indent string, otherwise it will be guessed
  .prepend('(function () {\n')
  .append('}());');

bundle.toString();
// (function () {
//   var answer = 42;
//   console.log( answer );
// }());

// options are as per `s.generateMap()` above
const map = bundle.generateMap({
  file: 'bundle.js',
  includeContent: true,
  hires: true
});
```

As an alternative syntax, if you a) don't have `filename` or `indentExclusionRanges` options, or b) passed those in when you used `new MagicString(...)`, you can simply pass the `MagicString` instance itself:

```js
const bundle = new MagicString.Bundle();
const source = new MagicString(someCode, {
  filename: 'foo.js'
});

bundle.addSource(source);
```

## License

MIT

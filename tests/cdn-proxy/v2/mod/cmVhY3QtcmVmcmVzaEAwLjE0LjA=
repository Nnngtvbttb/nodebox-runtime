‰Ù*/cjs/react-refresh-babel.production.min.jsÅº/**
 * @license React
 * react-refresh-babel.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';module.exports=function(r){function t(a,b){var c=a.scope.generateUidIdentifier("c");l.has(a)||l.set(a,[]);l.get(a).push({handle:c,persistentID:b});return c}function u(a){return"string"===typeof a&&"A"<=a[0]&&"Z">=a[0]}function m(a,b,c){var d=b.node;switch(d.type){case "Identifier":if(!u(d.name))break;c(a,d,null);return!0;case "FunctionDeclaration":return c(a,d.id,null),!0;case "ArrowFunctionExpression":if("ArrowFunctionExpression"===d.body.type)break;c(a,d,b);return!0;case "FunctionExpression":return c(a,
d,b),!0;case "CallExpression":var e=b.get("arguments");if(void 0===e||0===e.length)break;var g=b.get("callee");switch(g.node.type){case "MemberExpression":case "Identifier":g=g.getSource();if(!m(a+"$"+g,e[0],c))return!1;c(a,d,b);return!0;default:return!1}case "VariableDeclarator":if(e=d.init,null!==e&&(g=d.id.name,u(g))){switch(e.type){case "ArrowFunctionExpression":case "FunctionExpression":break;case "CallExpression":d=e.callee;var f=d.type;if("Import"===f||"Identifier"===f&&(0===d.name.indexOf("require")||
0===d.name.indexOf("import")))return!1;break;case "TaggedTemplateExpression":break;default:return!1}d=b.get("init");if(m(a,d,c))return!0;g=b.scope.getBinding(g);if(void 0===g)return;b=!1;g=g.referencePaths;for(f=0;f<g.length;f++){var h=g[f];if(!h.node||"JSXIdentifier"===h.node.type||"Identifier"===h.node.type){h=h.parent;if("JSXOpeningElement"===h.type)b=!0;else if("CallExpression"===h.type){h=h.callee;var v=void 0;switch(h.type){case "Identifier":v=h.name;break;case "MemberExpression":v=h.property.name}switch(v){case "createElement":case "jsx":case "jsxDEV":case "jsxs":b=
!0}}if(b)return c(a,e,d),!0}}}}return!1}function x(a){a=n.get(a);return void 0===a?null:{key:a.map(function(a){return a.name+"{"+a.key+"}"}).join("\n"),customHooks:a.filter(function(a){a:switch(a.name){case "useState":case "React.useState":case "useReducer":case "React.useReducer":case "useEffect":case "React.useEffect":case "useLayoutEffect":case "React.useLayoutEffect":case "useMemo":case "React.useMemo":case "useCallback":case "React.useCallback":case "useRef":case "React.useRef":case "useContext":case "React.useContext":case "useImperativeHandle":case "React.useImperativeHandle":case "useDebugValue":case "React.useDebugValue":a=
!0;break a;default:a=!1}return!a}).map(function(a){return f.cloneDeep(a.callee)})}}function C(a){a=a.hub.file;var b=y.get(a);if(void 0!==b)return b;b=!1;for(var c=a.ast.comments,d=0;d<c.length;d++)if(-1!==c[d].value.indexOf("@refresh reset")){b=!0;break}y.set(a,b);return b}function w(a,b,c){var d=b.key;b=b.customHooks;var e=C(c.path),g=[];b.forEach(function(a){switch(a.type){case "MemberExpression":if("Identifier"===a.object.type)var b=a.object.name;break;case "Identifier":b=a.name}c.hasBinding(b)?
g.push(a):e=!0});b=d;"function"!==typeof require||p.emitFullSignatures||(b=require("crypto").createHash("sha1").update(d).digest("base64"));a=[a,f.stringLiteral(b)];(e||0<g.length)&&a.push(f.booleanLiteral(e));0<g.length&&a.push(f.functionExpression(null,[],f.blockStatement([f.returnStatement(f.arrayExpression(g))])));return a}function D(a){for(var b=[];;){if(!a)return b;var c=a.parentPath;if(!c)return b;if("AssignmentExpression"===c.node.type&&a.node===c.node.right)a=c;else if("CallExpression"===
c.node.type&&a.node!==c.node.callee)b.push(c),a=c;else return b}}var p=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if("function"===typeof r.env){var z=r.env();if("development"!==z&&!p.skipEnvCheck)throw Error('React Refresh Babel transform should only be enabled in development environment. Instead, the environment is: "'+z+'". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');}var f=r.types,E=f.identifier(p.refreshReg||"$RefreshReg$"),A=f.identifier(p.refreshSig||
"$RefreshSig$"),l=new Map,y=new WeakMap,k=new WeakSet,q=new WeakSet,B=new WeakSet,n=new WeakMap,F={CallExpression:function(a){var b=a.node.callee,c=null;switch(b.type){case "Identifier":c=b.name;break;case "MemberExpression":c=b.property.name}if(null!==c&&/^use[A-Z]/.test(c)&&(b=a.scope.getFunctionParent(),null!==b)){b=b.block;n.has(b)||n.set(b,[]);b=n.get(b);var d="";"VariableDeclarator"===a.parent.type&&(d=a.parentPath.get("id").getSource());var e=a.get("arguments");"useState"===c&&0<e.length?d+=
"("+e[0].getSource()+")":"useReducer"===c&&1<e.length&&(d+="("+e[1].getSource()+")");b.push({callee:a.node.callee,name:c,key:d})}}};return{visitor:{ExportDefaultDeclaration:function(a){var b=a.node,c=b.declaration,d=a.get("declaration");if("CallExpression"===c.type&&!k.has(b)){k.add(b);var e=a.parentPath;m("%default%",d,function(a,b,d){null!==d&&(a=t(e,a),d.replaceWith(f.assignmentExpression("=",a,b)))})}},FunctionDeclaration:{enter:function(a){var b=a.node,c="";switch(a.parent.type){case "Program":var d=
a;var e=a.parentPath;break;case "TSModuleBlock":d=a;e=d.parentPath.parentPath;break;case "ExportNamedDeclaration":d=a.parentPath;e=d.parentPath;break;case "ExportDefaultDeclaration":d=a.parentPath;e=d.parentPath;break;default:return}if("TSModuleBlock"===a.parent.type||"ExportNamedDeclaration"===a.parent.type)for(;"Program"!==e.type;){if("TSModuleDeclaration"===e.type){if("Program"!==e.parentPath.type&&"ExportNamedDeclaration"!==e.parentPath.type)return;c=e.node.id.name+"$"+c}e=e.parentPath}var g=
b.id;null!==g&&(g=g.name,u(g)&&!k.has(b)&&(k.add(b),m(c+g,a,function(a,b){a=t(e,a);d.insertAfter(f.expressionStatement(f.assignmentExpression("=",a,b)))})))},exit:function(a){var b=a.node,c=b.id;if(null!==c){var d=x(b);if(null!==d&&!q.has(b)){q.add(b);b=a.scope.generateUidIdentifier("_s");a.scope.parent.push({id:b,init:f.callExpression(A,[])});a.get("body").unshiftContainer("body",f.expressionStatement(f.callExpression(b,[])));var e=null;a.find(function(a){if(a.parentPath.isBlock())return e=a,!0});
null!==e&&e.insertAfter(f.expressionStatement(f.callExpression(b,w(c,d,e.scope))))}}}},"ArrowFunctionExpression|FunctionExpression":{exit:function(a){var b=a.node,c=x(b);if(null!==c&&!q.has(b)){q.add(b);var d=a.scope.generateUidIdentifier("_s");a.scope.parent.push({id:d,init:f.callExpression(A,[])});"BlockStatement"!==a.node.body.type&&(a.node.body=f.blockStatement([f.returnStatement(a.node.body)]));a.get("body").unshiftContainer("body",f.expressionStatement(f.callExpression(d,[])));if("VariableDeclarator"===
a.parent.type){var e=null;a.find(function(a){if(a.parentPath.isBlock())return e=a,!0});null!==e&&e.insertAfter(f.expressionStatement(f.callExpression(d,w(a.parent.id,c,e.scope))))}else[a].concat(D(a)).forEach(function(a){a.replaceWith(f.callExpression(d,w(a.node,c,a.scope)))})}}},VariableDeclaration:function(a){var b=a.node,c="";switch(a.parent.type){case "Program":var d=a;var e=a.parentPath;break;case "TSModuleBlock":d=a;e=d.parentPath.parentPath;break;case "ExportNamedDeclaration":d=a.parentPath;
e=d.parentPath;break;case "ExportDefaultDeclaration":d=a.parentPath;e=d.parentPath;break;default:return}if("TSModuleBlock"===a.parent.type||"ExportNamedDeclaration"===a.parent.type)for(;"Program"!==e.type;){if("TSModuleDeclaration"===e.type){if("Program"!==e.parentPath.type&&"ExportNamedDeclaration"!==e.parentPath.type)return;c=e.node.id.name+"$"+c}e=e.parentPath}if(!k.has(b)&&(k.add(b),a=a.get("declarations"),1===a.length)){var g=a[0];m(c+g.node.id.name,g,function(a,b,c){null!==c&&(a=t(e,a),"VariableDeclarator"===
c.parent.type?d.insertAfter(f.expressionStatement(f.assignmentExpression("=",a,g.node.id))):c.replaceWith(f.assignmentExpression("=",a,b)))})}},Program:{enter:function(a){a.traverse(F)},exit:function(a){var b=l.get(a);if(void 0!==b){var c=a.node;if(!B.has(c)){B.add(c);l.delete(a);var d=[];a.pushContainer("body",f.variableDeclaration("var",d));b.forEach(function(b){var c=b.handle;a.pushContainer("body",f.expressionStatement(f.callExpression(E,[c,f.stringLiteral(b.persistentID)])));d.push(f.variableDeclarator(c))})}}}}}}};
Ù'/cjs/react-refresh-babel.development.jsÅhÅ/**
 * @license React
 * react-refresh-babel.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

function ReactFreshBabelPlugin (babel) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof babel.env === 'function') {
    // Only available in Babel 7.
    var env = babel.env();

    if (env !== 'development' && !opts.skipEnvCheck) {
      throw new Error('React Refresh Babel transform should only be enabled in development environment. ' + 'Instead, the environment is: "' + env + '". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');
    }
  }

  var t = babel.types;
  var refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');
  var refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');
  var registrationsByProgramPath = new Map();

  function createRegistration(programPath, persistentID) {
    var handle = programPath.scope.generateUidIdentifier('c');

    if (!registrationsByProgramPath.has(programPath)) {
      registrationsByProgramPath.set(programPath, []);
    }

    var registrations = registrationsByProgramPath.get(programPath);
    registrations.push({
      handle: handle,
      persistentID: persistentID
    });
    return handle;
  }

  function isComponentishName(name) {
    return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';
  }

  function findInnerComponents(inferredName, path, callback) {
    var node = path.node;

    switch (node.type) {
      case 'Identifier':
        {
          if (!isComponentishName(node.name)) {
            return false;
          } // export default hoc(Foo)
          // const X = hoc(Foo)


          callback(inferredName, node, null);
          return true;
        }

      case 'FunctionDeclaration':
        {
          // function Foo() {}
          // export function Foo() {}
          // export default function Foo() {}
          callback(inferredName, node.id, null);
          return true;
        }

      case 'ArrowFunctionExpression':
        {
          if (node.body.type === 'ArrowFunctionExpression') {
            return false;
          } // let Foo = () => {}
          // export default hoc1(hoc2(() => {}))


          callback(inferredName, node, path);
          return true;
        }

      case 'FunctionExpression':
        {
          // let Foo = function() {}
          // const Foo = hoc1(forwardRef(function renderFoo() {}))
          // export default memo(function() {})
          callback(inferredName, node, path);
          return true;
        }

      case 'CallExpression':
        {
          var argsPath = path.get('arguments');

          if (argsPath === undefined || argsPath.length === 0) {
            return false;
          }

          var calleePath = path.get('callee');

          switch (calleePath.node.type) {
            case 'MemberExpression':
            case 'Identifier':
              {
                var calleeSource = calleePath.getSource();
                var firstArgPath = argsPath[0];
                var innerName = inferredName + '$' + calleeSource;
                var foundInside = findInnerComponents(innerName, firstArgPath, callback);

                if (!foundInside) {
                  return false;
                } // const Foo = hoc1(hoc2(() => {}))
                // export default memo(React.forwardRef(function() {}))


                callback(inferredName, node, path);
                return true;
              }

            default:
              {
                return false;
              }
          }
        }

      case 'VariableDeclarator':
        {
          var init = node.init;

          if (init === null) {
            return false;
          }

          var name = node.id.name;

          if (!isComponentishName(name)) {
            return false;
          }

          switch (init.type) {
            case 'ArrowFunctionExpression':
            case 'FunctionExpression':
              // Likely component definitions.
              break;

            case 'CallExpression':
              {
                // Maybe a HOC.
                // Try to determine if this is some form of import.
                var callee = init.callee;
                var calleeType = callee.type;

                if (calleeType === 'Import') {
                  return false;
                } else if (calleeType === 'Identifier') {
                  if (callee.name.indexOf('require') === 0) {
                    return false;
                  } else if (callee.name.indexOf('import') === 0) {
                    return false;
                  } // Neither require nor import. Might be a HOC.
                  // Pass through.

                }

                break;
              }

            case 'TaggedTemplateExpression':
              // Maybe something like styled.div`...`
              break;

            default:
              return false;
          }

          var initPath = path.get('init');

          var _foundInside = findInnerComponents(inferredName, initPath, callback);

          if (_foundInside) {
            return true;
          } // See if this identifier is used in JSX. Then it's a component.


          var binding = path.scope.getBinding(name);

          if (binding === undefined) {
            return;
          }

          var isLikelyUsedAsType = false;
          var referencePaths = binding.referencePaths;

          for (var i = 0; i < referencePaths.length; i++) {
            var ref = referencePaths[i];

            if (ref.node && ref.node.type !== 'JSXIdentifier' && ref.node.type !== 'Identifier') {
              continue;
            }

            var refParent = ref.parent;

            if (refParent.type === 'JSXOpeningElement') {
              isLikelyUsedAsType = true;
            } else if (refParent.type === 'CallExpression') {
              var _callee = refParent.callee;
              var fnName = void 0;

              switch (_callee.type) {
                case 'Identifier':
                  fnName = _callee.name;
                  break;

                case 'MemberExpression':
                  fnName = _callee.property.name;
                  break;
              }

              switch (fnName) {
                case 'createElement':
                case 'jsx':
                case 'jsxDEV':
                case 'jsxs':
                  isLikelyUsedAsType = true;
                  break;
              }
            }

            if (isLikelyUsedAsType) {
              // const X = ... + later <X />
              callback(inferredName, init, initPath);
              return true;
            }
          }
        }
    }

    return false;
  }

  function isBuiltinHook(hookName) {
    switch (hookName) {
      case 'useState':
      case 'React.useState':
      case 'useReducer':
      case 'React.useReducer':
      case 'useEffect':
      case 'React.useEffect':
      case 'useLayoutEffect':
      case 'React.useLayoutEffect':
      case 'useMemo':
      case 'React.useMemo':
      case 'useCallback':
      case 'React.useCallback':
      case 'useRef':
      case 'React.useRef':
      case 'useContext':
      case 'React.useContext':
      case 'useImperativeHandle':
      case 'React.useImperativeHandle':
      case 'useDebugValue':
      case 'React.useDebugValue':
        return true;

      default:
        return false;
    }
  }

  function getHookCallsSignature(functionNode) {
    var fnHookCalls = hookCalls.get(functionNode);

    if (fnHookCalls === undefined) {
      return null;
    }

    return {
      key: fnHookCalls.map(function (call) {
        return call.name + '{' + call.key + '}';
      }).join('\n'),
      customHooks: fnHookCalls.filter(function (call) {
        return !isBuiltinHook(call.name);
      }).map(function (call) {
        return t.cloneDeep(call.callee);
      })
    };
  }

  var hasForceResetCommentByFile = new WeakMap(); // We let user do /* @refresh reset */ to reset state in the whole file.

  function hasForceResetComment(path) {
    var file = path.hub.file;
    var hasForceReset = hasForceResetCommentByFile.get(file);

    if (hasForceReset !== undefined) {
      return hasForceReset;
    }

    hasForceReset = false;
    var comments = file.ast.comments;

    for (var i = 0; i < comments.length; i++) {
      var cmt = comments[i];

      if (cmt.value.indexOf('@refresh reset') !== -1) {
        hasForceReset = true;
        break;
      }
    }

    hasForceResetCommentByFile.set(file, hasForceReset);
    return hasForceReset;
  }

  function createArgumentsForSignature(node, signature, scope) {
    var key = signature.key,
        customHooks = signature.customHooks;
    var forceReset = hasForceResetComment(scope.path);
    var customHooksInScope = [];
    customHooks.forEach(function (callee) {
      // Check if a corresponding binding exists where we emit the signature.
      var bindingName;

      switch (callee.type) {
        case 'MemberExpression':
          if (callee.object.type === 'Identifier') {
            bindingName = callee.object.name;
          }

          break;

        case 'Identifier':
          bindingName = callee.name;
          break;
      }

      if (scope.hasBinding(bindingName)) {
        customHooksInScope.push(callee);
      } else {
        // We don't have anything to put in the array because Hook is out of scope.
        // Since it could potentially have been edited, remount the component.
        forceReset = true;
      }
    });
    var finalKey = key;

    if (typeof require === 'function' && !opts.emitFullSignatures) {
      // Prefer to hash when we can (e.g. outside of ASTExplorer).
      // This makes it deterministically compact, even if there's
      // e.g. a useState initializer with some code inside.
      // We also need it for www that has transforms like cx()
      // that don't understand if something is part of a string.
      finalKey = require('crypto').createHash('sha1').update(key).digest('base64');
    }

    var args = [node, t.stringLiteral(finalKey)];

    if (forceReset || customHooksInScope.length > 0) {
      args.push(t.booleanLiteral(forceReset));
    }

    if (customHooksInScope.length > 0) {
      args.push( // TODO: We could use an arrow here to be more compact.
      // However, don't do it until AMA can run them natively.
      t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.arrayExpression(customHooksInScope))])));
    }

    return args;
  }

  function findHOCCallPathsAbove(path) {
    var calls = [];

    while (true) {
      if (!path) {
        return calls;
      }

      var parentPath = path.parentPath;

      if (!parentPath) {
        return calls;
      }

      if ( // hoc(_c = function() { })
      parentPath.node.type === 'AssignmentExpression' && path.node === parentPath.node.right) {
        // Ignore registrations.
        path = parentPath;
        continue;
      }

      if ( // hoc1(hoc2(...))
      parentPath.node.type === 'CallExpression' && path.node !== parentPath.node.callee) {
        calls.push(parentPath);
        path = parentPath;
        continue;
      }

      return calls; // Stop at other types.
    }
  }

  var seenForRegistration = new WeakSet();
  var seenForSignature = new WeakSet();
  var seenForOutro = new WeakSet();
  var hookCalls = new WeakMap();
  var HookCallsVisitor = {
    CallExpression: function (path) {
      var node = path.node;
      var callee = node.callee; // Note: this visitor MUST NOT mutate the tree in any way.
      // It runs early in a separate traversal and should be very fast.

      var name = null;

      switch (callee.type) {
        case 'Identifier':
          name = callee.name;
          break;

        case 'MemberExpression':
          name = callee.property.name;
          break;
      }

      if (name === null || !/^use[A-Z]/.test(name)) {
        return;
      }

      var fnScope = path.scope.getFunctionParent();

      if (fnScope === null) {
        return;
      } // This is a Hook call. Record it.


      var fnNode = fnScope.block;

      if (!hookCalls.has(fnNode)) {
        hookCalls.set(fnNode, []);
      }

      var hookCallsForFn = hookCalls.get(fnNode);
      var key = '';

      if (path.parent.type === 'VariableDeclarator') {
        // TODO: if there is no LHS, consider some other heuristic.
        key = path.parentPath.get('id').getSource();
      } // Some built-in Hooks reset on edits to arguments.


      var args = path.get('arguments');

      if (name === 'useState' && args.length > 0) {
        // useState second argument is initial state.
        key += '(' + args[0].getSource() + ')';
      } else if (name === 'useReducer' && args.length > 1) {
        // useReducer second argument is initial state.
        key += '(' + args[1].getSource() + ')';
      }

      hookCallsForFn.push({
        callee: path.node.callee,
        name: name,
        key: key
      });
    }
  };
  return {
    visitor: {
      ExportDefaultDeclaration: function (path) {
        var node = path.node;
        var decl = node.declaration;
        var declPath = path.get('declaration');

        if (decl.type !== 'CallExpression') {
          // For now, we only support possible HOC calls here.
          // Named function declarations are handled in FunctionDeclaration.
          // Anonymous direct exports like export default function() {}
          // are currently ignored.
          return;
        } // Make sure we're not mutating the same tree twice.
        // This can happen if another Babel plugin replaces parents.


        if (seenForRegistration.has(node)) {
          return;
        }

        seenForRegistration.add(node); // Don't mutate the tree above this point.
        // This code path handles nested cases like:
        // export default memo(() => {})
        // In those cases it is more plausible people will omit names
        // so they're worth handling despite possible false positives.
        // More importantly, it handles the named case:
        // export default memo(function Named() {})

        var inferredName = '%default%';
        var programPath = path.parentPath;
        findInnerComponents(inferredName, declPath, function (persistentID, targetExpr, targetPath) {
          if (targetPath === null) {
            // For case like:
            // export default hoc(Foo)
            // we don't want to wrap Foo inside the call.
            // Instead we assume it's registered at definition.
            return;
          }

          var handle = createRegistration(programPath, persistentID);
          targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr));
        });
      },
      FunctionDeclaration: {
        enter: function (path) {
          var node = path.node;
          var programPath;
          var insertAfterPath;
          var modulePrefix = '';

          switch (path.parent.type) {
            case 'Program':
              insertAfterPath = path;
              programPath = path.parentPath;
              break;

            case 'TSModuleBlock':
              insertAfterPath = path;
              programPath = insertAfterPath.parentPath.parentPath;
              break;

            case 'ExportNamedDeclaration':
              insertAfterPath = path.parentPath;
              programPath = insertAfterPath.parentPath;
              break;

            case 'ExportDefaultDeclaration':
              insertAfterPath = path.parentPath;
              programPath = insertAfterPath.parentPath;
              break;

            default:
              return;
          } // These types can be nested in typescript namespace
          // We need to find the export chain
          // Or return if it stays local


          if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {
            while (programPath.type !== 'Program') {
              if (programPath.type === 'TSModuleDeclaration') {
                if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {
                  return;
                }

                modulePrefix = programPath.node.id.name + '$' + modulePrefix;
              }

              programPath = programPath.parentPath;
            }
          }

          var id = node.id;

          if (id === null) {
            // We don't currently handle anonymous default exports.
            return;
          }

          var inferredName = id.name;

          if (!isComponentishName(inferredName)) {
            return;
          } // Make sure we're not mutating the same tree twice.
          // This can happen if another Babel plugin replaces parents.


          if (seenForRegistration.has(node)) {
            return;
          }

          seenForRegistration.add(node); // Don't mutate the tree above this point.

          var innerName = modulePrefix + inferredName; // export function Named() {}
          // function Named() {}

          findInnerComponents(innerName, path, function (persistentID, targetExpr) {
            var handle = createRegistration(programPath, persistentID);
            insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, targetExpr)));
          });
        },
        exit: function (path) {
          var node = path.node;
          var id = node.id;

          if (id === null) {
            return;
          }

          var signature = getHookCallsSignature(node);

          if (signature === null) {
            return;
          } // Make sure we're not mutating the same tree twice.
          // This can happen if another Babel plugin replaces parents.


          if (seenForSignature.has(node)) {
            return;
          }

          seenForSignature.add(node); // Don't mutate the tree above this point.

          var sigCallID = path.scope.generateUidIdentifier('_s');
          path.scope.parent.push({
            id: sigCallID,
            init: t.callExpression(refreshSig, [])
          }); // The signature call is split in two parts. One part is called inside the function.
          // This is used to signal when first render happens.

          path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.
          // This is used to associate a type with a signature.
          // Unlike with $RefreshReg$, this needs to work for nested
          // declarations too. So we need to search for a path where
          // we can insert a statement rather than hard coding it.

          var insertAfterPath = null;
          path.find(function (p) {
            if (p.parentPath.isBlock()) {
              insertAfterPath = p;
              return true;
            }
          });

          if (insertAfterPath === null) {
            return;
          }

          insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(id, signature, insertAfterPath.scope))));
        }
      },
      'ArrowFunctionExpression|FunctionExpression': {
        exit: function (path) {
          var node = path.node;
          var signature = getHookCallsSignature(node);

          if (signature === null) {
            return;
          } // Make sure we're not mutating the same tree twice.
          // This can happen if another Babel plugin replaces parents.


          if (seenForSignature.has(node)) {
            return;
          }

          seenForSignature.add(node); // Don't mutate the tree above this point.

          var sigCallID = path.scope.generateUidIdentifier('_s');
          path.scope.parent.push({
            id: sigCallID,
            init: t.callExpression(refreshSig, [])
          }); // The signature call is split in two parts. One part is called inside the function.
          // This is used to signal when first render happens.

          if (path.node.body.type !== 'BlockStatement') {
            path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);
          }

          path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.
          // This is used to associate a type with a signature.

          if (path.parent.type === 'VariableDeclarator') {
            var insertAfterPath = null;
            path.find(function (p) {
              if (p.parentPath.isBlock()) {
                insertAfterPath = p;
                return true;
              }
            });

            if (insertAfterPath === null) {
              return;
            } // Special case when a function would get an inferred name:
            // let Foo = () => {}
            // let Foo = function() {}
            // We'll add signature it on next line so that
            // we don't mess up the inferred 'Foo' function name.


            insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(path.parent.id, signature, insertAfterPath.scope)))); // Result: let Foo = () => {}; __signature(Foo, ...);
          } else {
            // let Foo = hoc(() => {})
            var paths = [path].concat(findHOCCallPathsAbove(path));
            paths.forEach(function (p) {
              p.replaceWith(t.callExpression(sigCallID, createArgumentsForSignature(p.node, signature, p.scope)));
            }); // Result: let Foo = __signature(hoc(__signature(() => {}, ...)), ...)
          }
        }
      },
      VariableDeclaration: function (path) {
        var node = path.node;
        var programPath;
        var insertAfterPath;
        var modulePrefix = '';

        switch (path.parent.type) {
          case 'Program':
            insertAfterPath = path;
            programPath = path.parentPath;
            break;

          case 'TSModuleBlock':
            insertAfterPath = path;
            programPath = insertAfterPath.parentPath.parentPath;
            break;

          case 'ExportNamedDeclaration':
            insertAfterPath = path.parentPath;
            programPath = insertAfterPath.parentPath;
            break;

          case 'ExportDefaultDeclaration':
            insertAfterPath = path.parentPath;
            programPath = insertAfterPath.parentPath;
            break;

          default:
            return;
        } // These types can be nested in typescript namespace
        // We need to find the export chain
        // Or return if it stays local


        if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {
          while (programPath.type !== 'Program') {
            if (programPath.type === 'TSModuleDeclaration') {
              if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {
                return;
              }

              modulePrefix = programPath.node.id.name + '$' + modulePrefix;
            }

            programPath = programPath.parentPath;
          }
        } // Make sure we're not mutating the same tree twice.
        // This can happen if another Babel plugin replaces parents.


        if (seenForRegistration.has(node)) {
          return;
        }

        seenForRegistration.add(node); // Don't mutate the tree above this point.

        var declPaths = path.get('declarations');

        if (declPaths.length !== 1) {
          return;
        }

        var declPath = declPaths[0];
        var inferredName = declPath.node.id.name;
        var innerName = modulePrefix + inferredName;
        findInnerComponents(innerName, declPath, function (persistentID, targetExpr, targetPath) {
          if (targetPath === null) {
            // For case like:
            // export const Something = hoc(Foo)
            // we don't want to wrap Foo inside the call.
            // Instead we assume it's registered at definition.
            return;
          }

          var handle = createRegistration(programPath, persistentID);

          if (targetPath.parent.type === 'VariableDeclarator') {
            // Special case when a variable would get an inferred name:
            // let Foo = () => {}
            // let Foo = function() {}
            // let Foo = styled.div``;
            // We'll register it on next line so that
            // we don't mess up the inferred 'Foo' function name.
            // (eg: with @babel/plugin-transform-react-display-name or
            // babel-plugin-styled-components)
            insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, declPath.node.id))); // Result: let Foo = () => {}; _c1 = Foo;
          } else {
            // let Foo = hoc(() => {})
            targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr)); // Result: let Foo = hoc(_c1 = () => {})
          }
        });
      },
      Program: {
        enter: function (path) {
          // This is a separate early visitor because we need to collect Hook calls
          // and "const [foo, setFoo] = ..." signatures before the destructuring
          // transform mangles them. This extra traversal is not ideal for perf,
          // but it's the best we can do until we stop transpiling destructuring.
          path.traverse(HookCallsVisitor);
        },
        exit: function (path) {
          var registrations = registrationsByProgramPath.get(path);

          if (registrations === undefined) {
            return;
          } // Make sure we're not mutating the same tree twice.
          // This can happen if another Babel plugin replaces parents.


          var node = path.node;

          if (seenForOutro.has(node)) {
            return;
          }

          seenForOutro.add(node); // Don't mutate the tree above this point.

          registrationsByProgramPath.delete(path);
          var declarators = [];
          path.pushContainer('body', t.variableDeclaration('var', declarators));
          registrations.forEach(function (_ref) {
            var handle = _ref.handle,
                persistentID = _ref.persistentID;
            path.pushContainer('body', t.expressionStatement(t.callExpression(refreshReg, [handle, t.stringLiteral(persistentID)])));
            declarators.push(t.variableDeclarator(handle));
          });
        }
      }
    }
  };
}

module.exports = ReactFreshBabelPlugin;
  })();
}
©/babel.jsÄÚ'use strict';

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react-refresh-babel.production.min.js');
} else {
  module.exports = require('./cjs/react-refresh-babel.development.js');
}
Ù,/cjs/react-refresh-runtime.production.min.jsÅa/**
 * @license React
 * react-refresh-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';throw Error("React Refresh runtime should not be included in the production bundle.");
«/runtime.jsÄÞ'use strict';

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react-refresh-runtime.production.min.js');
} else {
  module.exports = require('./cjs/react-refresh-runtime.development.js');
}
¨/LICENSEÅ>MIT License

Copyright (c) Facebook, Inc. and its affiliates.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
­/package.jsonÅr{
  "name": "react-refresh",
  "description": "React is a JavaScript library for building user interfaces.",
  "keywords": [
    "react"
  ],
  "version": "0.14.0",
  "homepage": "https://reactjs.org/",
  "bugs": "https://github.com/facebook/react/issues",
  "license": "MIT",
  "files": [
    "LICENSE",
    "README.md",
    "babel.js",
    "runtime.js",
    "cjs/",
    "umd/"
  ],
  "main": "runtime.js",
  "exports": {
    ".": "./runtime.js",
    "./runtime": "./runtime.js",
    "./babel": "./babel.js",
    "./package.json": "./package.json"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "devDependencies": {
    "react-16-8": "npm:react@16.8.0",
    "react-dom-16-8": "npm:react-dom@16.8.0",
    "scheduler-0-13": "npm:scheduler@0.13.0"
  }
}ª/README.mdÅH# react-refresh

This package implements the wiring necessary to integrate Fast Refresh into bundlers. Fast Refresh is a feature that lets you edit React components in a running application without losing their state. It is similar to an old feature known as "hot reloading", but Fast Refresh is more reliable and officially supported by React.

This package is primarily aimed at developers of bundler plugins. If youâ€™re working on one, here is a [rough guide](https://github.com/facebook/react/issues/16604#issuecomment-528663101) for Fast Refresh integration using this package.
Ù)/cjs/react-refresh-runtime.development.jsÅOÃ/**
 * @license React
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

// ATTENTION
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_MEMO_TYPE = Symbol.for('react.memo');

var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
// It's OK to reference families, but use WeakMap/Set for types.

var allFamiliesByID = new Map();
var allFamiliesByType = new PossiblyWeakMap();
var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
// that have actually been edited here. This keeps checks fast.
// $FlowIssue

var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
// It is an array of [Family, NextType] tuples.

var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.

var helpersByRendererID = new Map();
var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.

var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.

var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
// It needs to be weak because we do this even for roots that failed to mount.
// If there is no WeakMap, we won't attempt to do retrying.
// $FlowIssue

var rootElements = // $FlowIssue
typeof WeakMap === 'function' ? new WeakMap() : null;
var isPerformingRefresh = false;

function computeFullKey(signature) {
  if (signature.fullKey !== null) {
    return signature.fullKey;
  }

  var fullKey = signature.ownKey;
  var hooks;

  try {
    hooks = signature.getCustomHooks();
  } catch (err) {
    // This can happen in an edge case, e.g. if expression like Foo.useSomething
    // depends on Foo which is lazily initialized during rendering.
    // In that case just assume we'll have to remount.
    signature.forceReset = true;
    signature.fullKey = fullKey;
    return fullKey;
  }

  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];

    if (typeof hook !== 'function') {
      // Something's wrong. Assume we need to remount.
      signature.forceReset = true;
      signature.fullKey = fullKey;
      return fullKey;
    }

    var nestedHookSignature = allSignaturesByType.get(hook);

    if (nestedHookSignature === undefined) {
      // No signature means Hook wasn't in the source code, e.g. in a library.
      // We'll skip it because we can assume it won't change during this session.
      continue;
    }

    var nestedHookKey = computeFullKey(nestedHookSignature);

    if (nestedHookSignature.forceReset) {
      signature.forceReset = true;
    }

    fullKey += '\n---\n' + nestedHookKey;
  }

  signature.fullKey = fullKey;
  return fullKey;
}

function haveEqualSignatures(prevType, nextType) {
  var prevSignature = allSignaturesByType.get(prevType);
  var nextSignature = allSignaturesByType.get(nextType);

  if (prevSignature === undefined && nextSignature === undefined) {
    return true;
  }

  if (prevSignature === undefined || nextSignature === undefined) {
    return false;
  }

  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {
    return false;
  }

  if (nextSignature.forceReset) {
    return false;
  }

  return true;
}

function isReactClass(type) {
  return type.prototype && type.prototype.isReactComponent;
}

function canPreserveStateBetween(prevType, nextType) {
  if (isReactClass(prevType) || isReactClass(nextType)) {
    return false;
  }

  if (haveEqualSignatures(prevType, nextType)) {
    return true;
  }

  return false;
}

function resolveFamily(type) {
  // Only check updated types to keep lookups fast.
  return updatedFamiliesByType.get(type);
} // If we didn't care about IE11, we could use new Map/Set(iterable).


function cloneMap(map) {
  var clone = new Map();
  map.forEach(function (value, key) {
    clone.set(key, value);
  });
  return clone;
}

function cloneSet(set) {
  var clone = new Set();
  set.forEach(function (value) {
    clone.add(value);
  });
  return clone;
} // This is a safety mechanism to protect against rogue getters and Proxies.


function getProperty(object, property) {
  try {
    return object[property];
  } catch (err) {
    // Intentionally ignore.
    return undefined;
  }
}

function performReactRefresh() {

  if (pendingUpdates.length === 0) {
    return null;
  }

  if (isPerformingRefresh) {
    return null;
  }

  isPerformingRefresh = true;

  try {
    var staleFamilies = new Set();
    var updatedFamilies = new Set();
    var updates = pendingUpdates;
    pendingUpdates = [];
    updates.forEach(function (_ref) {
      var family = _ref[0],
          nextType = _ref[1];
      // Now that we got a real edit, we can create associations
      // that will be read by the React reconciler.
      var prevType = family.current;
      updatedFamiliesByType.set(prevType, family);
      updatedFamiliesByType.set(nextType, family);
      family.current = nextType; // Determine whether this should be a re-render or a re-mount.

      if (canPreserveStateBetween(prevType, nextType)) {
        updatedFamilies.add(family);
      } else {
        staleFamilies.add(family);
      }
    }); // TODO: rename these fields to something more meaningful.

    var update = {
      updatedFamilies: updatedFamilies,
      // Families that will re-render preserving state
      staleFamilies: staleFamilies // Families that will be remounted

    };
    helpersByRendererID.forEach(function (helpers) {
      // Even if there are no roots, set the handler on first update.
      // This ensures that if *new* roots are mounted, they'll use the resolve handler.
      helpers.setRefreshHandler(resolveFamily);
    });
    var didError = false;
    var firstError = null; // We snapshot maps and sets that are mutated during commits.
    // If we don't do this, there is a risk they will be mutated while
    // we iterate over them. For example, trying to recover a failed root
    // may cause another root to be added to the failed list -- an infinite loop.

    var failedRootsSnapshot = cloneSet(failedRoots);
    var mountedRootsSnapshot = cloneSet(mountedRoots);
    var helpersByRootSnapshot = cloneMap(helpersByRoot);
    failedRootsSnapshot.forEach(function (root) {
      var helpers = helpersByRootSnapshot.get(root);

      if (helpers === undefined) {
        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
      }

      if (!failedRoots.has(root)) {// No longer failed.
      }

      if (rootElements === null) {
        return;
      }

      if (!rootElements.has(root)) {
        return;
      }

      var element = rootElements.get(root);

      try {
        helpers.scheduleRoot(root, element);
      } catch (err) {
        if (!didError) {
          didError = true;
          firstError = err;
        } // Keep trying other roots.

      }
    });
    mountedRootsSnapshot.forEach(function (root) {
      var helpers = helpersByRootSnapshot.get(root);

      if (helpers === undefined) {
        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
      }

      if (!mountedRoots.has(root)) {// No longer mounted.
      }

      try {
        helpers.scheduleRefresh(root, update);
      } catch (err) {
        if (!didError) {
          didError = true;
          firstError = err;
        } // Keep trying other roots.

      }
    });

    if (didError) {
      throw firstError;
    }

    return update;
  } finally {
    isPerformingRefresh = false;
  }
}
function register(type, id) {
  {
    if (type === null) {
      return;
    }

    if (typeof type !== 'function' && typeof type !== 'object') {
      return;
    } // This can happen in an edge case, e.g. if we register
    // return value of a HOC but it returns a cached component.
    // Ignore anything but the first registration for each type.


    if (allFamiliesByType.has(type)) {
      return;
    } // Create family or remember to update it.
    // None of this bookkeeping affects reconciliation
    // until the first performReactRefresh() call above.


    var family = allFamiliesByID.get(id);

    if (family === undefined) {
      family = {
        current: type
      };
      allFamiliesByID.set(id, family);
    } else {
      pendingUpdates.push([family, type]);
    }

    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.

    if (typeof type === 'object' && type !== null) {
      switch (getProperty(type, '$$typeof')) {
        case REACT_FORWARD_REF_TYPE:
          register(type.render, id + '$render');
          break;

        case REACT_MEMO_TYPE:
          register(type.type, id + '$type');
          break;
      }
    }
  }
}
function setSignature(type, key) {
  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;

  {
    if (!allSignaturesByType.has(type)) {
      allSignaturesByType.set(type, {
        forceReset: forceReset,
        ownKey: key,
        fullKey: null,
        getCustomHooks: getCustomHooks || function () {
          return [];
        }
      });
    } // Visit inner types because we might not have signed them.


    if (typeof type === 'object' && type !== null) {
      switch (getProperty(type, '$$typeof')) {
        case REACT_FORWARD_REF_TYPE:
          setSignature(type.render, key, forceReset, getCustomHooks);
          break;

        case REACT_MEMO_TYPE:
          setSignature(type.type, key, forceReset, getCustomHooks);
          break;
      }
    }
  }
} // This is lazily called during first render for a type.
// It captures Hook list at that time so inline requires don't break comparisons.

function collectCustomHooksForSignature(type) {
  {
    var signature = allSignaturesByType.get(type);

    if (signature !== undefined) {
      computeFullKey(signature);
    }
  }
}
function getFamilyByID(id) {
  {
    return allFamiliesByID.get(id);
  }
}
function getFamilyByType(type) {
  {
    return allFamiliesByType.get(type);
  }
}
function findAffectedHostInstances(families) {
  {
    var affectedInstances = new Set();
    mountedRoots.forEach(function (root) {
      var helpers = helpersByRoot.get(root);

      if (helpers === undefined) {
        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
      }

      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
      instancesForRoot.forEach(function (inst) {
        affectedInstances.add(inst);
      });
    });
    return affectedInstances;
  }
}
function injectIntoGlobalHook(globalObject) {
  {
    // For React Native, the global hook will be set up by require('react-devtools-core').
    // That code will run before us. So we need to monkeypatch functions on existing hook.
    // For React Web, the global hook will be set up by the extension.
    // This will also run before us.
    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;

    if (hook === undefined) {
      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
      // Note that in this case it's important that renderer code runs *after* this method call.
      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
      var nextID = 0;
      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
        renderers: new Map(),
        supportsFiber: true,
        inject: function (injected) {
          return nextID++;
        },
        onScheduleFiberRoot: function (id, root, children) {},
        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},
        onCommitFiberUnmount: function () {}
      };
    }

    if (hook.isDisabled) {
      // This isn't a real property on the hook, but it can be set to opt out
      // of DevTools integration and associated warnings and logs.
      // Using console['warn'] to evade Babel and ESLint
      console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');
      return;
    } // Here, we just want to get a reference to scheduleRefresh.


    var oldInject = hook.inject;

    hook.inject = function (injected) {
      var id = oldInject.apply(this, arguments);

      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
        // This version supports React Refresh.
        helpersByRendererID.set(id, injected);
      }

      return id;
    }; // Do the same for any already injected roots.
    // This is useful if ReactDOM has already been initialized.
    // https://github.com/facebook/react/issues/17626


    hook.renderers.forEach(function (injected, id) {
      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
        // This version supports React Refresh.
        helpersByRendererID.set(id, injected);
      }
    }); // We also want to track currently mounted roots.

    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;

    var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};

    hook.onScheduleFiberRoot = function (id, root, children) {
      if (!isPerformingRefresh) {
        // If it was intentionally scheduled, don't attempt to restore.
        // This includes intentionally scheduled unmounts.
        failedRoots.delete(root);

        if (rootElements !== null) {
          rootElements.set(root, children);
        }
      }

      return oldOnScheduleFiberRoot.apply(this, arguments);
    };

    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {
      var helpers = helpersByRendererID.get(id);

      if (helpers !== undefined) {
        helpersByRoot.set(root, helpers);
        var current = root.current;
        var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
        // This logic is copy-pasted from similar logic in the DevTools backend.
        // If this breaks with some refactoring, you'll want to update DevTools too.

        if (alternate !== null) {
          var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null && mountedRoots.has(root);
          var isMounted = current.memoizedState != null && current.memoizedState.element != null;

          if (!wasMounted && isMounted) {
            // Mount a new root.
            mountedRoots.add(root);
            failedRoots.delete(root);
          } else if (wasMounted && isMounted) ; else if (wasMounted && !isMounted) {
            // Unmount an existing root.
            mountedRoots.delete(root);

            if (didError) {
              // We'll remount it on future edits.
              failedRoots.add(root);
            } else {
              helpersByRoot.delete(root);
            }
          } else if (!wasMounted && !isMounted) {
            if (didError) {
              // We'll remount it on future edits.
              failedRoots.add(root);
            }
          }
        } else {
          // Mount a new root.
          mountedRoots.add(root);
        }
      } // Always call the decorated DevTools hook.


      return oldOnCommitFiberRoot.apply(this, arguments);
    };
  }
}
function hasUnrecoverableErrors() {
  // TODO: delete this after removing dependency in RN.
  return false;
} // Exposed for testing.

function _getMountedRootCount() {
  {
    return mountedRoots.size;
  }
} // This is a wrapper over more primitive functions for setting signature.
// Signatures let us decide whether the Hook order has changed on refresh.
//
// This function is intended to be used as a transform target, e.g.:
// var _s = createSignatureFunctionForTransform()
//
// function Hello() {
//   const [foo, setFoo] = useState(0);
//   const value = useCustomHook();
//   _s(); /* Call without arguments triggers collecting the custom Hook list.
//          * This doesn't happen during the module evaluation because we
//          * don't want to change the module order with inline requires.
//          * Next calls are noops. */
//   return <h1>Hi</h1>;
// }
//
// /* Call with arguments attaches the signature to the type: */
// _s(
//   Hello,
//   'useState{[foo, setFoo]}(0)',
//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
// );

function createSignatureFunctionForTransform() {
  {
    var savedType;
    var hasCustomHooks;
    var didCollectHooks = false;
    return function (type, key, forceReset, getCustomHooks) {
      if (typeof key === 'string') {
        // We're in the initial phase that associates signatures
        // with the functions. Note this may be called multiple times
        // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).
        if (!savedType) {
          // We're in the innermost call, so this is the actual type.
          savedType = type;
          hasCustomHooks = typeof getCustomHooks === 'function';
        } // Set the signature for all types (even wrappers!) in case
        // they have no signatures of their own. This is to prevent
        // problems like https://github.com/facebook/react/issues/20417.


        if (type != null && (typeof type === 'function' || typeof type === 'object')) {
          setSignature(type, key, forceReset, getCustomHooks);
        }

        return type;
      } else {
        // We're in the _s() call without arguments, which means
        // this is the time to collect custom Hook signatures.
        // Only do this once. This path is hot and runs *inside* every render!
        if (!didCollectHooks && hasCustomHooks) {
          didCollectHooks = true;
          collectCustomHooksForSignature(savedType);
        }
      }
    };
  }
}
function isLikelyComponentType(type) {
  {
    switch (typeof type) {
      case 'function':
        {
          // First, deal with classes.
          if (type.prototype != null) {
            if (type.prototype.isReactComponent) {
              // React class.
              return true;
            }

            var ownNames = Object.getOwnPropertyNames(type.prototype);

            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {
              // This looks like a class.
              return false;
            } // eslint-disable-next-line no-proto


            if (type.prototype.__proto__ !== Object.prototype) {
              // It has a superclass.
              return false;
            } // Pass through.
            // This looks like a regular function with empty prototype.

          } // For plain functions and arrows, use name as a heuristic.


          var name = type.name || type.displayName;
          return typeof name === 'string' && /^[A-Z]/.test(name);
        }

      case 'object':
        {
          if (type != null) {
            switch (getProperty(type, '$$typeof')) {
              case REACT_FORWARD_REF_TYPE:
              case REACT_MEMO_TYPE:
                // Definitely React components.
                return true;

              default:
                return false;
            }
          }

          return false;
        }

      default:
        {
          return false;
        }
    }
  }
}

exports._getMountedRootCount = _getMountedRootCount;
exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
exports.findAffectedHostInstances = findAffectedHostInstances;
exports.getFamilyByID = getFamilyByID;
exports.getFamilyByType = getFamilyByType;
exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
exports.injectIntoGlobalHook = injectIntoGlobalHook;
exports.isLikelyComponentType = isLikelyComponentType;
exports.performReactRefresh = performReactRefresh;
exports.register = register;
exports.setSignature = setSignature;
  })();
}
